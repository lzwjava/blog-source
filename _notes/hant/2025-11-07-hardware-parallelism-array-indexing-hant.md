---
audio: false
generated: true
image: false
lang: hant
layout: post
model: x-ai/grok-4-fast
title: 硬件平行運算加速陣列索引
translated: true
---

### 為什麼索引比二分搜尋更快？

這篇 2013 年由王寅撰寫的部落格文章深入探討了直接陣列索引（例如 `arr[i]`）為何是常數時間 O(1)，而在已排序陣列上進行二分搜尋卻需要 O(log n) 時間的根本原因。他透過一個簡單的電路類比，從硬體層面進行剖析，指出索引並非「魔法」——它其實是內建於電腦定址系統中的大規模平行二分搜尋。

#### 關鍵解釋
- **核心概念**：陣列索引使用**定址電路**來根據地址（如索引）直接選擇記憶體位置。以一個僅有 4 個記憶體位置（W、X、Y、Z）和 2 位元地址（位元 A 和 B）的微型例子來說：
  - 每個地址位元的作用如同二分搜尋的一個步驟，將可能的選擇範圍減半。
  - 位元 A 決定在兩組之間選擇：{W, X} 或 {Y, Z}。
  - 位元 B 決定在另一種分割之間選擇：{W, Y} 或 {X, Z}。
  - 這些位元並非順序執行——它們透過 AND 閘和導線**並行運作**，結合訊號並點亮恰好一個輸出（例如，若 A=0, B=1 → 選擇 W）。
  
  這模仿了二分搜尋的 2 個步驟（log₂(4) = 2），但因為所有操作同時進行，所以在單一硬體「時脈週期」內完成。

- **規模擴展**：對於完整的 n 位元地址（可處理 2ⁿ 個元素），該電路會並行執行所有 log₂(n) 個二分搜尋步驟。這就是為什麼它是 O(1)：硬體瞬間完成「搜尋」，無需在軟體中進行迴圈或比較。

- **視覺輔助**：文章包含一個電路圖，展示了包含反相器、導線和 AND 閘的訊號流動。雖然沒有程式碼片段，但這是概念性的——可將其視為一個將二進位地址轉換為單一有效選擇的解碼器。

#### 這為何重要
王寅認為，這揭示了低階硬體最佳化如何使高階操作顯得輕而易舉。二分搜尋之所以「慢」，僅是因為它在軟體中順序模擬了這個電路；而 CPU 實際的記憶體存取使用的是平行版本。

對於任何對大 O 表示法之外的計算機科學基礎知識感到好奇的人來說，這是一篇簡短而富有見地的讀物。

[為什麼索引比二分搜尋更快](https://yinwang0.wordpress.com/2013/04/02/indexing/)