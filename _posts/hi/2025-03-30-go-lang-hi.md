---
audio: false
generated: true
lang: hi
layout: post
title: एक व्यापक गो प्रोग्रामिंग भाषा गाइड
translated: true
type: note
---

यह गाइड Go प्रोग्रामिंग भाषा का एक व्यापक अवलोकन प्रदान करने का लक्ष्य रखती है, जिसमें इसके मूल सिद्धांत, मुख्य अवधारणाएं और उन्नत सुविधाएं शामिल हैं। यह कुछ प्रोग्रामिंग अनुभव वाले शुरुआती लोगों और अन्य भाषाओं से आने वालों दोनों के लिए डिज़ाइन की गई है।

**I. Go का परिचय**

* **Go क्या है?**
    * Go (जिसे अक्सर Golang कहा जाता है) एक स्टैटिकली टाइप्ड, कंपाइल्ड प्रोग्रामिंग भाषा है जिसे Google में Robert Griesemer, Rob Pike, और Ken Thompson द्वारा डिज़ाइन किया गया था।
    * यह सरलता, समवर्तीता (concurrency), और प्रदर्शन पर जोर देती है।
    * Go ओपन-सोर्स है और इसका एक जीवंत और बढ़ता हुआ समुदाय है।
* **मुख्य विशेषताएं और डिज़ाइन सिद्धांत:**
    * **सरलता और पठनीयता:** साफ सिंटैक्स, न्यूनतम कीवर्ड, और एक चीज को अच्छी तरह से करने पर ध्यान केंद्रित।
    * **समवर्तीता (Concurrency):** हल्के गोरूटीन्स (goroutines) और चैनल्स (channels) के लिए अंतर्निहित समर्थन समवर्ती प्रोग्रामिंग को आसान और अधिक कुशल बनाता है।
    * **प्रदर्शन:** कुशल मेमोरी प्रबंधन (गार्बेज कलेक्शन) के साथ कंपाइल्ड भाषा जिसके परिणामस्वरूप तेज निष्पादन होता है।
    * **मजबूत टाइपिंग (Strong Typing):** विकास प्रक्रिया में शुरुआत में ही त्रुटियों को पकड़ने में मदद करती है।
    * **स्टैटिक लिंकिंग:** स्वतंत्र निष्पादन योग्य फाइलें बनाती है, जिससे डिप्लॉयमेंट सरल हो जाता है।
    * **गार्बेज कलेक्शन:** स्वचालित मेमोरी प्रबंधन डेवलपर्स पर बोझ कम करता है।
    * **स्टैंडर्ड लाइब्रेरी:** एक समृद्ध और व्यापक स्टैंडर्ड लाइब्रेरी विभिन्न कार्यों के लिए टूल्स प्रदान करती है।
    * **टूलिंग:** फॉर्मेटिंग (gofmt), लिंटिंग (golint, staticcheck), टेस्टिंग (go test), और डिपेंडेंसी मैनेजमेंट (go modules) के लिए उत्कृष्ट अंतर्निहित टूल्स।
* **उपयोग के मामले:**
    * सिस्टम प्रोग्रामिंग
    * नेटवर्क प्रोग्रामिंग (APIs, वेब सर्वर)
    * क्लाउड इन्फ्रास्ट्रक्चर (Docker, Kubernetes)
    * कमांड-लाइन टूल्स
    * डिस्ट्रिब्यूटेड सिस्टम्स
    * बिग डेटा प्रोसेसिंग

**II. अपने Go वातावरण की स्थापना**

* **इंस्टालेशन:**
    * आधिकारिक वेबसाइट ([https://go.dev/dl/](https://go.dev/dl/)) से अपने ऑपरेटिंग सिस्टम के लिए उपयुक्त Go डिस्ट्रीब्यूशन डाउनलोड करें।
    * अपने प्लेटफॉर्म के लिए इंस्टालेशन निर्देशों का पालन करें।
* **इंस्टालेशन सत्यापन:**
    * अपना टर्मिनल या कमांड प्रॉम्प्ट खोलें और `go version` चलाएं। इससे इंस्टॉल किया गया Go संस्करण दिखना चाहिए।
* **वर्कस्पेस और `GOPATH` (लीगेसी):**
    * ऐतिहासिक रूप से, Go प्रोजेक्ट्स को एक `GOPATH` एनवायरनमेंट वेरिएबल के भीतर व्यवस्थित किया जाता था। जबकि अभी भी समर्थित है, यह काफी हद तक Go मॉड्यूल्स द्वारा प्रतिस्थापित किया जा चुका है।
* **Go मॉड्यूल (अनुशंसित):**
    * Go मॉड्यूल आधिकारिक डिपेंडेंसी मैनेजमेंट समाधान है।
    * मॉड्यूल के साथ एक नया प्रोजेक्ट शुरू करने के लिए, टर्मिनल में अपनी प्रोजेक्ट डायरेक्टरी में नेविगेट करें और `go mod init <your_module_path>` चलाएं (उदाहरण के लिए, `go mod init github.com/yourusername/myproject`)।
    * डिपेंडेंसीज `go.mod` फाइल में घोषित की जाती हैं।

**III. बेसिक Go सिंटैक्स और अवधारणाएं**

* **Hello, World!**
    ```go
    package main

    import "fmt"

    func main() {
        fmt.Println("Hello, World!")
    }
    ```
    * `package main`: पैकेज को एक निष्पादन योग्य प्रोग्राम के एंट्री प्वाइंट के रूप में घोषित करता है।
    * `import "fmt"`: "fmt" पैकेज को इम्पोर्ट करता है, जो फॉर्मेटेड I/O फंक्शन प्रदान करता है।
    * `func main()`: मुख्य फ़ंक्शन जहां प्रोग्राम निष्पादन शुरू होता है।
    * `fmt.Println()`: कंसोल पर टेक्स्ट की एक पंक्ति प्रिंट करता है।
* **पैकेज और इम्पोर्ट्स:**
    * Go कोड पैकेज में व्यवस्थित होता है।
    * पैकेज कोड संगठन, पुन: प्रयोज्यता और नामकरण संघर्षों से बचने में मदद करते हैं।
    * अन्य पैकेज (स्टैंडर्ड लाइब्रेरी या थर्ड-पार्टी) से कार्यक्षमता लाने के लिए `import` कीवर्ड का उपयोग करें।
    * इम्पोर्ट पाथ सिंगल पैकेज (जैसे, `"fmt"`) या नेस्टेड (जैसे, `"net/http"`) हो सकते हैं।
    * इम्पोर्ट एलियासिंग: `import f "fmt"` (अब आप `f.Println` का उपयोग कर सकते हैं)।
    * साइड इफेक्ट्स के लिए ब्लैंक आइडेंटिफायर (`_`): `import _ "net/http/pprof"` (सीधे उपयोग के बिना pprof हैंडलर्स को इनिशियलाइज़ करता है)।
* **वेरिएबल्स:**
    * घोषणा:
        * `var name type` (उदाहरण के लिए, `var age int`)
        * `var name = value` (टाइप इन्फेरेंस, उदाहरण के लिए, `var name = "Alice"`)
        * `name := value` (शॉर्ट वेरिएबल डिक्लेरेशन, केवल फंक्शन के अंदर, उदाहरण के लिए, `count := 0`)
    * एकाधिक घोषणाएं:
        ```go
        var (
            firstName string = "John"
            lastName  string = "Doe"
            age       int    = 30
        )
        ```
    * कॉन्स्टेंट्स:
        * `const PI float64 = 3.14159`
        * कॉन्स्टेंट्स को कंपाइल टाइम पर घोषित किया जाना चाहिए।
        * अनटाइप्ड कॉन्स्टेंट्स अपने उपयोग के आधार पर अलग-अलग प्रकार ले सकते हैं।
* **डेटा प्रकार:**
    * **बेसिक प्रकार:**
        * **इंटीजर्स:** `int`, `int8`, `int16`, `int32` (`rune` - `int32` के लिए एलियास), `int64`, `uint`, `uint8` (`byte` - `uint8` के लिए एलियास), `uint16`, `uint32`, `uint64`, `uintptr` (एक पॉइंटर रखने के लिए पर्याप्त बड़ा अनसाइन्ड इंटीजर)।
        * **फ्लोटिंग-पॉइंट नंबर्स:** `float32`, `float64`।
        * **कॉम्प्लेक्स नंबर्स:** `complex64`, `complex128`।
        * **बूलियन:** `bool` (`true`, `false`)।
        * **स्ट्रिंग्स:** `string` (बाइट्स का अपरिवर्तनीय अनुक्रम, आमतौर पर UTF-8 एनकोडेड)।
    * **कम्पोजिट प्रकार:**
        * **ऐरे:** एक ही प्रकार के तत्वों का निश्चित आकार वाला अनुक्रम (उदाहरण के लिए, `[5]int`)।
        * **स्लाइस:** किसी ऐरे के तत्वों में गतिशील रूप से आकार बदलने योग्य, लचीला दृश्य (सबसे अधिक इस्तेमाल किया जाने वाला)।
        * **मैप्स:** की-वैल्यू जोड़े का अक्रमित संग्रह (हैश टेबल)।
        * **स्ट्रक्ट्स:** कम्पोजिट डेटा प्रकार जो विभिन्न प्रकारों के शून्य या अधिक नामित फ़ील्ड को एक साथ समूहित करते हैं।
        * **पॉइंटर्स:** किसी मान का मेमोरी एड्रेस रखते हैं।
        * **फ़ंक्शन:** फर्स्ट-क्लास सिटीजन, वेरिएबल्स को सौंपे जा सकते हैं और तर्कों के रूप में पारित किए जा सकते हैं।
        * **इंटरफेस:** विधियों के एक सेट को परिभाषित करते हैं जिन्हें एक प्रकार को लागू करना होगा।
        * **चैनल्स:** गोरूटीन्स के लिए संचार और सिंक्रनाइज़ करने का एक तरीका प्रदान करते हैं।
* **ऑपरेटर्स:**
    * **अंकगणितीय:** `+`, `-`, `*`, `/`, `%`, `++`, `--`।
    * **तुलना:** `==`, `!=`, `>`, `<`, `>=`, `<=`।
    * **तार्किक:** `&&` (AND), `||` (OR), `!` (NOT)।
    * **बिटवाइज़:** `&` (AND), `|` (OR), `^` (XOR), `&^` (AND NOT), `<<` (Left Shift), `>>` (Right Shift)।
    * **असाइनमेंट:** `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`।
* **कंट्रोल फ्लो:**
    * **`if`, `else if`, `else`:** सशर्त निष्पादन।
        ```go
        if age >= 18 {
            fmt.Println("Adult")
        } else if age >= 13 {
            fmt.Println("Teenager")
        } else {
            fmt.Println("Child")
        }
        ```
    * **`for` लूप:** Go में एकमात्र लूप कंस्ट्रक्ट।
        * बेसिक `for` लूप:
            ```go
            for i := 0; i < 5; i++ {
                fmt.Println(i)
            }
            ```
        * `while`-जैसा लूप:
            ```go
            j := 0
            for j < 5 {
                fmt.Println(j)
                j++
            }
            ```
        * अनंत लूप:
            ```go
            for {
                // कुछ करो
            }
            ```
        * संग्रहों पर पुनरावृत्ति (`range`):
            ```go
            numbers := []int{1, 2, 3}
            for index, value := range numbers {
                fmt.Printf("Index: %d, Value: %d\n", index, value)
            }

            m := map[string]string{"a": "apple", "b": "banana"}
            for key, val := range m {
                fmt.Printf("Key: %s, Value: %s\n", key, val)
            }
            ```
    * **`switch` स्टेटमेंट:** मल्टी-वे सशर्त निष्पादन।
        ```go
        grade := "B"
        switch grade {
        case "A":
            fmt.Println("Excellent!")
        case "B":
            fmt.Println("Good")
        case "C":
            fmt.Println("Average")
        default:
            fmt.Println("Needs improvement")
        }
        ```
        * कोई स्वचालित फॉलथ्रू नहीं (जरूरत पड़ने पर `fallthrough` कीवर्ड का उपयोग करें)।
        * केस में एकाधिक मान हो सकते हैं।
        * बिना किसी शर्त के स्विच (`if-else if-else` की तरह)।
    * **`defer` स्टेटमेंट:** आस-पास के फ़ंक्शन के अंत में निष्पादित होने के लिए एक फ़ंक्शन कॉल शेड्यूल करता है (अक्सर क्लीनअप कार्यों जैसे फाइलें बंद करने के लिए उपयोग किया जाता है)।
        ```go
        func example() {
            f, err := os.Open("file.txt")
            if err != nil {
                fmt.Println(err)
                return
            }
            defer f.Close() // f.Close() example() रिटर्न करते समय कॉल किया जाएगा

            // ... फाइल को प्रोसेस करें ...
        }
        ```
    * **`goto` स्टेटमेंट:** कंट्रोल को एक लेबल वाले स्टेटमेंट में स्थानांतरित करता है (बहुत कम उपयोग करें, स्पेगेटी कोड का कारण बन सकता है)।
    * **`break` और `continue`:** लूप निष्पादन को नियंत्रित करते हैं।

**IV. कम्पोजिट डेटा प्रकार विस्तार से**

* **ऐरे:**
    * निश्चित आकार, एक ही प्रकार के तत्व।
    * स्लाइस की तुलना में कम इस्तेमाल किया जाता है।
    * उदाहरण: `var a [3]int; a[0] = 1; a[1] = 2; a[2] = 3` या `b := [2]string{"hello", "world"}`।
* **स्लाइस:**
    * गतिशील रूप से आकार बदलने योग्य, एक अंतर्निहित ऐरे द्वारा समर्थित।
    * स्लाइस लिटरल (उदाहरण के लिए, `[]int{1, 2, 3}`), `make()` फ़ंक्शन (`make([]int, length, capacity)`), या मौजूदा ऐरे या स्लाइस को स्लाइस करके बनाया गया (`mySlice[start:end]`)।
    * `len()`: स्लाइस में तत्वों की संख्या लौटाता है।
    * `cap()`: अंतर्निहित ऐरे की क्षमता लौटाता है।
    * `append()`: स्लाइस के अंत में तत्व जोड़ता है (यदि क्षमता पूरी हो गई है तो अंतर्निहित ऐरे को पुन: आवंटित कर सकता है)।
    * `copy()`: तत्वों को एक स्लाइस से दूसरे में कॉपी करता है।
* **मैप्स:**
    * की-वैल्यू जोड़े का अक्रमित संग्रह।
    * कुंजियाँ एक तुलनीय प्रकार (comparable type) की होनी चाहिए (जैसे, इंटीजर्स, स्ट्रिंग्स, बूलियन, केवल तुलनीय फ़ील्ड वाले स्ट्रक्ट्स)।
    * मान कोई भी प्रकार के हो सकते हैं।
    * मैप लिटरल (उदाहरण के लिए, `map[string]int{"apple": 1, "banana": 2}`) या `make()` फ़ंक्शन (`make(map[string]string)`) का उपयोग करके बनाया गया।
    * मानों तक पहुंच: `value := myMap["key"]` (मान लौटाता है और एक बूलियन यह दर्शाता है कि कुंजी मौजूद है या नहीं)।
    * कुंजी अस्तित्व की जाँच: `value, ok := myMap["key"]` (यदि कुंजी मौजूद है तो `ok` `true` होगा)।
    * एंट्रीज जोड़ना/अपडेट करना: `myMap["newKey"] = "newValue"`।
    * एंट्रीज हटाना: `delete(myMap, "keyToDelete")`।
* **स्ट्रक्ट्स:**
    * उपयोगकर्ता-परिभाषित प्रकार जो विभिन्न प्रकारों के नामित फ़ील्ड को एक साथ समूहित करते हैं।
    * एकाधिक विशेषताओं वाली इकाइयों का प्रतिनिधित्व करने के लिए उपयोग किया जाता है।
    * घोषणा:
        ```go
        type Person struct {
            FirstName string
            LastName  string
            Age       int
        }
        ```
    * इंस्टेंस बनाना:
        ```go
        var p1 Person
        p1.FirstName = "Alice"
        p1.LastName = "Smith"
        p1.Age = 25

        p2 := Person{FirstName: "Bob", LastName: "Johnson", Age: 30}

        p3 := Person{"Charlie", "Brown", 20} // यदि फ़ील्ड नाम छोड़े गए हैं तो क्रम मायने रखता है
        ```
    * फ़ील्ड तक पहुंच: `p1.FirstName`।
    * एम्बेडेड स्ट्रक्ट्स (कम्पोजिशन)।
    * अनाम फ़ील्ड।
* **पॉइंटर्स:**
    * किसी मान का मेमोरी एड्रेस रखते हैं।
    * `*` ऑपरेटर का उपयोग करके घोषित (उदाहरण के लिए, `var ptr *int`)।
    * `&` ऑपरेटर का उपयोग करके किसी वेरिएबल का पता प्राप्त करें (उदाहरण के लिए, `ptr = &age`)।
    * जिस मान की ओर इशारा कर रहा है उसे एक्सेस करने के लिए `*` ऑपरेटर का उपयोग करके एक पॉइंटर को डीरिफरेंस करें (उदाहरण के लिए, `value := *ptr`)।
    * Go में स्पष्ट पॉइंटर अंकगणित नहीं है।
    * डेटा को रेफरेंस द्वारा पास करने, मानों को सीधे संशोधित करने और कुछ डेटा संरचनाओं के साथ काम करने के लिए पॉइंटर्स उपयोगी हैं।

**V. फ़ंक्शन**

* **फ़ंक्शन घोषणा:**
    ```go
    func functionName(parameterName1 type1, parameterName2 type2) returnType {
        // फ़ंक्शन बॉडी
        return returnValue
    }
    ```
    * एक ही प्रकार के एकाधिक पैरामीटर एक साथ घोषित किए जा सकते हैं: `func sum(a, b int) int`।
    * वेरिएडिक फ़ंक्शन (चर संख्या में तर्क स्वीकार करते हैं): `func sum(numbers ...int) int`।
    * एकाधिक रिटर्न मान:
        ```go
        func divide(a, b float64) (float64, error) {
            if b == 0 {
                return 0, fmt.Errorf("division by zero")
            }
            return a / b, nil
        }

        result, err := divide(10, 2)
        if err != nil {
            fmt.Println("Error:", err)
        } else {
            fmt.Println("Result:", result)
        }
        ```
    * नामित रिटर्न मान।
* **फर्स्ट-क्लास फ़ंक्शन:**
    * फ़ंक्शन को वेरिएबल्स को सौंपा जा सकता है, अन्य फ़ंक्शन के तर्कों के रूप में पारित किया जा सकता है, और फ़ंक्शन से वापस लौटाया जा सकता है।
    * उदाहरण:
        ```go
        func add(a, b int) int { return a + b }

        func operate(f func(int, int) int, x, y int) int {
            return f(x, y)
        }

        result := operate(add, 5, 3) // result 8 होगा
        ```
* **अनाम फ़ंक्शन (क्लोजर):**
    * बिना नाम वाले फ़ंक्शन, अक्सर इनलाइन कॉलबैक के रूप में उपयोग किए जाते हैं।
    * अपने आसपास के स्कोप से वेरिएबल्स को कैप्चर कर सकते हैं (क्लोजर)।
    * उदाहरण:
        ```go
        func multiplier(factor int) func(int) int {
            return func(x int) int {
                return x * factor
            }
        }

        double := multiplier(2)
        fmt.Println(double(5)) // आउटपुट: 10
        ```

**VI. मेथड्स**

* **मेथड घोषणा:**
    * एक मेथड एक विशिष्ट रिसीवर प्रकार से जुड़ा एक फ़ंक्शन है।
    * सिंटैक्स:
        ```go
        func (receiver Type) methodName(parameters) returnType {
            // मेथड बॉडी
        }
        ```
    * रिसीवर एक वैल्यू या पॉइंटर हो सकता है।
    * वैल्यू रिसीवर रिसीवर की एक कॉपी पर काम करते हैं।
    * पॉइंटर रिसीवर मूल रिसीवर पर काम करते हैं और उसकी स्थिति को संशोधित कर सकते हैं।
* **उदाहरण:**
    ```go
    type Circle struct {
        Radius float64
    }

    func (c Circle) Area() float64 {
        return math.Pi * c.Radius * c.Radius
    }

    func (c *Circle) SetRadius(newRadius float64) {
        c.Radius = newRadius
    }

    func main() {
        myCircle := Circle{Radius: 5}
        fmt.Println("Area:", myCircle.Area()) // वैल्यू रिसीवर पर Area मेथड को कॉल करता है

        myCircle.SetRadius(10) // पॉइंटर रिसीवर पर SetRadius मेथड को कॉल करता है
        fmt.Println("New Area:", myCircle.Area())
    }
    ```

**VII. इंटरफेस**

* **इंटरफेस परिभाषा:**
    * एक इंटरफेस विधियों के हस्ताक्षरों के एक सेट को परिभाषित करता है।
    * एक प्रकार एक इंटरफेस को लागू करता है यदि वह इंटरफेस में परिभाषित सभी विधियों के लिए कार्यान्वयन प्रदान करता है।
    * इंटरफेस अंतर्निहित रूप से संतुष्ट होते हैं (कोई स्पष्ट `implements` कीवर्ड नहीं)।
    * सिंटैक्स:
        ```go
        type Writer interface {
            Write(p []byte) (n int, err error)
        }

        type Reader interface {
            Read(p []byte) (n int, err error)
        }

        type ReadWriter interface {
            Reader
            Writer // इंटरफेस एम्बेड करना
            Close() error
        }
        ```
* **इंटरफेस उपयोग:**
    * पॉलीमॉर्फिज्म को सक्षम करते हैं (विभिन्न प्रकार की वस्तुओं को एक समान तरीके से व्यवहार करना)।
    * ठोस प्रकारों के बजाय इंटरफेस के लिए प्रोग्रामिंग करके कोड को डिकपल करें।
    * उदाहरण:
        ```go
        import "io"
        import "os"

        func writeData(w io.Writer, data []byte) error {
            _, err := w.Write(data)
            return err
        }

        func main() {
            file, err := os.Create("output.txt")
            if err != nil {
                fmt.Println("Error creating file:", err)
                return
            }
            defer file.Close()

            data :=[]byte("Hello, Go interfaces!\n")
            err = writeData(file, data)
            if err != nil {
                fmt.Println("Error writing to file:", err)
                return
            }

            // हम os.Stdout का भी उपयोग कर सकते हैं जो io.Writer को भी लागू करता है
            err = writeData(os.Stdout, []byte("Writing to stdout through the interface.\n"))
            if err != nil {
                fmt.Println("Error writing to stdout:", err)
                return
            }
        }
        ```
* **खाली इंटरफेस (`interface{}`):**
    * खाली इंटरफेस में कोई विधियाँ नहीं होती हैं।
    * सभी प्रकार खाली इंटरफेस को लागू करते हैं।
    * किसी भी प्रकार के मानों का प्रतिनिधित्व करने के लिए उपयोग किया जा सकता है, लेकिन अंतर्निहित मान तक पहुंचने के लिए अक्सर टाइप असर्शन की आवश्यकता होती है।
    ```go
    var i interface{}
    i = 42
    fmt.Println(i)
    i = "hello"
    fmt.Println(i)

    value, ok := i.(string) // स्ट्रिंग के लिए टाइप असर्शन
    if ok {
        fmt.Println("The value is a string:", value)
    } else {
        fmt.Println("The value is not a string")
    }
    ```
* **टाइप असर्शन और टाइप स्विच:**
    * **टाइप असर्शन:** किसी इंटरफेस वेरिएबल से अंतर्निहित ठोस मान निकालने के लिए उपयोग किया जाता है।
        * सिंटैक्स: `value, ok := interfaceVar.(ConcreteType)`
        * यदि असर्शन सही है, तो `value` ठोस मान रखेगा, और `ok` `true` होगा।
        * यदि असर्शन गलत है, और आप `ok` की जाँच नहीं करते हैं, तो यह पैनिक का कारण बनेगा।
    * **टाइप स्विच:** किसी इंटरफेस वेरिएबल द्वारा रखे गए ठोस प्रकार के आधार पर विभिन्न क्रियाएं करने के लिए उपयोग किया जाता है।
        ```go
        func describe(i interface{}) {
            switch v := i.(type) {
            case int:
                fmt.Printf("Twice %v is %v\n", v, v*2)
            case string:
                fmt.Printf("%q is %v bytes long\n", v, len(v))
            default:
                fmt.Printf("I don't know about type %T!\n", v)
            }
        }

        func main() {
            describe(42)
            describe("hello")
            describe(true)
        }
        ```

**VIII. गोरूटीन्स और समवर्तीता (Concurrency)**

Go का समवर्तीता मॉडल गोरूटीन्स और चैनल्स पर आधारित है।

* **गोरूटीन्स:**
    * हल्के, समवर्ती फ़ंक्शन।
    * एक फ़ंक्शन कॉल के बाद `go` कीवर्ड का उपयोग करके बनाया गया।
    * गोरूटीन्स अन्य फ़ंक्शन और गोरूटीन्स के साथ समवर्ती रूप से चलते हैं।
    * पारंपरिक OS थ्रेड्स की तुलना में बनाने और प्रबंधित करने में बहुत सस्ता।
    ```go
    package main

    import (
        "fmt"
        "time"
    )

    func say(s string) {
        for i := 0; i < 5; i++ {
            time.Sleep(100 * time.Millisecond)
            fmt.Println(s)
        }
    }

    func main() {
        go say("world") // एक नया गोरूटीन शुरू करें
        say("hello")    // मुख्य गोरूटीन में चलाएं

        // गोरूटीन के आउटपुट को देखने के लिए कुछ समय प्रतीक्षा करें
        time.Sleep(time.Second)
    }
    ```
* **चैनल्स:**
    * टाइप्ड कंड्यूट जिनके माध्यम से गोरूटीन्स मान भेज और प्राप्त कर सकते हैं।
    * समवर्ती कोड के लिए संचार और सिंक्रनाइज़ करने का एक सुरक्षित तरीका प्रदान करते हैं।
    * `make(chan Type)` सिंटैक्स का उपयोग करके बनाया गया।
    * चैनल पर भेजना: `channel <- value`
    * चैनल से प्राप्त करना: `value := <-channel`
    ```go
    package main

    import "fmt"

    func sum(s []int, c chan int) {
        sum := 0
        for _, v := range s {
            sum += v
        }
        c