---
audio: false
generated: true
image: false
lang: hi
layout: post
title: प्रून के साथ साफ़ रिमोट ब्रांचेज़
translated: true
type: note
---

`git fetch --prune` आपके स्थानीय रिमोट ब्रांच संदर्भों को साफ और अप-टू-डेट रखने का एक तरीका है।

### यह क्या करता है

* **`git fetch`** सामान्य रूप से रिमोट की ब्रांचों की आपकी स्थानीय कॉपी (जैसे `origin/main`, `origin/feature-x`) को अपडेट करता है, बिना आपकी अपनी स्थानीय ब्रांचों को छुए।
* समय के साथ, रिमोट रिपॉजिटरी कुछ ब्रांचों को हटा या उनका नाम बदल सकती है। सफाई के बिना, आपका स्थानीय रिपो आपको वे पुरानी रिमोट-ट्रैकिंग ब्रांच (जैसे, `origin/feature-old`) दिखाता रहेगा।
* **`--prune` जोड़ना** Git को बताता है: *"अगर रिमोट में अब कोई ब्रांच नहीं है, तो मेरे संबंधित रिमोट-ट्रैकिंग संदर्भ को हटा दो।"*

इसलिए, `git fetch --prune` चलाने के बाद, रिमोट ब्रांचों की आपकी स्थानीय सूची रिमोट में वर्तमान में मौजूद चीज़ों से बिल्कुल मेल खाती है।

### उदाहरण

1. रिमोट में ब्रांचें हैं: `main`, `feature-a`।
2. आप `git fetch` चलाते हैं → अब आपके पास `origin/main`, `origin/feature-a` हैं।
3. कोई रिमोट पर `feature-a` को हटा देता है।
4. यदि आप `git fetch` चलाते हैं, तो आप स्थानीय रूप से `origin/feature-a` (पुराना संदर्भ) देखते रहेंगे।
5. यदि आप `git fetch --prune` चलाते हैं, तो Git देखेगा कि `feature-a` गायब है और आपके स्थानीय रिपो से `origin/feature-a` को हटा देगा।

### यह उपयोगी क्यों है

* `git branch -r` (रिमोट ब्रांच सूची) को साफ रखता है।
* उन ब्रांचों में स्विच करने या मर्ज करने时的 भ्रम से बचाता है जो अब अपस्ट्रीम मौजूद नहीं हैं।
* अक्सर एलियासेस (जैसे, `git fetch -p`) के साथ इस्तेमाल किया जाता है या इसे डिफॉल्ट रूप से इसके साथ सेट किया जा सकता है:

  ```bash
  git config fetch.prune true
  ```

इस तरह, हर `git fetch` स्वचालित रूप से पुरानी ब्रांचों को हटा देगा।

---

क्या आप चाहते हैं कि मैं यह भी समझाऊं कि **pruning tags के साथ कैसे इंटरैक्ट करती है** (क्योंकि `git fetch --prune` डिफॉल्ट रूप से केवल ब्रांचों को संभालता है, लेकिन tags अलग तरह से व्यवहार करती हैं)?