---
audio: false
generated: true
image: false
lang: hi
layout: post
model: x-ai/grok-4-fast
title: संयोजन तर्क सर्किट गाइड
translated: true
type: note
---

यह गाइड *इलेक्ट्रॉनिक प्रौद्योगिकी के मूल सिद्धांत (III)* में कॉम्बिनेशनल लॉजिक सर्किट्स पर अध्याय की मुख्य अवधारणाओं को कवर करती है। कॉम्बिनेशनल लॉजिक सर्किट्स ऐसी डिजिटल प्रणालियाँ हैं जहाँ आउटपुट केवल वर्तमान इनपुट पर निर्भर करता है, इनमें कोई मेमोरी एलिमेंट नहीं होते (सीक्वेंशियल सर्किट्स के विपरीत)। हम इसे निर्दिष्ट अनुभागों में विभाजित करेंगे: विश्लेषण और डिजाइन, सामान्य मॉड्यूल, और हेजार्ड्स (खतरे) एवं उन्हें दूर करने के तरीके। ध्यान व्यावहारिक समझ पर है, जिसमें उदाहरण और चरण-दर-चरण स्पष्टीकरण शामिल हैं।

## 1. कॉम्बिनेशनल लॉजिक का विश्लेषण और डिजाइन

### विश्लेषण
विश्लेषण में किसी दिए गए सर्किट के गेट-लेवल विवरण से उसके आउटपुट व्यवहार का निर्धारण शामिल है।

- **ट्रूथ टेबल (सत्य सारणी)**: विश्लेषण की आधारशिला। सभी संभावित इनपुट संयोजनों को सूचीबद्ध करें और आउटपुट की गणना करें।
  - *n* इनपुट वाले सर्किट के लिए, 2^n पंक्तियाँ होती हैं।
  - उदाहरण: एक 2-इनपुट AND-OR सर्किट का विश्लेषण करें: Output = (A · B) + (A' · B') (जहाँ ' NOT को दर्शाता है)।

    | A | B | A · B | A' · B' | Output |
    |---|---|-------|---------|--------|
    | 0 | 0 |   0   |    1    |   1    |
    | 0 | 1 |   0   |    0    |   0    |
    | 1 | 0 |   0   |    0    |   0    |
    | 1 | 1 |   1   |    0    |   1    |

    यह A XOR B (एक्सक्लूसिव OR) में सरल हो जाता है।

- **कर्नॉफ मैप (K-मैप)**: विश्लेषण के दौरान बूलियन एक्सप्रेशन को सरल बनाने के लिए एक दृश्य उपकरण।
  - मिनटर्म्स (1s) को एक ग्रिड पर प्लॉट करें; प्राइम इम्प्लिकेंट्स खोजने के लिए आसन्न 1s (2 की घात) को समूहित करें।
  - यह Sum-of-Products (SOP) या Product-of-Sums (POS) फॉर्म में कम कर देता है।

### डिजाइन
डिजाइन एक समस्या विनिर्देश (जैसे, ट्रूथ टेबल या शब्द विवरण) से शुरू होता है और सर्किट का निर्माण करता है।

- **चरण**:
  1. स्पेस से ट्रूथ टेबल प्राप्त करें।
  2. कैनोनिकल SOP/POS एक्सप्रेशन लिखें (मिनटर्म्स/मैक्सटर्म्स का योग/गुणनफल)।
  3. K-मैप या Quine-McCluskey विधि का उपयोग करके सरल बनाएं।
  4. गेट्स (AND, OR, NOT, NAND, NOR) के साथ इम्प्लीमेंट करें।

- **उदाहरण डिजाइन**: एक मेजॉरिटी वोटर (बहुमत निर्धारक) के लिए एक सर्किट डिजाइन करें (आउटपुट 1 हो यदि तीन इनपुट A, B, C में से कम से कम दो 1 हों)।
  - ट्रूथ टेबल (आंशिक):

    | A | B | C | Output |
    |---|---|---|--------|
    | 0 | 0 | 0 |   0    |
    | 0 | 0 | 1 |   0    |
    | 0 | 1 | 1 |   1    |
    | 1 | 0 | 1 |   1    |
    | 1 | 1 | 0 |   1    |
    | 1 | 1 | 1 |   1    |

  - K-मैप (SOP के लिए):
    ```
    CD\AB | 00 | 01 | 11 | 10
    ------|----|----|----|----
    00    | 0  | 0  | 0  | 0
    01    | 0  | 0  | 1  | 0
    11    | 0  | 1  | 1  | 1
    10    | 0  | 1  | 1  | 0
    ```
    (पंक्तियाँ/स्तंभ ग्रे कोड द्वारा लेबल किए गए हैं।)

  - सरलीकृत: F = AB + AC + BC.
  - गेट इम्प्लीमेंटेशन: प्रत्येक टर्म के लिए तीन AND गेट, एक OR गेट।

सुझाव: हमेशा सिमुलेशन के साथ सत्यापित करें या अंतिम सर्किट का पुनः विश्लेषण करें।

## 2. सामान्य मॉड्यूल

ये बड़ी प्रणालियों के लिए मानक बिल्डिंग ब्लॉक्स हैं, जो डिजाइन की जटिलता को कम करते हैं।

### एनकोडर्स
- सक्रिय इनपुट(s) को बाइनरी कोड में परिवर्तित करते हैं।
- उदाहरण: 4-to-2 लाइन प्रायोरिटी एनकोडर (इनपुट: Y3, Y2, Y1, Y0; आउटपुट: A1, A0; वैलिड फ्लैग V)।
  - ट्रूथ टेबल:

    | Y3 | Y2 | Y1 | Y0 | A1 | A0 | V |
    |----|----|----|----|----|----|---|
    | 0  | 0  | 0  | 1  | 0  | 0  | 1 |
    | 0  | 0  | 1  | X  | 0  | 1  | 1 |
    | 0  | 1  | X  | X  | 1  | 0  | 1 |
    | 1  | X  | X  | X  | 1  | 1  | 1 |
    | 0  | 0  | 0  | 0  | X  | X  | 0 |

  - लॉजिक: A1 = Y3 + Y2; A0 = Y3 + Y1; V = Y3 + Y2 + Y1 + Y0.
  - उपयोग: कीबोर्ड इनपुट से बाइनरी।

### डिकोडर्स
- एनकोडर्स के विपरीत: बाइनरी इनपुट से वन-हॉट आउटपुट (एक लाइन सक्रिय करें)।
- उदाहरण: 2-to-4 डिकोडर (इनपुट: A1, A0; आउटपुट: D0-D3)।
  - ट्रूथ टेबल:

    | A1 | A0 | D3 | D2 | D1 | D0 |
    |----|----|----|----|----|----|
    | 0  | 0  | 0  | 0  | 0  | 1  |
    | 0  | 1  | 0  | 0  | 1  | 0  |
    | 1  | 0  | 0  | 1  | 0  | 0  |
    | 1  | 1  | 1  | 0  | 0  | 0  |

  - लॉजिक: D0 = A1' · A0'; D1 = A1' · A0; आदि।
  - उपयोग: मेमोरी एड्रेसिंग, 7-सेगमेंट डिस्प्ले ड्राइवर्स।

### मल्टीप्लेक्सर्स (MUX)
- सेलेक्ट लाइन्स के आधार पर कई इनपुट्स में से एक को सिंगल आउटपुट पर चुनते हैं।
- उदाहरण: 4-to-1 MUX (इनपुट: I0-I3; सेलेक्ट: S1, S0; आउटपुट: Y)।
  - ट्रूथ टेबल:

    | S1 | S0 | Y  |
    |----|----|----|
    | 0  | 0  | I0 |
    | 0  | 1  | I1 |
    | 1  | 0  | I2 |
    | 1  | 1  | I3 |

  - लॉजिक: Y = (S1' · S0' · I0) + (S1' · S0 · I1) + (S1 · S0' · I2) + (S1 · S0 · I3)।
  - कैस्केडिंग: बड़े MUX बनाना (जैसे, दो 4-to-1 से 8-to-1)।
  - उपयोग: डेटा रूटिंग, फंक्शन जनरेटर (2^n-to-1 MUX के साथ किसी भी n-वेरिएबल फंक्शन को इम्प्लीमेंट करना)।

## 3. हेजार्ड्स और उन्हें दूर करने के तरीके

हेजार्ड्स अवांछित ग्लिचेस (अस्थायी रूप से गलत आउटपुट) हैं जो गेट डिले में टाइमिंग अंतर के कारण होते हैं, भले ही स्थिर-अवस्था लॉजिक सही हो।

### हेजार्ड्स के प्रकार
- **स्टैटिक हेजार्ड**: आउटपुट स्थिर रहना चाहिए (0→0 या 1→1) लेकिन ग्लिच होता है।
  - स्टैटिक-1: SOP में गुम हुए प्रोडक्ट टर्म के कारण (जैसे, वह ट्रांजिशन जहाँ दो टर्म्स अपर्याप्त रूप से ओवरलैप करते हैं)।
- **डायनामिक हेजार्ड**: आउटपुट को बदलना चाहिए (0→1 या 1→0) लेकिन कई बार ऑसिलेट करता है।
  - अधिक जटिल, अक्सर कई स्टैटिक हेजार्ड्स से उत्पन्न।

- **पहचान**: टाइमिंग डायग्राम या K-मैप पर हेजार्ड कवर्स का उपयोग करें (सिंगल-वेरिएबल परिवर्तन के लिए आसन्न 1s की जाँच करें)।

उदाहरण: SOP सर्किट F = AB + A'C (A=1, B:0→1, C=1 पर स्टैटिक-1 हेजार्ड; ग्लिच यदि AB टर्म में देरी हो)।

### हेजार्ड्स को दूर करने के तरीके
- **रिडंडेंट टर्म्स जोड़ें (हेजार्ड कवर्स)**:
  - K-मैप में, ट्रांजिशन को कवर करने के लिए अतिरिक्त इम्प्लिकेंट्स जोड़ें (जैसे, उदाहरण के लिए AC जोड़ें: F = AB + A'C + AC)।
  - परिवर्तनों के दौरान ओवरलैप सुनिश्चित करता है; गेट काउंट बढ़ाता है लेकिन ग्लिचेस को खत्म करता है।

- **हेजार्ड-फ्री इम्प्लीमेंटेशन का उपयोग करें**:
  - एसेंशियल प्राइम इम्प्लिकेंट्स (EPIs) + कॉन्सेंसस टर्म्स।
  - डायनामिक के लिए: प्रति वेरिएबल सिंगल ट्रांजिशन सुनिश्चित करें।

- **अन्य तकनीकें**:
  - संतुलित डिले (गेट पाथ्स को समान करना, VLSI में अव्यावहारिक)।
  - लैच-आधारित फिक्स (लेकिन वह सीक्वेंशियल है)।
  - सत्यापन के लिए सिमुलेशन टूल्स।

सुझाव: हाई-स्पीड डिजाइन में हेजार्ड्स महत्वपूर्ण हैं; हमेशा सिंगल-इनपुट परिवर्तनों की जाँच करें।

## सारांश और अभ्यास के सुझाव
- **मुख्य निष्कर्ष**: कॉम्बिनेशनल लॉजिक इनपुट्स को आउटपुट में कुशलतापूर्वक मैप करने के बारे में है। ट्रूथ टेबल और K-मैप में महारत हासिल करें—इनका उपयोग हर जगह होता है।
- **अभ्यास**: MUX का उपयोग करके एक फुल ऐडर डिजाइन करें; हेजार्ड्स के लिए एक डिकोडर का विश्लेषण करें।
- **अगले कदम**: मेमोरी एलिमेंट्स के लिए सीक्वेंशियल लॉजिक की ओर बढ़ें।

गहन जानकारी के लिए, मानो की *डिजिटल डिजाइन* जैसी मानक पुस्तकों का संदर्भ लें।

[Digital Design by M. Morris Mano](https://www.pearson.com/us/higher-education/program/Morris-Mano-Digital-Design-with-an-Introduction-to-the-Verilog-HDL-5th-Edition/PGM110392.html)  
[Fundamentals of Digital Logic with Verilog Design by Brown and Vranesic](https://www.mheducation.com/higher-education/product/fundamentals-digital-logic-verilog-design-brown-vranesic/M9780073380544.html)