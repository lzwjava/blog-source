---
audio: false
lang: hi
layout: post
title: Java Packages in Project का विश्लेषण
translated: true
---

यह एक Python स्क्रिप्ट है जो एक डायरेक्टरी को रिकर्सिव रूप से विश्लेषित करता है, सभी `.java` फाइलों में उपयोग किए गए सभी Java पैकेजों को ढूंढता है, डुप्लिकेट्स को हटा देता है, और प्रोजेक्ट में उपयोग किए गए सभी अननिक पैकेजों की सूची बनाता है। स्क्रिप्ट केवल `.java` फाइलों पर ध्यान केंद्रित करता है और सभी सबडायरेक्टरी को ट्रैवर्स करने के द्वारा प्रोजेक्ट्स को संभालता है जो मॉड्यूल हो सकते हैं।

### Python स्क्रिप्ट:

```python
import os
import sys

def find_java_files(root_dir):
    """
    दिए गए डायरेक्टरी और उसके सबडायरेक्टरी में सभी .java फाइलों को रिकर्सिव रूप से ढूंढें।

    Args:
        root_dir (str): खोज शुरू करने के लिए रूट डायरेक्टरी।

    Yields:
        str: प्रत्येक .java फाइल के लिए पूर्ण पथ।
    """
    for dirpath, dirnames, filenames in os.walk(root_dir):
        for filename in filenames:
            if filename.endswith('.java'):
                yield os.path.join(dirpath, filename)

def extract_package(import_statement):
    """
    एक इम्पोर्ट स्टेटमेंट से पैकेज नाम निकालें।

    पैकेज नाम आम तौर पर लॉवरकेस में होते हैं, जबकि क्लास नाम अक्सर अप्परकेस से शुरू होते हैं। वाइल्डकार्ड इम्पोर्ट (*) के लिए, पैकेज '*' से पहले का हिस्सा होता है।

    Args:
        import_statement (str): एक Java फाइल से इम्पोर्ट स्टेटमेंट लाइन।

    Returns:
        str: पैकेज नाम, या अगर नही तो खाली स्ट्रिंग।
    """
    # 'import' और 'static' को हटाएं अगर मौजूद हैं
    parts = import_statement.split()
    if parts[0] == 'import':
        parts = parts[1:]
    if parts[0] == 'static':
        parts = parts[1:]

    # शेष हिस्सों को जोड़ें और ट्रेलिंग ';' को हटाएं
    import_path = ' '.join(parts).strip(';').strip()

    # इम्पोर्ट पथ को '.' से विभाजित करें
    identifiers = import_path.split('.')

    # पहला पहचानकर्ता जहां पहला पहचानकर्ता अप्परकेस से शुरू होता है या '*' है, उस इंडेक्स को ढूंढें
    for i, ident in enumerate(identifiers):
        if ident == '*' or (ident and ident[0].isupper()):
            package_parts = identifiers[:i]
            break
    else:
        package_parts = []

    package = '.'.join(package_parts)
    return package

if __name__ == '__main__':
    # कमांड लाइन अर्जुमेंट के लिए रूट डायरेक्टरी की जांच करें
    if len(sys.argv) < 2:
        print("उपयोग: python script.py <root_directory>")
        sys.exit(1)

    root_dir = sys.argv[1]
    packages = set()

    # डायरेक्टरी और सबडायरेक्टरी में सभी .java फाइलों को ट्रैवर्स करें
    for java_file in find_java_files(root_dir):
        try:
            with open(java_file, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    if line.startswith('import'):
                        package = extract_package(line)
                        if package:  # केवल नॉन-खाली पैकेज नाम जोड़ें
                            packages.add(package)
        except Exception as e:
            print(f"चेतावनी: फाइल {java_file} को पढ़ा नहीं जा सका: {e}")
            continue

    # अननिक पैकेजों की सॉर्टेड सूची को प्रिंट करें
    for package in sorted(packages):
        print(package)
```

### स्क्रिप्ट का उपयोग कैसे करें:

1. स्क्रिप्ट को एक फाइल में सेभ करें, उदाहरण के लिए, `analyze_java_packages.py`।
2. कमांड लाइन से स्क्रिप्ट को चलाएं, Java प्रोजेक्ट के रूट डायरेक्टरी के पथ को प्रदान करें:
   ```
   python analyze_java_packages.py /path/to/your/java/project
   ```
3. स्क्रिप्ट `.java` फाइलों में इम्पोर्ट किए गए अननिक पैकेज नामों की सॉर्टेड सूची को आउटपुट करेगा।

### स्क्रिप्ट क्या करता है:

- **.java फाइलों को ढूंढता है:**
  - `os.walk()` का उपयोग करके डायरेक्टरी और उसके सबडायरेक्टरी को रिकर्सिव रूप से ट्रैवर्स करता है।
  - सभी `.java` से समाप्त होने वाले फाइलों को पहचानता है।

- **पैकेज नाम निकालता है:**
  - प्रत्येक `.java` फाइल को लाइन द्वारा लाइन विश्लेषित करता है।
  - `import` से शुरू होने वाले लाइन पहचानता है।
  - इम्पोर्ट स्टेटमेंट से पैकेज नाम निकालता है, निम्नलिखित को संभालता है:
    - सामान्य इम्पोर्ट (उदाहरण के लिए, `import java.util.List;`)
    - वाइल्डकार्ड इम्पोर्ट (उदाहरण के लिए, `import java.util.*;`)
    - स्टेटिक इम्पोर्ट (उदाहरण के लिए, `import static java.util.Collections.sort;`)
  - Java नामकरण परंपराओं पर आधारित एक ह्यूरिस्टिक का उपयोग करता है:
    - पैकेज नाम आम तौर पर लॉवरकेस होते हैं (उदाहरण के लिए, `java.util`).
    - क्लास नाम अक्सर अप्परकेस से शुरू होते हैं (उदाहरण के लिए, `List`, `Collections`).
    - वाइल्डकार्ड इम्पोर्ट `*` से समाप्त होते हैं।

- **डुप्लिकेट्स को हटाता है:**
  - सभी पैकेज नामों को एक `set` में एकत्र करता है ताकि डुप्लिकेट्स को स्वचालित रूप से हटाया जा सके।

- **नतीजे को आउटपुट करता है:**
  - सेट को एक सॉर्टेड सूची में परिवर्तित करता है और प्रत्येक पैकेज नाम को नए लाइन पर प्रिंट करता है।

### अनुमान और सीमाएं:

- **इम्पोर्ट स्टेटमेंट:**
  - इम्पोर्ट स्टेटमेंट को अपने ही लाइन पर मानता है और टिप्पणियों या स्ट्रिंग्स में एम्बेड नहीं हैं।
  - दोनों सामान्य और स्टेटिक इम्पोर्ट, वाइल्डकार्ड इम्पोर्ट सहित, को संभालता है।

- **नामकरण परंपराएं:**
  - पैकेज नाम लॉवरकेस होते हैं और क्लास नाम अप्परकेस से शुरू होते हैं, इस पर निर्भर करता है।
  - नॉन-स्टैंडर्ड नामकरण (उदाहरण के लिए, अप्परकेस पैकेज नाम) को सही से संभालने में असमर्थ हो सकता है, लेकिन यह प्रैक्टिस में दुर्लभ है।

- **फाइल एन्कोडिंग:**
  - `.java` फाइलों को UTF-8 में एन्कोड किया गया मानता है। आवश्यकता के अनुसार `encoding` पैरामीटर को समायोजित करें।

- **एरर हैंडलिंग:**
  - पढ़ने में असमर्थ फाइलों के लिए बुनियादी एरर हैंडलिंग शामिल है, चेतावनी प्रिंट करता है और जारी रहता है।

### उदाहरण:

अगर आपका Java प्रोजेक्ट निम्नलिखित `.java` फाइलों को रखता है:

- **File1.java:**
  ```java
  import java.util.List;
  import java.util.*;
  import java.lang.String;
  ```

- **File2.java:**
  ```java
  import java.util.Collections;
  import static java.util.Collections.sort;
  import com.example.myapp.*;
  ```

स्क्रिप्ट को चलाने पर निम्नलिखित आउटपुट होगा:
```
com.example.myapp
java.lang
java.util
```

यह प्रोजेक्ट में इम्पोर्ट किए गए सभी अननिक पैकेजों की सूची देता है, वर्णमाला के अनुसार सॉर्ट किया गया है।

### नोट्स:

- स्क्रिप्ट केवल `import` स्टेटमेंट्स के माध्यम से इम्पोर्ट किए गए पैकेजों पर ध्यान केंद्रित करता है, जो प्रोजेक्ट द्वारा उपयोग किए गए बाहरी और आंतरिक पैकेजों को दर्शाता है।
- यह `.java` फाइलों के पैकेज घोषणाओं को शामिल नहीं करता (उदाहरण के लिए, `package com.mycompany.myapp;`), क्योंकि ये पैकेजों को दर्शाते हैं जिनमें फाइलों का समावेश होता है, न कि वे पैकेज जो वे उपयोग करते हैं।
- प्रोजेक्ट में मॉड्यूल हो सकते हैं, इसलिए स्क्रिप्ट सभी सबडायरेक्टरी को रिकर्सिव रूप से विश्लेषित करता है ताकि सभी `.java` फाइलों को प्रोसेस किया जा सके।