---
audio: false
generated: true
image: false
lang: hi
layout: post
model: x-ai/grok-4-fast
title: सहकारक की परिभाषा और सहखंड संबंध
translated: true
type: note
---

### एड्जुगेट की परिभाषा को स्पष्ट करना (और कोफैक्टर्स से इसका संबंध)

आप एड्जुगेट के निर्माण को लेकर जिस तरह से सोच रहे हैं, वह काफी हद तक सही है, लेकिन आपके विवरण में एक छोटा लेकिन महत्वपूर्ण सुधार की आवश्यकता है। एड्जुगेट मैट्रिक्स (जिसे अक्सर `adj(A)` से दर्शाया जाता है) को मूल एंट्री `a(i,j)` को "बाकी" (पंक्ति i और कॉलम j को हटाने के बाद बचे सबमैट्रिक्स) के साइन्ड डिटरमिनेंट से गुणा करके नहीं बनाया जाता है। बल्कि:

- एंट्री `a(i,j)` का **कोफैक्टर** `C_ij` इस प्रकार परिभाषित किया जाता है: `C_ij = (-1)^{i+j} * det(M_ij)`, जहाँ `M_ij` वह सबमैट्रिक्स है जो A से पंक्ति i और कॉलम j को हटाकर प्राप्त किया जाता है। यह विशुद्ध रूप से **साइन्ड माइनर** है—इसमें `a(i,j)` से स्वयं को गुणा करना शामिल नहीं है।
- **कोफैक्टर मैट्रिक्स** C में ये `C_ij` इसकी एंट्रीज के रूप में होते हैं।
- **एड्जुगेट**, कोफैक्टर मैट्रिक्स का **ट्रांसपोज़** होता है: `adj(A) = C^T`। इसलिए, `adj(A)` की पोजीशन (i,j) में एंट्री वास्तव में `C_ji` (अदल-बदले हुए इंडेक्स से प्राप्त कोफैक्टर) होती है।

यह साइन्ड माइनर सेटअप डिटरमिनेंट की गणना के लिए लाप्लास विस्तार (इस पर नीचे और अधिक) से आता है। आपका विवरण कुछ-कुछ डिटरमिनेंट फॉर्मूले जैसा लगता है: `det(A) = j पर sum of a(i,j) * C_ij` (किसी भी पंक्ति i के साथ), जिसमें *वास्तव में* `a(i,j)` से गुणा करना शामिल होता है। लेकिन एड्जुगेट उस गुणन को छोड़ देता है—यह सिर्फ उन साइन्ड माइनर्स का संग्रह है, जिसे ट्रांसपोज़ किया गया है, ताकि साफ-सुथरी बीजगणितीय पहचानों को सक्षम बनाया जा सके।

एक त्वरित 2x2 उदाहरण के लिए (मान लें A = [[a, b], [c, d]]):
- कोफैक्टर्स: C_11 = (-1)^{1+1} det([d]) = d; C_12 = (-1)^{1+2} det([c]) = -c; C_21 = (-1)^{2+1} det([b]) = -b; C_22 = (-1)^{2+2} det([a]) = a.
- कोफैक्टर मैट्रिक्स C = [[d, -c], [-b, a]].
- एड्जुगेट adj(A) = C^T = [[d, -b], [-c, a]].
- ध्यान दें कि कोफैक्टर्स में कोई मूल a, b, c, d मल्टीप्लायर नहीं हैं—यह पूरी तरह से "बाकी" सबमैट्रिक्स के बारे में है।

हाँ, एड्जुगेट की गणना आप ठीक इसी तरह करते हैं: प्रत्येक पोजीशन के लिए पंक्ति/कॉलम हटाएं, बचे हुए का डिटरमिनेंट लें, चिह्न `(-1)^{i+j}` लगाएं, C में असेंबल करें, फिर adj(A) प्राप्त करने के लिए ट्रांसपोज़ करें। यह रिकर्सिव है (माइनर्स को छोटे मैट्रिक्स मिलते हैं), इसलिए बड़े n x n मैट्रिक्स के लिए, यह कम्प्यूटेशनली इंटेंसिव होता है—यही कारण है कि व्यवहार में हम अक्सर इनवर्स के लिए गॉसियन एलिमिनेशन का उपयोग करते हैं।

### हमें एड्जुगेट की आवश्यकता क्यों है? (यह सिर्फ एक इंटरमीडिएट स्टेप से अधिक है)

आपका यह कहना बिल्कुल सही है कि यह मैट्रिक्स इनवर्जन के लिए एक "इंटरमीडिएट प्रेजेंटेशन" जैसा लगता है—और कई कम्प्यूटेशनल अर्थों में, यह है! मुख्य फॉर्मूला है `A^{-1} = (1 / det(A)) * adj(A)`, यह मानते हुए कि det(A) ≠ 0 है। यह सीधे तौर पर सबमैट्रिक्स के डिटरमिनेंट का उपयोग करके, बिना रो ऑपरेशन्स की आवश्यकता के, इनवर्स देता है। लेकिन यह *सिर्फ* एक स्टेपिंग स्टोन नहीं है; यहाँ बताया गया है कि यह उपयोगी और आवश्यक क्यों है:

1.  **मैट्रिक्स इनवर्जन फॉर्मूला**: छोटे मैट्रिक्स या सिम्बॉलिक कम्प्यूटेशन (जैसे, प्रूफ्स या एक्सैक्ट अंकगणित में) के लिए, यह इनवर्स को व्यक्त करने का एक साफ-सुथरा, एक्सप्लिसिट तरीका है। यह दर्शाता है कि इनवर्स कैसे स्केल्ड कोफैक्टर्स में "डीकंपोज़" होता है।

2.  **सैद्धांतिक अंतर्दृष्टि**: पहचान `A * adj(A) = adj(A) * A = det(A) * I` (जहाँ I आइडेंटिटी मैट्रिक्स है) गहरी संरचना को प्रकट करती है। यह दर्शाती है कि प्रत्येक मैट्रिक्स एक स्केलर तक अपने एड्जुगेट के साथ कम्यूट करता है, और यह सिंगुलर मैट्रिक्स (det(A)=0 का तात्पर्य A adj(A)=0 है, इसलिए नल स्पेस संरेखित होते हैं) को समझने की नींव है।

3.  **लीनियर सिस्टम्स के लिए क्रैमर का नियम**: Ax = b को हल करने के लिए, i-वां सॉल्यूशन एंट्री `x_i = det(A_i) / det(A)` होता है, जहाँ A_i, A के कॉलम i को b से बदल देता है। लेकिन det(A_i) b की एंट्रीज से जुड़े कोफैक्टर्स के माध्यम से विस्तारित होता है—अनिवार्य रूप से बिना पूर्ण इनवर्जन के एफिशिएंट कम्प्यूटेशन के लिए एड्जुगेट का लाभ उठाता है।

4.  **डिटरमिनेंट एक्सपेंशन**: कोफैक्टर्स लाप्लास विस्तार (आपका "det(rest)" आइडिया) को सक्षम करते हैं, जो छोटी समस्याओं में तोड़कर det(A) की गणना करने के लिए महत्वपूर्ण है। ऐतिहासिक रूप से, इसने कंप्यूटरों से पहले डिटरमिनेंट्स को सुगम बनाया।

5.  **व्यापक अनुप्रयोग**: प्रोजेक्टिव ज्योमेट्री, कंप्यूटर ग्राफिक्स (ट्रांसफॉर्मेशन), और यहाँ तक कि फिजिक्स (जैसे, इम्पीडेंस मैट्रिक्स) में, एड्जुगेट सिंगुलैरिटीज को हैंडल करने या रियल्स (जैसे पॉलिनोमियल्स) से परे रिंग्स में इनवर्स प्राप्त करने के लिए प्रकट होते हैं।

संक्षेप में, जबकि न्यूमेरिक्स के लिए रो रिडक्शन तेज है, एड्जुगेट एक "एनालिटिकल" पथ प्रदान करता है जो थ्योरी, एजुकेशन और उन मामलों के लिए एलिगेंट है जहाँ आपको एक्सप्लिसिट फॉर्मूलों की आवश्यकता होती है। यह इनवर्स के पीछे "कारण" जैसा है, न कि सिर्फ अंत तक पहुँचने का एक साधन।

### एड्जुगेट का आविष्कार कैसे हुआ? (थोड़ा सा इतिहास)

एड्जुगेट किसी एक "यूरेका" क्षण से नहीं उपजा—यह डिटरमिनेंट और लीनियर इक्वेशन पर 18वीं-19वीं सदी के काम का एक प्राकृतिक विस्तार है, जब मैट्रिक्स अभी तक औपचारिक रूप से नहीं बने थे ("मैट्रिक्स" शब्द 1850 में आया)। किसी एक आविष्कारक को श्रेय नहीं दिया जाता है, लेकिन यहाँ इसके विकास का सिलसिला है:

-   **डिटरमिनेंट में जड़ें (1600 के अंत–1700)**: डिटरमिनेंट लीनियर सिस्टम्स को हल करने से उभरे (जैसे, 2x2 केस के लिए लाइबनिज़ 1693 में)। 1700 तक, क्रैमर (1750) जैसे गणितज्ञ सॉल्यूशन के लिए माइनर एक्सपेंशन का उपयोग करते थे, जिसमें कोफैक्टर्स पर अंतर्निहित रूप से छुआ जाता था।

-   **प्रारंभिक "एड्जॉइंट" अवधारणाएँ (1760–1800)**: जोसेफ-लुई लाग्रांज ने लगभग 1766 में डिफरेंशियल इक्वेशन के लिए "एड्जॉइंट इक्वेशन" शब्द गढ़ा, जहाँ एक "एड्जॉइंट" ऑपरेटर मूल (मैट्रिक्स के लिए ट्रांसपोज़ की तरह) को दर्पण दिखाता है। आर्थर केले (1840–50) ने अपने मैट्रिक्स कार्य में इसे "एड्जॉइंट लीनियर फॉर्म्स" तक बढ़ाया। मैक्सिम बोचर ने शुरुआती 1900 में "एड्जॉइंट मैट्रिक्स" को औपचारिक रूप दिया, लेकिन मूल विचार उनसे पहले का है।

-   **गॉस की मुख्य अंतर्दृष्टि (1801)**: कार्ल फ्रेडरिक गॉस ने अपने *डिसक्विजिशन्स अरिथमेटिके* में, क्वाड्रेटिक फॉर्म्स (जैसे, ax² + 2bxy + cy²) के लिए एक "एड्जॉइंट" को परिभाषित किया। उन्होंने एक कंपेनियन फॉर्म का निर्माण किया जिसके गुणांक मूल को दर्शाने वाले सिमेट्रिक मैट्रिक्स के साइन्ड 2x2 माइनर्स हैं—ठीक एड्जुगेट (साइन कन्वेंशन तक) की पूर्वसूचना देते हैं। यह नंबर थ्योरी (बाइनरी क्वाड्रेटिक फॉर्म्स) के लिए था, लेकिन इसने आधुनिक परिभाषा की सीधे पूर्वसूचना दी। गॉस के काम ने इस निर्माण को व्यवस्थित बनाया।

-   **औपचारिकीकरण (1800 के मध्य के बाद)**: जैसे-जैसे मैट्रिक्स थ्योरी मजबूत हुई (केले, सिल्वेस्टर, क्रोनकर), कोफैक्टर एक्सपेंशन (लाप्लास, 1772 से) इन विचारों में विलीन हो गया। 1850–60 तक, पूर्ण इनवर्जन फॉर्मूला `A^{-1} = adj(A)/det(A)` टेक्स्ट्स में दिखाई दिया, जिसमें "एड्जुगेट" (लैटिन "adjugare" से, यानी एक साथ जोतना) इनवर्जन में इसकी बाइंडिंग भूमिका पर जोर देता है।

"आविष्कार" संभवतः पैटर्न-स्पॉटिंग से उपजा: डिटरमिनेंट का विस्तार करते समय, गणितज्ञों ने देखा कि कोफैक्टर्स का संग्रह स्केल करने पर मैट्रिक्स को "इनवर्ट" कर देता है। यह प्रतिभा की चमक से कम और हाथ से समीकरणों को हल करने से एक जैविक विकास अधिक था। आधुनिक ग्रंथ (जैसे, स्ट्रैंग की *इंट्रोडक्शन टू लीनियर अलजेब्रा*) अभी भी अंतर्ज्ञान के लिए इसे इसी तरह सिखाते हैं।

यदि आप कोड में उदाहरण चाहते हैं (जैसे, किसी एक की गणना करने के लिए Python via NumPy/SymPy) या गॉस के निर्माण में गहराई से उतरना चाहते हैं, तो बस कहें!

[Adjugate matrix - Wikipedia](https://en.wikipedia.org/wiki/Adjugate_matrix)
[First usage of "adjoint" - History of Science and Mathematics Stack Exchange](https://hsm.stackexchange.com/questions/5908/what-is-the-first-usage-of-the-term-adjoint-and-why-was-this-word-chosen)