---
audio: false
generated: true
image: false
lang: hi
layout: post
model: x-ai/grok-4-fast
title: आईबीएम डीबी२ इंडेक्स संरचना की व्याख्या
translated: true
type: note
---

### आईबीएम डीबी2 इंडेक्स कैसे काम करते हैं

आईबीएम डीबी2 अपने इंडेक्स के लिए प्राथमिक डेटा संरचना के रूप में **B+ ट्री** का उपयोग करता है। यह एक संतुलित ट्री वेरिएंट है जो डिस्क-आधारित स्टोरेज और रेंज क्वेरीज़ के लिए अनुकूलित है, जो रिलेशनल डेटाबेस में आम है। B+ ट्री बड़े डेटासेट के लिए आदर्श, लॉगरिदमिक टाइम कॉम्प्लेक्सिटी (O(log n)) के साथ कुशल खोज, सम्मिलन और विलोपन सुनिश्चित करते हैं। नीचे, मैं संरचना, मुख्य ऑपरेशन और डीबी2-विशिष्ट नोट्स को तोड़कर समझाऊंगा।

#### डीबी2 में B+ ट्री संरचना
डीबी2 में एक B+ ट्री **पेजों** (जिन्हें नोड्स भी कहा जाता है) के पदानुक्रम में संगठित होता है, जिनमें से प्रत्येक आमतौर पर डिस्क पर 4KB आकार का होता है। ट्री स्व-संतुलित होता है, जिसका अर्थ है कि सभी लीफ नोड्स एक ही गहराई पर होते हैं, और यह डेटा बदलने के साथ गतिशील रूप से बढ़ता या सिकुड़ता है। यहां इसका विवरण है:

- **रूट पेज**: ट्री के शीर्ष पर प्रवेश बिंदु। इसमें क्रमबद्ध कुंजी मान और नीचे चाइल्ड पेजों के पॉइंटर होते हैं। छोटे इंडेक्स के लिए, रूट सीधे लीफ पेजों की ओर इशारा कर सकता है।

- **आंतरिक (नॉन-लीफ) पेज**: ये मध्यवर्ती स्तर डायरेक्टरी के रूप में कार्य करते हैं। प्रत्येक पेज रखता है:
  - **इंडेक्स कुंजियों** (इंडेक्स कॉलम से मान, जैसे कर्मचारी आईडी) की एक क्रमबद्ध सूची।
  - चाइल्ड पेजों के पॉइंटर (कुंजियों से एक अधिक पॉइंटर, रेंज को अलग करते हुए)।
  - विशेष रूप से, प्रत्येक एंट्री उसके नीचे सबट्री में **सबसे उच्च कुंजी मान** होती है, जो एक **रिकॉर्ड आइडेंटिफायर (RID)** के साथ जोड़ी जाती है - एक अद्वितीय पॉइंटर जो उस पेज और स्लॉट की ओर इशारा करता है जहां वास्तविक डेटा पंक्ति टेबल में रहती है।

  नॉन-लीफ पेज वास्तविक डेटा पॉइंटर *नहीं* संग्रहीत करते हैं; वे ट्रैवर्सल को निर्देशित करते हैं।

- **लीफ पेज**: सबसे निचला स्तर, द्वि-दिशात्मक (आगे और पीछे) जुड़ा हुआ है जो कुशल रेंज स्कैन के लिए होता है। प्रत्येक लीफ पेज में शामिल होता है:
  - इंडेक्स कॉलम से पूर्ण क्रमबद्ध **कुंजी मान**।
  - संबद्ध **RID** सीधे टेबल पंक्तियों की ओर इशारा करते हैं।
  - आसन्न लीफ पेजों के पॉइंटर, जो अनुक्रमिक पहुंच को सक्षम करते हैं (जैसे, `WHERE column BETWEEN x AND y` के लिए)।

ट्री कम से कम 2 स्तरों (रूट + लीफ) के साथ शुरू होता है और बड़े पैमाने की टेबल (लाखों पंक्तियों) के लिए 3-5+ स्तरों तक बढ़ सकता है। स्तरों की संख्या (NLEVELS) `SYSCAT.INDEXES` के माध्यम से क्वेरी करने योग्य है और प्रदर्शन को प्रभावित करती है - कम स्तरों का मतलब तेज ट्रैवर्सल है, लेकिन डीबी2 इसे स्वचालित रूप से प्रबंधित करता है।

इंडेक्स टेबल्स से अलग अपने स्वयं के टेबलस्पेस में संग्रहीत होते हैं, और इंडेक्स किए गए डेटा के अनुपात में डिस्क स्थान की खपत करते हैं (उदाहरण के लिए, 1M-पंक्ति वाली टेबल पर एक अद्वितीय इंडेक्स टेबल आकार का ~10-20% ले सकता है)।

#### खोज कैसे काम करती है
1. **रूट पेज** पर शुरू करें और इसे मेमोरी में लोड करें।
2. सर्च कुंजी (जैसे, `WHERE id = 123`) की तुलना वर्तमान पेज में क्रमबद्ध कुंजियों से करें।
3. उपयुक्त चाइल्ड पॉइंटर चुनें (जैसे, यदि सर्च कुंजी > वर्तमान कुंजी, तो दाएं जाएं)।
4. ट्री के नीचे तक दोहराते रहें (आमतौर पर 1-5 I/O ऑपरेशन) जब तक कि एक **लीफ पेज** तक नहीं पहुंच जाते।
5. लीफ में, मेल खाने वालों को खोजने के लिए क्रमबद्ध कुंजियों को स्कैन करें, फिर सटीक पंक्ति को टेबल से प्राप्त करने के लिए RID का उपयोग करें (एक और I/O)।

यह पाथ कम्प्रेशन ट्रैवर्सल को उथला रखता है। रेंज क्वेरीज़ के लिए, एक बार शुरुआती लीफ पर पहुंचने के बाद, ट्री में वापस ऊपर कूदे बिना अनुक्रमिक रूप से स्कैन करने के लिए सिबलिंग लिंक का पालन करें।

#### सम्मिलन और विलोपन
- **सम्मिलन**:
  1. सही लीफ पर पहुंचें (खोज के समान)।
  2. नई कुंजी + RID को क्रमबद्ध लीफ पेज में डालें।
  3. यदि पेज ओवरफ्लो हो जाता है (अधिकतम एंट्री से अधिक, कुंजी आकार के आधार पर ~200-500), इसे दो पेजों में विभाजित करें और एक सेपरेटर कुंजी को पैरेंट (आंतरिक) पेज में डालें।
  4. यदि पैरेंट ओवरफ्लो हो जाता है, तो ऊपर की ओर विभाजित करें (एक नया रूट बना सकता है)। डीबी2 कंकरेंसी के लिए पेजों को संक्षेप में लॉक करता है।

- **विलोपन**:
  1. लीफ पर पहुंचें और कुंजी + RID को हटा दें।
  2. यदि पेज अंडरफ्लो हो जाता है (बहुत कम एंट्री), तो एक सिबलिंग से उधार लें या उसके साथ मर्ज करें, सेपरेटर कुंजी को पैरेंट से हटा दें।
  3. यदि आवश्यक हो तो मर्ज को ऊपर की ओर प्रसारित करें। डीबी2 दक्षता के लिए परिवर्तनों को बैच करने के लिए पुनर्गठन में देरी कर सकता है।

ये ऑपरेशन स्वचालित रूप से संतुलन बनाए रखते हैं, जिसमें न्यूनतम पेज विभाजन/मर्ज (~1% ऑपरेशन) होते हैं।

#### डीबी2-विशिष्ट सुविधाएँ
- **ऑप्टिमाइज्ड B+ ट्री** (DB2 for z/OS में): मेनफ्रेम कंकरेंसी के लिए बढ़ाया गया, पेजों की भविष्यवाणी करने और प्रीलोड करने के लिए फ्रैक्टल प्रीफेचिंग के साथ, I/O को कम करता है।
- **क्लस्टरिंग**: इंडेक्स को बेहतर रेंज प्रदर्शन के लिए "क्लस्टर्ड" (डेटा भौतिक रूप से इंडेक्स क्रम के अनुसार क्रमबद्ध) किया जा सकता है।
- **प्रकार**: अद्वितीय, कम्पोजिट (मल्टी-कॉलम), और बिटमैप इंडेक्स का समर्थन करता है, सभी B+ आधारित। कोई नेटिव हैश इंडेक्स नहीं।
- **रखरखाव**: ऑप्टिमाइज़र के लिए सांख्यिकी को अपडेट करने के लिए बल्क परिवर्तनों के बाद `RUNSTATS` चलाएं। `INSPECT` जैसे टूल समस्याओं की जांच करते हैं।

B+ ट्री डीबी2 में उत्कृष्ट हैं क्योंकि वे रैंडम I/O को कम करते हैं (डिस्क-बाउंड सिस्टम के लिए महत्वपूर्ण) और पूर्ण टेबल स्कैन के बिना क्रमबद्ध पहुंच का समर्थन करते हैं।

[इंडेक्स संरचना - आईबीएम](https://www.ibm.com/docs/en/db2/11.1.0?topic=indexes-index-structure)  
[डीबी2 LUW इंडेक्स: B-ट्री विवरण](https://datageek.blog/2013/09/19/db2-luw-basics-indexes/)  
[इनसाइड Db2 for z/OS: ऑप्टिमाइज्ड B+ ट्री कैसे हाई-स्पीड इंडेक्सिंग को पावर देते हैं](https://planetmainframe.com/2025/06/inside-db2-for-z-os-how-optimized-b-trees-power-high-speed-indexing/)  
[डीबी2 B-ट्री इंडेक्स को जल्दी से कैसे समझें](https://srinimf.com/2021/07/26/db2-how-to-understand-b-tree-structure-of-index/)  
[Db2 इंडेक्स अवलोकन](https://www.idug.org/news/db2-index-overview)