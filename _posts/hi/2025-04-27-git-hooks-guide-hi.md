---
audio: false
generated: true
image: false
lang: hi
layout: post
model: x-ai/grok-code-fast-1
title: गिट हुक्स गाइड प्री कमिट प्री पुश
translated: true
type: note
---

### Git Hooks का अवलोकन
Git hooks अनुकूलन योग्य स्क्रिप्ट्स हैं जो Git वर्कफ़्लो के विशिष्ट बिंदुओं पर कार्यों को स्वचालित करती हैं। ये क्लाइंट-साइड (आपके लोकल मशीन पर चलने वाले) या सर्वर-साइड (रिमोट रिपॉजिटरी पर चलने वाले) हो सकते हैं। Hooks रिपॉजिटरी के `.git/hooks/` डायरेक्टरी में संग्रहीत होते हैं। नीचे, मैं प्री-कमिट, प्री-पुश और पुश से संबंधित सर्वर-साइड hooks को समझाऊंगा, और बताऊंगा कि वे कैसे निष्पादित होते हैं।

### क्लाइंट-साइड Hooks: प्री-कमिट और प्री-पुश
ये hooks आपके मशीन पर स्थानीय रूप से चलते हैं, कार्यों के अंतिम रूप लेने से पहले, जिससे आप नियम लागू कर सकते हैं या जांच चला सकते हैं।

- **प्री-कमिट हुक**:
  - **यह कब चलता है**: आपके द्वारा परिवर्तनों को कमिट करने से ठीक पहले स्वचालित रूप से ट्रिगर होता है (जैसे, `git commit` के माध्यम से)।
  - **उद्देश्य**: कोड गुणवत्ता जांचों के लिए उपयोगी, जैसे लिंटर्स, टेस्ट, या फॉर्मेटिंग टूल्स चलाना। यदि हुक विफल हो जाता है (नॉन-जीरो स्टेटस के साथ एक्जिट होता है), तो कमिट रद्द हो जाती है।
  - **उदाहरण**: एक सैंपल प्री-कमिट हुक JavaScript फाइलों पर `eslint` चला सकता है। यदि कोई एरर हैं, तो कमिट रुक जाती है।
  - **यह कैसे काम करता है**: स्क्रिप्ट `.git/hooks/pre-commit` में होती है। इसे `chmod +x .git/hooks/pre-commit` के साथ एक्जीक्यूटेबल बनाएं। यदि आप Husky (Git hooks प्रबंधित करने के लिए एक लोकप्रिय लाइब्रेरी) जैसे टूल्स का उपयोग करते हैं, तो यह सेटअप को सरल बना देता है।

- **प्री-पुश हुक**:
  - **यह कब चलता है**: आपके द्वारा रिमोट पर पुश करने से ठीक पहले स्वचालित रूप से ट्रिगर होता है (जैसे, `git push` के माध्यम से)।
  - **उद्देश्य**: परिवर्तनों को रिमोट पर भेजने से पहले टेस्ट चलाना, कोड कवरेज सत्यापित करना, या संगतता सुनिश्चित करना जैसी चीजों की जांच करता है। यदि यह विफल होता है, तो पुश ब्लॉक हो जाता है।
  - **"कुछ प्रीपुश" पर नोट**: Git में कोई मानक "prepush" हुक नहीं है—मेरा मानना है कि आपका मतलब "pre-push" हुक (हाइफन के साथ) से है। आप कस्टम प्री-पुश स्क्रिप्ट्स बना सकते हैं, अक्सर Husky जैसे टूल्स के माध्यम से, ताकि "केवल तभी पुश करें जब सभी टेस्ट पास हों" जैसे नियम लागू कर सकें।
  - **उदाहरण**: एक प्री-पुश हुक `npm test` चला सकता है और यदि टेस्ट फेल होते हैं तो पुश को रोक देता है। यदि इसे स्किप किया जाता है (जैसे, `git push --no-verify` के साथ), तो हुक नहीं चलेगा।
  - **यह कैसे काम करता है**: `.git/hooks/pre-push` पर स्थित होता है। एक्जीक्यूटेबल परमिशन की आवश्यकता होती है। यह रिमोट नाम और पुश किए जा रहे ref जैसे आर्गुमेंट्स प्राप्त करता है।

क्लाइंट-साइड hooks यह सुनिश्चित करते हैं कि समस्याएं जल्दी पकड़ी जाएं, जिससे खराब कमिट या पुश आपके मशीन से बाहर न जा सकें।

### पुश के दौरान सर्वर-साइड Hooks
जब आप `git push` चलाते हैं, तो पुश रिमोट रिपॉजिटरी (जैसे GitHub, GitLab, या कस्टम सर्वर) पर भेजा जाता है। रिमोट के अपने hooks हो सकते हैं जो पुश प्रक्रिया के दौरान या बाद में निष्पादित होते हैं। ये रिमोट Git रिपॉजिटरी की `.git/hooks/` डायरेक्टरी में संग्रहीत होते हैं और सर्वर एडमिन द्वारा प्रबंधित किए जाते हैं।

- **पुश के दौरान प्रक्रिया**:
  1. **लोकल जांच**: प्री-पुश हुक पहले चलता है (यदि मौजूद हो)।
  2. **डेटा ट्रांसफर**: परिवर्तन रिमोट पर भेजे जाते हैं।
  3. **रिमोट निष्पादन**: सर्वर-साइड hooks रिमोट सर्वर पर चलते हैं, आपके मशीन पर नहीं।

- **प्री-रिसीव हुक**:
  - **यह कब चलता है**: रिमोट सर्वर पर, पुश प्राप्त होते ही, लेकिन किसी भी ref (ब्रांच या टैग) को अपडेट करने से पहले।
  - **उद्देश्य**: आने वाले परिवर्तनों को वैलिडेट करता है। यदि जांच विफल होती है, जैसे कमिट मैसेज लागू करना, कोड रिव्यू, या सिक्योरिटी स्कैन, तो यह पूरे पुश को रिजेक्ट कर सकता है।
  - **यह कैसे काम करता है**: यदि हुक नॉन-जीरो स्टेटस के साथ एक्जिट होता है, तो पुश अस्वीकार कर दिया जाता है, और आपको एक एरर मैसेज दिखेगा। उदाहरण: ऐसे पुश को रिजेक्ट करना जो एक निश्चित साइज से बड़ी फाइलें इंट्रोड्यूस करते हैं।

- **अपडेट हुक** (प्री-रिसीव के समान लेकिन प्रति-ref):
  - **यह कब चलता है**: प्रत्येक ब्रांच/टैग के लिए जिसे अपडेट किया जा रहा है, प्री-रिसीव के बाद।
  - **उद्देश्य**: बारीक नियंत्रण की अनुमति देता है, जैसे जांचना कि पुश अधिकृत उपयोगकर्ता से है या ब्रांच नेमिंग कन्वेंशन का पालन करती है।
  - **यह कैसे काम करता है**: अपडेट किए जा रहे ref के बारे में विवरण प्राप्त करता है।

- **पोस्ट-रिसीव हुक**:
  - **यह कब चलता है**: रिमोट सर्वर पर, पुश के पूरी तरह से स्वीकार किए जाने और refs के अपडेट हो जाने के बाद।
  - **उद्देश्य**: डाउनस्ट्रीम एक्शन्स को ट्रिगर करता है, जैसे कोड डिप्लॉय करना, नोटिफिकेशन भेजना (जैसे Slack अलर्ट), या पोस्ट-डिप्लॉयमेंट स्क्रिप्ट्स चलाना जैसे "एप्लिकेशन को रीबिल्ड करना"।
  - **यह कैसे काम करता है**: सफल पुश के बाद विश्वसनीय रूप से चलता है। उदाहरण: स्वचालित रूप से एक CI/CD पाइपलाइन ट्रिगर करना या वेब सर्वर अपडेट करना।

सर्वर-साइड hooks केंद्रीकृत प्रवर्तन प्रदान करते हैं, इसलिए भले ही आपके लोकल hooks को बायपास कर दिया जाए, रिमोट फिर भी पुश को वैलिडेट कर सकता है या उस पर प्रतिक्रिया दे सकता है। GitHub जैसे प्लेटफॉर्म समान उद्देश्यों के लिए वेबहुक्स (API-आधारित समकक्ष) का उपयोग करते हैं, लेकिन बेयर Git सर्वर या सेल्फ-होस्टेड रिपॉजिटरीज के लिए, उपरोक्त hooks महत्वपूर्ण हैं।

### मुख्य अंतर और सर्वोत्तम अभ्यास
- **क्लाइंट बनाम सर्वर**: क्लाइंट hooks (जैसे प्री-कमिट/प्री-पुश) आपको स्थानीय रूप से त्वरित फीडबैक देते हैं। सर्वर hooks रिपॉजिटरी-व्यापी नियम लागू करते हैं।
- **अनुकूलन**: Hooks शेल स्क्रिप्ट्स (जैसे Bash) हैं लेकिन Python, Node.js, आदि को इनवोक कर सकते हैं। इन्हें प्रबंधित करने के लिए pre-commit (एक फ्रेमवर्क) जैसे टूल्स का उपयोग करें।
- **बायपास करना**: `--no-verify` के साथ कमिट करें, `--no-verify` के साथ पुश करें, लेकिन सर्वर hooks को बायपास नहीं किया जा सकता जब तक कि आपके पास एडमिन एक्सेस न हो।
- **सेटअप टिप्स**: Hooks रिपॉजिटरीज के बीच कॉपी नहीं होते हैं, इसलिए उन्हें रिपॉजिटरी के टेम्पलेट में जोड़ें या उन्हें इंस्टॉल करने के लिए किसी टूल का उपयोग करें।

यदि आप इसे सेट अप कर रहे हैं, तो Git के डॉक्यूमेंटेशन या node प्रोजेक्ट्स के लिए Husky जैसे टूल्स चेक करें। यदि आपके पास कोई विशिष्ट परिदृश्य है (जैसे कोड उदाहरण), तो अनुरूप सलाह के लिए अधिक विवरण प्रदान करें!