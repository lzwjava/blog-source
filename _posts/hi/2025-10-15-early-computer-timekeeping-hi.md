---
audio: false
generated: true
image: false
lang: hi
layout: post
model: x-ai/grok-4-fast
title: यूनिक्स से पहले प्रारंभिक कंप्यूटर समय प्रबंधन
translated: true
type: note
---

हाँ, तुम बिल्कुल सही कह रहे हो—1970 के दशक में यूनिक्स टाइमस्टैम्प्स से बहुत पहले, हमारे पास ENIAC (मेरे ख्याल से तुम्हारा मतलब यही था, ANNIC नहीं; यह 1945 का इलेक्ट्रॉनिक न्यूमेरिकल इंटीग्रेटर एंड कंप्यूटर था), Altair 8800 (1975 का वह किट जिसने पीसी क्रांति की शुरुआत की, जहाँ बिल गेट्स और पॉल एलन ने टेलीटाइप पर वह प्रसिद्ध BASIC इंटरप्रेटर हैक किया था), और जॉन वॉन न्यूमैन के मौलिक विचार (जैसे उनकी 1945 की EDVAC रिपोर्ट जिसने स्टोर्ड-प्रोग्राम कॉन्सेप्ट को जन्म दिया और बाद की हर चीज़ को प्रभावित किया) जैसे विशालकाय शुरुआती मशीनें मौजूद थीं।

लेकिन उस ज़माने में "टाइम को हैंडल करना"? हमारी सेकंड्स-सिंस-एपोक (epoch) की सुंदरता जैसा कुछ नहीं था। इन राक्षसों के पास तारीखों या दीवार घड़ी के समय के लिए रियल-टाइम क्लॉक (RTC) नहीं होते थे—वे सिर्फ़ कच्चे कम्प्यूटेशन साइकिल के बारे में थे, न कि आपके डेंटिस्ट अपॉइंटमेंट को शेड्यूल करने के लिए। समय बहुत ही बुनियादी था: ज़्यादातर ऑपरेशन्स को सिंक्रोनाइज़ करने के लिए आंतरिक घड़ियाँ, या देरी के लिए लूप काउंटर्स जैसे सॉफ़्टवेयर हैक्स। "अब 15 अक्टूबर, 2025 है" के लिए कोई स्थायी मेमोरी नहीं। आइए इनमें से हर एक को, नंबर-क्रंचिंग के नज़रिए से जल्दी से समझते हैं।

### ENIAC (1945): पल्स ट्रेन्स और एक मास्टर क्लॉक
यह 30 टन का दैत्य केबल लगाकर और स्विच फ्लिप करके प्रोग्राम किया जाता था—कोई कोड स्टोरेज नहीं, सिर्फ़ बैलिस्टिक्स टेबल जैसी मैथ प्रॉब्लम्स के लिए वायरिंग। टाइम हैंडलिंग पूरी तरह से हार्डवेयर-टाइम्ड थी:
- **क्लॉक बेसिक्स**: एक केंद्रीय "साइकिलिंग यूनिट" ऑसिलेटर 100,000 पल्स प्रति सेकंड (हर 10 माइक्रोसेकंड) की दर से पल्स भेजता था। हर चीज़ इन पल्स के साथ सिंक होती थी—जैसे वैक्यूम ट्यूबों के लिए एक हृदय की धड़कन।
- **ऑपरेशन टाइमिंग**: एक एडिशन में 20 पल्स (200 माइक्रोसेकंड, या 1/5,000वां सेकंड) लगते थे। लूप्स या डिले? आप मैन्युअल तरीके से रिपीटर्स या काउंटर्स वायर करते थे; कोई सॉफ़्टवेयर टाइमर्स नहीं।
- **रियल-वर्ल्ड टाइम?** बिल्कुल नहीं। यह बैलिस्टिक कैल्क 30 सेकंड में चलाता था, जिसमें एनालॉग मशीनों को 15 मिनट लगते थे, लेकिन "समय" का मतलब साइकिल काउंट्स था, न कि कैलेंडर। वॉन न्यूमैन ने इस पर सलाह दी थी लेकिन टाइमिंग को और लचीला बनाने के लिए स्टोर्ड प्रोग्राम्स पर ज़ोर दिया।

नंबरों के नज़रिए से: इसे फिक्स्ड-रेट टिक्स (100kHz) के रूप में सोचें, जहाँ आप यह गिनने के लिए पल्स्स को जोड़ते कि कोई कैल्क "कितनी देर" चला—सेकंड्स का एक कच्चा रूप, लेकिन डीबग करते समय आपको इन्हें हाथ से गिनना पड़ता।

### Altair 8800 (1975): क्रिस्टल क्लॉक और DIY डिले
Altair पहला "पर्सनल" कंप्यूटर था—एक ब्लिंकी बॉक्स जिसमें Intel 8080 चिप थी, शुरुआत में कोई कीबोर्ड या स्क्रीन नहीं (सिर्फ़ स्विच और LED)। गेट्स का 4K BASIC टेप के ज़रिए लोड होता था, जिससे होबीस्ट्स इसे एक्सप्लोर कर पाते थे।
- **क्लॉक बेसिक्स**: एक 2 MHz क्रिस्टल ऑसिलेटर CPU को चलाता था—इंस्ट्रक्शन फ़ेच/एक्ज़िक्यूट करने के लिए 2 मिलियन साइकिल/सेकंड की स्थिर टिक्स।
- **टाइमिंग ट्रिक्स**: तारीखों के लिए कोई बिल्ट-इन क्लॉक नहीं; आप बेसिक इंटरप्ट्स या काउंटर्स के लिए एक "टाइम क्लॉक" एक्सेसरी बोर्ड (88-ACC) जोड़ते थे। नहीं तो, सॉफ़्टवेयर लूप्स: जैसे, BASIC में डिले के लिए साइकिल्स जलाने के लिए एक FOR-NEXT लूप (जैसे `FOR I=1 TO 1000: NEXT I` एक अनुमानित "पॉज़" के लिए)।
- **BASIC का तरीका**: शुरुआती Altair BASIC में कोई TIME$ फ़ंक्शन नहीं था (वह बाद में Microsoft BASIC में आया)। समय रिलेटिव था—इंस्ट्रक्शन्स को गिनना या रियल-टाइम क्लॉक चिप (दुर्लभ ऐड-ऑन) जैसे एक्सटर्नल हार्डवेयर को जोड़ना।

नंबरों के हिसाब से: 2 MHz पर, एक इंस्ट्रक्शन में 4-20 साइकिल लग सकते थे, तो 1-सेकंड की डिले? लगभग 2 मिलियन बार लूप चलाना। कठिन, लेकिन इसने हमें एफ़िशिएंसी सिखाई।

### वॉन न्यूमैन आर्किटेक्चर (1945+): सार्वभौमिक टिक के रूप में साइकिल्स
वॉन न्यूमैन ने हार्डवेयर नहीं बनाया (वह 1952 में IAS मशीन थी), लेकिन उनकी ब्लूप्रिंट—CPU, मेमोरी, I/O सभी एक बस के ज़रिए बात करते हैं—ने इसकी नींव रखी। समय? सब सिंक्रोनाइज़्ड साइकिल्स के बारे में।
- **क्लॉक की भूमिका**: एक मास्टर क्लॉक (क्रिस्टल या अन्य) इंस्ट्रक्शन्स को फ़ेच-डिकोड-एक्ज़िक्यूट करने के लिए पल्स भेजता है। हर साइकिल (राइज़िंग/फ़ॉलिंग एज) स्टेट को आगे बढ़ाती है—कोई ओवरलैप नहीं, प्योर सीरियल।
- **समय का प्रतिनिधित्व**: इंस्ट्रक्शन्स फिक्स्ड साइकिल लेते थे (जैसे 1-4 टिक्स में जोड़ना), इसलिए "समय" साइकिल काउंट्स था। डिले के लिए, काउंटर्स पर ब्रांच करना; रियल क्लॉक एक्सटर्नल होते थे (जैसे वॉल प्लग या मैन्युअल रीसेट)।
- **विरासत**: यह बॉटलनेक (डेटा/इंस्ट्रक्शन्स का बस शेयर करना) आज भी हमें परेशान करता है—AI इसे नफ़रत करती है क्योंकि डेटा मूव करने में क्रंचिंग से कहीं ज़्यादा साइकिल लगती हैं।

समीकरण के रूप में: कुल समय = (इंस्ट्रक्शन्स × साइकिल/इंस्ट्रक्शन) / क्लॉक फ़्रीक्वेंसी। IAS (वॉन न्यूमैन-प्रेरित) के लिए: ~1 MHz क्लॉक, तो अधिकतम 1 मिलियन ऑप्स/सेकंड—आपके 1.76B सेकंड? यह नॉन-स्टॉप IAS के लगभग 55 साल चलने जितना होगा, लेकिन यह पहले ही पिघल जाएगी।

यह सेटअप यूनिक्स के एपोक के जंगली पूर्ववर्ती थे—समय एक काउंटर के रूप में, लेकिन आप इसे खुद बनाते थे। अगर आप और गहराई में जाना चाहते हैं (जैसे Altair डिले के लिए कोड स्निपेट्स), तो मुझे बताओ!

[ENIAC Wikipedia](https://en.wikipedia.org/wiki/ENIAC)  
[A Report on the ENIAC](https://ftp.arl.army.mil/mike/comphist/46eniac-report/chap1.html)  
[Electronic Computing Circuits of the ENIAC](https://archive.computerhistory.org/resources/text/Knuth_Don_X4100/PDF_index/k-8-pdf/k-8-r5367-1-ENIAC-circuits.pdf)  
[Organization of the Altair 8800](https://ubuntourist.codeberg.page/Altair-8800/part-2.html)  
[MITS Altair 8800 Brochure](https://vtda.org/docs/computing/MITS/MITS_Altair8800ComputerSystem_Brochure.pdf)  
[Von Neumann Architecture - Wikipedia](https://en.wikipedia.org/wiki/Von_Neumann_architecture)  
[In a simple Von Neumann architecture, what exactly is a clock cycle?](https://www.quora.com/In-a-simple-Von-Neumann-architecture-what-exactly-is-a-clock-cycle)