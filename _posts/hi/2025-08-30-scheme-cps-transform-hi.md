---
audio: false
generated: true
image: false
lang: hi
layout: post
title: स्कीम सीपीएस रूपांतरण कोड विवरण
translated: true
type: note
---

यहाँ आपके स्क्रीनशॉट से निकाला गया कोड है, जिसे स्पष्टता के लिए पुनः स्वरूपित किया गया है:

```scheme
(define cps
  (lambda (exp)
    (letrec
        ([trivial? (lambda (x) (memq x '(zero? add1 sub1)))]
         [id (lambda (v) v)]
         [ctx0 (lambda (v) `(k ,v))]   ; tail context
         [fv (let ([n -1])
               (lambda ()
                 (set! n (+ 1 n))
                 (string->symbol (string-append "v" (number->string n)))))]
         [cps1
          (lambda (exp ctx)
            (pmatch exp
              [,x (guard (not (pair? x))) (ctx x)]
              [(if ,test ,conseq ,alt)
               (cps1 test
                     (lambda (t)
                       (cond
                         [(memq ctx (list ctx0 id))
                          `(if ,t ,(cps1 conseq ctx) ,(cps1 alt ctx))]
                         [else
                          (let ([u (fv)])
                            `(let ([k (lambda (,u) ,(ctx u))])
                               (if ,t ,(cps1 conseq ctx0) ,(cps1 alt ctx0))))])))]
              [(lambda (,x) ,body)
               (ctx `(lambda (,x ,k) ,(cps1 body ctx0)))]
              [(,op ,a ,b)
               (cps1 a
                     (lambda (v1)
                       (cps1 b
                             (lambda (v2)
                               (ctx `(,op ,v1 ,v2)))))))]
              [(,rator ,rand)
               (cps1 rator
                     (lambda (r)
                       (cps1 rand
                             (lambda (d)
                               (cond
                                 [(trivial? r) (ctx `(,r ,d))]
                                 [(eq? ctx ctx0) `(,r ,d ,k)] ; tail call
                                 [else
                                  (let ([u (fv)])
                                    `(,r ,d (lambda (,u) ,(ctx u))))]))))))]))]
      (cps1 exp id))))
```

---

## यह कोड क्या करता है

यह एक छोटी Scheme-जैसी भाषा के लिए एक **कंटिन्यूएशन-पासिंग स्टाइल (CPS) ट्रांसफॉर्मर** का कार्यान्वयन है। CPS प्रोग्राम्स को फिर से लिखने का एक तरीका है ताकि *कंटिन्यूएशन फंक्शन्स* को पास करके कंट्रोल फ्लो को स्पष्ट बनाया जा सके।

### मुख्य घटक

1. **तुच्छ संचालन**

   ```scheme
   (trivial? (lambda (x) (memq x '(zero? add1 sub1))))
   ```

   कुछ आदिम ऑपरेटरों को तुच्छ (CPS रैपिंग की आवश्यकता नहीं) के रूप में चिह्नित करता है।

2. **कंटिन्यूएशन संदर्भ**

   ```scheme
   [id (lambda (v) v)]      ; identity context
   [ctx0 (lambda (v) `(k ,v))] ; default tail continuation
   ```

   `id` बस अपने आर्गुमेंट को लौटाता है, जबकि `ctx0` का मतलब है "मान को कंटिन्यूएशन `k` पर लौटाएं"।

3. **नए वेरिएबल**

   ```scheme
   [fv ...] ; generates symbols v0, v1, v2, ...
   ```

   जब नई बाइंडिंग्स की आवश्यकता होती है तो उपयोग किया जाता है।

4. **मुख्य ट्रांसफॉर्मर**

   ```scheme
   cps1
   ```

   यह एक्सप्रेशन्स को CPS फॉर्म में केस-बाय-केस रिकर्सिवली बदलता है।

   * **वेरिएबल्स और कॉन्स्टेंट्स**
     यदि `x` एक पेयर नहीं है (अणुवत), तो बस कंटिन्यूएशन संदर्भ को लागू करें।

   * **सशर्त कथन**

     ```scheme
     (if test conseq alt)
     ```

     टेस्ट को पहले CPS-ट्रांसफॉर्म किया जाता है।
     यदि संदर्भ सरल है (`ctx0` या `id`), तो सीधा `if` उत्पन्न करें।
     अन्यथा, एक नई कंटिन्यूएशन `k` उत्पन्न करें और दोनों शाखाओं को `ctx0` के साथ CPS करें।

   * **लैम्ब्डा**

     ```scheme
     (lambda (x) body)
     ```

     इसे `(lambda (x k) <CPS of body>)` में बदल दिया जाता है, यानी लैम्ब्डा अब स्पष्ट रूप से एक कंटिन्यूएशन लेते हैं।

   * **बाइनरी ऑपरेशन**

     ```scheme
     (op a b)
     ```

     दोनों ऑपरेंड को CPS'd किया जाता है, फिर संयोजित किया जाता है।

   * **फंक्शन एप्लिकेशन**

     ```scheme
     (rator rand)
     ```

     ऑपरेटर और ऑपरेंड को CPS'd किया जाता है। फिर तुच्छता के आधार पर:

     * यदि ऑपरेटर आदिम है, तो सीधे लागू करें।
     * यदि टेल पोजीशन में है (`ctx = ctx0`), तो बस `(r d k)` को कॉल करें।
     * अन्यथा, एक नई कंटिन्यूएशन में लपेटें।

5. **एंट्री पॉइंट**

   ```scheme
   (cps exp)
   ```

   प्रारंभिक संदर्भ के रूप में `id` के साथ `cps1` को कॉल करता है।

---

## उदाहरण अंतर्ज्ञान

मान लीजिए आप इसे CPS करते हैं:

```scheme
((lambda (x) (add1 x)) 5)
```

CPS ट्रांसफॉर्म इसे कुछ इस तरह बदल देगा:

```scheme
((lambda (x k)
   (k (add1 x)))
 5
 k)
```

जहाँ `k` परिणाम के लिए कंटिन्यूएशन है। मान लौटाने के बजाय, फ़ंक्शन उसे `k` के साथ कॉल करता है।

---

## समीक्षा

* **मजबूत पक्ष**

  * सभी मुख्य CPS ट्रांसफॉर्मेशन नियमों को लागू करता है: वेरिएबल्स, सशर्त कथन, लैम्ब्डा, एप्लिकेशन।
  * तुच्छ ऑपरेटरों बनाम हायर-ऑर्डर कॉल्स को सही ढंग से अलग करता है।
  * टेल कॉल्स को विशेष रूप से हैंडल करता है (Scheme शब्दार्थ के लिए महत्वपूर्ण)।
  * स्वच्छ नए वेरिएबल जनरेशन (`fv`) का उपयोग करता है।

* **संभावित मुद्दे**

  * सीमित आदिम (`zero?`, `add1`, `sub1`) — एक समृद्ध भाषा के लिए `trivial?` को विस्तारित करने की आवश्यकता होगी।
  * `pmatch` (पैटर्न मैचर) का उपयोग करता है — एक सपोर्टिंग मैक्रो लाइब्रेरी की आवश्यकता है।
  * नया वेरिएबल जनरेटर (`fv`) वैश्विक `n` को म्यूटेट करता है — छोटे प्रयोगों के लिए ठीक है, लेकिन समवर्ती या मॉड्यूलर उपयोग में असुरक्षित।
  * मल्टी-आर्गुमेंट लैम्ब्डा को हैंडल नहीं करता है (केवल यूनरी)।
  * लेट-बाइंडिंग्स या फ़ंक्शन एप्लिकेशन से परे अनुक्रमण के लिए कोई समर्थन नहीं है।

---

✅ कुल मिलाकर: यह एक टॉय Scheme के लिए CPS रूपांतरण का एक साफ-सुथरा *शैक्षिक कार्यान्वयन* है। यह कंटिन्यूएशन पासिंग के यांत्रिकी को स्पष्ट रूप से प्रदर्शित करता है: `k` आर्गुमेंट जोड़ना, शाखाओं को लपेटना और नियंत्रण को स्पष्ट बनाना।

---

क्या आप चाहेंगे कि मैं **एक ठोस कार्यशील उदाहरण के माध्यम से चलूँ** (उदाहरण के लिए, `(if (zero? x) (add1 y) (sub1 y))` के चरण-दर-चरण CPS रूपांतरण को दिखाऊं)? इस तरह आप सटीक रूप से देख सकते हैं कि यह कोड इसे कैसे फिर से लिखता है।