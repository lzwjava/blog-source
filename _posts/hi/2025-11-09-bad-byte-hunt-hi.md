---
audio: false
generated: true
image: false
lang: hi
layout: post
model: x-ai/grok-4-fast
title: खराब बाइट की तलाश
translated: true
type: note
---

### यह बुरा बाइट क्यों नहीं मिला
आपके द्वारा प्राप्त `hexdump` का आउटपुट **फ़ाइल ऑफ़सेट** (`000008d0`) से मेल खाता था, न कि वास्तविक कंटेंट में मौजूद `\x8D` बाइट से। Grep पूरी लाइन में टेक्स्ट सर्च कर रहा था, और "8d" हेक्स एड्रेस (जैसे, `08d0`) में दिखाई दिया, इसलिए उसने उस असंबंधित लाइन को खींच लिया। वहाँ मौजूद डेटा बाइट्स (`6f 67 20 ...`) सिर्फ `"og = og_images[i"` के लिए सामान्य ASCII हैं, कोई समस्या नहीं है।

### `\x8D` को ढूंढने के बेहतर तरीके
इन कमांड्स को अपने प्रोजेक्ट डायरेक्टरी में (`_layouts/default.html` के बगल में) चलाएं। ये फ़ाइल के बाइट्स को सीधे स्कैन करेंगे।

1. **बेहतर Hexdump (डेटा में बाइट के लिए Grep करें)**:
   यह ` 8d ` (ऑफ़सेट से नहीं, हेक्स बाइट्स से मेल खाने के लिए चारों ओर स्पेस) के लिए grep करता है:
   ```
   hexdump -C _layouts/default.html | grep ' 8d '
   ```
   - अगर यह कुछ ढूंढ लेता है, तो आपको ऑफ़सेट (बायाँ कॉलम) और आसपास के बाइट्स दिखाई देंगे। ऑफ़सेट नोट करें, फिर अपने एडिटर में उस पोजीशन पर जाएँ (उदा., VS Code: Ctrl+G > बाइट ऑफ़सेट / 16 लगभग लाइन के लिए)।
   - हिट होने पर उदाहरण आउटपुट: `00001234  ...  8d  20  61  62  ... |... ab...|`

2. **`xxd` का उपयोग करें (अक्सर Hexdump से बेहतर)**:
   macOS में `xxd` बिल्ट-इन होता है:
   ```
   xxd _layouts/default.html | grep 8d
   ```
   - इसी तरह: हेक्स बाइट्स में "8d" से मेल खाता है। अगर कोई आउटपुट नहीं है, तो वह बाइट वहाँ नहीं है (दुर्लभ, लेकिन संभव अगर यह किसी अन्य फ़ाइल में है)।

3. **बाइनरी Grep (सीधा बाइट सर्च)**:
   ```
   grep -a -o -P '\x8d' _layouts/default.html | hexdump -C
   ```
   - यह बाइट से एकदम मेल खाने वाले को निकालता है और उन्हें हेक्स में डंप करता है। अगर खाली है, तो कोई `\x8D` नहीं है।

4. **Ruby वन-लाइनर (सटीक पोजीशन)**:
   जैसा मैंने पहले सुझाव दिया था—बाइट इंडेक्स पाने के लिए इसे चलाएँ:
   ```
   ruby -e "File.open('_layouts/default.html', 'rb') { |f| f.read.each_byte.with_index { |b, i| puts \"Found at byte #{i}: #{b.chr(Encoding::ASCII_8BIT).inspect}\" if b == 0x8D } }"
   ```
   - आउटपुट इस तरह होगा: `Found at byte 1234: "\x8D"`। फिर एडिट करें: फ़ाइल खोलें, लगभग ~1234 वें कैरेक्टर पर जाएँ (या लाइन = 1234/80 के आसपास), और उस अदृश्य कैरेक्टर को डिलीट करें (यह कुछ भी नहीं जैसा दिख सकता है; इसके आसपास सिलेक्ट/डिलीट करें)।

### अगर कोई मैच नहीं मिले?
- `\x8D` किसी **अलग फ़ाइल** में हो सकता है (उदा., लेआउट में `{{ content }}` के माध्यम से रेंडर की गई `_posts/` में एक पोस्ट)। पूरी साइट को स्कैन करें:
  ```
  find . -name "*.md" -o -name "*.html" | xargs grep -l $'\x8D'
  ```
  (या प्रत्येक संदिग्ध फ़ाइल पर Ruby स्क्रिप्ट का उपयोग करें।)
- या यह फ़ाइल की शुरुआत में एक BOM/अदृश्य है: एडिटर में खोलें, पहली लाइन अगर खाली है तो डिलीट करें, फिर से UTF-8 में सेव करें।

एक बार इसे हटा देने के बाद, `bundle exec jekyll serve --incremental` फिर से चलाएँ। अगर अभी भी समस्या है, तो इनमें से किसी एक कमांड (या Ruby वाले) का आउटपुट पेस्ट करें, और हम इसे ठीक कर लेंगे।

[बाइट हंटिंग के लिए Hexdump टिप्स](https://unix.stackexchange.com/questions/38331/finding-bad-characters-in-hex-dump)