---
audio: false
generated: true
lang: hi
layout: post
title: जावा की प्रकार प्रणाली
translated: true
type: note
---

ठीक है, आइए Java के टाइप सिस्टम में गोता लगाएँ! यह ट्यूटोरियल आपको शुरुआत करने के लिए मूलभूत अवधारणाओं को कवर करेगा।

**टाइप सिस्टम क्या है?**

प्रोग्रामिंग में, एक टाइप सिस्टम उन प्रकार के मूल्यों को परिभाषित करता है जिनका उपयोग किया जा सकता है और उन्हें कैसे मैनिपुलेट किया जा सकता है। यह यह सुनिश्चित करने में मदद करता है कि प्रोग्राम टाइप-सेफ हैं, मतलब कि ऑपरेशन सही प्रकार के डेटा पर किए जाते हैं, जिससे अप्रत्याशित एरर्स को रोका जा सके और कोड की विश्वसनीयता में सुधार हो सके।

Java का एक **स्ट्रॉन्ग और स्टैटिक टाइप सिस्टम** है।

* **स्ट्रॉन्ग टाइपिंग:** Java स्ट्रॉन्गली टाइप्ड है, जिसका अर्थ है कि एक वेरिएबल का टाइप कंपाइल टाइम और रनटाइम पर सख्ती से लागू होता है। आम तौर पर आप एक्सप्लिसिट कन्वर्जन (कास्टिंग) के बिना असंगत प्रकारों पर ऑपरेशन नहीं कर सकते। यह डेवलपमेंट प्रक्रिया में जल्दी एरर्स को पकड़ने में मदद करता है।
* **स्टैटिक टाइपिंग:** Java स्टैटिकली टाइप्ड है, जिसका अर्थ है कि वेरिएबल्स के प्रकार प्रोग्राम के रन होने से पहले घोषित (या कुछ मामलों में `var` के साथ अनुमानित) किए जाते हैं। कंपाइलर एक्जिक्यूशन से पहले कंपेटिबिलिटी के लिए इन प्रकारों की जाँच करता है।

**Java के टाइप सिस्टम के मुख्य घटक:**

Java का टाइप सिस्टम मोटे तौर पर दो मुख्य श्रेणियों में विभाजित है:

1.  **प्रिमिटिव टाइप्स:** ये Java में सबसे बेसिक डेटा टाइप हैं। ये मेमोरी में सीधे सिंगल वैल्यूज को रिप्रेजेंट करते हैं।
2.  **रेफरेंस टाइप्स:** ये टाइप ऑब्जेक्ट्स को रिप्रेजेंट करते हैं, जो क्लासेज या इंटरफेस के इंस्टेंस होते हैं। रेफरेंस वेरिएबल्स ऑब्जेक्ट का मेमोरी एड्रेस (रेफरेंस) स्टोर करते हैं।

आइए इनमें से प्रत्येक को विस्तार से देखें।

**1. प्रिमिटिव टाइप्स:**

Java के आठ प्रिमिटिव डेटा टाइप हैं:

| टाइप    | साइज (बिट्स) | विवरण                                      | रेंज                                                                 | उदाहरण         |
| ------- | ----------- | ------------------------------------------------ | --------------------------------------------------------------------- | --------------- |
| `byte`  | 8           | साइन्ड इंटीजर                                   | -128 से 127                                                           | `byte age = 30;` |
| `short` | 16          | साइन्ड इंटीजर                                   | -32,768 से 32,767                                                     | `short count = 1000;` |
| `int`   | 32          | साइन्ड इंटीजर                                   | -2,147,483,648 से 2,147,483,647                                     | `int score = 95;` |
| `long`  | 64          | साइन्ड इंटीजर                                   | -9,223,372,036,854,775,808 से 9,223,372,036,854,775,807             | `long population = 1000000000L;` ('L' सफिक्स नोट करें) |
| `float` | 32          | सिंगल-प्रिसिजन फ्लोटिंग-पॉइंट नंबर (IEEE 754) | लगभग ±3.40282347E+38F                                        | `float price = 19.99F;` ('F' सफिक्स नोट करें) |
| `double`| 64          | डबल-प्रिसिजन फ्लोटिंग-पॉइंट नंबर (IEEE 754) | लगभग ±1.79769313486231570E+308                               | `double pi = 3.14159;` |
| `char`  | 16          | सिंगल यूनिकोड कैरेक्टर                         | '\u0000' (0) से '\uffff' (65,535)                                   | `char initial = 'J';` |
| `boolean`| वैरीज़ होती है      | एक लॉजिकल वैल्यू रिप्रेजेंट करता है                       | `true` या `false`                                                     | `boolean isVisible = true;` |

**प्रिमिटिव टाइप्स के बारे में मुख्य बातें:**

* इन्हें सीधे मेमोरी में स्टोर किया जाता है।
* इनके प्रीडिफाइंड साइज और रेंज होते हैं।
* ये ऑब्जेक्ट नहीं होते हैं और इनसे जुड़ी कोई मेथड्स नहीं होती हैं (हालांकि रैपर क्लासेज जैसे `Integer`, `Double`, आदि ऑब्जेक्ट रिप्रेजेंटेशन प्रदान करते हैं)।
* अगर प्रिमिटिव टाइप फील्ड्स को एक्सप्लिसिटली इनिशियलाइज़ नहीं किया जाता है तो उन्हें डिफॉल्ट वैल्यूज असाइन की जाती हैं (जैसे, `int` डिफॉल्ट 0, `boolean` डिफॉल्ट `false`)।

**2. रेफरेंस टाइप्स:**

रेफरेंस टाइप ऑब्जेक्ट्स को रिप्रेजेंट करते हैं, जो क्लासेज या इंटरफेस के इंस्टेंस होते हैं। रेफरेंस टाइप्स के वेरिएबल्स हीप में ऑब्जेक्ट का मेमोरी एड्रेस (रेफरेंस) होल्ड करते हैं।

**सामान्य रेफरेंस टाइप्स:**

* **क्लासेज:** क्लासेज ऑब्जेक्ट्स बनाने के लिए ब्लूप्रिंट होती हैं। वे उस टाइप के ऑब्जेक्ट्स के डेटा (फील्ड्स/एट्रिब्यूट्स) और बिहेवियर (मेथड्स) को डिफाइन करती हैं।
    ```java
    class Dog {
        String name;
        int age;

        public void bark() {
            System.out.println("Woof!");
        }
    }

    public class Main {
        public static void main(String[] args) {
            Dog myDog = new Dog(); // 'Dog' रेफरेंस टाइप है
            myDog.name = "Buddy";
            myDog.age = 3;
            myDog.bark();
        }
    }
    ```
* **इंटरफेस:** इंटरफेस मेथड्स के एक कॉन्ट्रैक्ट को डिफाइन करते हैं जिन्हें एक क्लास इम्प्लीमेंट कर सकती है। वे बिहेवियर्स के एक सेट को रिप्रेजेंट करते हैं।
    ```java
    interface Animal {
        void makeSound();
    }

    class Cat implements Animal {
        public void makeSound() {
            System.out.println("Meow!");
        }
    }

    public class Main {
        public static void main(String[] args) {
            Animal myCat = new Cat(); // 'Animal' रेफरेंस टाइप है
            myCat.makeSound();
        }
    }
    ```
* **अरेज़:** अरेज़ एक ही टाइप के एलिमेंट्स के कलेक्शन होते हैं। अरे का टाइप उसके एलिमेंट्स के टाइप द्वारा निर्धारित होता है।
    ```java
    int[] numbers = new int[5]; // 'int[]' रेफरेंस टाइप है
    numbers[0] = 10;

    String[] names = {"Alice", "Bob", "Charlie"}; // 'String[]' रेफरेंस टाइप है
    ```
* **एनम्स (एनुमरेशन्स):** एनम्स नामित कॉन्स्टेंट्स के एक फिक्स्ड सेट को रिप्रेजेंट करते हैं।
    ```java
    enum Day {
        MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
    }

    public class Main {
        public static void main(String[] args) {
            Day today = Day.MONDAY; // 'Day' रेफरेंस टाइप है
            System.out.println("Today is " + today);
        }
    }
    ```
* **रैपर क्लासेज:** प्रत्येक प्रिमिटिव टाइप के लिए, Java एक संबंधित रैपर क्लास प्रदान करता है (जैसे, `int` के लिए `Integer`, `double` के लिए `Double`)। ये आपको प्रिमिटिव वैल्यूज को ऑब्जेक्ट्स के रूप में ट्रीट करने की अनुमति देते हैं।
    ```java
    Integer num = 10; // 'Integer' रेफरेंस टाइप है
    Double piValue = 3.14; // 'Double' रेफरेंस टाइप है
    ```

**रेफरेंस टाइप्स के बारे में मुख्य बातें:**

* ये हीप में ऑब्जेक्ट्स के रेफरेंस (मेमोरी एड्रेस) स्टोर करते हैं।
* ये `null` हो सकते हैं, मतलब रेफरेंस किसी ऑब्जेक्ट को पॉइंट नहीं करता।
* इनसे जुड़ी मेथड्स और फील्ड्स होती हैं (जो उनकी क्लास या इंटरफेस द्वारा डिफाइन की गई होती हैं)।
* अनइनिशियलाइज़्ड रेफरेंस टाइप फील्ड्स के लिए डिफॉल्ट वैल्यू `null` होती है।

**3. `var` के साथ टाइप इन्फरेंस (Java 10 और बाद के वर्जन):**

Java 10 ने `var` कीवर्ड पेश किया, जो लोकल वेरिएबल टाइप इन्फरेंस की अनुमति देता है। टाइप को एक्सप्लिसिटली डिक्लेयर करने के बजाय, कंपाइलर इनिशियलाइज़र एक्सप्रेशन के आधार पर टाइप का अनुमान लगा सकता है।

```java
var message = "Hello"; // कंपाइलर 'message' का टाइप String अनुमानित करता है
var count = 100;      // कंपाइलर 'count' का टाइप int अनुमानित करता है
var prices = new double[]{10.5, 20.3}; // कंपाइलर 'prices' का टाइप double[] अनुमानित करता है
```

**`var` के बारे में महत्वपूर्ण नोट्स:**

* `var` का उपयोग केवल मेथड्स, कंस्ट्रक्टर्स, या इनिशियलाइज़र्स के अंदर लोकल वेरिएबल्स के लिए किया जा सकता है।
* `var` का उपयोग करते समय आपको एक इनिशियलाइज़र प्रदान करना होगा क्योंकि कंपाइलर को टाइप का अनुमान लगाने के लिए इसकी आवश्यकता होती है।
* `var` Java की स्टैटिक टाइपिंग को नहीं बदलता है। टाइप अभी भी कंपाइल टाइम पर निर्धारित होता है।

**4. जेनेरिक्स:**

जेनेरिक्स आपको टाइप्स को पैरामीटराइज़ करने की अनुमति देते हैं। इसका मतलब है कि आप ऐसी क्लासेज, इंटरफेस और मेथड्स डिफाइन कर सकते हैं जो कंपाइल-टाइम टाइप सेफ्टी प्रदान करते हुए अलग-अलग टाइप्स के साथ काम कर सकें।

```java
import java.util.ArrayList;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<String> names = new ArrayList<>(); // स्ट्रिंग्स की लिस्ट
        names.add("Alice");
        names.add("Bob");

        // names.add(123); // यह कंपाइल-टाइम एरर का कारण बनेगा

        List<Integer> numbers = new ArrayList<>(); // इंटीजर्स की लिस्ट
        numbers.add(10);
        numbers.add(20);
    }
}
```

यहाँ, `<String>` और `<Integer>` टाइप पैरामीटर्स हैं। जेनेरिक्स कंपाइल टाइम पर टाइप कंस्ट्रेंट्स लागू करके रनटाइम पर `ClassCastException` को रोकने में मदद करते हैं।

**5. टाइप चेकिंग:**

Java मुख्य रूप से दो स्टेजेस पर टाइप चेकिंग करता है:

* **कंपाइल-टाइम टाइप चेकिंग:** Java कंपाइलर कोड को एक्जिक्यूट होने से पहले टाइप एरर्स के लिए चेक करता है। अगर कोई टाइप मिसमैच हैं (जैसे, एक्सप्लिसिट कास्टिंग के बिना एक `String` को `int` वेरिएबल में असाइन करने की कोशिश करना), तो कंपाइलर एक एरर रिपोर्ट करेगा और प्रोग्राम को कंपाइल होने से रोक देगा।
* **रनटाइम टाइप चेकिंग:** कुछ टाइप चेक प्रोग्राम एक्जिक्यूशन के दौरान किए जाते हैं। उदाहरण के लिए, जब आप एक रेफरेंस टाइप को दूसरे टाइप में कास्ट करते हैं, तो JVM चेक करता है कि क्या ऑब्जेक्ट वास्तव में टारगेट टाइप का एक इंस्टेंस है। यदि नहीं, तो एक `ClassCastException` थ्रो होती है।

**6. टाइप कन्वर्जन (कास्टिंग):**

कभी-कभी आपको एक वैल्यू को एक टाइप से दूसरे टाइप में कन्वर्ट करने की आवश्यकता होती है। Java दो प्रकार की कास्टिंग सपोर्ट करता है:

* **इम्प्लिसिट कास्टिंग (वाइडनिंग कन्वर्जन):** यह ऑटोमैटिक होती है जब आप एक छोटे प्रिमिटिव टाइप के वैल्यू को एक बड़े प्रिमिटिव टाइप के वेरिएबल में असाइन करते हैं। कोई डेटा लॉस नहीं होता है।
    ```java
    int myInt = 10;
    long myLong = myInt; // int से long में इम्प्लिसिट कास्टिंग
    double myDouble = myLong; // long से double में इम्प्लिसिट कास्टिंग
    ```
* **एक्सप्लिसिट कास्टिंग (नैरोइंग कन्वर्जन):** यह मैन्युअली एक कास्ट ऑपरेटर `(targetType)` का उपयोग करके की जानी चाहिए जब आप एक बड़े प्रिमिटिव टाइप के वैल्यू को एक छोटे प्रिमिटिव टाइप के वेरिएबल में असाइन करते हैं। डेटा लॉस हो सकता है।
    ```java
    double myDouble = 10.99;
    int myInt = (int) myDouble; // double से int में एक्सप्लिसिट कास्टिंग (myInt 10 होगा)
    ```
* **रेफरेंस टाइप कास्टिंग:** आप रेफरेंस टाइप्स के बीच भी कास्ट कर सकते हैं, लेकिन यह अधिक कॉम्प्लेक्स है और इसमें इनहेरिटेंस और इंटरफेस शामिल होते हैं।
    * **अपकास्टिंग:** एक सबक्लास के ऑब्जेक्ट को उसके सुपरक्लास टाइप में कास्ट करना। यह हमेशा इम्प्लिसिटली अनुमति दी जाती है।
    * **डाउनकास्टिंग:** एक सुपरक्लास टाइप के ऑब्जेक्ट को उसकी सबक्लास टाइप में कास्ट करना। इसके लिए एक्सप्लिसिट कास्ट की आवश्यकता होती है और अगर ऑब्जेक्ट वास्तव में सबक्लास का इंस्टेंस नहीं है तो इसके परिणामस्वरूप रनटाइम पर `ClassCastException` हो सकती है।

**रेफरेंस टाइप कास्टिंग का उदाहरण:**

```java
class Animal {}
class Dog extends Animal {
    public void bark() {
        System.out.println("Woof!");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Dog(); // अपकास्टिंग (इम्प्लिसिट)

        // Dog myDog = myAnimal; // कंपाइल-टाइम एरर: Animal से Dog में इम्प्लिसिटली कन्वर्ट नहीं कर सकते
        Dog myDog = (Dog) myAnimal; // डाउनकास्टिंग (एक्सप्लिसिट)
        myDog.bark(); // यह काम करेगा

        Animal anotherAnimal = new Animal();
        // Dog anotherDog = (Dog) anotherAnimal; // यह रनटाइम पर ClassCastException थ्रो करेगा
    }
}
```

**निष्कर्ष:**

Java के टाइप सिस्टम को समझना सही और मजबूत कोड लिखने के लिए महत्वपूर्ण है। प्रिमिटिव और रेफरेंस टाइप्स के बीच के अंतर, जेनेरिक्स कैसे काम करते हैं, और टाइप चेकिंग और कास्टिंग के नियमों को जानकर, आप सामान्य प्रोग्रामिंग एरर्स से बच सकते हैं और अधिक विश्वसनीय एप्लिकेशन बना सकते हैं।

यह ट्यूटोरियल एक मूलभूत समझ प्रदान करता है। जैसे-जैसे आप Java सीखना जारी रखेंगे, आप टाइप्स से संबंधित अधिक उन्नत अवधारणाओं का सामना करेंगे, जैसे इनहेरिटेंस, पॉलीमॉर्फिज्म, और अधिक कॉम्प्लेक्स जेनेरिक सिनेरियो। अपनी समझ को मजबूत करने के लिए अभ्यास जारी रखें और विभिन्न प्रकारों के साथ प्रयोग करते रहें!