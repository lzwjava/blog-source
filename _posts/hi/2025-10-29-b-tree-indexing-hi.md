---
audio: false
generated: true
image: false
lang: hi
layout: post
model: x-ai/grok-4-fast
title: कारगर डेटाबेस इंडेक्सिंग के लिए बी-ट्री
translated: true
type: note
---

### B-ट्री क्या है?

B-ट्री (जिसका पूरा नाम "बैलेंस्ड ट्री" है) एक सेल्फ-बैलेंसिंग ट्री डेटा स्ट्रक्चर है जिसे बड़ी मात्रा में डेटा के कुशल भंडारण, सम्मिलन, विलोपन और पुनर्प्राप्ति के लिए डिज़ाइन किया गया है। यह विशेष रूप से उन सिस्टम के लिए अनुकूलित है जहां डेटा डिस्क पर संग्रहीत होता है (जैसे डेटाबेस), क्योंकि यह पेड़ को यथासंभव उथला रखकर महंगी डिस्क I/O ऑपरेशनों की संख्या को कम करता है।

#### B-ट्री के मुख्य गुण
- **ऑर्डर (या डिग्री)**: एक पैरामीटर *t* (न्यूनतम डिग्री) द्वारा परिभाषित, जहां प्रत्येक नोड में *t-1* से *2t-1* कुंजियाँ (और अधिकतम *2t* चिल्ड्रन) हो सकती हैं। यह नोड्स को कई कुंजियाँ रखने की अनुमति देता है, जिससे पेड़ चौड़ा और छोटा बनता है।
- **संतुलित संरचना**: सभी लीफ नोड्स एक ही स्तर पर होते हैं, जो ऑपरेशन्स के लिए लॉगरिदमिक टाइम कॉम्प्लेक्सिटी (O(log n), जहाँ n कुंजियों की संख्या है) सुनिश्चित करता है।
- **क्रमबद्ध कुंजियाँ**: प्रत्येक नोड में कुंजियाँ क्रमबद्ध क्रम में संग्रहीत होती हैं, और पेड़ इस इनवेरिएंट को बनाए रखता है। एक कुंजी के बाईं ओर के सबट्री में छोटे मान होते हैं, और दाईं ओर बड़े मान होते हैं।
- **नोड संरचना**: इंटरनल नोड्स में ऐसी कुंजियाँ होती हैं जो खोज को चाइल्ड नोड्स की ओर ले जाती हैं। लीफ नोड्स वास्तविक डेटा (या उसके पॉइंटर्स) को संग्रहीत करते हैं।

बाइनरी सर्च ट्री (BST) के विपरीत, जो प्रति नोड दो चिल्ड्रन तक सीमित होते हैं और असंतुलित हो सकते हैं (जिससे O(n) वर्स्ट-केस परफॉर्मेंस होती है), B-ट्री मल्टी-वे ट्री होते हैं जो सम्मिलन/विलोपन के दौरान नोड्स को विभाजित और मर्ज करके संतुलित बने रहते हैं।

#### सरल उदाहरण
एक ऑर्डर 3 के B-ट्री (*t=3*, इसलिए प्रति नोड 2-5 कुंजियाँ) की कल्पना करें। एक छोटा पेड़ टेक्स्ट फॉर्म में कुछ इस तरह दिख सकता है:

```
       [10, 20, 30]
      /    |    |    \
 [5,7]  [15] [22,25] [35,40]
```

- 25 की खोज: रूट पर शुरू करें, 10/20/30 से तुलना करें → [22,25] पर जाएँ → मिल गया।

यह संरचना कुछ ही नोड्स को ट्रैवर्स करके रेंज क्वेरीज़ (जैसे, 15 और 25 के बीच की सभी कुंजियाँ) को कुशल बनाती है।

### डेटाबेस B-ट्री का उपयोग कैसे करते हैं

डेटाबेस (जैसे रिलेशनल वाले: MySQL, PostgreSQL, SQL Server) डिस्क पर संग्रहीत बड़ी टेबल्स पर क्वेरीज़ को तेज़ करने के लिए **इंडेक्सिंग** हेतु B-ट्री (या B+ ट्री जैसे वेरिएंट) पर भारी निर्भर करते हैं। इंडेक्स के बिना, क्वेरीज़ को फुल टेबल स्कैन (O(n) टाइम, लाखों पंक्तियों के लिए धीमा) की आवश्यकता होगी।

#### डेटाबेस में प्राथमिक उपयोग
1.  **प्राथमिक और द्वितीयक इंडेक्स**:
    - एक **प्राइमरी इंडेक्स** प्राइमरी की (यूनिक आइडेंटिफायर) पर बनाया जाता है। यह तेज़ लुकअप के लिए टेबल की पंक्तियों को B-ट्री क्रम में व्यवस्थित करता है।
    - **सेकेंडरी इंडेक्स** अन्य कॉलम (जैसे नाम, तिथि) पर होते हैं। लीफ नोड्स वास्तविक पंक्ति स्थानों (रो आईडी के माध्यम से) की ओर इशारा करते हैं।

2.  **कुशल डिस्क एक्सेस**:
    - डिस्क डेटा को ब्लॉक्स (जैसे, 4KB पेज) में पढ़ती है। B-ट्री नोड्स का आकार एक डिस्क ब्लॉक में फिट होने के लिए होता है, इसलिए एक खोज में आमतौर पर केवल 3-4 ब्लॉक (पेड़ की ऊंचाई) पढ़ने की आवश्यकता होती है, बनिस्बत एक लिंक्ड लिस्ट में संभावित हज़ारों के।
    - ऊंचाई लॉगरिदमिक होती है: 1 अरब कुंजियों के लिए, ऊंचाई केवल 4-5 स्तर की हो सकती है।

3.  **B+ ट्री वेरिएंट (डीबी में आम)**:
    - अधिकांश डेटाबेस **B+ ट्री** का उपयोग करते हैं, जो एक B-ट्री ट्वीक है जहां:
        - केवल लीफ नोड्स डेटा/पॉइंटर्स संग्रहीत करते हैं।
        - इंटरनल नोड्स में केवल रूटिंग के लिए कुंजियाँ होती हैं।
        - लीफ्स कुशल अनुक्रमिक स्कैन और रेंज क्वेरीज़ (जैसे, `SELECT * WHERE age BETWEEN 20 AND 30`) के लिए लिंक्ड (डबल-लिंक्ड लिस्ट) होते हैं।
    - यह रेंज ऑपरेशन और कैश दक्षता में सुधार करता है।

4.  **व्यवहार में ऑपरेशन**:
    - **INSERT/UPDATE/DELETE**: पेड़ संतुलन बनाए रखने के लिए नोड्स को विभाजित या मर्ज करता है। डेटाबेस लैच/लॉक के साथ समवर्तीता को संभालते हैं।
    - **क्वेरी ऑप्टिमाइज़ेशन**: क्वेरी प्लानर इंडेक्स स्टैटिस्टिक्स का उपयोग टेबल स्कैन पर B-ट्री इंडेक्स को चुनने के लिए करता है।
    - **क्लस्टर्ड बनाम नॉन-क्लस्टर्ड**: क्लस्टर्ड इंडेक्स (जैसे, MySQL में InnoDB) में, टेबल डेटा भौतिक रूप से B-ट्री लीफ क्रम में संग्रहीत होता है। नॉन-क्लस्टर्ड वाले केवल डेटा की ओर इशारा करते हैं।

#### लाभ और समायोजन
- **फायदे**: समानता, रेंज और क्रमबद्ध क्वेरीज़ के लिए तेज़; बढ़ते डेटा को अच्छी तरह से संभालता है।
- **नुकसान**: सम्मिलन/विलोपन के लिए ओवरहेड (पेड़ रखरखाव); बैचिंग के बिना बहुत लगातार अपडेट के लिए आदर्श नहीं।

संक्षेप में, इंडेक्स्ड एक्सेस के लिए डेटाबेस प्रदर्शन की रीढ़ B-ट्री हैं, जो रैखिक खोजों को उनके संतुलित, डिस्क-अनुकूल डिज़ाइन के माध्यम से लगभग स्थिर-समय ऑपरेशन में बदल देती हैं।

#### संदर्भ
- [B-tree - Wikipedia](https://en.wikipedia.org/wiki/B-tree)
- [B+ Tree in DBMS - GeeksforGeeks](https://www.geeksforgeeks.org/introduction-of-b-tree/)
- [How Indexes Work in SQL Databases - Use The Index, Luke](https://use-the-index-luke.com/sql/anatomy/index-btree)