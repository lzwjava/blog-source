---
audio: false
generated: true
image: false
lang: hi
layout: post
model: x-ai/grok-4-fast
title: केएमपी एल्गोरिदम कुशल स्ट्रिंग खोज
translated: true
type: note
---

### नाइफ-मॉरिस-प्रैट (KMP) एल्गोरिदम को समझना

आपकी समझ बिल्कुल सही है: KMP पूरी तरह से स्ट्रिंग खोज के दौरान **आंशिक मेल (partial matches) को बर्बाद न करने** के बारे में है। जब आप एक लंबे टेक्स्ट (जैसे "ababcabc") में एक पैटर्न (जैसे "abc") ढूंढ रहे होते हैं, तो नाइव तरीका हर बार मिसमैच होने पर शुरुआत से फिर से शुरू करता है, जो अक्षम है। KMP चतुराई से "याद रखता है" कि आपने पैटर्न का कितना हिस्सा पहले ही मैच कर लिया है और आगे बढ़ जाता है, जिससे अनावश्यक तुलनाएं बचती हैं। यह इसे सुपर फास्ट बनाता है—रैखिक समय, O(n + m), जहाँ n टेक्स्ट की लंबाई है और m पैटर्न की लंबाई है।

मैं इसे एक सरल उदाहरण के साथ चरण दर चरण समझाऊंगा। हम टेक्स्ट `T = "ababababc"` में पैटर्न `P = "abab"` को खोजेंगे। (यह पोजीशन 0 और 2 पर मिलता है।)

#### चरण 1: समस्या और नाइव तरीका
- **लक्ष्य**: `T` में वे सभी शुरुआती पोजीशन ढूंढना जहाँ `P` पूरी तरह से मेल खाता है।
- **नाइव तरीका**: `P` को `T` पर स्लाइड करें, और प्रत्येक कैरेक्टर की तुलना करें। यदि `P` की पोजीशन i पर मिसमैच होता है, तो `P` को 1 से शिफ्ट करें और `P` की शुरुआत से फिर से कोशिश करें।
  - हमारे उदाहरण के लिए:
    - T[0] से शुरू करें: "a"=="a" (मेल), "b"=="b" (मेल), "a"=="a" (मेल), "b"=="b" (मेल) → 0 पर मिला।
    - T[1] पर शिफ्ट करें: "b"=="a"? नहीं → `P` को शुरुआत से रीस्टार्ट करें। बर्बादी!
    - T[2]: "a"=="a", "b"=="b", "a"=="a", "b"=="b" → 2 पर मिला।
    - T[3]: "a"=="a", "b"=="b", "a"=="a", "b"=="a"? नहीं → रीस्टार्ट।
    - और आगे भी। `P` के कैरेक्टर 0 पर बहुत सारी बैकट्रैकिंग।

सबसे खराब स्थिति में यह O(n*m) हो सकता है (उदाहरण के लिए, "aaa...ab" को "aaaaa...a" में खोजना)।

#### चरण 2: KMP की मुख्य अवधारणा – प्रीफिक्स टेबल (या "फेल्योर फंक्शन")
KMP पैटर्न `P` के लिए एक टेबल `π` (पाई) प्रीकंप्यूट करता है। यह टेबल आपको बताती है, `P` की प्रत्येक पोजीशन i के लिए, **`P[0..i]` का सबसे लंबा उचित प्रीफिक्स (proper prefix) जो एक सफिक्स (suffix) भी है**। दूसरे शब्दों में: "अगर हमें यहाँ मिसमैच होता है, तो हम इस ओवरलैपिंग प्रीफिक्स पर जाकर आंशिक मेल के कितने हिस्से का पुन: उपयोग कर सकते हैं?"

- **उचित प्रीफिक्स/सफिक्स**: एक प्रीफिक्स/सफिक्स जो पूरी स्ट्रिंग नहीं है (उदाहरण के लिए, "aba" के लिए, प्रीफिक्स "a" सफिक्स "a" से मेल खाता है)।
- क्यों? यह आपको मिसमैच होने पर पैटर्न को 1 से अधिक से "स्लाइड" करने देता है, रीस्टार्ट करने के बजाय ओवरलैप का पुन: उपयोग करता है।

`P = "abab"` के लिए:
- `π` को चरण दर चरण बनाएं (हम इसे जल्द ही कोड करेंगे)।

| पोजीशन i | P[0..i] | सबसे लंबा उचित प्रीफिक्स = सफिक्स | π[i] |
|------------|---------|--------------------------------|------|
| 0          | "a"     | कोई नहीं (सिंगल कैरेक्टर)             | 0    |
| 1          | "ab"    | कोई नहीं                           | 0    |
| 2          | "aba"   | "a" (प्रीफिक्स "a" == सफिक्स "a") | 1    |
| 3          | "abab"  | "ab" (प्रीफिक्स "ab" == सफिक्स "ab") | 2  |

- π[2] = 1 का मतलब: यदि आपने "aba" मैच किया है लेकिन अगले कैरेक्टर पर मिसमैच होता है, तो मान लें कि आपने अब तक प्रीफिक्स "a" (लंबाई 1) मैच किया है।
- π[3] = 2 का मतलब: पूरे "abab" के लिए, "ab" का ओवरलैप।

#### चरण 3: प्रीफिक्स टेबल (π) बनाना
यह O(m) समय में किया जाता है। यह `P` को स्वयं के विरुद्ध खोजने जैसा है, एक समान लॉजिक का उपयोग करते हुए।

स्यूडोकोड:
```
def compute_prefix_function(P):
    m = len(P)
    pi = [0] * m
    k = 0  # वर्तमान प्रीफिक्स-सफिक्स मैच की लंबाई
    for i in range(1, m):
        while k > 0 and P[k] != P[i]:
            k = pi[k-1]  # पिछले ओवरलैप पर जाएँ (पुन: उपयोग!)
        if P[k] == P[i]:
            k += 1
        pi[i] = k
    return pi
```

- π[0] = 0 से शुरू करें।
- प्रत्येक i=1 से m-1 के लिए:
  - वर्तमान मैच लंबाई k को बढ़ाने का प्रयास करें।
  - यदि मिसमैच हो, तो π[k-1] पर वापस जाएँ (बर्बाद न करें—पिछले ओवरलैप का पुन: उपयोग करें)।
  - यदि मैच हो, तो k++।

"abab" के लिए:
- i=1: P[0]='a' != P[1]='b' → k=0, π[1]=0.
- i=2: P[0]='a' == P[2]='a' → k=1, π[2]=1.
- i=3: P[1]='b' == P[3]='b' → k=2, π[3]=2.

#### चरण 4: प्रीफिक्स टेबल के साथ खोजना
अब `T` को `P` और `π` के साथ खोजें:
- एक वेरिएबल `q` = वर्तमान स्टेट (अब तक मैच किए गए प्रीफिक्स की लंबाई) रखें।
- `T` के प्रत्येक कैरेक्टर के लिए:
  - जब तक मिसमैच हो और q>0 हो, तब तक q = π[q-1] सेट करें (चतुराई से वापस जाएँ)।
  - यदि मैच हो, तो q++।
  - यदि q == m हो, तो मिल गया! फिर q = π[q-1] ओवरलैप्स के लिए जारी रखने के लिए।

स्यूडोकोड:
```
def kmp_search(T, P):
    n, m = len(T), len(P)
    if m == 0: return []
    pi = compute_prefix_function(P)
    q = 0
    matches = []
    for i in range(n):
        while q > 0 and P[q] != T[i]:
            q = pi[q-1]
        if P[q] == T[i]:
            q += 1
        if q == m:
            matches.append(i - m + 1)  # शुरुआती पोजीशन
            q = pi[q-1]  # अगली खोज के लिए ओवरलैप
    return matches
```

`T = "ababababc"`, `P = "abab"` के लिए:
- i=0: 'a'=='a' → q=1
- i=1: 'b'=='b' → q=2
- i=2: 'a'=='a' → q=3
- i=3: 'b'=='b' → q=4 == m → 0 पर मैच, q=π[3]=2
- i=4: अब q=2, T[4]='a' == P[2]='a' → q=3
- i=5: 'b'=='b' → q=4 == m → 2 पर मैच, q=2
- i=6: q=2, 'a'=='a' → q=3
- i=7: q=3, 'b' != P[3]='b'? रुकिए, 'b'=='b' → q=4 == m? लेकिन T[7]='b', नहीं रुकिए: T="ababababc", i=6='a' (q=3), i=7='b'==P[3]='b' → q=4, लेकिन i=8='c' अगला।
- असल में: i=5 (पोजीशन 2) पर दूसरा मैच के बाद, q=2, i=6='a'==P[2]='a' q=3, i=7='b'==P[3]='b' q=4 → 4 पर मैच? रुकिए, पूरी ट्रेस करते हैं।

रुकिए, ट्रेस पर सुधार (पूरी रन 0 और 2 पर मैच देती है; i=7 पर: q=4 i=7 पर? नहीं:
- i=3 तक: मैच, q=2
- i=4: T[4]='a' ("ababa" के बाद), P[2]='a' हाँ q=3
- i=5: T[5]='b' P[3]='b' q=4 → 2 पर मैच (5-4+1=2), q=π[3]=2
- i=6: T[6]='a' P[2]='a' q=3
- i=7: T[7]='b' P[3]='b' q=4 → 4 पर मैच होगा, लेकिन T[4:8]="abab" हाँ! रुकिए, T="a b a b a b a b c" पोजीशन 0-8।
- T[4:8] = "abab" हाँ, लेकिन मेरे T="ababababc" में, हाँ पोजीशन 4-7: a(4)b(5)a(6)b(7) = "abab" → 4 पर तीसरा मैच।
- फिर i=8: 'c' != P[4]? लेकिन m=4, मैच के बाद q=2, लेकिन अंत होने के कारण, और नहीं।

रुकिए, असल में इस T के लिए, मैच 0,2,4 पर हैं। हाँ!

देखा? मिसमैच पर (जैसे अगर एक होता), यह q=0 के बजाय q=π[q-1] पर जाता है।

#### यह जादुई क्यों लगता है
- `T` में कोई बैकट्रैकिंग नहीं—आप केवल आगे बढ़ते हैं।
- मिसमैच के लिए "while" लूप कुल मिलाकर एमोर्टाइज्ड O(1) बार चलता है, क्योंकि प्रत्येक जंप q को घटाता है, और q अधिकतम n बार बढ़ता है।

#### इसे स्वयं आजमाएं: सरल Python कोड
```python
def compute_prefix_function(P):
    m = len(P)
    pi = [0] * m
    k = 0
    for i in range(1, m):
        while k > 0 and P[k] != P[i]:
            k = pi[k - 1]
        if P[k] == P[i]:
            k += 1
        pi[i] = k
    return pi

def kmp_search(T, P):
    n, m = len(T), len(P)
    if m == 0: return []
    pi = compute_prefix_function(P)
    q = 0
    matches = []
    for i in range(n):
        while q > 0 and P[q] != T[i]:
            q = pi[q - 1]
        if P[q] == T[i]:
            q += 1
        if q == m:
            matches.append(i - m + 1)
            q = pi[q - 1]
    return matches

# टेस्ट
T = "ababababc"
P = "abab"
print(kmp_search(T, P))  # आउटपुट: [0, 2, 4]
```

इसे रन करें—q में जंप देखने के लिए P/T को ट्वीक करें (q के लिए प्रिंट जोड़ें)।

#### सामान्य गलतियाँ और सुझाव
- π[0] हमेशा 0 होता है।
- सेल्फ-ओवरलैप के बिना पैटर्न के लिए (उदाहरण के लिए, "abc"), π सभी 0 होते हैं—नाइव पर वापस आ जाता है।
- DNA सीक्वेंस या कोड ऑटोकम्पलीट के लिए बढ़िया।
- यदि अभी भी अस्पष्ट है, तो π को एक "स्टेट मशीन" के रूप में विज़ुअलाइज़ करें: प्रत्येक स्टेट मैच की गई लंबाई है, मैच/मिसमैच पर ट्रांजिशन।

अब यह क्लिक कर जाना चाहिए—यह सिर्फ प्रीकंप्यूटेड ओवरलैप्स के माध्यम से स्मार्ट स्किपिंग है। यदि आपके पास कोई विशिष्ट उदाहरण है जो आपको उलझा रहा है, तो उसे साझा करें!

[GeeksforGeeks: KMP Algorithm](https://www.geeksforgeeks.org/dsa/kmp-algorithm-for-pattern-searching/)  
[Wikipedia: Knuth–Morris–Pratt Algorithm](https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm)