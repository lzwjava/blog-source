---
audio: false
generated: true
image: false
lang: hi
layout: post
model: x-ai/grok-4-fast
title: भाषा को विकसित करना
translated: true
type: note
---

### अवलोकन
"ग्रोइंग अ लैंग्वेज" (Growing a Language) नामक यह वार्ता गाय एल. स्टील जूनियर (Guy L. Steele Jr.) द्वारा OOPSLA '98 (ऑब्जेक्ट-ओरिएंटेड प्रोग्रामिंग, सिस्टम्स, लैंग्वेजेज एंड एप्लिकेशन्स कॉन्फ्रेंस) में 19 अक्टूबर, 1998 को वैंकूवर, कनाडा में दी गई थी। यह भाषा डिजाइन और विकास पर एक महत्वपूर्ण 45-मिनट की प्रस्तुति है, जिसमें लाइव-कोडिंग डेमो के रूप में स्कीम (Scheme - Lisp की एक बोली) का उपयोग किया गया है। स्टील, जो जावा (Java) और स्कीम (Scheme) के सह-डिजाइनर हैं, यह दर्शाते हैं कि कैसे एक प्रोग्रामिंग भाषा को न्यूनतम आधार से शुरू करके क्रमिक रूप से विकसित किया जा सकता है, जिसमें सादगी, अभिव्यंजकता और विस्तारणीयता पर जोर दिया गया है। मूल विचार यह है कि भाषाएं "विकसित" होती हैं - न्यूनतम आदिम (primitives) से शुरू करके और उसके ऊपर सुविधाओं की परतें जोड़कर, न कि सब कुछ एक साथ डिजाइन करके।

यह वीडियो YouTube पर उपलब्ध है (ACM SIGPLAN द्वारा संग्रहीत) और इसने आधुनिक भाषा डिजाइन की चर्चाओं, जिसमें फंक्शनल और एम्बेडेड डोमेन-स्पेसिफिक लैंग्वेजेज (DSLs) शामिल हैं, को प्रभावित किया है।

### मुख्य विषय और संरचना
स्टील इस वार्ता को एक हैंड्स-ऑन ट्यूटोरियल के रूप में संरचित करते हैं, एक साधारण एक्सप्रेशन एवेल्यूएटर को एक पूर्ण विकसित भाषा में "विकसित" करने के लिए स्कीम में लाइव कोडिंग करते हैं। वह विकासवादी डिजाइन के पक्ष में तर्क देने के लिए "बागवानी" (सुविधाओं को पोषित करना) बनाम "वास्तुकला" (कठोर ब्लूप्रिंट) जैसे रूपकों का उपयोग करते हैं। यहां मुख्य भागों का विवरण दिया गया है:

1.  **परिचय: भाषा क्यों विकसित करें? (0:00–5:00)**
    स्टील "बिग बैंग" भाषा डिजाइन (जैसे, शुरू में ही सब कुछ निर्दिष्ट करना, जिससे जटिलता आती है) की आलोचना करके वार्ता की शुरुआत करते हैं। वह "विकसित" करने का प्रस्ताव रखते हैं: छोटी शुरुआत करें, बार-बार परीक्षण करें और वास्तविक आवश्यकताओं के आधार पर विस्तार करें। वे Lisp के इतिहास से उदाहरण लेते हैं, जहां भाषा एक एवेल्यूएटर कोड से विकसित हुई। लक्ष्य: अंकगणितीय एक्सप्रेशन के लिए एक छोटी सी भाषा बनाना जो ट्यूरिंग-पूर्ण (Turing-complete) कुछ बन सके।

2.  **बीज: बेसिक एवेल्यूएटर (5:00–10:00)**
    सबसे सरल कर्नेल से शुरुआत: एक फ़ंक्शन जो परमाणु संख्याओं का मूल्यांकन करता है (जैसे, `3` → 3)।
    - कोड स्निपेट (स्कीम में):
      ```scheme
      (define (eval exp) exp)  ; परमाणुओं के लिए पहचान
      ```
    वह इसे लाइव चलाते हैं, दिखाते हैं कि `(eval 3)`, 3 लौटाता है। यह "बीज" है - शुद्ध, कोई सिंटैक्स शुगर नहीं।

3.  **अंकुरण: ऑपरेशन जोड़ना (10:00–20:00)**
    लिस्ट पर पैटर्न-मिलान करके बाइनरी ऑपरेटर जैसे `+` और `*` को पेश करता है (जैसे, `(+ 2 3)`)।
    - एवेल्यूएटर का विस्तार करता है:
      ```scheme
      (define (eval exp)
        (if (pair? exp)
            (let ((op (car exp))
                  (args (cdr exp)))
              (apply op (map eval args)))
            exp))
      ```
    मूल्यांकन प्रदर्शित करता है: `(+ (* 2 3) 4)` → 10। हाइजीन पर जोर देता है—इसे सरल रखें, समय से पहले ऑप्टिमाइजेशन से बचें।

4.  **शाखाएं: कंडीशनल और वेरिएबल (20:00–30:00)**
    कंडीशनल के लिए `if` और वेरिएबल बाइंडिंग के लिए `let` जोड़ता है, यह दिखाते हुए कि स्कोपिंग स्वाभाविक रूप से कैसे उभरती है।
    - विस्तार का उदाहरण:
      ```scheme
      (define (eval exp env)
        (if (pair? exp)
            (case (car exp)
              ((quote) (cadr exp))
              ((if) (if (eval (cadr exp) env)
                        (eval (caddr exp) env)
                        (eval (cadddr exp) env)))
              ((let) (eval (cadddr exp) (extend-env env (caadr exp) (eval (cadadr exp) env))))
              (else ...))  ; फ़ंक्शन एप्लिकेशन पर वापस जाना
            (lookup exp env)))  ; वेरिएबल लुकअप
      ```
    लाइव डेमो: रिकर्सिव `let` बाइंडिंग के माध्यम से फैक्टोरियल की गणना करता है, यह उजागर करता है कि रिकर्सन पुनरावृत्ति (iteration) से कैसे "विकसित" होता है।

5.  **पुष्पण: मैक्रोज़ और एब्स्ट्रक्शन (30:00–40:00)**
    डोमेन-स्पेसिफिक सिंटैक्स (जैसे, एक `while` लूप) जोड़ने के लिए हाइजीनिक मैक्रोज़ पेश करता है। दिखाता है कि कैसे मैक्रो उपयोगकर्ताओं को स्वयं भाषा को "विकसित" करने देते हैं।
    - मुख्य अंतर्दृष्टि: भाषाएं विस्तार के लिए "खुली" होनी चाहिए, जैसे Lisp की मैक्रो सिस्टम, जो कोर को फोर्क किए बिना DSLs को सक्षम बनाती है।

6.  **निष्कर्ष: डिजाइनरों के लिए सबक (40:00–45:00)**
    स्टील सिद्धांतों के साथ समापन करते हैं:
    - **वृद्धिशीलता**: एक समय में एक सुविधा जोड़ें; तुरंत परीक्षण करें।
    - **एकरूपता**: आदिम (primitives) का पुन: उपयोग करें (जैसे, सब कुछ एक एक्सप्रेशन है)।
    - **उपयोगकर्ता सशक्तिकरण**: मैक्रो या इसी तरह के माध्यम से उपयोगकर्ताओं को विस्तार करने दें।
    वे इसे वास्तविक दुनिया की भाषाओं (जावा, स्कीम) से जोड़ते हैं और "फीचर क्रीप" के खिलाफ चेतावनी देते हैं। प्रश्नोत्तर सेशन में प्रदर्शन और कार्यान्वयन की चुनौतियों पर चर्चा होती है।

### प्रभाव और टेकअवे
इस वार्ता ने "लैंग्वेज वर्कबेंच" के विचारों को लोकप्रिय बनाया, जिसने रैकेट (Racket - जो स्कीम का विस्तार है) जैसे टूल और रस्ट (Rust) के मैक्रोज़ या स्विफ्ट (Swift) के एक्सटेंशन में अवधारणाओं को प्रभावित किया। यह भाषाओं के बारे में जीवित प्रणालियों के रूप में सोचने में एक उत्कृष्ट उदाहरण है—व्यावहारिक, दार्शनिक और मनोरंजक (स्टील की शुष्क विनोदी शैली इसमें चमकती है)।

पूर्ण अनुभव के लिए, वीडियो देखें: [Growing a Language - OOPSLA '98](https://www.youtube.com/watch?v=_ahvzDzKdB0)। ट्रांसक्रिप्ट/सारांश कम उपलब्ध हैं, लेकिन कोड को स्लाइड्स (ACM डिजिटल लाइब्रेरी के माध्यम से उपलब्ध) से पुनर्निर्मित किया जा सकता है। यदि आप PL डिजाइन में रुचि रखते हैं, तो इसे स्टील की बाद की "ग्रोइंग अ पैटर्न लैंग्वेज" (OOPSLA '05) के साथ जोड़कर देखें।