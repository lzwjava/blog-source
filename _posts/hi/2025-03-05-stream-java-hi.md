---
audio: false
generated: true
lang: hi
layout: post
title: Stream API in Java का अनुवाद
translated: true
---

`java.util.stream` का उपयोग करने के लिए Java में, आप Java 8 में पेश किए गए Stream API का उपयोग कर सकते हैं, जो डेटा के संग्रहों को एक फंक्शनल और डिक्लेरेटिव तरीके से प्रोसेस करने के लिए उपयोग किया जाता है। स्ट्रीम आपको लिस्ट या एरेयों जैसे तत्वों के अनुक्रमों पर फिल्टरिंग, मैपिंग और रिड्यूसिंग जैसे ऑपरेशंस को दक्षता और संक्षिप्तता के साथ करने की अनुमति देते हैं। नीचे, मैं एक विशिष्ट उदाहरण के माध्यम से `java.util.stream` का उपयोग करने की व्याख्या करूँगा: एक इंटीजर लिस्ट से 10 से अधिक और सम संख्याओं का औसत निकालना। यह मुख्य स्ट्रीम ऑपरेशंस और अवधारणाओं को प्रदर्शित करेगा।

---

### **`java.util.stream` का संक्षिप्त परिचय**
`java.util.stream` पैकेज `Stream` इंटरफेस और संबंधित क्लासेस (जैसे `IntStream`, `DoubleStream` आदि) प्रदान करता है, जो डेटा को प्रोसेस करने के लिए उपयोग किया जाता है। एक स्ट्रीम तत्वों का एक अनुक्रम है जो एक पाइपलाइन में कार्यान्वित किए जाने वाले ऑपरेशंस का समर्थन करता है। ये ऑपरेशंस हैं:
- **अंतरम ऑपरेशंस**: स्ट्रीम को ट्रांसफॉर्म या फिल्टर करना (जैसे `filter`, `map`), एक नया स्ट्रीम लौटाना। ये लेजी हैं और केवल जब एक टर्मिनल ऑपरेशन को बुलाया जाता है तब ही कार्यान्वित होते हैं।
- **टर्मिनल ऑपरेशंस**: एक परिणाम या साइड इफेक्ट उत्पन्न करना (जैसे `average`, `collect`), पाइपलाइन को डेटा को प्रोसेस करने के लिए ट्रिगर करना।

स्ट्रीम का उपयोग करने के लिए, आप आम तौर पर:
1. एक डेटा स्रोत (जैसे एक लिस्ट) से एक स्ट्रीम बनाएं।
2. डेटा को ट्रांसफॉर्म या फिल्टर करने के लिए अंतरम ऑपरेशंस लागू करें।
3. एक परिणाम उत्पन्न करने के लिए एक टर्मिनल ऑपरेशन का उपयोग करें।

---

### **उदाहरण समस्या**
इस समस्या को हल करें: एक `List<Integer>` दिया गया है, तो सभी 10 से अधिक और सम संख्याओं का औसत निकालें। अगर ऐसे संख्याएं मौजूद नहीं हैं, तो 0.0 लौटाएं। इसे `java.util.stream` का उपयोग करके कैसे करें, यह देखें।

#### **कदम-दर-कदम समाधान**
1. **स्ट्रीम बनाएं**
   - एक `List<Integer>` (जैसे `List.of(1, 2, 12, 15, 20, 25, 30)`) से शुरू करें।
   - `stream()` विधि का उपयोग करके एक `Stream<Integer>` बनाएं:
     ```java
     list.stream()
     ```

2. **स्ट्रीम को फिल्टर करें**
   - केवल उन संख्याओं को रखें जो सम हैं और 10 से अधिक हैं।
   - `filter` विधि एक `Predicate` (एक बूलियन लौटाने वाला फंक्शन) को एक लैम्बडा एक्सप्रेशन के रूप में लेती है:
     ```java
     .filter(number -> number % 2 == 0 && number > 10)
     ```
     - `number % 2 == 0` एक संख्या को सम होने की जांच करता है।
     - `number > 10` सुनिश्चित करता है कि संख्या 10 से अधिक है।
     - उदाहरण लिस्ट `[1, 2, 12, 15, 20, 25, 30]` के लिए, यह `[12, 20, 30]` रखता है।

3. **एक `IntStream` में परिवर्तित करें**
   - क्योंकि `average()` प्राइमिटिव स्ट्रीम जैसे `IntStream` (नहीं `Stream<Integer>`) पर उपलब्ध है, `mapToInt` का उपयोग करके `Stream<Integer>` को `IntStream` में परिवर्तित करें:
     ```java
     .mapToInt(i -> i)
     ```
     - `i -> i` प्रत्येक `Integer` को एक `int` में अनबॉक्स करता है। विकल्प के रूप में, आप `Integer::intValue` का उपयोग कर सकते हैं।
     - यह `[12, 20, 30]` का एक `IntStream` देता है।

4. **औसत निकालें**
   - `IntStream` पर `average()` विधि का उपयोग करें, जो एक `OptionalDouble` लौटाता है (क्योंकि स्ट्रीम खाली हो सकता है):
     ```java
     .average()
     ```
     - `[12, 20, 30]` के लिए, यह `(12 + 20 + 30) / 3 = 20.666...` का हिसाब लगाता है।
     - अगर स्ट्रीम खाली है, तो यह एक खाली `OptionalDouble` लौटाता है।

5. **खाली मामले को संभालें**
   - `OptionalDouble` पर `orElse(0.0)` का उपयोग करें, अगर कोई संख्याएं फिल्टर को पूरा नहीं करती हैं तो 0.0 लौटाएं:
     ```java
     .orElse(0.0)
     ```
     - `[12, 20, 30]` के लिए, यह `20.666...` लौटाता है।
     - एक लिस्ट जैसे `[1, 3, 5]` (10 से अधिक और सम संख्याएं नहीं) के लिए, यह `0.0` लौटाता है।

#### **पूर्ण कोड**
यह पूर्ण समाधान एक विधि के रूप में है:
```java
import java.util.List;

public class Main {
    public static double averageOfEvenGreaterThanTen(List<Integer> list) {
        return list.stream()
                   .filter(number -> number % 2 == 0 && number > 10)
                   .mapToInt(i -> i)
                   .average()
                   .orElse(0.0);
    }

    public static void main(String[] args) {
        // टेस्ट केस
        System.out.println(averageOfEvenGreaterThanTen(List.of(1, 2, 12, 15, 20, 25, 30)));  // ~20.666
        System.out.println(averageOfEvenGreaterThanTen(List.of(1, 3, 5)));                    // 0.0
        System.out.println(averageOfEvenGreaterThanTen(List.of(12)));                         // 12.0
        System.out.println(averageOfEvenGreaterThanTen(List.of()));                           // 0.0
        System.out.println(averageOfEvenGreaterThanTen(List.of(10, 8, 6)));                   // 0.0
        System.out.println(averageOfEvenGreaterThanTen(List.of(11, 13, 14, 16)));             // 15.0
    }
}
```

---

### **`java.util.stream` द्वारा प्रदर्शित मुख्य विशेषताएं**
- **चेनिंग**: ऑपरेशंस को एक फ्लूएंट शैली में चेन किया जाता है (जैसे `.filter().mapToInt().average()`).
- **लेजी**: अंतरम ऑपरेशंस (जैसे `filter` और `mapToInt`) केवल जब टर्मिनल ऑपरेशन (`average`) को बुलाया जाता है तब ही कार्यान्वित होते हैं।
- **प्राइमिटिव स्ट्रीम**: `IntStream` जैसे प्राइमिटिव स्ट्रीम नंबरिक ऑपरेशंस के लिए `average()` जैसे विधियों को प्रदान करते हैं, जो बॉक्सिंग ओवरहेड को टालते हैं।
- **ऑप्शनल हैंडलिंग**: `OptionalDouble` ऐसे मामलों को संभालता है जहां कोई परिणाम मौजूद नहीं है, और `orElse` एक डिफॉल्ट मान प्रदान करता है।

---

### **वैकल्पिक दृष्टिकोण**
आप `Collectors` क्लास का भी उपयोग कर सकते हैं:
```java
import java.util.stream.Collectors;

double average = list.stream()
                     .filter(number -> number % 2 == 0 && number > 10)
                     .collect(Collectors.averagingInt(i -> i));
```
- यह एक `Double` सीधे लौटाता है और एक खाली स्ट्रीम के लिए `0.0` लौटाता है। हालांकि, `mapToInt().average()` इस सरल मामले के लिए अधिक सीधा है और प्राइमिटिव स्ट्रीम उपयोग के साथ मेल खाता है।

---

### **स्ट्रीम का उपयोग कब करें**
- `java.util.stream` को संक्षिप्त और पढ़ने योग्य कोड लिखने के लिए संग्रहों को प्रोसेस करने के लिए उपयोग करें।
- बड़े डेटासेट के लिए, `parallelStream()` का उपयोग `stream()` के बजाय करें, ताकि पैरललिज्म का लाभ उठाया जा सके, हालांकि यह छोटे लिस्टों के लिए ओवरहेड के कारण ओवरकिल है।

---

यह उदाहरण दिखाता है कि `java.util.stream` का उपयोग करके एक व्यावहारिक समस्या को कैसे हल किया जा सकता है। आप इन कदमों को अन्य परिस्थितियों में अनुकूलित कर सकते हैं—स्ट्रीम बनाना, फिल्टर करना, मैप करना और रिड्यूस करना!