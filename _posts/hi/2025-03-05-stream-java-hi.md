---
audio: false
generated: true
lang: hi
layout: post
title: जावा में स्ट्रीम एपीआई
translated: true
type: note
---

Java में `java.util.stream` का उपयोग करने के लिए, आप Java 8 में पेश किए गए Stream API का लाभ उठा सकते हैं ताकि डेटा के संग्रह को एक कार्यात्मक और घोषणात्मक तरीके से प्रोसेस किया जा सके। स्ट्रीम आपको तत्वों के अनुक्रमों (जैसे सूचियों या arrays) पर कार्यवाहियाँ जैसे फ़िल्टरिंग, मैपिंग, और रिड्यूसिंग को कुशल और संक्षिप्त तरीके से करने की अनुमति देती हैं। नीचे, मैं `java.util.stream` के उपयोग को एक विशिष्ट उदाहरण के माध्यम से समझाऊंगा: पूर्णांकों की एक सूची से 10 से बड़ी सम संख्याओं का औसत ज्ञात करना। यह मुख्य स्ट्रीम ऑपरेशन्स और अवधारणाओं को प्रदर्शित करेगा।

---

### **`java.util.stream` का अवलोकन**
`java.util.stream` पैकेज `Stream` इंटरफेस और संबंधित कक्षाएं (जैसे `IntStream`, `DoubleStream`, आदि) प्रदान करता है ताकि डेटा को प्रोसेस किया जा सके। एक स्ट्रीम तत्वों का एक अनुक्रम है जो पाइपलाइन में निष्पादित होने वाले ऑपरेशन्स को सपोर्ट करता है। ये ऑपरेशन हैं:
- **इंटरमीडिएट ऑपरेशन्स**: स्ट्रीम को ट्रांसफॉर्म या फ़िल्टर करते हैं (जैसे, `filter`, `map`), एक नई स्ट्रीम लौटाते हैं। ये आलसी (lazy) होते हैं और केवल तब निष्पादित होते हैं जब एक टर्मिनल ऑपरेशन इनवोक किया जाता है।
- **टर्मिनल ऑपरेशन्स**: एक परिणाम या साइड इफेक्ट उत्पन्न करते हैं (जैसे, `average`, `collect`), जो डेटा को प्रोसेस करने के लिए पाइपलाइन को ट्रिगर करते हैं।

स्ट्रीम का उपयोग करने के लिए, आप आमतौर पर:
1. एक डेटा स्रोत (जैसे, एक सूची) से एक स्ट्रीम बनाएं।
2. डेटा को ट्रांसफॉर्म या फ़िल्टर करने के लिए इंटरमीडिएट ऑपरेशन्स लागू करें।
3. एक परिणाम उत्पन्न करने के लिए एक टर्मिनल ऑपरेशन का उपयोग करें।

---

### **उदाहरण समस्या**
आइए इस समस्या को हल करें: एक `List<Integer>` दी गई है, 10 से बड़ी सभी सम संख्याओं का औसत ज्ञात कीजिए। यदि ऐसी कोई संख्या नहीं है, तो 0.0 लौटाइए। यहाँ बताया गया है कि इसे `java.util.stream` का उपयोग करके कैसे करें।

#### **चरण-दर-चरण समाधान**
1. **एक स्ट्रीम बनाएं**
   - एक `List<Integer>` से शुरू करें (जैसे, `List.of(1, 2, 12, 15, 20, 25, 30)`)।
   - एक `Stream<Integer>` बनाने के लिए `stream()` मेथड का उपयोग करें:
     ```java
     list.stream()
     ```

2. **स्ट्रीम को फ़िल्टर करें**
   - केवल उन संख्याओं को रखने के लिए `filter` मेथड का उपयोग करें जो सम हैं और 10 से बड़ी हैं।
   - `filter` मेथड एक `Predicate` (एक फ़ंक्शन जो बूलियन लौटाता है) को लैम्बा एक्सप्रेशन के रूप में लेता है:
     ```java
     .filter(number -> number % 2 == 0 && number > 10)
     ```
     - `number % 2 == 0` जांचता है कि क्या संख्या सम है।
     - `number > 10` सुनिश्चित करता है कि संख्या 10 से बड़ी है।
     - उदाहरण सूची `[1, 2, 12, 15, 20, 25, 30]` के लिए, यह `[12, 20, 30]` को रखता है।

3. **एक `IntStream` में कनवर्ट करें**
   - चूंकि `average()` प्रिमिटिव स्ट्रीम्स जैसे `IntStream` (न कि `Stream<Integer>`) पर उपलब्ध है, `Stream<Integer>` को `mapToInt` का उपयोग करके `IntStream` में कनवर्ट करें:
     ```java
     .mapToInt(i -> i)
     ```
     - `i -> i` प्रत्येक `Integer` को `int` में अनबॉक्स करता है। वैकल्पिक रूप से, आप `Integer::intValue` का उपयोग कर सकते हैं।
     - यह `[12, 20, 30]` का एक `IntStream` देता है।

4. **औसत की गणना करें**
   - `IntStream` पर `average()` मेथड का उपयोग करें, जो एक `OptionalDouble` लौटाता है (क्योंकि स्ट्रीम खाली हो सकती है):
     ```java
     .average()
     ```
     - `[12, 20, 30]` के लिए, यह `(12 + 20 + 30) / 3 = 20.666...` की गणना करता है।
     - यदि स्ट्रीम खाली है, तो यह एक खाली `OptionalDouble` लौटाता है।

5. **खाली केस को हैंडल करें**
   - यदि कोई संख्या फ़िल्टर को संतुष्ट नहीं करती है तो 0.0 लौटाने के लिए `OptionalDouble` पर `orElse(0.0)` का उपयोग करें:
     ```java
     .orElse(0.0)
     ```
     - `[12, 20, 30]` के लिए, यह `20.666...` लौटाता है।
     - `[1, 3, 5]` जैसी सूची (10 से बड़ी कोई सम संख्या नहीं) के लिए, यह `0.0` लौटाता है।

#### **पूर्ण कोड**
यहाँ एक मेथड के रूप में पूरा समाधान दिया गया है:
```java
import java.util.List;

public class Main {
    public static double averageOfEvenGreaterThanTen(List<Integer> list) {
        return list.stream()
                   .filter(number -> number % 2 == 0 && number > 10)
                   .mapToInt(i -> i)
                   .average()
                   .orElse(0.0);
    }

    public static void main(String[] args) {
        // टेस्ट केस
        System.out.println(averageOfEvenGreaterThanTen(List.of(1, 2, 12, 15, 20, 25, 30)));  // ~20.666
        System.out.println(averageOfEvenGreaterThanTen(List.of(1, 3, 5)));                    // 0.0
        System.out.println(averageOfEvenGreaterThanTen(List.of(12)));                         // 12.0
        System.out.println(averageOfEvenGreaterThanTen(List.of()));                           // 0.0
        System.out.println(averageOfEvenGreaterThanTen(List.of(10, 8, 6)));                   // 0.0
        System.out.println(averageOfEvenGreaterThanTen(List.of(11, 13, 14, 16)));             // 15.0
    }
}
```

---

### **`java.util.stream` की प्रमुख विशेषताएं प्रदर्शित**
- **चेनिंग**: ऑपरेशन्स एक फ्लुऐंट स्टाइल में चेन किए जाते हैं (जैसे, `.filter().mapToInt().average()`)।
- **आलस्य (Laziness)**: इंटरमीडिएट ऑपरेशन्स (जैसे `filter` और `mapToInt`) केवल तब निष्पादित होते हैं जब टर्मिनल ऑपरेशन (`average`) कहा जाता है।
- **प्रिमिटिव स्ट्रीम्स**: `IntStream` `average()` जैसी मेथड्स प्रदान करता है जो संख्यात्मक ऑपरेशन्स के लिए तैयार की गई हैं, बॉक्सिंग ओवरहेड से बचाती हैं।
- **ऑप्शनल हैंडलिंग**: `OptionalDouble` उन मामलों को हैंडल करता है जहाँ कोई परिणाम मौजूद नहीं होता है, जिसमें `orElse` एक डिफॉल्ट मान प्रदान करता है।

---

### **वैकल्पिक दृष्टिकोण**
आप `Collectors` क्लास का भी उपयोग कर सकते हैं:
```java
import java.util.stream.Collectors;

double average = list.stream()
                     .filter(number -> number % 2 == 0 && number > 10)
                     .collect(Collectors.averagingInt(i -> i));
```
- यह सीधे एक `Double` लौटाता है और खाली स्ट्रीम के लिए `0.0` लौटाता है। हालाँकि, इस सरल मामले के लिए `mapToInt().average()` अधिक सीधा है और प्रिमिटिव स्ट्रीम उपयोग के साथ संरेखित होता है।

---

### **स्ट्रीम्स का उपयोग कब करें**
- संग्रहों को प्रोसेस करते समय संक्षिप्त, पठनीय कोड के लिए `java.util.stream` का उपयोग करें।
- बड़े डेटासेट के लिए, समानांतरता (parallelism) का लाभ उठाने के लिए `stream()` के बजाय `parallelStream()` पर विचार करें, हालाँकि छोटी सूचियों के लिए ओवरहेड के कारण यह अति हो सकता है।

---

यह उदाहरण दिखाता है कि एक व्यावहारिक समस्या को हल करने के लिए `java.util.stream` का उपयोग कैसे करें। आप इन चरणों को—एक स्ट्रीम बनाना, फ़िल्टरिंग, मैपिंग, और रिड्यूसिंग—को आवश्यकतानुसार अन्य परिदृश्यों के लिए अनुकूलित कर सकते हैं!