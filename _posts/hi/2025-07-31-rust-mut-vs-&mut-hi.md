---
audio: false
generated: true
image: false
lang: hi
layout: post
title: रस्ट का `mut` और `&mut` समझाया गया
translated: true
type: note
---

रस्ट में, `mut` और `&mut` कीवर्ड संबंधित लेकिन अलग-अलग उद्देश्यों की पूर्ति करते हैं, और ये सीधे तौर पर Java की deep/shallow copy अवधारणाओं या C के पॉइंटर्स के बराबर नहीं हैं—हालांकि स्पष्टता के लिए हम कुछ सादृश्यता जरूर बना सकते हैं। मैं इसे चरण दर चरण समझाता हूँ, अंतर स्पष्ट करता हूँ, और मान पासिंग बनाम रेफरेंस पासिंग, परिवर्तनशीलता, और परिवर्तन मूल डेटा को कैसे प्रभावित करते हैं, के आपके सवालों का जवाब दूंगा। मैं उदाहरण देने के लिए आपके दिए गए कोड का उपयोग करूंगा।

### 1. **वेरिएबल डिक्लेरेशन में `mut` को समझना**
   - जब आप `let mut` के साथ एक वेरिएबल डिक्लेयर करते हैं, तो आप *बाइंडिंग* (वेरिएबल नाम) को परिवर्तनशील बना रहे होते हैं। इसका मतलब है कि आप वेरिएबल को पुनः असाइन कर सकते हैं या उसकी सामग्री को सीधे संशोधित कर सकते हैं, लेकिन केवल उस स्कोप के भीतर जहां इसे डिक्लेयर किया गया है।
   - आपके कोड से उदाहरण:
     ```rust
     let mut arr = [3, 6, 8, 10, 1, 2, 1];
     ```
     यहाँ, `arr` परिवर्तनशील है, इसलिए आप `arr[0] = 99;` कर सकते हैं या बाद में `arr = [1, 2, 3];` भी पुनः असाइन कर सकते हैं। `mut` के बिना, रस्ट एक अपरिवर्तनीय वेरिएबल को संशोधित करने का प्रयास करने पर शिकायत करेगा (सुरक्षा के लिए रस्ट डिफ़ॉल्ट रूप से अपरिवर्तनशीलता का उपयोग करता है)।
   - यह `mut` वेरिएबल के बारे में है, न कि यह कि इसे फ़ंक्शन में कैसे पास किया जाता है। यह कॉपी करने या रेफरेंस देने का संकेत नहीं देता—यह केवल वेरिएबल को उसी स्थान पर बदलने की अनुमति है।

### 2. **फ़ंक्शन पैरामीटर्स और रेफरेंसेज में `&mut` को समझना**
   - `&mut` एक *परिवर्तनशील रेफरेंस* (mutable reference) बनाता है (जिसे mutable borrow भी कहा जाता है)। यह C में एक पॉइंटर की तरह है जो पॉइंट किए गए डेटा को पढ़ने *और* लिखने की अनुमति देता है, लेकिन रस्ट के सख्त बोरो चेकर के साथ जो सुरक्षा सुनिश्चित करता है (कोई डेटा रेस नहीं, कोई डैंगलिंग पॉइंटर्स नहीं)।
   - आपके कोड में:
     ```rust
     fn quick_sort(arr: &mut [i32]) { ... }
     ```
     - पैरामीटर `arr`, `i32` के एक स्लाइस का एक परिवर्तनशील रेफरेंस है (`&mut [i32]`)। रस्ट में स्लाइस एरेज़ या वेक्टर्स में व्यू (view) होते हैं (जैसे एक पॉइंटर + लंबाई), और उन्हें लगभग हमेशा रेफरेंस के रूप में पास किया जाता है क्योंकि स्लाइस "अनसाइज्ड" टाइप होते हैं (उनका आकार कंपाइल टाइम पर ज्ञात नहीं होता)।
     - जब आप `quick_sort(&mut arr);` कॉल करते हैं, तो आप मूल `arr` को एक परिवर्तनशील रेफरेंस पास कर रहे होते हैं। यह फ़ंक्शन को रेफरेंस के माध्यम से मूल एरे के एलिमेंट्स को संशोधित करने की अनुमति देता है (जैसे, `partition` में स्वैप के माध्यम से)।
     - फ़ंक्शन के अंदर, `arr.swap(i, j);` जैसे ऑपरेशन सीधे मूल डेटा को प्रभावित करते हैं क्योंकि `arr` एक रेफरेंस है जो उसकी ओर इशारा कर रहा है।
   - `&` के बिना, आप इस तरह से सीधे `[i32]` जैसे स्लाइस को पैरामीटर के रूप में पास नहीं कर सकते—अनसाइज्ड टाइप्स के लिए रस्ट को रेफरेंस की आवश्यकता होती है। लेकिन अधिक सामान्य तौर पर, `&mut` म्यूटेशन अधिकारों के साथ रेफरेंस पासिंग सक्षम करता है।

### 3. **रस्ट में वैल्यू पासिंग बनाम रेफरेंस पासिंग**
   - रस्ट अपने कोर मॉडल के रूप में *ओनरशिप* (ownership) का उपयोग करता है, जो Java (जो ज्यादातर रेफरेंस-आधारित है और गार्बेज कलेक्शन के साथ आता है) या C (मैनुअल पॉइंटर्स) से अलग है।
     - **वैल्यू पासिंग (ओनरशिप ट्रांसफर)**: जब आप `&` के बिना एक वैल्यू पास करते हैं (जैसे, `fn foo(x: i32)` या `fn bar(mut v: Vec<i32>)`), तो डेटा की ओनरशिप फ़ंक्शन में ट्रांसफर हो जाती है। फ़ंक्शन इसे स्थानीय रूप से संशोधित कर सकता है, लेकिन परिवर्तन कॉलर के मूल को प्रभावित नहीं करते (क्योंकि कॉलर का अब उस पर कोई स्वामित्व नहीं है)। यदि टाइप `Copy` को इम्प्लीमेंट करता है (जैसे `i32` जैसे प्रिमिटिव्स), तो यह स्वचालित रूप से कॉपी हो जाता है, मूव नहीं होता—जब तक आप स्पष्ट रूप से क्लोन नहीं करते, तब तक डीप कॉपी नहीं होती।
       - उदाहरण:
         ```rust
         fn foo(mut x: i32) {
             x += 1;  // स्थानीय x को संशोधित करता है, लेकिन कॉलर का मूल अपरिवर्तित रहता है (या मूव/कॉपी हो जाता है)।
             println!("Inside: {}", x);
         }

         let y = 5;
         foo(y);  // वैल्यू द्वारा पास करता है (कॉपी, क्योंकि i32 कॉपी है)।
         println!("After: {}", y);  // अभी भी 5 है।
         ```
       - यह अन्य भाषाओं में "वैल्यू पासिंग" जैसा है: प्रिमिटिव्स कॉपी होते हैं, बड़े टाइप्स (जैसे एरेज़/वेक्टर्स) मूव होते हैं (कुशल, क्लोन किए बिना कोई कॉपी नहीं)।
     - **रेफरेंस पासिंग (उधार लेना)**: `&` (अपरिवर्तनीय रेफरेंस) या `&mut` (परिवर्तनशील रेफरेंस) का उपयोग करके ओनरशिप ट्रांसफर किए बिना डेटा को "उधार" (borrow) लिया जाता है। फ़ंक्शन को एक अस्थायी व्यू मिलता है (जैसे एक पॉइंटर), और मूल मालिक नियंत्रण बनाए रखता है।
       - `&`: केवल-पढ़ने के लिए उधार। मूल को संशोधित नहीं कर सकता।
       - `&mut`: पढ़ने-लिखने का उधार। मूल को संशोधित *कर सकता है*, जैसे C++ में रेफरेंस द्वारा पास करना या C में एक परिवर्तनशील पॉइंटर।
       - उदाहरण:
         ```rust
         fn bar(x: &mut i32) {
             *x += 1;  // डेरिफरेंस करें और मूल को संशोधित करें।
         }

         let mut y = 5;
         bar(&mut y);  // परिवर्तनशील रेफरेंस पास करें।
         println!("After: {}", y);  // अब 6 है, मूल बदल गया है।
         ```
       - आपके क्विकसॉर्ट कोड में, यह `&mut` के साथ रेफरेंस पासिंग है, इसलिए स्वैप मूल एरे को बदल देते हैं। यदि यह केवल `& [i32]` होता, तो आप इसे संशोधित नहीं कर सकते थे (अपरिवर्तनीय उधार)।

   - आपके बिंदु पर: हाँ, `&mut` मूल वैल्यूज़ को बदलने की अनुमति देता है (म्यूटेशन के साथ रेफरेंस पासिंग), जबकि `&` के बिना पास करने (वैल्यू पासिंग) पर डेटा या तो कॉपी/मूव हो जाता है, इसलिए संशोधन स्थानीय होते हैं और मूल को प्रभावित नहीं करते। लेकिन:
     - सभी टाइप्स स्वचालित रूप से कॉपी नहीं होते—केवल वे जो `Copy` को इम्प्लीमेंट करते हैं (जैसे, `i32`, एरेज़ या वेक्टर्स नहीं)। आपके एरे जैसे नॉन-`Copy` टाइप्स के लिए, वैल्यू द्वारा पास करने पर ओनरशिप *मूव* हो जाएगी, और आपको इसे कॉलर को "वापस देने" के लिए इसे रिटर्न करना होगा।
     - रस्ट दक्षता के लिए अनावश्यक कॉपी से बचता है। आपका एरे `&mut [i32]` के रूप में पास होने पर कॉपी नहीं होता—यह सिर्फ एक रेफरेंस है (शैलो, जैसे एक पॉइंटर)।

### 4. **Java और C से तुलना**
   - **Java**: सभी गैर-प्रिमिटिव चीजें रेफरेंस द्वारा पास की जाती हैं (शैलो—ऑब्जेक्ट्स शेयर किए जाते हैं, लेकिन पैरामीटर को पुनः असाइन करने से कॉलर प्रभावित नहीं होता)। प्रिमिटिव्स वैल्यू द्वारा पास होते हैं (कॉपी)। `mut` या `&mut` का कोई सीधा समकक्ष नहीं है; परिवर्तनशीलता क्लास डिज़ाइन द्वारा नियंत्रित होती है (जैसे, final फ़ील्ड्स)। Java में रस्ट की ओनरशिप नहीं है, इसलिए यह शेयर्ड म्यूटेबल स्टेट के मुद्दों के प्रति अधिक संवेदनशील है। डीप कॉपी के लिए मैनुअल क्लोनिंग की आवश्यकता होती है।
   - **C**: `&mut` एक पॉइंटर पास करने जैसा है (`int*`) जहाँ आप डेरिफरेंस और संशोधित कर सकते हैं (`*ptr = 10;`)। सादा `mut` (डिक्लेरेशन में) नॉन-कॉन्स्ट वेरिएबल्स जैसा है। लेकिन C में कोई बोरो चेकर नहीं है, इसलिए आप लाइफटाइम्स को मैन्युअली मैनेज करते हैं (त्रुटि-प्रवण)। C में वैल्यू द्वारा पास करने पर डेटा कॉपी हो जाता है (स्ट्रक्चर्स के लिए शैलो, जब तक आप डीप-कॉपी नहीं करते)।
   - मुख्य अंतर: रस्ट "एक समय में एक परिवर्तनशील रेफरेंस" (या एक साथ कई अपरिवर्तनीय) लागू करता है, जिससे बग्स रोके जाते हैं। कोई नल नहीं, कोई वाइल्ड पॉइंटर्स नहीं।

### 5. **आपके कोड में कभी `mut` और कभी `&mut` क्यों?**
   - केवल `mut`: स्थानीय वेरिएबल्स के लिए उपयोग किया जाता है जिन्हें बदलने की आवश्यकता होती है, जैसे `let mut arr` (ताकि आप बाद में `&mut arr` पास कर सकें या इसे सीधे संशोधित कर सकें)।
   - `&mut`: पैरामीटर्स में उपयोग किया जाता है जब फ़ंक्शन को ओनरशिप लिए बिना कॉलर के डेटा को उधार लेने और संशोधित करने की आवश्यकता होती है। `quick_sort` और `partition` में, `&mut [i32]` उन्हें एरे को मूव/कॉपी किए बिना उसी स्थान पर सॉर्ट करने देता है।
   - यदि आपने `fn quick_sort(mut arr: [i32])` की कोशिश की, तो यह कंपाइल नहीं होगा—स्लाइस को इस तरह वैल्यू द्वारा पास नहीं किया जा सकता। आपको एक फिक्स्ड-साइज एरे (जैसे, `[i32; 7]`) की आवश्यकता होगी और यह ओनरशिप को मूव कर देगा।
   - `partition` में, लूप आंतरिक रूप से `mut i` का उपयोग करती है—यह एक स्थानीय परिवर्तनशील वेरिएबल है, जो पासिंग से असंबंधित है।

### 6. **क्या यह मूल वैल्यूज़ को बदलता है?**
   - `&mut` के लिए हाँ: परिवर्तन मूल तक पहुँचते हैं (रेफरेंस पासिंग)।
   - वैल्यू पासिंग ( `&` के बिना) के लिए नहीं: केवल स्थानीय परिवर्तन (जब तक आप संशोधित वैल्यू वापस नहीं लौटाते)।
   - आपके `quick_sort_interact()` में, `println!("After: {:?}", arr);` सॉर्ट किए गए एरे को दिखाएगा क्योंकि `&mut` का उपयोग किया गया था।

यदि आप अपना कोड चलाते हैं, तो इसका आउटपुट होना चाहिए:
```
Before: [3, 6, 8, 10, 1, 2, 1]
After: [1, 1, 2, 3, 6, 8, 10]
```
( `mod simple;` और `simple::run_simple();` असंबंधित लगते हैं—शायद एक प्लेसहोल्डर? यदि वहाँ कोई त्रुटि है, तो यह इसलिए हो सकती है क्योंकि `simple` परिभाषित नहीं है।)

यदि यह स्पष्ट नहीं है या आपके पास ट्वीक/टेस्ट करने के लिए कोड का कोई विशिष्ट हिस्सा है, तो मुझे बताएं!