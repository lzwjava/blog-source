---
audio: false
generated: true
lang: hi
layout: post
title: सी में आईसीएमपी पिंग प्रोग्राम
translated: true
type: note
---

ICMP (Internet Control Message Protocol) एक नेटवर्क लेयर प्रोटोकॉल है जिसका उपयोग IP नेटवर्क में डायग्नोस्टिक और एरर-रिपोर्टिंग उद्देश्यों के लिए किया जाता है। यह `ping` यूटिलिटी द्वारा होस्ट्स के बीच कनेक्टिविटी टेस्ट करने के लिए सबसे प्रसिद्ध रूप से उपयोग किया जाता है। ICMP मैसेज सीधे IP पैकेट में एनकैप्सुलेटेड होते हैं (कोई TCP या UDP लेयर नहीं) और इनमें एक टाइप, कोड, चेकसम और पेलोड होता है। `ping` के लिए, "Echo Request" (टाइप 8) और "Echo Reply" (टाइप 0) मैसेज महत्वपूर्ण हैं।

यहाँ उच्च-स्तर पर बताया गया है कि ICMP कैसे काम करता है:
1. एक सेंडर (जैसे, आपका कंप्यूटर) एक टार्गेट IP को ICMP Echo Request भेजता है।
2. टार्गेट, यदि पहुँच योग्य है और जवाब देने के लिए कॉन्फ़िगर किया गया है, तो एक ICMP Echo Reply वापस भेजता है।
3. सेंडर रिप्लाई के आने के समय के आधार पर राउंड-ट्रिप टाइम (RTT) मापता है।

`libpcap` या `libnet` जैसे लाइब्रेरीज़ के बिना C में एक `ping`-जैसा प्रोग्राम इम्प्लीमेंट करने के लिए, हम सीधे ICMP पैकेट क्राफ्ट करने और भेजने के लिए रॉ सॉकेट (`SOCK_RAW`) का उपयोग करेंगे। इसके लिए रूट प्रिविलेज (जैसे, `sudo`) की आवश्यकता होती है क्योंकि रॉ सॉकेट उच्च-स्तरीय एब्स्ट्रैक्शन्स को बायपास करते हैं।

नीचे एक सरलीकृत C प्रोग्राम दिया गया है जो ICMP Echo Requests भेजता है और Echo Replies सुनता है, जो बेसिक `ping` फंक्शनैलिटी की नकल करता है।

---

### C में ICMP Ping प्रोग्राम

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>
#include <time.h>
#include <errno.h>

// ICMP चेकसम की गणना करें
unsigned short checksum(void *b, int len) {
    unsigned short *buf = b;
    unsigned int sum = 0;
    unsigned short result;

    for (sum = 0; len > 1; len -= 2) {
        sum += *buf++;
    }
    if (len == 1) {
        sum += *(unsigned char *)buf;
    }
    sum = (sum >> 16) + (sum & 0xFFFF);
    sum += (sum >> 16);
    result = ~sum;
    return result;
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: %s <destination_ip>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    int sock_fd;
    struct sockaddr_in dest_addr;
    char packet[64];  // ICMP हेडर + कुछ डेटा
    struct icmphdr *icmp;
    char recv_buffer[1024];
    struct timespec start, end;

    // ICMP के लिए रॉ सॉकेट बनाएँ
    sock_fd = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);
    if (sock_fd < 0) {
        perror("Socket creation failed (run as root?)");
        exit(EXIT_FAILURE);
    }

    // डेस्टिनेशन एड्रेस सेट अप करें
    dest_addr.sin_family = AF_INET;
    if (inet_pton(AF_INET, argv[1], &dest_addr.sin_addr) <= 0) {
        perror("Invalid IP address");
        close(sock_fd);
        exit(EXIT_FAILURE);
    }

    // ICMP Echo Request पैकेट तैयार करें
    memset(packet, 0, sizeof(packet));
    icmp = (struct icmphdr *)packet;
    icmp->type = ICMP_ECHO;        // टाइप 8: Echo Request
    icmp->code = 0;
    icmp->un.echo.id = getpid();   // आइडेंटिफ़ायर के रूप में प्रोसेस ID का उपयोग करें
    icmp->un.echo.sequence = 1;    // सीक्वेंस नंबर
    for (int i = sizeof(*icmp); i < 64; i++) {
        packet[i] = i;             // पेलोड को डमी डेटा से भरें
    }
    icmp->checksum = 0;            // पैकेट भरने के बाद चेकसम की गणना करें
    icmp->checksum = checksum(packet, 64);

    printf("Pinging %s...\n", argv[1]);

    for (int i = 0; i < 4; i++) { // 4 पिंग भेजें
        // भेजने का समय रिकॉर्ड करें
        clock_gettime(CLOCK_MONOTONIC, &start);

        // ICMP Echo Request भेजें
        if (sendto(sock_fd, packet, 64, 0, (struct sockaddr *)&dest_addr, sizeof(dest_addr)) < 0) {
            perror("Send failed");
            close(sock_fd);
            exit(EXIT_FAILURE);
        }

        // ICMP Echo Reply प्राप्त करें
        struct sockaddr_in from_addr;
        socklen_t from_len = sizeof(from_addr);
        int bytes_received = recvfrom(sock_fd, recv_buffer, sizeof(recv_buffer), 0,
                                      (struct sockaddr *)&from_addr, &from_len);
        if (bytes_received < 0) {
            perror("Receive failed");
            continue;
        }

        // प्राप्ति का समय रिकॉर्ड करें
        clock_gettime(CLOCK_MONOTONIC, &end);

        // प्राप्त IP और ICMP हेडर पार्स करें
        struct iphdr *ip = (struct iphdr *)recv_buffer;
        struct icmphdr *icmp_reply = (struct icmphdr *)(recv_buffer + (ip->ihl * 4));
        if (icmp_reply->type == ICMP_ECHOREPLY && icmp_reply->un.echo.id == getpid()) {
            double rtt = (end.tv_sec - start.tv_sec) * 1000.0 +
                         (end.tv_nsec - start.tv_nsec) / 1000000.0;
            printf("%d bytes from %s: seq=%d time=%.2f ms\n",
                   bytes_received - (ip->ihl * 4), argv[1], icmp_reply->un.echo.sequence, rtt);
        } else {
            printf("Unexpected ICMP response: type=%d\n", icmp_reply->type);
        }

        sleep(1); // पिंग्स के बीच 1 सेकंड प्रतीक्षा करें
        icmp->un.echo.sequence++; // सीक्वेंस नंबर बढ़ाएँ
        icmp->checksum = 0;
        icmp->checksum = checksum(packet, 64); // चेकसम पुनः गणना करें
    }

    close(sock_fd);
    return 0;
}
```

---

### यह कैसे काम करता है

1. **सॉकेट क्रिएशन**:
   - `socket(AF_INET, SOCK_RAW, IPPROTO_ICMP)` ICMP के लिए एक रॉ सॉकेट बनाता है। यह हमें मैन्युअल रूप से ICMP पैकेट क्राफ्ट करने देता है।

2. **ICMP पैकेट कंस्ट्रक्शन**:
   - ICMP हेडर (`struct icmphdr`) को निम्नलिखित से भरा जाता है:
     - `type = ICMP_ECHO` (8) Echo Request के लिए।
     - `code = 0`.
     - `id` हमारे पिंग्स की पहचान करने के लिए प्रोसेस ID पर सेट।
     - `sequence` अलग-अलग रिक्वेस्ट्स को ट्रैक करने के लिए।
   - एक पेलोड (डमी डेटा) जोड़ा जाता है, और चेकसम की गणना पूरे पैकेट पर की जाती है।

3. **भेजना**:
   - `sendto()` पैकेट को डेस्टिनेशन IP पर भेजता है। किसी पोर्ट की आवश्यकता नहीं है क्योंकि ICMP ट्रांसपोर्ट लेयर के नीचे काम करता है।

4. **प्राप्त करना**:
   - `recvfrom()` ICMP Echo Reply वाले रॉ IP पैकेट को कैप्चर करता है।
   - हम IP हेडर (`ihl * 4` बाइट्स) को छोड़कर ICMP हेडर तक पहुँचते हैं।
   - जाँच करें कि क्या यह एक Echo Reply (टाइप 0) है और हमारे `id` से मेल खाता है।

5. **टाइमिंग**:
   - `clock_gettime()` मिलीसेकंड में RTT को मापता है।

6. **चेकसम**:
   - `checksum()` फंक्शन ICMP द्वारा आवश्यक 16-बिट वन्स कॉम्प्लीमेंट सम की गणना करता है।

---

### कंपाइलेशन और उपयोग
- कंपाइल करें: `gcc ping.c -o ping`
- रन करें (रूट के रूप में): `sudo ./ping 8.8.8.8`
- उदाहरण आउटपुट:
  ```
  Pinging 8.8.8.8...
  64 bytes from 8.8.8.8: seq=1 time=12.34 ms
  64 bytes from 8.8.8.8: seq=2 time=11.89 ms
  ...
  ```

---

### नोट्स
- **रूट प्रिविलेज**: रॉ सॉकेट के लिए `sudo` की आवश्यकता होती है क्योंकि वे सीधे नेटवर्क पैकेट्स को मैनिपुलेट करते हैं।
- **फ़ायरवॉल**: टार्गेट को ICMP Echo Requests का जवाब देना चाहिए (कुछ होस्ट उन्हें ब्लॉक करते हैं)।
- **सरलीकरण**: यह वर्जन सभी एज केसेस (जैसे, टाइमआउट, पैकेट लॉस पूरी तरह से, या IP ऑप्शन्स) को हैंडल नहीं करता है।

यह यूजर स्पेस में ICMP के साथ जितना लो-लेवल हो सकता है उतना है। इसके नीचे, IP स्टैक के साथ सीधे इंटरैक्ट करने के लिए आपको करनेल-लेवल कोड की आवश्यकता होगी। यदि आप इसे और ट्वीक करना चाहते हैं तो मुझे बताएं!