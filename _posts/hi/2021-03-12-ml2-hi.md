---
audio: false
generated: false
image: false
lang: hi
layout: post
title: मशीन लर्निंग का परिचय - PyTorch
translated: true
type: post
---

```markdown
यह पोस्ट मूल रूप से चाइनीज़ भाषा में लिखी गई थी। इसे अन्य भाषाओं में अनुवाद करने की सुविधा के लिए अंग्रेज़ी में अनूदित किया गया है।

---

## PyTorch

आइए इसे इंस्टॉल करें। यह Python के संस्करण `3.9` को सपोर्ट करता है।

```shell
$ pip install torch torchvision
Collecting torch
  Downloading torch-1.8.0-cp39-none-macosx_10_9_x86_64.whl (120.6 MB)
     |████████████████████████████████| 120.6 MB 224 kB/s
Collecting torchvision
  Downloading torchvision-0.9.0-cp39-cp39-macosx_10_9_x86_64.whl (13.1 MB)
     |████████████████████████████████| 13.1 MB 549 kB/s
Requirement already satisfied: numpy in /usr/local/lib/python3.9/site-packages (from torch) (1.20.1)
Collecting typing-extensions
  Downloading typing_extensions-3.7.4.3-py3-none-any.whl (22 kB)
Requirement already satisfied: pillow>=4.1.1 in /usr/local/lib/python3.9/site-packages (from torchvision) (8.0.1)
Installing collected packages: typing-extensions, torch, torchvision
Successfully installed torch-1.8.0 torchvision-0.9.0 typing-extensions-3.7.4.3
```

आइए इसकी जांच करें।

```python
import torch
x = torch.rand(5, 3)
print(x)
```

एक त्रुटि हुई।

```shell
Traceback (most recent call last):
  File "torch.py", line 1, in <module>
    import torch
  File "torch.py", line 2, in <module>
    x = torch.rand(5, 3)
AttributeError: partially initialized module 'torch' has no attribute 'rand' (most likely due to a circular import)
```

इस त्रुटि संदेश को गूगल करने के बाद पता चला कि हमारी फ़ाइल का नाम भी `torch` था, जिससे नाम का टकराव हो रहा था। इसे पुनः नाम देने के बाद यह ठीक से काम करता है।

```shell
tensor([[0.5520, 0.9446, 0.5543],
        [0.6192, 0.0908, 0.8726],
        [0.0223, 0.7685, 0.9814],
        [0.4019, 0.5406, 0.3861],
        [0.5485, 0.6040, 0.2387]])
```

आइए एक उदाहरण देखें।

```python
# -*- coding: utf-8 -*-

import torch
import math
dtype = torch.float
device = torch.device("cpu")
# device = torch.device("cuda:0") # GPU पर चलाने के लिए इस लाइन को अनकमेंट करें

# यादृच्छिक इनपुट और आउटपुट डेटा बनाएं
x = torch.linspace(-math.pi, math.pi, 2000, device=device, dtype=dtype)
y = torch.sin(x)

# यादृच्छिक रूप से वज़न प्रारंभ करें
a = torch.randn((), device=device, dtype=dtype)
b = torch.randn((), device=device, dtype=dtype)
c = torch.randn((), device=device, dtype=dtype)
d = torch.randn((), device=device, dtype=dtype)

learning_rate = 1e-6
for t in range(2000):
    # आगे की प्रक्रिया: अनुमानित y की गणना करें
    y_pred = a + b * x + c * x ** 2 + d * x ** 3

    # हानि की गणना करें और प्रिंट करें
    loss = (y_pred - y).pow(2).sum().item()
    if t % 100 == 99:
        print(t, loss)

    # हानि के संबंध में a, b, c, d के ग्रेडिएंट की गणना करने के लिए बैकप्रोपेगेशन करें
    grad_y_pred = 2.0 * (y_pred - y)
    grad_a = grad_y_pred.sum()
    grad_b = (grad_y_pred * x).sum()
    grad_c = (grad_y_pred * x ** 2).sum()
    grad_d = (grad_y_pred * x ** 3).sum()

    # ग्रेडिएंट डिसेंट का उपयोग करके वज़न अपडेट करें
    a -= learning_rate * grad_a
    b -= learning_rate * grad_b
    c -= learning_rate * grad_c
    d -= learning_rate * grad_d
print(f'परिणाम: y = {a.item()} + {b.item()} x + {c.item()} x^2 + {d.item()} x^3')
```

आइए इसे चलाएं।

```shell
99 1273.537353515625
199 849.24853515625
299 567.4786987304688
399 380.30291748046875
499 255.92752075195312
599 173.2559814453125
699 118.2861328125
799 81.72274780273438
899 57.39331817626953
999 41.198158264160156
1099 30.41307830810547
1199 23.227672576904297
1299 18.438262939453125
1399 15.244369506835938
1499 13.113286972045898
1599 11.690631866455078
1699 10.740333557128906
1799 10.105220794677734
1899 9.6804780960083
1999 9.39621353149414
परिणाम: y = -0.011828352697193623 + 0.8360244631767273 x + 0.002040589228272438 x^2 + -0.09038365632295609 x^3
```

आइए केवल `numpy` लाइब्रेरी का उपयोग करने वाले कोड को देखें।

```python
# -*- coding: utf-8 -*-
import numpy as np
import math

# यादृच्छिक इनपुट और आउटपुट डेटा बनाएं
x = np.linspace(-math.pi, math.pi, 2000)
y = np.sin(x)

# यादृच्छिक रूप से वज़न प्रारंभ करें
a = np.random.randn()
b = np.random.randn()
c = np.random.randn()
d = np.random.randn()

learning_rate = 1e-6
for t in range(2000):
    # आगे की प्रक्रिया: अनुमानित y की गणना करें
    # y = a + b x + c x^2 + d x^3
    y_pred = a + b * x + c * x ** 2 + d * x ** 3

    # हानि की गणना करें और प्रिंट करें
    loss = np.square(y_pred - y).sum()
    if t % 100 == 99:
        print(t, loss)

    # हानि के संबंध में a, b, c, d के ग्रेडिएंट की गणना करने के लिए बैकप्रोपेगेशन करें
    grad_y_pred = 2.0 * (y_pred - y)
    grad_a = grad_y_pred.sum()
    grad_b = (grad_y_pred * x).sum()
    grad_c = (grad_y_pred * x ** 2).sum()
    grad_d = (grad_y_pred * x ** 3).sum()

    # वज़न अपडेट करें
    a -= learning_rate * grad_a
    b -= learning_rate * grad_b
    c -= learning_rate * grad_c
    d -= learning_rate * grad_d

print(f'परिणाम: y = {a} + {b} x + {c} x^2 + {d} x^3')
```

ध्यान दें कि ये दो अलग-अलग तरीके हैं जिनसे गणनाएं की जाती हैं।

इन उदाहरणों में, सबसे पहले x और y के मानों का एक सेट बनाया जाता है। फिर, इसे घन समीकरण माना जाता है। इसके बाद, गुणांकों की गणना करने के लिए कुछ तरीकों का उपयोग करते हुए पुनरावृत्तियाँ की जाती हैं। ये एल्गोरिदम क्या हैं? ध्यान दें कि यह `2000` बार लूप करता है, प्रत्येक पुनरावृत्ति के साथ अधिक सटीक होता जाता है। हम यहां इसके विवरण में नहीं जाएंगे।

## अंत में

वर्तमान में, हम यह नहीं समझते कि मशीन लर्निंग की गणनाएं पर्दे के पीछे कैसे काम करती हैं। हालांकि, यह अभी महत्वपूर्ण नहीं है। ऊपर दिए गए ज्ञान से, हम पहले से ही कई चीजें कर सकते हैं। मशीन लर्निंग का उपयोग टेक्स्ट, ऑडियो, और अन्य चीजों को प्रोसेस करने के लिए भी किया जा सकता है। दर्जनों उदाहरणों का पता लगाने के बाद, सिद्धांत सीखना देर नहीं होगी।

## अभ्यास

* छात्रों को ऊपर दिखाए अनुसार खोजबीन करनी चाहिए।
```