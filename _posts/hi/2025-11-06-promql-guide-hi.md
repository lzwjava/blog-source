---
audio: false
generated: true
image: false
lang: hi
layout: post
model: x-ai/grok-4-fast
title: प्रोमक्यूएल क्वेरी भाषा गाइड
translated: true
type: note
---

PromQL (Prometheus Query Language) एक फंक्शनल क्वेरी भाषा है जिसका उपयोग Prometheus से टाइम सीरीज़ डेटा को रियल टाइम में चुनने और एकत्रित करने के लिए किया जाता है। यह इंस्टेंट क्वेरीज़ (एक ही समय बिंदु पर मूल्यांकित) और रेंज क्वेरीज़ (समय सीमा पर कई चरणों में मूल्यांकित) को सपोर्ट करती है। PromQL एक्सप्रेशन चार डेटा प्रकारों में से एक लौटा सकते हैं: **इंस्टेंट वेक्टर**, **रेंज वेक्टर**, **स्केलर**, या **स्ट्रिंग**।

---

## परिचय

PromQL उपयोगकर्ताओं को सक्षम बनाती है:
- **इंस्टेंट वेक्टर सेलेक्टर्स** का उपयोग करके टाइम सीरीज़ चुनना।
- **रेंज वेक्टर सेलेक्टर्स** का उपयोग करके एक समय सीमा पर डेटा प्राप्त करना।
- **ऑपरेटर्स** (अंकगणितीय, तुलना, तार्किक, एकत्रीकरण) लागू करना।
- विश्लेषण के लिए `rate()`, `sum()`, `avg()` जैसे **फ़ंक्शन** का उपयोग करना।
- **HTTP API** के माध्यम से डेटा क्वेरी करना।

एक्सप्रेशन का मूल्यांकन Prometheus UI में किया जाता है:
- **टेबल टैब**: इंस्टेंट क्वेरीज़।
- **ग्राफ टैब**: रेंज क्वेरीज़।

---

## टाइम सीरीज़ सेलेक्टर्स

टाइम सीरीज़ सेलेक्टर्स परिभाषित करते हैं कि कौन से मेट्रिक्स और लेबल प्राप्त करने हैं।

### इंस्टेंट वेक्टर सेलेक्टर्स

प्रत्येक मेल खाने वाली टाइम सीरीज़ के लिए नवीनतम सैंपल चुनता है।

**सिंटैक्स**:  
```
<metric_name>{<label_matchers>}
```

**उदाहरण**:
- मेट्रिक `http_requests_total` वाली सभी टाइम सीरीज़:
  ```
  http_requests_total
  ```
- विशिष्ट जॉब और ग्रुप:
  ```
  http_requests_total{job="prometheus", group="canary"}
  ```
- एनवायरनमेंट पर रेगेक्स मिलान और GET मेथड को छोड़कर:
  ```
  http_requests_total{environment=~"staging|testing|development", method!="GET"}
  ```
- `__name__` पर मिलान:
  ```
  {__name__=~"job:.*"}
  ```

**लेबल मैचर्स**:
- `=` : सटीक मिलान
- `!=` : बराबर नहीं
- `=~` : रेगेक्स मिलान (एंकर किया हुआ)
- `!~` : रेगेक्स मिलान नहीं

> नोट: `{job=~".+"}` वैध है; केवल `{}` अमान्य है।

---

### रेंज वेक्टर सेलेक्टर्स

समय के साथ सैंपल्स की एक रेंज चुनता है।

**सिंटैक्स**:  
```
<instant_selector>[<duration>]
```

**उदाहरण**:
- `prometheus` जॉब के लिए `http_requests_total` के अंतिम 5 मिनट:
  ```
  http_requests_total{job="prometheus"}[5m]
  ```

> रेंज **लेफ्ट-ओपन, राइट-क्लोज्ड** है: प्रारंभ समय को छोड़कर, अंत समय को शामिल करती है।

---

### ऑफ़सेट मॉडिफायर

मूल्यांकन समय को आगे या पीछे शिफ्ट करता है।

**सिंटैक्स**:  
```
<selector> offset <duration>
```

**उदाहरण**:
- 5 मिनट पहले `http_requests_total` का मान:
  ```
  http_requests_total offset 5m
  ```
- 1 सप्ताह पहले की दर:
  ```
  rate(http_requests_total[5m] offset 1w)
  ```
- आगे देखें (नकारात्मक ऑफ़सेट):
  ```
  rate(http_requests_total[5m] offset -1w)
  ```

> सेलेक्टर के तुरंत बाद आना चाहिए।

---

### `@` मॉडिफायर

एक विशिष्ट टाइमस्टैम्प पर मूल्यांकन करता है।

**सिंटैक्स**:  
```
<selector> @ <timestamp>
```

**उदाहरण**:
- यूनिक्स टाइमस्टैम्प `1609746000` पर मान:
  ```
  http_requests_total @ 1609746000
  ```
- विशिष्ट समय पर दर:
  ```
  rate(http_requests_total[5m] @ 1609746000)
  ```
- `start()` या `end()` का उपयोग करें:
  ```
  http_requests_total @ start()
  rate(http_requests_total[5m] @ end())
  ```

> `offset` के साथ संयोजित किया जा सकता है।

---

## रेट और एग्रीगेशन

PromQL समय के साथ या सीरीज़ के पार मेट्रिक्स की गणना करने के लिए **रेट** और **एग्रीगेशन** ऑपरेटर्स को सपोर्ट करती है।

### रेट फ़ंक्शन

प्रति-सेकंड औसत वृद्धि दर की गणना करता है।

**उदाहरण**:
```
rate(http_requests_total[5m])
```

> **रेंज वेक्टर्स** पर उपयोग किया जाता है।

---

### एग्रीगेशन ऑपरेटर्स

टाइम सीरीज़ को संयोजित करने के लिए इंस्टेंट वेक्टर्स पर लागू होते हैं।

**उदाहरण**:
- सभी `http_requests_total` का योग:
  ```
  sum(http_requests_total)
  ```
- प्रति इंस्टेंस औसत:
  ```
  avg by (instance)(http_requests_total)
  ```
- प्रति जॉब गिनती:
  ```
  count by (job)(http_requests_total)
  ```

> एग्रीगेशन के लिए मिलान वाली सीरीज़ की आवश्यकता होती है; `by` या `without` क्लॉज़ का उपयोग करें।

---

## ऑपरेटर्स

PromQL कई ऑपरेटर प्रकारों को सपोर्ट करती है।

### अंकगणितीय ऑपरेटर्स

| ऑपरेटर | विवरण             | उदाहरण                          |
|--------|--------------------|----------------------------------|
| `+`    | जोड़            | `rate(a[5m]) + rate(b[5m])`      |
| `-`    | घटाव         | `rate(a[5m]) - rate(b[5m])`      |
| `*`    | गुणा    | `http_requests_total * 60`       |
| `/`    | भाग          | `rate(a[5m]) / rate(b[5m])`      |
| `%`    | मॉड्यूलो           | `http_requests_total % 100`      |

> ऑपरेंड संगत होने चाहिए (समान प्रकार और आकार)।

---

### तुलना ऑपरेटर्स

दो इंस्टेंट वेक्टर्स की तुलना करते हैं।

| ऑपरेटर | विवरण             | उदाहरण                             |
|--------|--------------------|-------------------------------------|
| `==`   | बराबर              | `rate(a[5m]) == rate(b[5m])`        |
| `!=`   | बराबर नहीं          | `rate(a[5m]) != 0`                  |
| `>`    | से बड़ा        | `http_requests_total > 100`         |
| `<`    | से कम           | `http_requests_total < 10`          |
| `>=`   | से बड़ा या बराबर | `rate(a[5m]) >= 2`                  |
| `<=`   | से कम या बराबर  | `http_requests_total <= 5`          |

> बूलियन इंस्टेंट वेक्टर लौटाता है।

---

### तार्किक ऑपरेटर्स

बूलियन एक्सप्रेशन को संयोजित करते हैं।

| ऑपरेटर  | विवरण         | उदाहरण                                     |
|---------|----------------|---------------------------------------------|
| `and`   | लॉजिकल AND    | `rate(a[5m]) > 1 and rate(b[5m]) > 1`       |
| `or`    | लॉजिकल OR     | `rate(a[5m]) > 1 or rate(b[5m]) > 1`        |
| `unless`| एक्सेप्ट      | `rate(a[5m]) unless rate(b[5m]) > 0`        |

> ऑपरेंड समान कार्डिनैलिटी के बूलियन वेक्टर होने चाहिए।

---

## फ़ंक्शन

PromQL में ट्रांसफॉर्मेशन और विश्लेषण के लिए बिल्ट-इन फ़ंक्शन शामिल हैं।

**सामान्य फ़ंक्शन**:
- `rate(v range-vector)` – प्रति-सेकंड दर।
- `irate(v range-vector)` – तात्कालिक दर (अंतिम दो बिंदु)।
- `avg(v)` – औसत मान।
- `sum(v)` – मानों का योग।
- `count(v)` – तत्वों की संख्या।
- `min(v)`, `max(v)` – न्यूनतम/अधिकतम।
- `quantile(v instant-vector, q)` – प्रतिशतक।

**उदाहरण**:
```
quantile by (job)(0.95, http_request_duration_seconds_bucket[5m])
```

> पूरी सूची के लिए [Prometheus Functions Documentation](https://prometheus.io/docs/prometheus/latest/querying/functions/) देखें।

---

## क्वेरी करने के लिए HTTP API

PromQL क्वेरीज़ को HTTP API के माध्यम से भेजा जा सकता है।

### इंस्टेंट क्वेरीज़

**एंडपॉइंट**: `/api/v1/query`

**मेथड**: `GET`

**पैरामीटर्स**:
- `query`: PromQL एक्सप्रेशन
- `time`: मूल्यांकन टाइमस्टैम्प (यूनिक्स सेकंड, वैकल्पिक)
- `timeout`: क्वेरी टाइमआउट (उदा. `30s`)

**उदाहरण**:
```
GET /api/v1/query?query=http_requests_total{job="prometheus"}&time=1609746000
```

**रिस्पॉन्स**: `status`, `data.result` (इंस्टेंट वेक्टर या स्केलर) के साथ JSON।

---

### रेंज क्वेरीज़

**एंडपॉइंट**: `/api/v1/query_range`

**पैरामीटर्स**:
- `query`: PromQL एक्सप्रेशन
- `start`: प्रारंभ समय (यूनिक्स सेकंड)
- `end`: समाप्ति समय (यूनिक्स सेकंड)
- `step`: रेज़ोल्यूशन स्टेप (उदा. `15s`)

**उदाहरण**:
```
GET /api/v1/query_range?query=rate(http_requests_total[5m])&start=1609746000&end=1609746600&step=10s
```

**रिस्पॉन्स**: प्रत्येक स्टेप पर टाइम सीरीज़ डेटा के साथ JSON।

---

## अतिरिक्त नोट्स

- **लिटरल्स**:
  - स्ट्रिंग्स: `"hello"`, `'world'`, `` `raw` ``
  - फ्लोट्स: `3.14`, `-2.5e-3`, `1_000`, `0xFF`
  - ड्यूरेशन: `5m`, `1h30m`, `500ms`

- **कमेंट्स**: `#` से शुरू करें

- **स्टेलनेस**: अपडेट के बिना 5 मिनट (डिफ़ॉल्ट) के बाद सीरीज़ स्टेल हो जाती हैं।

- **सबक्वेरी**: एक रेंज पर इंस्टेंट क्वेरी चलाएँ:
  ```
  rate(http_requests_total[10m:5m])[5m]
  ```

---

यह गाइड शुरुआती से लेकर इंटरमीडिएट उपयोगकर्ताओं के लिए PromQL के मूल को कवर करती है। उन्नत उपयोग के लिए, [Prometheus Querying Basics](https://prometheus.io/docs/prometheus/latest/querying/basics/) और लिंक्ड पेज देखें।