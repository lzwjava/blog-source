---
audio: false
generated: true
image: false
lang: hi
layout: post
title: सिंक स्प्रिंग यूएटी ब्रांचें और कोड
translated: true
type: note
---

यहाँ सर्वोत्तम प्रथाओं और पैटर्नों का एक संग्रह है जिसे आप मिला-जुलाकर इस्तेमाल कर सकते हैं, ताकि आपकी तीन UAT ब्रांचें सिंक में रहें, आपका इतिहास साफ़ रहे, और Spring ऐप में देश-विशिष्ट कोड को हैंडल किया जा सके—साथ ही, यह भी बताया गया है कि AI कहाँ मदद कर सकता है।

---

## 1. ब्रांचिंग और सिंक्रनाइज़ेशन

1.  **छोटी अवधि वाली फीचर ब्रांचों के साथ ट्रंक-आधारित विकास**

    *   एक ही **main** (या **develop**) ब्रांच रखें।
    *   प्रत्येक Jira टिकट (जैसे FT-103) और देश के लिए, इस प्रकार नामित फीचर ब्रांचें बनाएँ:

        ```
        feature/FT-103-cn
        feature/FT-103-sg
        feature/FT-103-tw
        ```
    *   जब कार्य तैयार हो, तो **main** में वापस मर्ज करें, फिर प्रत्येक `uat_cn`, `uat_sg`, `uat_tw` में चेरी-पिक या मर्ज करें।
    *   लाभ: main में मर्ज एक बार होता है; देश ब्रांचें केवल वही उठाती हैं जिसकी उन्हें आवश्यकता होती है।

2.  **UAT ब्रांचों की नियमित सिंकिंग**

    *   प्रत्येक `uat_*` ब्रांच को `main` पर रीबेस करने के लिए एक दैनिक (या प्रति-बिल्ड) जॉब शेड्यूल करें ताकि वे बहुत अलग न हो जाएँ।
    *   इसे CI (जैसे एक GitHub Action जो हर रात `uat_cn` को रीबेस करती है) में ऑटोमेट करें।

3.  **पुल-रिक्वेस्ट्स + रिव्यू एन्फोर्समेंट का उपयोग करें**

    *   प्रत्येक फीचर-ब्रांच → main मर्ज के लिए एक PR आवश्यक करें।
    *   सुनिश्चित करें कि "FT-xxx" टिकट ब्रांच नाम और PR टाइटल/विवरण में हो।

---

## 2. कमिट-मैसेज कन्वेंशंस और स्क्वाशिंग

1.  **कन्वेंशनल-स्टाइल के साथ JIRA कुंजी**

    ```
    FT-103: fix null-pointer in customer lookup
    ```

2.  **माइक्रो-कमिट → मर्ज के समय स्क्वाश करें**

    *   फीचर कार्य के दौरान, डेवलपर्स जैसे-जैसे काम करते हैं, कमिट करते रहें:

        ```
        FT-103 #1: initial wiring of service beans
        FT-103 #2: add validation logic
        FT-103 #3: update error handling
        ```
    *   PR मर्ज पर, सभी FT-103 कमिट्स को एक संक्षिप्त कमिट में समेटने के लिए "Squash and merge" का उपयोग करें:

        ```
        FT-103: customer-service validation and error handling
        ```

3.  **एक टिकट के भीतर नंबरिंग**

    *   यदि एक ही टिकट में कई अलग-अलग चरणों को ट्रैक कर रहे हैं, तो डेवलपमेंट के दौरान नंबरिंग (`#1`, `#2`) ठीक है।
    *   एक बार मर्ज हो जाने के बाद, सब कुछ एक *ही* FT-103 कमिट में स्क्वाश कर दें; इतिहास साफ़ रहता है और प्रत्येक टिकट एक तार्किक परिवर्तन होता है।

4.  **कमिट-लिंट ऑटोमेट करें**

    *   प्रत्येक संदेश की शुरुआत में `FT-\d+` को लागू करने के लिए एक Git हुक या CI प्लगइन (जैसे [commitlint](https://commitlint.js.org)) का उपयोग करें।
    *   वैकल्पिक रूप से एक स्कोप लागू करें: `FT-103(sg): …`.

---

## 3. Spring में देश-विशिष्ट कोड को हैंडल करना

1.  **प्रोफाइल्स और कंडीशनल बीन्स**

    *   प्रति देश एक Spring प्रोफाइल परिभाषित करें: `@Profile("cn")`, `@Profile("sg")`, `@Profile("tw")`.
    *   `application-cn.yml`, `application-sg.yml`, आदि में, देश-विशिष्ट प्रॉपर्टीज़ सेट करें।
    *   स्टार्टअप पर, सही बीन्स चुनने के लिए `--spring.profiles.active=cn` (या sg, tw) पास करें।

2.  **स्ट्रैटेजी पैटर्न / प्लगइन मॉड्यूल**

    *   एक इंटरफेस `PaymentProcessor` बनाएँ जिसके तीन इम्प्लीमेंटेशन हों (`CnPaymentProcessor`, आदि)।
    *   `@Component` + `@Profile` का उपयोग करें या एक फैक्ट्री जो रनटाइम फ्लैग के आधार पर बीन चुनती हो।

3.  **रिसोर्स बंडल / फीचर फ्लैग्स**

    *   यदि अंतर छोटे हैं (जैसे तारीख प्रारूप, एंडपॉइंट URL), तो एक कोड पाथ रखें और अंतरों को प्रॉपर्टी फाइलों या फीचर-फ्लैग सर्विस में एक्सटर्नलाइज़ करें।

4.  **अलग मॉड्यूल (यदि बड़े हों)**

    *   बहुत भिन्न लॉजिक के लिए, सब-मॉड्यूल में विभाजित करें:

        ```
        /core
        /country-cn
        /country-sg
        /country-tw
        ```
    *   मुख्य ऐप बिल्ड/डिप्लॉय टाइम पर केवल एक्टिव देश मॉड्यूल को शामिल करता है।

---

## 4. लेखक बनाम टिकट के आधार पर कार्यों को अलग करना

*   **टिकट के आधार पर, लेखक के आधार पर नहीं।** कार्यों को *फीचर्स* (Jira IDs) के इकाई के रूप में होना चाहिए, व्यक्ति के आधार पर नहीं।
*   यदि कई डेवलपर्स FT-103 पर काम करते हैं, तो वे एक ही ब्रांच पर सहयोग करते हैं या उससे टॉपिक ब्रांचों का उपयोग करते हैं—लेकिन अंततः सभी एक ही FT-103 ब्रांच में वापस मर्ज हो जाते हैं।
*   लेखक मेटाडेटा कमिट ऑथर फील्ड में रहता है; आपको लेखक के आधार पर स्क्वाश करने की आवश्यकता नहीं है।

---

## 5. AI को काम पर लगाना

1.  **कमिट-मैसेज जनरेशन**

    *   GitHub Copilot या OpenAI जैसे टूल आपके डिफ से साफ़, कन्वेंशनल कमिट संदेश सुझा सकते हैं।
    *   एक प्री-कमिट हुक इंटीग्रेट करें जो `ai-commit --preview` चलाता हो ताकि रिव्यू के लिए संदेश का मसौदा तैयार हो सके।

2.  **PR विवरण और चेंजलॉग**

    *   किसी टिकट के तहत सभी कमिट्स को एक सुसंगत PR विवरण या रिलीज़ नोट में सारांशित करने के लिए एक AI असिस्टेंट का उपयोग करें:

        > “feature/FT-103 में हुए परिवर्तनों को बुलेट पॉइंट्स में सारांशित करें।”

3.  **कोड रिव्यू सहायता**

    *   AI-पावर्ड लिंटर्स (SonarQube with AI plugins, DeepCode) देश-विशिष्ट कोड पाथ में मुद्दों की ओर इशारा कर सकते हैं।

4.  **चेरी-पिक्स/रीबेस को ऑटोमेट करना**

    *   एक छोटी सी स्क्रिप्ट लिखें (या लो-कोड प्लेटफॉर्म का उपयोग करें) जो, जब FT-103 `main` पर लैंड होता है, तो स्वचालित रूप से उसे प्रत्येक `uat_*` में चेरी-पिक कर दे और किसी भी मर्ज कॉन्फ्लिक्ट के लिए PR खोल दे।

---

### सबको एक साथ रखते हुए

1.  **`feature/FT-XXX-<cn/sg/tw>` पर डेवलप करें।**
2.  **स्वतंत्र रूप से कमिट करें** (नंबर्ड स्टेप्स ठीक हैं), JIRA कुंजी का संदर्भ देते हुए।
3.  **एक PR खोलें** → main; **Squash-and-merge** चुनें ताकि प्रत्येक FT-XXX एक साफ़ कमिट हो।
4.  **CI जॉब** उस कमिट को स्वचालित रूप से प्रत्येक `uat_cn`, `uat_sg`, `uat_tw` में रीबेस/मर्ज कर देती है।
5.  **Spring प्रोफाइल्स** रनटाइम पर सही देश लॉजिक चुनती हैं—तीन ब्रांचों में कोड डुप्लिकेशन नहीं होता।
6.  **AI टूल्स** कमिट स्टाइल को लागू करने, PRs को सारांशित करने और मर्ज को मैनेज करने में मदद करते हैं।

यह वर्कफ़्लो आपके इतिहास को साफ़ रखता है, यह सुनिश्चित करता है कि प्रत्येक टिकट सभी एन्वायरनमेंट्स में एक ही कमिट से ट्रेस करने योग्य हो, देश लॉजिक को Git इतिहास के बजाय रनटाइम में अलग करता है, और AI का लाभ उन जगहों पर उठाता है जहाँ यह सबसे अधिक मूल्य जोड़ता है।