---
audio: false
generated: true
lang: hi
layout: post
title: लीनियर रिग्रेशन का उपयोग करके व्यापार
translated: true
type: note
---

बढ़िया सवाल! आप यहाँ दो कार्यों को जोड़ रहे हैं:

1. **TigerOpen API का उपयोग करके ऐतिहासिक स्टॉक डेटा (जैसे, Tencent) प्राप्त करना**
2. **उस डेटा को आपके मौजूदा numpy-आधारित लीनियर रिग्रेशन कोड के साथ उपयोग करना**

---

## क्या यह ऐसे ही काम करेगा?

**नहीं, सीधे तौर पर नहीं।** आपका मौजूदा ML कोड `x_train` और `y_train` को संख्यात्मक मानों के numpy arrays के रूप में अपेक्षा करता है जो फीचर्स और लेबल्स (जैसे, जनसंख्या बनाम लाभ) को दर्शाते हैं। लेकिन TigerOpen API **ऐतिहासिक स्टॉक बार्स (OHLCV डेटा)** लौटाती है, जो कई फील्ड्स वाली एक टाइम सीरीज है।

आपको यह करने की आवश्यकता है:

- स्टॉक डेटा को उचित `x_train` और `y_train` arrays में ठीक से निकालना और प्रीप्रोसेस करना।
- अपने मॉडल और कोड को स्टॉक डेटा संदर्भ के अनुकूल बनाना (जैसे, पिछले दिनों के आधार पर क्लोजिंग प्राइस का पूर्वानुमान लगाना)।

---

## अपने लीनियर रिग्रेशन मॉडल के लिए स्टॉक डेटा को कैसे अनुकूलित करें?

### चरण 1: Tencent (सिंबल `'00700'`) के लिए ऐतिहासिक डेटा प्राप्त करें

```python
bars_dict = quote_client.get_bars(
    symbols=['00700'],
    period=BarPeriod.DAY,
    begin_time='2024-01-01',
    end_time=datetime.now().strftime('%Y-%m-%d'),
    limit=100,
    right=QuoteRight.BR
)

bars = bars_dict.get('00700', [])
```

### चरण 2: फीचर्स और लेबल्स निकालें

एक सरल तरीका:

- `x_train` के रूप में दिन के इंडेक्स का उपयोग करें (जैसे, 0, 1, 2, ...)
- `y_train` के रूप में क्लोजिंग प्राइस का उपयोग करें

```python
import numpy as np

x_train = np.array([i for i in range(len(bars))])
y_train = np.array([bar.close for bar in bars])
```

वैकल्पिक रूप से, आप अगले दिन के क्लोज की भविष्यवाणी करने के लिए फीचर के रूप में पिछले दिन के क्लोज का उपयोग कर सकते हैं, या और अधिक उन्नत फीचर्स का उपयोग कर सकते हैं।

### चरण 3: अपने लीनियर रिग्रेशन कोड का उपयोग करें

अब आपके `x_train` और `y_train` संख्याओं के numpy arrays हैं, इसलिए आपका कोड आपके `compute_cost` और `compute_gradient` फंक्शन्स को ठीक करने के बाद (जो वर्तमान में शून्य या शून्य ग्रेडिएंट्स लौटाते हैं) ठीक काम करना चाहिए।

---

## उदाहरण: compute_cost और compute_gradient को लागू करें

```python
def compute_cost(x, y, w, b):
    m = x.shape[0]
    total_cost = 0.5 * np.sum((w * x + b - y) ** 2) / m
    return total_cost

def compute_gradient(x, y, w, b):
    m = x.shape[0]
    error = w * x + b - y
    dj_dw = np.sum(error * x) / m
    dj_db = np.sum(error) / m
    return dj_dw, dj_db
```

---

## सारांश

- TigerOpen API के साथ ऐतिहासिक स्टॉक डेटा प्राप्त करें
- टाइम सीरीज डेटा को संख्यात्मक arrays (`x_train`, `y_train`) में बदलें
- अपने कॉस्ट और ग्रेडिएंट फंक्शन्स को लागू करें या ठीक करें
- फिर आपका ग्रेडिएंट डिसेंट और प्लॉटिंग कोड स्टॉक प्राइस डेटा पर एक लीनियर मॉडल फिट करने के लिए काम करेगा

---

## बोनस: स्टॉक प्राइस प्लॉटिंग

आपका स्कैटर प्लॉट दिनों के हिसाब से क्लोजिंग प्राइस दिखाएगा, और रिग्रेशन लाइन एक ट्रेंड को फिट करेगी।

---

अगर आप चाहें, तो मैं TigerOpen डेटा फ़ेचिंग को आपके numpy लीनियर रिग्रेशन कोड के साथ एकीकृत करने का एक पूरा उदाहरण लिखने में आपकी मदद कर सकता हूँ! बस पूछें।