---
audio: false
generated: true
lang: hi
layout: post
title: 'माइक्रोमीटर के लिए मार्गदर्शिका: उपकरण और प्रेक्षणीयता'
translated: true
type: note
---

यह व्यापक मार्गदर्शिका दो अलग-अलग विषयों को कवर करती है: **माइक्रोमीटर (मापन उपकरण)** और **माइक्रोमीटर (जावा एप्लिकेशन, विशेष रूप से स्प्रिंग बूट के लिए ऑब्ज़र्वेबिलिटी फ़ैकेड), जो ट्रेसिंग समाधानों पर केंद्रित है।**

आइए इन्हें अलग-अलग समझते हैं:

-----

## भाग 1: माइक्रोमीटर (मापन उपकरण) के बारे में व्यापक मार्गदर्शिका

माइक्रोमीटर, जिसे अक्सर माइक्रोमीटर स्क्रू गेज कहा जाता है, एक अत्यधिक सटीक मापन उपकरण है जिसका उपयोग छोटी दूरियों के अत्यधिक सटीक माप प्राप्त करने के लिए किया जाता है, आमतौर पर इंच के हज़ारवें हिस्से या मिलीमीटर के सौवें हिस्से की सीमा में। इसका व्यापक रूप से इंजीनियरिंग, मशीनिंग, विनिर्माण और वैज्ञानिक क्षेत्रों में उपयोग किया जाता है जहां सटीक आयाम महत्वपूर्ण होते हैं।

### 1. माइक्रोमीटर क्या है?

इसके मूल में, एक माइक्रोमीटर घूर्णन गति को रैखिक गति में बदलने के लिए एक सटीक रूप से मशीनीकृत स्क्रू तंत्र का उपयोग करता है। यह एक स्थिर एविल और एक चल स्पिंडल के बीच वस्तु को क्लैंप करके उसके आयामों के लिए बारीक समायोजन और सटीक रीडिंग की अनुमति देता है।

### 2. माइक्रोमीटर के मुख्य घटक:

* **फ्रेम:** C-आकार का मुख्य निकाय जो अन्य सभी घटकों को धारण करता है। यह स्थिरता प्रदान करता है और थर्मल विस्तार की त्रुटियों से बचने के लिए इसे सावधानी से संभालने की आवश्यकता होती है।
* **एविल:** स्थिर मापने वाला सिरा जिसके विरुद्ध वस्तु को रखा जाता है।
* **स्पिंडल:** चल मापने वाला सिरा जो थिम्बल को घुमाने पर एविल की ओर या उससे दूर जाता है।
* **स्लीव (या बैरल):** माइक्रोमीटर का स्थिर हिस्सा जिसमें मुख्य रैखिक पैमाना होता है, जो पूर्ण संख्याएं और आधे इंक्रीमेंट (जैसे, इंच या मिलीमीटर में) प्रदर्शित करता है।
* **थिम्बल:** घूमने वाला हिस्सा जो स्पिंडल को हिलाता है और अधिक सटीक रीडिंग के लिए एक बारीक से अंकित पैमाना रखता है।
* **रैचेट स्टॉप:** थिम्बल के अंत में स्थित, यह सही बल लगने पर फिसल कर सुसंगत मापन दबाव सुनिश्चित करता है, जिससे वर्कपीस के ओवरटाइटनिंग और विकृति को रोका जा सके।
* **लॉक नट (या लॉक लीवर):** एक बार माप लेने के बाद स्पिंडल को जगह पर लॉक करने के लिए उपयोग किया जाता है, जो आकस्मिक गति को रोकता है और रीडिंग को सुरक्षित रखता है।

### 3. माइक्रोमीटर के प्रकार:

माइक्रोमीटर विभिन्न प्रकार के होते हैं, प्रत्येक विशिष्ट मापन कार्यों के लिए डिज़ाइन किया गया है:

* **आउटसाइड माइक्रोमीटर (एक्सटर्नल माइक्रोमीटर):** सबसे आम प्रकार, बाहरी आयामों जैसे शाफ्ट का व्यास या प्लेट की मोटाई मापने के लिए उपयोग किया जाता है।
* **इनसाइड माइक्रोमीटर (इंटरनल माइक्रोमीटर):** आंतरिक आयामों, जैसे बोर या छेद का व्यास मापने के लिए उपयोग किया जाता है। इनकी अक्सर अलग-अलग डिज़ाइन होती हैं, जैसे ट्यूबलर या जॉ-टाइप माइक्रोमीटर।
* **डेप्थ माइक्रोमीटर:** छिद्रों, स्लॉट्स, या स्टेप्स की गहराई मापने के लिए उपयोग किया जाता है।
* **स्क्रू थ्रेड माइक्रोमीटर:** स्क्रू थ्रेड्स के पिच व्यास को मापने के लिए डिज़ाइन किया गया।
* **बॉल माइक्रोमीटर:** वक्रित सतहों या ट्यूब की दीवारों जैसी विशिष्ट विशेषताओं की मोटाई मापने के लिए गोलाकार एविल/स्पिंडल होते हैं।
* **डिस्क माइक्रोमीटर:** पतली सामग्री, कागज, या गियर दांतों को मापने के लिए सपाट, डिस्क के आकार के मापने वाले सिरे होते हैं।
* **डिजिटल माइक्रोमीटर:** सीधी डिजिटल रीडिंग के लिए एक इलेक्ट्रॉनिक डिस्प्ले होता है, जो पैरालेक्स त्रुटि को खत्म करता है और रीडिंग को आसान बनाता है।
* **एनालॉग माइक्रोमीटर:** स्लीव और थिम्बल पर पैमानों को मैन्युअल रूप से पढ़ने की आवश्यकता होती है।
* **वर्नियर माइक्रोमीटर:** और भी अधिक सटीकता के लिए एक अतिरिक्त वर्नियर पैमाना शामिल होता है, जो थिम्बल के मुख्य ग्रेजुएशन से परे रीडिंग की अनुमति देता है।

### 4. माइक्रोमीटर कैसे पढ़ें (एनालॉग/इम्पीरियल उदाहरण):

जबकि विशिष्ट रीडिंग इम्पीरियल (इंच) और मीट्रिक (मिलीमीटर) और एनालॉग/डिजिटल के बीच भिन्न होती है, एनालॉग माइक्रोमीटर के लिए सामान्य सिद्धांत है:

1.  **स्लीव स्केल (मुख्य पैमाना) पढ़ें:**
    * **पूर्ण इंच:** दिखने वाले सबसे बड़े पूर्ण इंच के निशान को नोट करें।
    * **इंच का दसवां हिस्सा (0.100"):** स्लीव पर प्रत्येक क्रमांकित रेखा 0.100 इंच का प्रतिनिधित्व करती है।
    * **पच्चीस हज़ारवां हिस्सा (0.025"):** दसवें हिस्से के निशानों के बीच की प्रत्येक बिना नंबर वाली रेखा 0.025 इंच का प्रतिनिधित्व करती है।
2.  **थिम्बल स्केल पढ़ें:**
    * थिम्बल में 25 ग्रेजुएशन होते हैं, प्रत्येक निशान 0.001 इंच का प्रतिनिधित्व करता है।
    * स्लीव पर इंडेक्स लाइन के साथ संरेखित होने वाली थिम्बल पर रेखा को पढ़ें।
3.  **रीडिंग को जोड़ें:** स्लीव (पूर्ण इंच, दसवां हिस्सा, और पच्चीस हज़ारवां हिस्सा) और थिम्बल (हज़ारवां हिस्सा) से मानों को जोड़कर अंतिम माप प्राप्त करें।

**उदाहरण (इम्पीरियल):**

* स्लीव:
    * मान लें आपको "1" दिखाई देता है (1.000" के लिए)
    * फिर "1" के बाद 3 लाइनें (3 x 0.100" = 0.300")
    * और मुख्य रेखा के नीचे 2 लाइनें (2 x 0.025" = 0.050")
    * स्लीव से कुल: 1.000 + 0.300 + 0.050 = 1.350"
* थिम्बल:
    * थिम्बल का 15वां निशान इंडेक्स लाइन के साथ संरेखित होता है (0.015")
* **कुल रीडिंग:** 1.350" + 0.015" = **1.365"**

### 5. उचित उपयोग और सर्वोत्तम अभ्यास:

* **सफाई:** हमेशा सुनिश्चित करें कि मापने वाले सिरे (एविल और स्पिंडल) साफ और धूल, तेल, या मलबे से मुक्त हों।
* **जीरोइंग:** उपयोग से पहले, हमेशा माइक्रोमीटर को "जीरो" करें। रैचेट स्टॉप का उपयोग करके मापने वाले सिरों को धीरे से बंद करें जब तक कि वे स्पर्श न करें। रीडिंग 0.000 (या प्रारंभिक सीमा, जैसे 25-50mm) होनी चाहिए। यदि नहीं है, तो जीरो त्रुटि के लिए माइक्रोमीटर को समायोजित करें। डिजिटल माइक्रोमीटर में आमतौर पर एक रीसेट बटन होता है।
* **तापमान:** माइक्रोमीटर को उसके इंसुलेटेड फ्रेम से पकड़ें या दस्ताने पहनें, क्योंकि शरीर की गर्मी थर्मल विस्तार का कारण बन सकती है और सटीकता को प्रभावित कर सकती है, विशेष रूप से बड़े माइक्रोमीटर के लिए। उपकरण और वस्तु दोनों को कमरे के तापमान पर आने दें।
* **सुसंगत दबाव:** हमेशा सुसंगत और उचित मापन दबाव लागू करने के लिए रैचेट स्टॉप का उपयोग करें। अत्यधिक कसने से वस्तु या माइक्रोमीटर विकृत हो सकता है।
* **वस्तु की स्थिति:** तिरछी रीडिंग से बचने के लिए वस्तु को एविल और स्पिंडल के बीच सीधा रखें।
* **एकाधिक माप:** महत्वपूर्ण आयामों के लिए, विविधताओं को ध्यान में रखते हुए वस्तु पर विभिन्न बिंदुओं पर कई माप लें।
* **भंडारण:** माइक्रोमीटर को क्षति से बचाने के लिए उनके सुरक्षात्मक केस में संग्रहित करें।
* **कैलिब्रेशन:** उनकी सटीकता सुनिश्चित करने के लिए माइक्रोमीटर को ज्ञात मानकों (जैसे, गेज ब्लॉक) के विरुद्ध नियमित रूप से जांचें और कैलिब्रेट करें।

-----

## भाग 2: स्प्रिंग जावा प्रोजेक्ट्स के लिए एक ट्रेसिंग समाधान के रूप में माइक्रोमीटर

स्प्रिंग जावा प्रोजेक्ट्स के संदर्भ में, "माइक्रोमीटर" एक **एप्लिकेशन ऑब्ज़र्वेबिलिटी फ़ैकेड** को संदर्भित करता है जो JVM-आधारित एप्लिकेशन को इंस्ट्रुमेंट करने के लिए एक वेंडर-न्यूट्रल API प्रदान करता है। यह आपको विभिन्न टेलीमेट्री डेटा, जिसमें मेट्रिक्स, लॉगिंग, और **डिस्ट्रिब्यूटेड ट्रेसिंग** शामिल हैं, को एकत्रित और निर्यात करने की अनुमति देता है।

माइक्रोमीटर ट्रेसिंग स्प्रिंग क्लाउड स्लूथ का उत्तराधिकारी है और कई सेवाओं में अनुरोधों को ट्रैक करके जटिल वितरित प्रणालियों में अंतर्दृष्टि प्रदान करने के लिए डिज़ाइन किया गया है।

### 1. डिस्ट्रिब्यूटेड ट्रेसिंग क्या है?

एक माइक्रोसर्विसेज आर्किटेक्चर में, एक एकल उपयोगकर्ता अनुरोध अक्सर कई सेवाओं से होकर गुजरता है। डिस्ट्रिब्यूटेड ट्रेसिंग आपको यह करने की अनुमति देती है:

* **प्रवाह को ट्रैक करें:** अपनी प्रणाली के माध्यम से एक अनुरोध द्वारा लिए गए पूर्ण पथ को देखें।
* **बॉटलनेक की पहचान करें:** पिनपॉइंट करें कि कौन सी सेवा या ऑपरेशन विलंबता का कारण बन रही है।
* **निर्भरताएं समझें:** विभिन्न सेवाओं के बीच की बातचीत को विज़ुअलाइज़ करें।
* **डीबगिंग को सरल बनाएं:** विशिष्ट अनुरोधों के साथ लॉग को सहसंबद्ध करें, जिससे समस्या निवारण बहुत आसान हो जाता है।

एक डिस्ट्रिब्यूटेड ट्रेस **स्पैन** से बना होता है। एक **स्पैन** एक ट्रेस के भीतर एक एकल ऑपरेशन या कार्य की इकाई का प्रतिनिधित्व करता है (उदाहरण के लिए, एक सेवा के लिए एक HTTP अनुरोध, एक डेटाबेस क्वेरी, एक विधि निष्पादन)। स्पैन के पास एक अद्वितीय ID, एक प्रारंभ और समाप्ति समय होता है, और इसमें अतिरिक्त मेटाडेटा के लिए टैग (की-वैल्यू पेयर) और इवेंट शामिल हो सकते हैं। स्पैन पदानुक्रमित रूप से व्यवस्थित होते हैं, जिनमें पैरेंट-चाइल्ड संबंध होते हैं, जो एक ट्रेस बनाते हैं।

### 2. स्प्रिंग बूट 3.x+ में माइक्रोमीटर ट्रेसिंग

स्प्रिंग बूट 3.x+ माइक्रोमीटर के ऑब्ज़र्वेशन API और माइक्रोमीटर ट्रेसिंग के साथ गहराई से एकीकृत होता है, जिससे डिस्ट्रिब्यूटेड ट्रेसिंग को लागू करना काफी आसान हो जाता है।

#### 2.1. मूल अवधारणाएँ:

* **ऑब्ज़र्वेशन API:** आपके कोड को इंस्ट्रुमेंट करने के लिए माइक्रोमीटर का एकीकृत API, जो एक एकल इंस्ट्रुमेंटेशन बिंदु से मेट्रिक्स, ट्रेस और लॉग उत्पन्न करने में सक्षम है।
* **माइक्रोमीटर ट्रेसिंग:** लोकप्रिय ट्रेसर लाइब्रेरीज जैसे OpenTelemetry और OpenZipkin Brave पर एक फ़ैकेड। यह स्पैन के जीवनचक्र, कॉन्टेक्स्ट प्रोपगेशन, और ट्रेसिंग बैकएंड्स को रिपोर्टिंग को संभालता है।
* **ट्रेसर ब्रिज:** माइक्रोमीटर ट्रेसिंग विशिष्ट ट्रेसिंग कार्यान्वयन (जैसे, OpenTelemetry के लिए `micrometer-tracing-bridge-otel`, OpenZipkin Brave के लिए `micrometer-tracing-bridge-brave`) से अपने API को जोड़ने के लिए "ब्रिज" प्रदान करता है।
* **रिपोर्टर/एक्सपोर्टर:** ये घटक एकत्रित ट्रेस डेटा को एक ट्रेसिंग बैकएंड (जैसे, Zipkin, Jaeger, Grafana Tempo) पर भेजते हैं।

#### 2.2. एक स्प्रिंग बूट जावा प्रोजेक्ट में माइक्रोमीटर ट्रेसिंग सेट अप करना:

यहां एक चरण-दर-चरण मार्गदर्शिका दी गई है:

**चरण 1: निर्भरताएँ जोड़ें**

आपको ऑब्ज़र्वेबिलिटी सुविधाओं के लिए `spring-boot-starter-actuator`, एक माइक्रोमीटर ट्रेसिंग ब्रिज, और आपके चुने हुए ट्रेसिंग बैकएंड के लिए एक रिपोर्टर/एक्सपोर्टर की आवश्यकता है।

**OpenTelemetry और Zipkin के साथ उदाहरण (सामान्य विकल्प):**

आपके `pom.xml` (Maven) में:

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>

    <dependency>
        <groupId>io.micrometer</groupId>
        <artifactId>micrometer-observation</artifactId>
    </dependency>

    <dependency>
        <groupId>io.micrometer</groupId>
        <artifactId>micrometer-tracing-bridge-otel</artifactId>
    </dependency>

    <dependency>
        <groupId>io.opentelemetry</groupId>
        <artifactId>opentelemetry-exporter-zipkin</artifactId>
    </dependency>

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-webflux</artifactId>
    </dependency>
</dependencies>
```

**चरण 2: ट्रेसिंग गुण कॉन्फ़िगर करें**

`application.properties` या `application.yml` में, आप ट्रेसिंग व्यवहार को कॉन्फ़िगर कर सकते हैं।

```properties
# ट्रेसिंग सक्षम करें (आमतौर पर एक्चुएटर और ट्रेसिंग निर्भरताओं के साथ डिफ़ॉल्ट रूप से true)
management.tracing.enabled=true

# सैंपलिंग संभावना कॉन्फ़िगर करें (1.0 = 100% अनुरोध ट्रेस किए जाते हैं)
# डिफ़ॉल्ट अक्सर 0.1 (10%) होता है, विकास/परीक्षण के लिए 1.0 पर सेट करें
management.tracing.sampling.probability=1.0

# Zipkin बेस URL कॉन्फ़िगर करें (यदि Zipkin का उपयोग कर रहे हैं)
spring.zipkin.base-url=http://localhost:9411
```

**चरण 3: एक ट्रेसिंग बैकएंड चलाएँ (जैसे, Zipkin)**

आपको अपने ट्रेस को एकत्रित करने और विज़ुअलाइज़ करने के लिए एक ट्रेसिंग सर्वर की आवश्यकता है। स्थानीय विकास के लिए Zipkin एक लोकप्रिय विकल्प है।

आप Zipkin को Docker के माध्यम से चला सकते हैं:

```bash
docker run -d -p 9411:9411 openzipkin/zipkin
```

एक बार चलने के बाद, आप Zipkin UI को `http://localhost:9411` पर एक्सेस कर सकते हैं।

**चरण 4: स्वचालित इंस्ट्रुमेंटेशन (स्प्रिंग बूट का जादू!)**

स्प्रिंग बूट में कई सामान्य घटकों (जैसे `RestController` एंडपॉइंट्स, `RestTemplate`, `WebClient`, `JdbcTemplate`, Kafka लिसनर्स/प्रोड्यूसर्स, आदि) के लिए, माइक्रोमीटर ट्रेसिंग **स्वचालित इंस्ट्रुमेंटेशन** प्रदान करता है। इसका मतलब है कि आमतौर पर बुनियादी अनुरोध ट्रेसिंग के काम करने के लिए आपको कोई स्पष्ट ट्रेसिंग कोड लिखने की आवश्यकता नहीं होती है।

स्प्रिंग बूट यह सुनिश्चित करता है:

* आने वाले HTTP अनुरोध स्वचालित रूप से एक नया ट्रेस बनाते हैं या मौजूदा ट्रेस को जारी रखते हैं यदि ट्रेस हेडर मौजूद हैं।
* ऑटो-कॉन्फ़िगर किए गए `RestTemplateBuilder`, `RestClient.Builder`, या `WebClient.Builder` के साथ किए गए आउटगोइंग अनुरोध डाउनस्ट्रीम सेवाओं में ट्रेस कॉन्टेक्स्ट को प्रोपेगेट करते हैं।
* लॉग स्टेटमेंट्स में स्वचालित रूप से `traceId` और `spanId` शामिल होते हैं (यदि आप अपना लॉगिंग पैटर्न कॉन्फ़िगर करते हैं)।

**उदाहरण लॉगिंग पैटर्न (`application.properties` में):**

```properties
logging.pattern.level=%5p [${spring.application.name:},%X{traceId:-},%X{spanId:-}] %c{1.}:%M:%L - %m%n
```

यह पैटर्न आपकी लॉग लाइनों में `traceId` और `spanId` को इंजेक्ट करेगा, जिससे लॉग को एक विशिष्ट ट्रेस के साथ सहसंबद्ध करना आसान हो जाएगा।

**चरण 5: मैनुअल इंस्ट्रुमेंटेशन (कस्टम लॉजिक के लिए)**

जबकि ऑटो-इंस्ट्रुमेंटेशन बहुत कुछ कवर करता है, आप अक्सर अपने एप्लिकेशन के भीतर विशिष्ट बिजनेस लॉजिक या महत्वपूर्ण ऑपरेशन को ट्रेस करना चाहेंगे। आप इसे निम्नलिखित का उपयोग करके कर सकते हैं:

* **`@Observed` एनोटेशन (स्प्रिंग बूट 3.x+ के लिए अनुशंसित):**
    यह एनोटेशन माइक्रोमीटर ऑब्ज़र्वेशन API का हिस्सा है और ऑब्ज़र्वेशन बनाने का पसंदीदा तरीका है (जो मेट्रिक्स और ट्रेस दोनों उत्पन्न कर सकता है)।

    ```java
    import io.micrometer.observation.annotation.Observed;
    import org.springframework.stereotype.Service;

    @Service
    public class MyService {

        @Observed(name = "myService.processData", contextualName = "processing-data")
        public String processData(String input) {
            // ... आपका बिजनेस लॉजिक ...
            System.out.println("Processing data: " + input);
            return "Processed: " + input;
        }
    }
    ```

    `name` विशेषता ऑब्ज़र्वेशन के लिए नाम को परिभाषित करती है (जो मेट्रिक नाम और ट्रेस स्पैन नाम बन जाता है)। `contextualName` ट्रेसिंग टूल्स में स्पैन के लिए एक अधिक मानव-पठनीय नाम प्रदान करता है।

* **प्रोग्रामेटिक API (अधिक नियंत्रण के लिए):**
    आप सीधे स्प्रिंग बूट द्वारा प्रदान किए गए `ObservationRegistry` और `Tracer` बीन्स का उपयोग कर सकते हैं।

    ```java
    import io.micrometer.observation.Observation;
    import io.micrometer.observation.ObservationRegistry;
    import org.springframework.stereotype.Service;

    @Service
    public class AnotherService {

        private final ObservationRegistry observationRegistry;

        public AnotherService(ObservationRegistry observationRegistry) {
            this.observationRegistry = observationRegistry;
        }

        public String performComplexOperation(String id) {
            return Observation.createNotStarted("complex.operation", observationRegistry)
                    .lowCardinalityKeyValue("operation.id", id) // एक टैग जोड़ें
                    .observe(() -> {
                        // ... यहाँ जटिल लॉजिक ...
                        try {
                            Thread.sleep(100); // कार्य का अनुकरण करें
                        } catch (InterruptedException e) {
                            Thread.currentThread().interrupt();
                        }
                        return "Completed complex operation for " + id;
                    });
        }
    }
    ```

    यहाँ, `observe()` कोड ब्लॉक को रैप करता है, और `lowCardinalityKeyValue` स्पैन में एक टैग जोड़ता है।

### 3. माइक्रोसर्विसेज में डिस्ट्रिब्यूटेड ट्रेसिंग:

जब आपके पास एकाधिक स्प्रिंग बूट सेवाएँ होती हैं, तो माइक्रोमीटर ट्रेसिंग `RestTemplate`, `WebClient`, और अन्य इंस्ट्रुमेंटेड क्लाइंट्स के लिए कॉन्टेक्स्ट प्रोपगेशन को स्वचालित रूप से सुविधाजनक बनाता है। इसका मतलब है कि `traceId` और `spanId` सेवाओं के बीच HTTP हेडर में पास किए जाते हैं (उदाहरण के लिए, W3C ट्रेस कॉन्टेक्स्ट के लिए `traceparent` हेडर)।

जब एक अनुरोध एक डाउनस्ट्रीम सेवा में आता है, तो माइक्रोमीटर ट्रेसिंग इन हेडर का पता लगाता है और मौजूदा ट्रेस को जारी रखता है, नए स्पैन बनाता है जो कॉलिंग सेवा से पैरेंट स्पैन के चिल्ड्रन होते हैं। यह पूर्ण एंड-टू-एंड ट्रेस बनाता है।

### 4. ट्रेस को विज़ुअलाइज़ करना:

एक बार जब आपका एप्लिकेशन इंस्ट्रुमेंटेड हो जाता है और Zipkin (या Jaeger, Lightstep, आदि) जैसे बैकएंड को ट्रेस भेज रहा होता है, तो आप यह कर सकते हैं:

1.  **UI एक्सेस करें:** ट्रेसिंग बैकएंड के वेब UI पर जाएँ (उदाहरण के लिए, Zipkin के लिए `http://localhost:9411`)।
2.  **ट्रेस ढूंढें:** विशिष्ट ट्रेस ढूंढने के लिए फ़िल्टर (सेवा नाम, स्पैन नाम, ट्रेस ID) का उपयोग करें।
3.  **ट्रेस विवरण का विश्लेषण करें:** उसकी टाइमलाइन, व्यक्तिगत स्पैन, उनकी अवधि, टैग और इवेंट देखने के लिए एक ट्रेस पर क्लिक करें।
4.  **निर्भरता ग्राफ:** अधिकांश ट्रेसिंग बैकएंड एकत्रित ट्रेस के आधार पर सेवा निर्भरताओं को विज़ुअलाइज़ कर सकते हैं।

### 5. माइक्रोमीटर ट्रेसिंग के लिए सर्वोत्तम अभ्यास:

* **अपने स्पैन को सार्थक नाम दें:** अपने स्पैन के लिए स्पष्ट, संक्षिप्त और लो-कार्डिनैलिटी वाले नामों का उपयोग करें (जैसे, "userService.getUser", "productService.updateStock")। स्पैन नामों में अत्यधिक डायनामिक डेटा शामिल करने से बचें।
* **विवरण के लिए टैग का उपयोग करें (हाई कार्डिनैलिटी डेटा):** डायनामिक डेटा को स्पैन नामों में रखने के बजाय, अतिरिक्त कॉन्टेक्स्ट के लिए टैग (की-वैल्यू पेयर) का उपयोग करें। उदाहरण के लिए, `userId`, `orderId`, `customerType`। **हाई कार्डिनैलिटी** टैग के प्रति सचेत रहें, क्योंकि वे आपके ट्रेसिंग बैकएंड में भंडारण लागत और क्वेरी सम