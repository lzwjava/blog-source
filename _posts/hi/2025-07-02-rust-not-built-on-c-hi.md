---
audio: false
generated: true
lang: hi
layout: post
title: रस्ट का सी से संबंध
translated: true
type: note
---

नहीं, रस्ट (Rust) "सी (C) पर बनी हुई" नहीं है, इस अर्थ में कि यह सी में कंपाइल होती है या अपने संचालन के लिए सी को एक आधारभूत परत के रूप में आवश्यकता होती है। रस्ट एक अलग, आधुनिक सिस्टम प्रोग्रामिंग भाषा है।

यहाँ रस्ट और सी के बीच संबंध और रस्ट सी लाइब्रेरीज़ के साथ कैसे इंटरैक्ट करती है, इसका विवरण दिया गया है:

**क्या रस्ट सी पर बनी है?**

* **कंपाइलर:** रस्ट कंपाइलर (`rustc`) मुख्य रूप से स्वयं रस्ट में लिखा गया है। कंपाइलर के शुरुआती संस्करण OCaml का उपयोग करके बूटस्ट्रैप किए गए थे, लेकिन अब यह स्वयं-होस्टिंग है।
* **लो-लेवल इंटरैक्शन:** रस्ट एक लो-लेवल भाषा है जो सीधे ऑपरेटिंग सिस्टम और हार्डवेयर के साथ इंटरैक्ट कर सकती है, ठीक सी या सी++ की तरह। यह इन मूलभूत ऑपरेशनों के लिए सी पर एक मध्यस्थ के रूप में निर्भर नहीं करती है।
* **LLVM:** रस्ट का कंपाइलर कोड जनरेशन और ऑप्टिमाइजेशन के लिए अपने बैकएंड के रूप में LLVM (लो लेवल वर्चुअल मशीन) का उपयोग करता है। LLVM स्वयं मुख्य रूप से C++ में लिखा गया है। इसका मतलब है कि रस्ट कोड अंततः LLVM इंटरमीडिएट रिप्रेजेंटेशन (IR) में अनुवादित हो जाता है, जिसे बाद में ऑप्टिमाइज़ किया जाता है और मशीन कोड में कंपाइल किया जाता है। तो, इस अर्थ में, एक C++-आधारित टूलचेन (LLVM) पर एक निर्भरता है, लेकिन रस्ट स्वयं "सी पर बनी हुई" नहीं है।

**क्या रस्ट सभी सी लाइब्रेरीज़ का उपयोग कर सकती है?**

हाँ, रस्ट अपने **फॉरेन फंक्शन इंटरफेस (FFI)** के माध्यम से सी लाइब्रेरीज़ के साथ उत्कृष्ट इंटरऑपरेबिलिटी प्रदान करती है। इसका मतलब है कि आप अपने रस्ट कोड के भीतर सीधे मौजूदा सी लाइब्रेरीज़ के फ़ंक्शन्स को कॉल कर सकते हैं और डेटा स्ट्रक्चर्स का उपयोग कर सकते हैं।

यह आम तौर पर कैसे काम करता है:

1.  **`extern "C"` ब्लॉक्स:** आप अपने रस्ट कोड में एक `extern "C"` ब्लॉक को परिभाषित करते हैं ताकि उन सी फ़ंक्शन्स के सिग्नेचर घोषित किए जा सकें जिन्हें आप कॉल करना चाहते हैं। यह रस्ट कंपाइलर को बताता है कि ये फ़ंक्शन सी एप्लिकेशन बाइनरी इंटरफेस (ABI) का पालन करते हैं, जो यह निर्धारित करता है कि फ़ंक्शन कैसे कॉल किए जाते हैं और डेटा मेमोरी में कैसे व्यवस्थित होता है।
2.  **`#[link]` एट्रिब्यूट:** आप `#[link(name = "foo")]` एट्रिब्यूट का उपयोग रस्ट लिंकर को निर्दिष्ट सी लाइब्रेरी (जैसे, `libfoo.so` या `foo.lib`) के विरुद्ध लिंक करने के लिए कहने के लिए करते हैं।
3.  **`unsafe` ब्लॉक्स:** सी फ़ंक्शन के कॉल आमतौर पर रस्ट में `unsafe` ब्लॉक्स में लपेटे जाते हैं। ऐसा इसलिए है क्योंकि "फॉरेन" कोड के साथ इंटरैक्ट करते समय, जो रस्ट के नियमों का पालन नहीं करता है, रस्ट की मजबूत मेमोरी सेफ्टी गारंटी लागू नहीं की जा सकती है। आप, प्रोग्रामर के रूप में, इन कॉल्स की सुरक्षा सुनिश्चित करने के लिए जिम्मेदार हैं।
4.  **`bindgen`:** बड़ी सी लाइब्रेरीज़ के लिए, सभी `extern "C"` घोषणाओं को मैन्युअल रूप से लिखना थकाऊ हो सकता है। `bindgen` जैसे टूल सी हेडर फाइलों से स्वचालित रूप से रस्ट FFI बाइंडिंग्स जेनरेट कर सकते हैं, जिससे प्रक्रिया काफी सरल हो जाती है।
5.  **`cty` क्रेट:** `cty` क्रेट रस्ट और सी के बीच सही डेटा टाइप मैपिंग सुनिश्चित करने के लिए सी-संगत आदिम प्रकार (जैसे, `c_int`, `c_char`, आदि) प्रदान करता है।

**रस्ट में सी लाइब्रेरीज़ का उपयोग क्यों करें?**

*   **मौजूदा कोड का लाभ उठाना:** विभिन्न कार्यों (जैसे, सिस्टम कॉल, क्रिप्टोग्राफी, न्यूमेरिकल कंप्यूटिंग, ग्राफिक्स) के लिए परीक्षित और अत्यधिक ऑप्टिमाइज़्ड सी लाइब्रेरीज़ का एक विशाल इकोसिस्टम मौजूद है। रस्ट आपको सब कुछ शून्य से दोबारा लिखे बिना इस मौजूदा संसाधन का उपयोग करने की अनुमति देती है।
*   **ऑपरेटिंग सिस्टम इंटरफेस:** ऑपरेटिंग सिस्टम अपनी कई कार्यक्षमताओं को सी-संगत इंटरफेस के माध्यम से एक्सपोज़ करते हैं। रस्ट को ओएस के साथ इंटरैक्ट करने के लिए इन फ़ंक्शन्स को कॉल करने में सक्षम होना चाहिए।
*   **परफॉर्मेंस-क्रिटिकल सेक्शन:** जबकि रस्ट आम तौर पर बहुत तेज है, कुछ अत्यधिक विशिष्ट परफॉर्मेंस-क्रिटिकल कोड पहले से ही सी में मौजूद हो सकते हैं और उन्हें सीधे एकीकृत किया जा सकता है।

संक्षेप में, रस्ट "सी पर बनी हुई" नहीं है, लेकिन यह सी लाइब्रेरीज़ के साथ सहज इंटरऑपरेबिलिटी के लिए मजबूत तंत्र (FFI) प्रदान करती है, जो रस्ट डेवलपर्स को व्यापक सी इकोसिस्टम का लाभ उठाने की अनुमति देती है।