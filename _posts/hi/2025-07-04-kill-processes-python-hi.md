---
audio: false
generated: true
image: false
lang: hi
layout: post
model: x-ai/grok-code-fast-1
title: पायथन से प्रक्रियाओं को समाप्त करना
translated: true
type: note
---

### विंडोज़ पर प्रक्रियाओं को समाप्त करने के लिए Python का उपयोग

विंडोज़ पर प्रोग्रामेटिक रूप से प्रक्रियाओं को समाप्त करने के लिए, आप मुख्य रूप से `taskkill` जैसे सिस्टम कमांड्स को चलाने के लिए `subprocess` मॉड्यूल का उपयोग करेंगे। `signal` मॉड्यूल Unix-केंद्रित है और विंडोज़ पर प्रक्रियाओं को समाप्त करने के लिए विश्वसनीय रूप से काम नहीं करता है (SIGKILL जैसे सिग्नल्स मूल रूप से समर्थित नहीं हैं; `os.kill()` सीमित सिग्नल भेज सकता है, लेकिन यह पूर्ण प्रक्रिया समाप्ति के लिए आदर्श नहीं है)। `platform` मॉड्यूल OS-विशिष्ट व्यवहार के लिए यह पुष्टि करने में मदद कर सकता है कि आप विंडोज़ पर हैं।

#### चरण 1: मॉड्यूल इंस्टॉल करें और इम्पोर्ट करें
- `subprocess`, `signal`, और `platform` Python स्टैंडर्ड लाइब्रेरी का हिस्सा हैं, इसलिए किसी इंस्टॉलेशन की आवश्यकता नहीं है।
- उदाहरण इम्पोर्ट:

```python
import subprocess
import platform
import os  # PID एक्सेस के लिए, यदि आवश्यक हो
```

#### चरण 2: विंडोज़ OS का पता लगाएं (`platform` का उपयोग करके)
- क्रॉस-प्लेटफ़ॉर्म समस्याओं से बचने के लिए वातावरण की पुष्टि करें:

```python
if platform.system() == 'Windows':
    print("विंडोज़ पर चल रहा है - संगत समाप्ति विधियों का उपयोग कर रहा हूँ।")
```

#### चरण 3: एक प्रक्रिया को समाप्त करना
- किसी मौजूदा प्रक्रिया को उसके Process ID (PID) या नाम से समाप्त करने के लिए, `subprocess` के माध्यम से `taskkill` का उपयोग करें। यह विश्वसनीय विंडोज़-नेटिव तरीका है, क्योंकि `subprocess.terminate()` या `.kill()` केवल उन प्रक्रियाओं पर काम करता है जिन्हें आपने `subprocess.Popen` के साथ लॉन्च किया है।
- उदाहरण: PID द्वारा प्रक्रिया समाप्त करें (`/F` फ्लैग के साथ जबरदस्ती)। `1234` को वास्तविक PID से बदलें।

```python
def kill_process_by_pid(pid):
    try:
        subprocess.call(['taskkill', '/PID', str(pid), '/F'])
        print(f"प्रक्रिया {pid} समाप्त कर दी गई।")
    except subprocess.CalledProcessError as e:
        print(f"प्रक्रिया {pid} को समाप्त करने में विफल: {e}")

# उपयोग
kill_process_by_pid(1234)
```

- प्रक्रिया नाम द्वारा समाप्त करें (उदाहरण के लिए, 'notepad.exe'), जो सभी मेल खाने वाली प्रक्रियाओं को समाप्त कर देता है:

```python
def kill_process_by_name(name):
    try:
        subprocess.call(['taskkill', '/IM', name, '/F'])
        print(f"'{name}' से मेल खाने वाली प्रक्रियाएं समाप्त कर दी गईं।")
    except subprocess.CalledProcessError as e:
        print(f"प्रक्रियाओं '{name}' को समाप्त करने में विफल: {e}")

# उपयोग
kill_process_by_name('notepad.exe')
```

#### सीमाएँ और नोट्स
- `subprocess` बाहरी कमांड्स को चलाता है, इसलिए सुनिश्चित करें कि आपकी स्क्रिप्ट के पास उचित अनुमतियाँ हैं (उदाहरण के लिए, सिस्टम प्रक्रियाओं के लिए व्यवस्थापक के रूप में चलाएँ)।
- `subprocess.Popen` के माध्यम से लॉन्च की गई प्रक्रिया के लिए, सीधे `.terminate()` (विनम्र शटडाउन) या `.kill()` (जबरदस्त) का उपयोग करें:

```python
proc = subprocess.Popen(['notepad.exe'])  # लॉन्च करें
proc.kill()  # इसे समाप्त करें
```

- `signal` मॉड्यूल: `os.kill(pid, signal.SIGTERM)` का उपयोग विंडोज़ पर कुछ सिग्नल्स के लिए काम कर सकता है (Python 3.2+), लेकिन यह कम मजबूत है और सभी प्रक्रियाओं को समाप्त नहीं कर सकता है। उदाहरण के लिए:

```python
import signal
os.kill(pid, signal.SIGTERM)  # कोमलता से बंद हो सकता है; गारंटीकृत नहीं
```

विंडोज़ पर समाप्त करने के लिए `signal` पर भरोसा करने से बचें—सर्वोत्तम परिणामों के लिए `taskkill` के साथ `subprocess` का उपयोग करें।

यदि आपको PIDs की सूची बनाने की आवश्यकता है (उदाहरण के लिए, `tasklist` कमांड के माध्यम से), तो आप डायनामिक समाप्ति के लिए पहले उन्हीं क्वेरी कर सकते हैं। अधिक उन्नत प्रक्रिया प्रबंधन के लिए, `psutil` जैसी तृतीय-पक्ष लाइब्रेरीज़ पर विचार करें, लेकिन उपरोक्त केवल मानक मॉड्यूल का उपयोग करता है।