---
audio: false
generated: true
lang: hi
layout: post
title: डेटाबेस डेडलॉक
translated: true
type: note
---

एक **डेटाबेस डेडलॉक** तब होता है जब दो या दो से अधिक लेन-देन (ट्रांजैक्शन) संसाधनों पर लॉक जारी करने के लिए एक-दूसरे की प्रतीक्षा कर रहे होते हैं, जिससे एक गोलाकार निर्भरता बन जाती है जो उनमें से किसी को भी आगे बढ़ने से रोकती है। डेटाबेस मैनेजमेंट सिस्टम (DBMS) आमतौर पर इस स्थिति का पता लगाता है और लेन-देन में से किसी एक को रोल बैक करके इसे हल करता है। नीचे डेडलॉक परिदृश्य का एक विस्तृत उदाहरण दिया गया है:

---

### उदाहरण: दो लेन-देन के बीच डेडलॉक
- **परिदृश्य**:
  - लेन-देन T1, `Orders` टेबल में एक पंक्ति को अपडेट करता है और फिर `Customers` टेबल में एक पंक्ति को अपडेट करने की आवश्यकता होती है।
  - लेन-देन T2, `Customers` टेबल में एक पंक्ति को अपडेट करता है और फिर `Orders` टेबल में एक पंक्ति को अपडेट करने की आवश्यकता होती है।
  - दोनों लेन-देन संसाधनों को अलग-अलग क्रम में लॉक करते हैं, जिससे डेडलॉक उत्पन्न होता है।

- **चरणबद्ध तरीका**:
  1. T1, `Orders` में एक पंक्ति को लॉक करता है।
  2. T2, `Customers` में एक पंक्ति को लॉक करता है।
  3. T1, `Customers` में पंक्ति को लॉक करने का प्रयास करता है (T2 द्वारा ब्लॉक किया गया)।
  4. T2, `Orders` में पंक्ति को लॉक करने का प्रयास करता है (T1 द्वारा ब्लॉक किया गया)।
  - परिणाम: कोई भी लेन-देन आगे नहीं बढ़ सकता, जिससे डेडलॉक बनता है।

- **SQL उदाहरण**:
  ```sql
  -- लेन-देन T1
  BEGIN TRANSACTION;
  UPDATE Orders SET Status = 'Shipped' WHERE OrderID = 100;  -- OrderID 100 को लॉक करता है
  -- (कुछ देरी या प्रोसेसिंग)
  UPDATE Customers SET LastOrderDate = '2025-03-27' WHERE CustomerID = 1;  -- T2 द्वारा ब्लॉक किया गया

  -- लेन-देन T2
  BEGIN TRANSACTION;
  UPDATE Customers SET Balance = Balance - 50 WHERE CustomerID = 1;  -- CustomerID 1 को लॉक करता है
  -- (कुछ देरी या प्रोसेसिंग)
  UPDATE Orders SET PaymentStatus = 'Paid' WHERE OrderID = 100;  -- T1 द्वारा ब्लॉक किया गया
  ```

- **क्या होता है**:
  - T1, `OrderID = 100` पर एक एक्सक्लूसिव लॉक रखता है और `CustomerID = 1` की प्रतीक्षा करता है।
  - T2, `CustomerID = 1` पर एक एक्सक्लूसिव लॉक रखता है और `OrderID = 100` की प्रतीक्षा करता है।
  - यह गोलाकार प्रतीक्षा की स्थिति एक डेडलॉक है।
  - DBMS इसका पता लगाता है (उदाहरण के लिए, टाइमआउट या डेडलॉक डिटेक्शन एल्गोरिदम के माध्यम से) और एक लेन-देन को रोल बैक कर देता है (उदाहरण के लिए, T2), जिससे T1 को पूरा करने की अनुमति मिलती है।

---

### डेडलॉक का दृश्य प्रतिनिधित्व
```
T1: Locks Orders(100) --> Wants Customers(1)
   |                        ↑
   |                        |
T2: Wants Orders(100)  <-- Locks Customers(1)
```

- **समाधान**: DBMS एक त्रुटि आउटपुट कर सकता है, जैसे:
  ```
  Transaction T2 was deadlocked on lock resources with another process and has been chosen as the deadlock victim. Rerun the transaction.
  ```

---

### यह क्यों होता है
- **लॉकिंग क्रम**: T1 और T2 लॉक को अलग-अलग क्रम में प्राप्त करते हैं (T1: Orders → Customers; T2: Customers → Orders)।
- **समवर्तिता (Concurrency)**: दोनों लेन-देन एक साथ चलते हैं और अतिव्यापी संसाधनों की आवश्यकता होती है।
- **एक्सक्लूसिव लॉक**: अपडेट के लिए एक्सक्लूसिव लॉक की आवश्यकता होती है, जो अन्य लेन-देन को समान डेटा तक पहुंचने से रोकते हैं।

---

### डेडलॉक से कैसे बचें
1. **सुसंगत लॉक क्रम**: सुनिश्चित करें कि सभी लेन-देन लॉक को एक ही क्रम में प्राप्त करते हैं (उदाहरण के लिए, हमेशा पहले `Orders` को लॉक करें, फिर `Customers` को)।
   ```sql
   -- T1 और T2 दोनों को पहले Orders को लॉक करना चाहिए, फिर Customers को
   ```
2. **लेन-देन का समय कम करें**: ओवरलैप की संभावना को कम करने के लिए लेन-देन के भीतर देरी को कम से कम करें।
3. **कम आइसोलेशन लेवल का उपयोग करें**: यदि उचित हो, तो लॉकिंग की अवधि को कम करने के लिए कम सख्त आइसोलेशन लेवल (उदाहरण के लिए, Read Committed) का उपयोग करें।
4. **टाइमआउट**: तेजी से फेल होने और पुनः प्रयास करने के लिए छोटे लॉक टाइमआउट सेट करें।

---

यदि आप एक अधिक विशिष्ट उदाहरण (उदाहरण के लिए, किसी विशेष DBMS जैसे PostgreSQL या SQL Server के साथ) या और स्पष्टीकरण चाहते हैं, तो मुझे बताएं!