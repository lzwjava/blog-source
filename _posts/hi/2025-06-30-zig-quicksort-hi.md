---
audio: false
generated: true
lang: hi
layout: post
title: ज़िग क्विक सॉर्ट कार्यान्वयन
translated: true
type: note
---

यहाँ Zig में क्विक सॉर्ट का समकक्ष कार्यान्वयन दिया गया है।

```zig
const std = @import("std");

// क्विक सॉर्ट फ़ंक्शन
fn quickSort(arr: []i32) void {
    if (arr.len <= 1) {
        return;
    }

    const pivot_index = partition(arr);

    // ऐरे को बाएँ और दाएँ पार्टिशन में विभाजित करें
    // नोट: Zig की स्लाइस स्प्लिटिंग Rust से थोड़ी अलग है
    // हमें पिवट एलिमेंट को सावधानी से हैंडल करने की आवश्यकता है
    var left_slice = arr[0..pivot_index];
    var right_slice = arr[pivot_index + 1 .. arr.len]; // पिवट को दाएँ स्लाइस से बाहर रखें

    quickSort(left_slice);
    quickSort(right_slice);
}

// पार्टिशन फ़ंक्शन
fn partition(arr: []i32) usize {
    const len = arr.len;
    // सरलता के लिए, हम अंतिम एलिमेंट को पिवट के रूप में उपयोग करेंगे, Rust उदाहरण के समान।
    // प्रोडक्शन क्विकसॉर्ट में, आप बेहतर औसत केस परफॉर्मेंस के लिए रैंडम पिवट या मीडियन-ऑफ-थ्री चुन सकते हैं।
    const pivot = arr[len - 1];
    var i: usize = 0; // छोटे एलिमेंट का इंडेक्स

    for (0..(len - 1)) |j| {
        if (arr[j] <= pivot) {
            std.mem.swap(i32, &arr[i], &arr[j]);
            i += 1;
        }
    }

    // पिवट को उसकी सही स्थिति पर रखें
    std.mem.swap(i32, &arr[i], &arr[len - 1]);

    return i;
}

pub fn main() !void {
    var arr = [_]i32{ 3, 6, 8, 10, 1, 2, 1 };

    // क्विकसॉर्ट फ़ंक्शन के लिए ऐरे से एक म्यूटेबल स्लाइस बनाएँ
    var slice: []i32 = &arr;

    std.debug.print("पहले: {any}\n", .{slice});

    quickSort(slice);

    std.debug.print("बाद में: {any}\n", .{slice});
}

```

### परिवर्तनों और Zig अवधारणाओं की व्याख्या:

1.  **`const std = @import("std");`**: यह लाइन Zig स्टैंडर्ड लाइब्रेरी को इम्पोर्ट करती है, जो प्रिंटिंग के लिए `std.debug.print` और एलिमेंट्स को स्वैप करने के लिए `std.mem.swap` जैसे उपयोगी यूटिलिटीज प्रदान करती है।
2.  **`fn quickSort(arr: []i32) void`**:
      * `fn` एक फ़ंक्शन घोषित करता है।
      * `arr: []i32`, `arr` को `i32` (32-बिट इंटीजर्स) की एक स्लाइस के रूप में घोषित करता है। Zig में, `[]T` टाइप `T` की एक म्यूटेबल स्लाइस को दर्शाता है। Rust की तरह अलग से `&mut` नहीं होता; म्यूटेबिलिटी इस बात से निहित होती है कि स्लाइस को होल्ड करने वाला वेरिएबल म्यूटेबल है या नहीं।
      * `void` इंगित करता है कि फ़ंक्शन कोई वैल्यू रिटर्न नहीं करता।
3.  **`if (arr.len <= 1)`**: कंडीशनल स्टेटमेंट्स में कंडीशन के चारों ओर कोष्ठकों का उपयोग होता है।
4.  **`const pivot_index = partition(arr);`**: अपरिवर्तनीय वेरिएबल्स के लिए `const` का उपयोग किया जाता है।
5.  **Zig में स्लाइस स्प्लिटिंग**:
      * `var left_slice = arr[0..pivot_index];`
      * `var right_slice = arr[pivot_index + 1 .. arr.len];`
      * Rust के `split_at_mut` के विपरीत, जो दो म्यूटेबल स्लाइस बनाता है जो ओवरलैप नहीं करती हैं, Zig की स्लाइसिंग `arr[start..end]` ओरिजिनल ऐरे में नई स्लाइस (व्यू) बनाती है।
      * महत्वपूर्ण रूप से, रिकर्सिव कॉल्स में, हमें पिवट को बाएँ और दाएँ दोनों सब-ऐरे से *अवश्य* बाहर रखना चाहिए, क्योंकि `partition` के बाद पिवट पहले ही अपनी अंतिम सॉर्टेड स्थिति में है। Rust कोड में, `right[1..]` यह `right` स्लाइस के पहले एलिमेंट (जो पिवट है) को प्रभावी रूप से स्किप करके हासिल करता है। हम इसे `right_slice` की शुरुआत के लिए `pivot_index + 1` का उपयोग करके दोहराते हैं।
6.  **`std.mem.swap(i32, &arr[i], &arr[j]);`**:
      * एलिमेंट्स को स्वैप करने के लिए `std.mem.swap` का उपयोग किया जाता है।
      * पहला आर्गुमेंट (`i32`) स्वैप किए जा रहे एलिमेंट्स का टाइप है।
      * बाद वाले आर्गुमेंट स्वैप की जाने वाली मेमोरी लोकेशन के पॉइंटर्स हैं (`&arr[i]` और `&arr[j]`)।
7.  **`for (0..(len - 1)) |j| { ... }`**: यह एक `for` लूप है जो `0` से `len - 1` तक (लेकिन इसमें शामिल नहीं) इटरेट करता है। लूप वेरिएबल `j` के रूप में कैप्चर किया जाता है।
8.  **`pub fn main() !void { ... }`**:
      * `pub` `main` फ़ंक्शन को पब्लिकली एक्सेसिबल बनाता है।
      * `!void` इंगित करता है कि फ़ंक्शन एक एरर रिटर्न कर सकता है, लेकिन इस मामले में, हम कोई भी एक्सप्लिसिटली हैंडल नहीं कर रहे हैं। सरल प्रोग्राम्स के लिए, `void` ठीक है, लेकिन Zig में `!void` अक्सर देखा जाता है क्योंकि यह मजबूत एरर हैंडलिंग को प्रोत्साहित करता है।
9.  **`var arr = [_]i32{ 3, 6, 8, 10, 1, 2, 1 };`**:
      * `[_]i32` `i32` की एक फिक्स्ड-साइज ऐरे घोषित करता है। `_` कंपाइलर को इनिशियलाइज़र लिस्ट से साइज का अनुमान लगाने के लिए कहता है।
10. **`var slice: []i32 = &arr;`**: हम फिक्स्ड-साइज ऐरे `arr` से एक म्यूटेबल स्लाइस (`[]i32`) बनाते हैं क्योंकि `quickSort` एक स्लाइस की अपेक्षा करता है।
11. **`std.debug.print("पहले: {any}\n", .{slice});`**:
      * `std.debug.print` डीबगिंग आउटपुट के लिए Zig का `println!` समकक्ष है।
      * `{any}` एक फॉर्मेट स्पेसिफायर है जो Zig को वैल्यू को ह्यूमन-रीडेबल, डीबग-फ्रेंडली फॉर्मेट में प्रिंट करने के लिए कहता है।
      * `.{slice}` एक "स्ट्रक्चर लिटरल" (अनाम स्ट्रक्चर) है जिसका उपयोग फॉर्मेट स्ट्रिंग को आर्गुमेंट्स पास करने के लिए किया जाता है।

इस Zig कोड को कंपाइल और रन करने के लिए:

1.  इसे `quick_sort.zig` के रूप में सेव करें।
2.  अपना टर्मिनल उसी डायरेक्टरी में खोलें।
3.  रन करें: `zig run quick_sort.zig`