---
audio: false
generated: true
image: false
lang: hi
layout: post
model: x-ai/grok-code-fast-1
title: पोर्ट पर प्रक्रिया को समाप्त करें पीएसयूटिल के साथ
translated: true
type: note
---

### विशिष्ट पोर्ट पर प्रक्रिया का पता लगाने और उसे समाप्त करने के लिए psutil का उपयोग करना (Windows)

Psutil एक क्रॉस-प्लेटफॉर्म पायथन लाइब्रेरी है जो चल रही प्रक्रियाओं और सिस्टम उपयोग की जानकारी प्राप्त करने के लिए है। आप इसका उपयोग किसी विशिष्ट पोर्ट पर सुनने वाली प्रक्रियाओं को खोजने के लिए कर सकते हैं (उदाहरण के लिए, यह पहचानना कि क्या उस पोर्ट पर npm डेव सर्वर जैसा कुछ चल रहा है) और फिर उस प्रक्रिया को समाप्त कर सकते हैं। यह Windows पर काम करता है, लेकिन ध्यान रखें:

- **अनुमतियाँ**: Windows पर, प्रक्रियाओं को समाप्त करने के लिए अक्सर प्रशासनिक विशेषाधिकारों की आवश्यकता होती है (अपनी पायथन स्क्रिप्ट को व्यवस्थापक के रूप में चलाएँ)। ऐसा न करने पर `AccessDenied` एक्सेप्शन हो सकता है।
- **पोर्ट डिटेक्शन**: हम TCP कनेक्शन पर ध्यान केंद्रित करेंगे जिनकी किस्म 'inet' है (जो IPv4 और IPv6 दोनों को कवर करती है)। यह वेब सर्वर के लिए आम है, जैसे कि `npm run dev` या इसी तरह के कमांड द्वारा शुरू किए गए सर्वर।
- **धारणाएँ**: हम मान रहे हैं कि आप एक सुनने वाले (सर्वर) पोर्ट की जाँच करना चाहते हैं (उदाहरण के लिए, कुछ जो स्थानीय रूप से बाउंड है)। यदि आपका मतलब किसी पोर्ट से आउटबाउंड कनेक्शन है, तो दृष्टिकोण थोड़ा अलग होगा—स्पष्टीकरण के लिए बताएँ।

#### चरण 1: psutil इंस्टॉल करें
यदि आपने पहले से नहीं किया है:
```bash
pip install psutil
```

#### चरण 2: पता लगाने और समाप्त करने के लिए नमूना कोड
यहाँ एक संपूर्ण पायथन स्क्रिप्ट है। यह एक फ़ंक्शन को परिभाषित करती है जो दिए गए पोर्ट पर सुनने वाली प्रक्रिया का PID ढूँढती है (आपके द्वारा निर्दिष्ट `kind='inet'` का उपयोग करके), फिर उसे समाप्त करती है। Windows पर, `terminate()` को `kill()` से बेहतर माना जाता है क्योंकि यह सुरुचिपूर्ण शटडाउन की अनुमति देता है (यूनिक्स पर SIGTERM के बराबर)।

```python
import psutil
import time  # वैकल्पिक विलंब के लिए

def get_pid_listening_on_port(port, kind='inet'):
    """
    निर्दिष्ट पोर्ट पर सुनने वाली प्रक्रियाओं के लिए नेटवर्क कनेक्शन स्कैन करता है।
    PIDs की एक सूची लौटाता है (आमतौर पर एक, लेकिन दुर्लभ मामलों में कई हो सकते हैं)।
    """
    pids = []
    for conn in psutil.net_connections(kind=kind):
        # जाँच करें कि क्या यह एक सुनने वाला कनेक्शन है (status='LISTEN') और स्थानीय पता पोर्ट मेल खाता है
        if conn.status == 'LISTEN' and conn.laddr and conn.laddr.port == port:
            if conn.pid:
                pids.append(conn.pid)
    return pids

def kill_process_on_port(port, kind='inet'):
    """
    निर्दिष्ट पोर्ट पर सुनने वाली प्रक्रिया को ढूँढता और समाप्त करता है।
    यदि कई प्रक्रियाएँ हैं, तो सभी को समाप्त कर देता है (एक चेतावनी के साथ)।
    """
    pids = get_pid_listening_on_port(port, kind)
    if not pids:
        print(f"पोर्ट {port} पर सुनने वाली कोई प्रक्रिया नहीं मिली।")
        return
    
    for pid in pids:
        try:
            proc = psutil.Process(pid)
            print(f"पोर्ट {port} पर प्रक्रिया {proc.name()} (PID {pid}) को समाप्त किया जा रहा है...")
            # सुरुचिपूर्ण शटडाउन के लिए terminate() का उपयोग करें; यह SIGTERM जैसा सिग्नल भेजता है
            proc.terminate()
            # वैकल्पिक: थोड़ा इंतजार करें और यदि यह बाहर नहीं निकलता है तो जबरदस्ती kill करें
            gone, still_alive = psutil.wait_procs([proc], timeout=3)
            if still_alive:
                print(f"PID {pid} को जबरदस्ती kill किया जा रहा है...")
                still_alive[0].kill()
        except psutil.AccessDenied:
            print(f"एक्सेस अस्वीकृत: PID {pid} को समाप्त नहीं किया जा सकता। क्या व्यवस्थापक के रूप में चलाएँ?")
        except psutil.NoSuchProcess:
            print(f"प्रक्रिया {pid} अब मौजूद नहीं है।")

# उदाहरण उपयोग: 3000 को अपने लक्षित पोर्ट से बदलें (उदाहरण के लिए, npm डेव सर्वर अक्सर 3000 का उपयोग करते हैं)
if __name__ == "__main__":
    kill_process_on_port(3000)  # यदि आवश्यक हो तो kind को एडजस्ट करें (उदाहरण के लिए, केवल IPv4 के लिए 'inet4')
```

#### मुख्य स्पष्टीकरण
- **`psutil.net_connections(kind='inet')`**: यह 'inet' किस्म के नेटवर्क कनेक्शन प्राप्त करता है (जिसमें IPv4 और IPv6 दोनों शामिल हैं)। प्रत्येक कनेक्शन एक namedtuple है जिसमें फ़ील्ड हैं जैसे:
  - `laddr`: स्थानीय पता (उदाहरण के लिए, ('0.0.0.0', 8080) – IP और पोर्ट)।
  - `status`: कनेक्शन की प्रतीक्षा कर रहे सर्वर के लिए 'LISTEN'।
  - `pid`: मालिक की प्रक्रिया ID।
  - हम सर्वर (जैसे npm का डेव पोर्ट) खोजने के लिए `status == 'LISTEN'` के लिए फ़िल्टर करते हैं, क्लाइंट कनेक्शन के लिए नहीं।
- **PID प्राप्ति**: स्क्रिप्ट सीधे कनेक्शन tuple से PID प्राप्त करती है। यदि आप केवल बिना मारे पता लगाना चाहते हैं, तो `get_pid_listening_on_port(port)` का उपयोग करें जो PID(s) लौटाता है।
- **प्रक्रिया को समाप्त करना**:
  - `psutil.Process(pid).terminate()`: एक समाप्ति सिग्नल भेजता है। Windows पर, यह CTRL+C की तरह है।
  - यदि यह बाहर नहीं निकलता है, तो हम वैकल्पिक रूप से `kill()` के साथ जबरदस्ती kill करते हैं (SIGKILL के बराबर)।
  - Psutil का `wait_procs()` प्रक्रिया के समाप्त होने की प्रतीक्षा करता है।
- **inet किस्म की विशिष्टता**: 'inet' में IPv4 और IPv6 दोनों शामिल हैं। यदि आप जानते हैं कि यह IPv4 है, तो इसे `kind='inet4'` में बदलें। यह आपके "inet kind" अनुरोध को सीधे संबोधित करता है।
- **Windows-विशिष्ट नोट्स**:
  - Psutil Windows आंतरिक तंत्र को अच्छी तरह से संभालता है, लेकिन कुछ मामलों में नेटवर्क जानकारी के लिए उन्नत विशेषाधिकारों की आवश्यकता हो सकती है।
  - 1024 से नीचे के पोर्ट (विशेषाधिकार प्राप्त) के लिए, केवल सिस्टम सेवाएँ ही बाइंड कर सकती हैं, लेकिन पता लगाना अभी भी काम करना चाहिए।
- **त्रुटि प्रबंधन**: कोई प्रक्रिया न होने या एक्सेस मुद्दों के लिए बुनियादी जाँच जोड़ी गई है।
- **परीक्षण**: पोर्ट 3000 पर कब्ज़ा करने के लिए `npm run dev` जैसा कुछ चलाएँ, फिर इस स्क्रिप्ट को चलाएँ।

यदि यह आपकी सटीक आवश्यकता से मेल नहीं खाता है (उदाहरण के लिए, यदि "npm run port" का कुछ और मतलब है या आप गैर-सुनने वाले कनेक्शन का पता लगाना चाहते हैं), ति सुधार के लिए अधिक विवरण प्रदान करें! सुरक्षा/सुरक्षा के लिए, सुनिश्चित करें कि आप केवल इच्छित प्रक्रियाओं को मार रहे हैं।