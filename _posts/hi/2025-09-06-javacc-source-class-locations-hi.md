---
audio: false
generated: true
image: false
lang: hi
layout: post
model: x-ai/grok-4-fast:free
title: जावासीसी स्रोत और कक्षा स्थान
translated: true
type: note
---

### JavaCC का अवलोकन
JavaCC (Java Compiler Compiler) एक ऐसा टूल है जो व्याकरण विशिष्टता फ़ाइलों (.jj फ़ाइलों) से Java स्रोत कोड (जैसे, पार्सर क्लासेज) जनरेट करता है। यह **सीधे** कोड को बाइटकोड (.class फ़ाइलों) में कंपाइल नहीं करता—यह काम एक स्टैण्डर्ड Java कंपाइलर जैसे `javac` द्वारा किया जाता है। यदि आप JavaCC का प्रोग्रामेटिक रूप से उपयोग कर रहे हैं (जैसे, किसी IDE या रनटाइम एनवायरनमेंट में) डायनामिक कोड जनरेट और कंपाइल करने के लिए, तो आउटपुट लोकेशन इस बात पर निर्भर करती है कि आपने इसे कैसे कॉन्फ़िगर किया है। मैं इसे स्टेप बाई स्टेप, स्टैण्डर्ड JavaCC व्यवहार और सामान्य उपयोग पैटर्न के आधार पर समझाता हूँ।

### JavaCC स्रोत फ़ाइलें कहाँ जनरेट करता है
- **डिफ़ॉल्ट आउटपुट लोकेशन**: JavaCC जनरेट की गई `.java` फ़ाइलों को **करंट वर्किंग डायरेक्टरी** में आउटपुट करता है (या यदि निर्दिष्ट नहीं की गई है तो "output" नामक एक सबडायरेक्टरी में)। आप इसे कमांड-लाइन ऑप्शन जैसे `-OUTPUT_DIRECTORY=<path>` या प्रोग्रामेटिक रूप से `JavaCCOptions` क्लास के माध्यम से ओवरराइड कर सकते हैं।
- **उदाहरण कमांड-लाइन उपयोग**:
  ```
  javacc -OUTPUT_DIRECTORY=/path/to/generated MyGrammar.jj
  ```
  यह `/path/to/generated` में `.java` फ़ाइलें (जैसे, `Token`, `Parser`, `ParseException`) बनाएगा।
- **प्रोग्रामेटिक उपयोग**: यदि आप JavaCC को अपने Java एप्लिकेशन के भीतर से कॉल कर रहे हैं (जैसे, `org.javacc.JavaCC.main()` या समान APIs का उपयोग करके), तो आप आउटपुट पथ निर्दिष्ट करने के लिए ऑप्शन सेट कर सकते हैं। स्रोत फ़ाइलें सादी `.java` फ़ाइलें होती हैं जिन्हें आगे कंपाइलेशन की आवश्यकता होती है।

यह ऑफिशियल JavaCC डॉक्यूमेंटेशन के अनुरूप है (जैसे, SourceForge पर लेगेसी JavaCC प्रोजेक्ट या Maven-आधारित डिस्ट्रीब्यूशन), जो बताता है कि जनरेट की गई क्लासेज स्रोत कोड के रूप में निर्दिष्ट डायरेक्टरी में आउटपुट होती हैं, बाइटकोड के रूप में नहीं।

### यदि आप जनरेट किए गए कोड को कंपाइल करते हैं तो कंपाइल्ड क्लासेज कहाँ स्टोर होती हैं
JavaCC स्वयं `.class` फ़ाइलों में कंपाइल नहीं करता—आपको इसे मैन्युअली करना होगा या अपने कोड में ऑटोमेट करना होगा। आगे यह होता है:

- **मैन्युअल कंपाइलेशन**: जनरेट की गई `.java` फ़ाइलों पर `javac` का उपयोग करें:
  ```
  javac -d /path/to/classes MyGeneratedParser.java
  ```
  - `-d` फ्लैग `.class` फ़ाइलों के लिए आउटपुट डायरेक्टरी निर्दिष्ट करता है, जो अक्सर एक `classes/` फोल्डर या आपके प्रोजेक्ट का बिल्ड टार्गेट (जैसे, Maven/Gradle में `target/classes/`) होता है।
  - सामान्य लोकेशन: आपके बिल्ड सिस्टम (जैसे, Ant, Maven) के आधार पर `bin/`, `build/classes/`, या `target/classes/`।

- **कोड में डायनामिक कंपाइलेशन**: यदि आप रनटाइम पर JavaCC का उपयोग डायनामिक कोड के लिए पार्सर जनरेट करने के लिए कर रहे हैं (जैसे, स्क्रिप्ट इंटरप्रिटेशन या ऑन-द-फ़्लाई पार्सिंग के लिए), तो आप आमतौर पर यह करेंगे:
  1. `.java` फ़ाइलों को प्रोग्रामेटिक रूप से जनरेट करें (जैसे, एक टेम्प डायरेक्टरी जैसे `System.getProperty("java.io.tmpdir")` में लिखना)।
  2. उन्हें Java Compiler API (javax.tools.JavaCompiler) या Janino जैसी लाइब्रेरी का उपयोग करके कंपाइल करें।
     - उदाहरण: कंपाइलेशन आउटपुट को एक कस्टम डायरेक्टरी, जैसे `new File("generated/classes")` पर सेट करें।
     - कंपाइल की गई `.class` फ़ाइलें उस डायरेक्टरी में स्टोर हो जाती हैं। रनटाइम पर, उन्हें वहाँ से लोड करने के लिए एक कस्टम ClassLoader का उपयोग करें या इन-मेमोरी बफ़र्स का उपयोग करें।
  - **JVM डिफ़ॉल्ट**: कस्टम पथ के बिना, क्लासेज डिफ़ॉल्ट `target/classes` में चली जाती हैं यदि बिल्ड टूल्स का उपयोग कर रहे हैं, या कंपाइलेशन टास्क में आपके द्वारा निर्दिष्ट किसी भी डायरेक्टरी में।

- **सामान्य डायनामिक परिदृश्य**:
  - **इन-मेमोरी कंपाइलेशन**: Compiler API जैसी लाइब्रेरीज़ डिस्क पर लिखे बिना कंपाइल करने की अनुमति देती हैं, बाइटकोड को `ClassLoader.defineClass()` के माध्यम से मेमोरी में स्टोर करती हैं। कोई भौतिक स्टोरेज नहीं होती।
  - **अस्थायी संग्रहण**: यदि जनरेट किए गए कोड को कंपाइल करके स्थायी रूप से रखा जाता है, तो यह अक्सर यूनिक्स-जैसी सिस्टम पर `/tmp/` या अस्थायी फोल्डर्स में चला जाता है। प्रोडक्शन ऐप्स के लिए, अपनी प्रोजेक्ट की फ़ाइल सिस्टम में एक समर्पित `generated/` या `cache/` डायरेक्टरी का उपयोग करें।
  - **फ्रेमवर्क**: ANTLR (JavaCC का विकल्प) या कस्टम रनर जैसे टूल इसे ऑटोमेट कर सकते हैं, क्लासेज को RAM या क्लासपथ फोल्डर (जैसे, `CLASSPATH` एंट्रीज़) में स्टोर करते हैं।

### मुख्य विचार और सर्वोत्तम अभ्यास
- **रनटाइम सुरक्षा**: डायनामिक रूप से कोड कंपाइल करने में जोखिम होते हैं (जैसे, सुरक्षा मुद्दे)। सुनिश्चित करें कि यूजर-जनरेटेड व्याकरण सैंडबॉक्स्ड हों।
- **बिल्ड टूल्स इंटीग्रेशन**: यदि Maven या Gradle का उपयोग कर रहे हैं, तो JavaCC प्लगइन (जैसे, `javacc-maven-plugin`) स्रोतों के लिए `target/generated-sources/javacc/` और कंपाइल्ड क्लासेज के लिए `target/classes/` में आउटपुट करते हैं, जिन्हें आपके `pom.xml` या `build.gradle` में कॉन्फ़िगर किया जा सकता है।
- **डिबगिंग**: यदि कंपाइलेशन फेल हो जाती है, तो JavaCC के एरर आउटपुट या लॉग्स की जाँच करें। जनरेट की गई फ़ाइलें आमतौर पर वहाँ स्टोर होती हैं जहाँ आपका ऐप चलता है, वैश्विक रूप से नहीं।
- **डॉक्स से साक्ष्य**: JavaCC के ऑफिशियल गाइड (javacc.github.io या लेगेसी डॉक्स) के अनुसार, आउटपुट डायरेक्टरी-आधारित होता है और पोस्ट-कंपाइलेशन हैंडलिंग यूजर-मैनेज्ड होती है। GitHub रेपो में रियल-वर्ल्ड उदाहरण (जैसे, JavaCC उपयोग के लिए सर्च करें) कस्टम आउटपुट डिरेक्टरीज जैसे `src/main/generated/` दिखाते हैं।

यदि यह आपके सेटअप से मेल नहीं खाता (जैसे, कोई विशिष्ट फ्रेमवर्क या IDE), तो अधिक विवरण प्रदान करें जैसे आपका कोड स्निपेट या एनवायरनमेंट, और मैं जवाब को परिष्कृत कर सकता हूँ!