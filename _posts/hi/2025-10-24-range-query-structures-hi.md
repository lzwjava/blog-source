---
audio: false
generated: true
image: false
lang: hi
layout: post
model: x-ai/grok-4-fast
title: कुशल रेंज क्वेरी डेटा संरचनाएँ
translated: true
type: note
---

### सेगमेंट ट्री और फेनविक ट्री: अवलोकन

सेगमेंट ट्री और फेनविक ट्री (जिन्हें बाइनरी इंडेक्स्ड ट्री भी कहा जाता है) दोनों ही कुशल डेटा स्ट्रक्चर हैं जिनका उपयोग कॉम्पिटिटिव प्रोग्रामिंग और एल्गोरिदम में ऐरे पर रेंज क्वेरी और अपडेट को हैंडल करने के लिए किया जाता है। ये ऑपरेशन जैसे कि किसी रेंज पर योग क्वेरी या पॉइंट अपडेट को लॉगरिदमिक समय में संभव बनाते हैं, जो बड़े डेटासेट के लिए साधारण O(n) तरीकों की तुलना में कहीं अधिक तेज़ है।

#### सेगमेंट ट्री
एक **सेगमेंट ट्री** एक बाइनरी ट्री-आधारित स्ट्रक्चर है जो किसी ऐरे को सेगमेंट (अंतराल) में विभाजित करके प्रस्तुत करता है। ट्री में प्रत्येक नोड ऐरे की एक सीमा से संबंधित होता है:
- लीफ नोड अलग-अलग एलिमेंट को प्रस्तुत करते हैं।
- पैरेंट नोड अपने चिल्ड्रेन की सीमाओं के मेल को प्रस्तुत करते हैं (जैसे, उप-सीमाओं का योग, न्यूनतम, अधिकतम)।
- ट्री को आमतौर पर पुनरावर्ती रूप से बनाया जाता है, आमतौर पर आकार n की ऐरे के लिए O(log n) ऊंचाई के साथ।

**मुख्य ऑपरेशन:**
- **बिल्ड:** ट्री के निर्माण में O(n) समय।
- **अपडेट:** एक एकल एलिमेंट को संशोधित करना और O(log n) में ट्री में परिवर्तनों को प्रसारित करना।
- **क्वेरी:** O(log n) में प्रासंगिक नोड्स को ट्रैवर्स करके एक रेंज पर एग्रीगेट (जैसे, योग) की गणना करना।

**उपयोग के मामले:** रेंज सुम/मिन/मैक्स क्वेरी, फ्रीक्वेंसी काउंटिंग, या कोई भी साहचर्य संक्रिया। यह अधिक लचीला है लेकिन O(4n) स्पेस का उपयोग करता है।

**सरल उदाहरण (रेंज सुम):**
मान लीजिए एक ऐरे [1, 3, 5, 7] है। सेगमेंट ट्री कुछ इस तरह दिख सकता है:
- रूट: [1-7] का योग = 16
- लेफ्ट चाइल्ड: [1-3] का योग = 4
- राइट चाइल्ड: [5-7] का योग = 12
- और इसी तरह, लीफ्स तक।

#### फेनविक ट्री
एक **फेनविक ट्री** (पीटर फेनविक द्वारा 1994 में प्रस्तुत) प्रीफिक्स सुम और समान ऑपरेशन के लिए एक अधिक कॉम्पैक्ट ऐरे-आधारित स्ट्रक्चर है। यह एलिमेंट्स को कुशलतापूर्वक इंडेक्स करने के लिए बिटवाइज़ ऑपरेशन का उपयोग करता है, संचयी योग को चतुराई से ट्रैक करता है:
- प्रत्येक इंडेक्स उस इंडेक्स पर समाप्त होने वाली एक सीमा के योग को संग्रहीत करता है।
- अपडेट और क्वेरी लो-बिट मैनिपुलेशन (जैसे, `index & -index` से लीस्ट सिग्निफिकेंट बिट ढूंढना) का उपयोग करते हैं।

**मुख्य ऑपरेशन:**
- **बिल्ड:** O(n log n) या ऑप्टिमाइज़्ड करके O(n)।
- **अपडेट:** O(log n) में किसी इंडेक्स पर एक वैल्यू जोड़ना/घटाना।
- **क्वेरी:** O(log n) में किसी इंडेक्स तक प्रीफिक्स सुम प्राप्त करना; प्रीफिक्स अंतर के माध्यम से रेंज सुम।

**उपयोग के मामले:** सेगमेंट ट्री के समान लेकिन 1D प्रीफिक्स सुम, ऑर्डर स्टैटिस्टिक्स, या इनवर्जन काउंट के लिए ऑप्टिमाइज़्ड। यह O(n) स्पेस का उपयोग करता है, जिससे यह हल्का होता है।

**सरल उदाहरण (रेंज सुम):**
ऐरे [1, 3, 5, 7] के लिए, फेनविक ऐरे [1, 4, 5, 16] (संचयी समायोजन) हो सकता है। sum[1-3] क्वेरी करने के लिए: prefix(3) - prefix(0) = 9.

#### तुलना

| पहलू          | सेगमेंट ट्री                  | फेनविक ट्री                  |
|-----------------|-------------------------------|-------------------------------|
| **स्पेस**      | O(4n)                         | O(n)                          |
| **बिल्ड टाइम** | O(n)                          | O(n log n)                    |
| **लचीलापन**| किसी भी रेंज एग्रीगेट को सपोर्ट करता है | प्रीफिक्स सुम/अपडेट के लिए सर्वोत्तम  |
| **जटिलता** | कोड थोड़ा अधिक            | सरल इम्प्लीमेंटेशन        |

दोनों ही एल्गोरिदम के मुख्य आधार हैं (जैसे, LeetCode या Codeforces पर)। यदि आप उन्हें इम्प्लीमेंट कर रहे हैं, तो सरलता के लिए फेनविक से शुरुआत करें!

गहन जानकारी के लिए:  
[Segment Tree Tutorial - GeeksforGeeks](https://www.geeksforgeeks.org/segment-tree-data-structure/)  
[Fenwick Tree Explained - CP-Algorithms](https://cp-algorithms.com/data_structures/fenwick.html)