---
audio: false
generated: true
lang: hi
layout: post
title: जेनकिन्सफ़ाइल लिखना
translated: true
type: note
---

एक साझा लाइब्रेरी, एक स्ट्रिंग पैरामीटर, एक ट्राई-कैच ब्लॉक, एक नोड ब्लॉक और एक आईएफ स्टेटमेंट को शामिल करने वाला Jenkinsfile लिखने के लिए, आप निम्नलिखित दृष्टिकोण का उपयोग कर सकते हैं। Jenkinsfile Groovy में लिखे जाते हैं और बिल्ड, टेस्ट और डिप्लॉयमेंट प्रक्रियाओं को स्वचालित करने के लिए एक पाइपलाइन को परिभाषित कर सकते हैं। नीचे एक स्क्रिप्टेड Jenkinsfile का पूरा उदाहरण दिया गया है जो इन आवश्यकताओं को पूरा करता है।

सबसे पहले, एक साझा लाइब्रेरी का उपयोग करने के लिए, आपको इसे `@Library` एनोटेशन के साथ इम्पोर्ट करना होगा। Jenkins में साझा लाइब्ररियों में पुन: प्रयोज्य कोड होता है जिसे कई पाइपलाइनों से कॉल किया जा सकता है। उदाहरण के लिए, यदि आपकी साझा लाइब्रेरी का नाम `my-shared-library` है, तो आप इसे Jenkinsfile के शीर्ष पर इस तरह शामिल करते हैं:

```groovy
@Library('my-shared-library') _
```

एनोटेशन के बाद अंडरस्कोर (`_`) लाइब्रेरी को सही तरीके से इम्पोर्ट करने के लिए आवश्यक है।

अगला, एक स्ट्रिंग पैरामीटर को परिभाषित करने के लिए, `properties` स्टेप का उपयोग करें। यह उपयोगकर्ताओं को पाइपलाइन चलाते समय एक स्ट्रिंग वैल्यू पास करने की अनुमति देता है। यहाँ बताया गया है कि `MY_STRING` नामक एक स्ट्रिंग पैरामीटर कैसे जोड़ा जाए:

```groovy
properties([
    parameters([
        string(name: 'MY_STRING', defaultValue: 'default', description: 'A string parameter')
    ])
])
```

`node` ब्लॉक निर्दिष्ट करता है कि पाइपलाइन कहाँ निष्पादित होती है, जैसे कि किसी भी उपलब्ध एजेंट पर। इस ब्लॉक के अंदर, आप अपना पाइपलाइन लॉजिक शामिल कर सकते हैं:

```groovy
node {
    // Pipeline steps go here
}
```

संभावित त्रुटियों को हैंडल करने के लिए, अपने स्टेप्स को एक `try-catch` ब्लॉक में लपेटें। यह सुनिश्चित करता है कि यदि कुछ विफल हो जाता है, तो आप एक्सेप्शन को कैच कर सकते हैं और उसे सही तरीके से हैंडल कर सकते हैं। इसके अतिरिक्त, स्ट्रिंग पैरामीटर (`params.MY_STRING`) के वैल्यू के आधार पर निर्णय लेने के लिए एक `if` स्टेटमेंट का उपयोग किया जा सकता है।

यहाँ सभी तत्वों को मिलाने वाला पूरा Jenkinsfile दिया गया है:

```groovy
@Library('my-shared-library') _

properties([
    parameters([
        string(name: 'MY_STRING', defaultValue: 'default', description: 'A string parameter')
    ])
])

node {
    try {
        // Call a function from the shared library (assuming it exists)
        myLibraryFunction()
        
        // Use an if statement based on the string parameter
        if (params.MY_STRING == 'test') {
            echo "Running test"
        } else {
            echo "Not running test"
        }
    } catch (Exception e) {
        echo "An error occurred: ${e.message}"
    }
}
```

### कम्पोनेंट्स की व्याख्या

- **`@Library('my-shared-library') _`**: `my-shared-library` नामक एक साझा लाइब्रेरी को इम्पोर्ट करता है। `my-shared-library` को अपनी लाइब्रेरी के वास्तविक नाम से बदलें। फ़ंक्शन `myLibraryFunction()` इस लाइब्रेरी में परिभाषित होने की उम्मीद है।
- **`properties`**: `'default'` डिफ़ॉल्ट वैल्यू और एक विवरण के साथ एक स्ट्रिंग पैरामीटर `MY_STRING` को परिभाषित करता है। आप इस पैरामीटर को पाइपलाइन में `params.MY_STRING` का उपयोग करके एक्सेस कर सकते हैं।
- **`node`**: पाइपलाइन को किसी भी उपलब्ध एजेंट पर चलाता है। यदि आवश्यक हो तो आप एक विशेष एजेंट (जैसे, `node('linux')`) निर्दिष्ट कर सकते हैं।
- **`try-catch`**: `try` ब्लॉक के अंदर के स्टेप्स को निष्पादित करता है और `catch` ब्लॉक में किसी भी एक्सेप्शन को कैच करता है, यदि कुछ गलत होता है तो एक एरर मैसेज प्रिंट करता है।
- **`if`**: जाँचता है कि क्या `MY_STRING` `'test'` के बराबर है और तदनुसार एक संदेश प्रिंट करता है। आवश्यकतानुसार आप कंडीशन और एक्शन को संशोधित कर सकते हैं।

### नोट्स
- यह उदाहरण एक स्क्रिप्टेड पाइपलाइन मानता है, जो Groovy सिंटैक्स के साथ अधिक लचीलापन प्रदान करती है। यदि आपको इसके बजाय एक डिक्लेरेटिव पाइपलाइन की आवश्यकता है, तो संरचना थोड़ी भिन्न होगी (जैसे, Groovy कोड के लिए `pipeline` और `script` ब्लॉक का उपयोग करना)।
- `myLibraryFunction()` कॉल एक प्लेसहोल्डर है। सुनिश्चित करें कि आपकी साझा लाइब्रेरी इस फ़ंक्शन को परिभाषित करती है, या इसे अपनी लाइब्रेरी के वास्तविक फ़ंक्शन से बदलें।
- आप इस Jenkinsfile को स्टेजेज (जैसे, `stage('Build')`) या अपनी आवश्यकताओं के आधार पर अधिक जटिल लॉजिक जोड़कर विस्तारित कर सकते हैं।

यह Jenkinsfile एक ठोस आधार प्रदान करता है जिसमें आपके द्वारा अनुरोधित सभी तत्व शामिल हैं: एक साझा लाइब्रेरी, एक स्ट्रिंग पैरामीटर, एक ट्राई-कैच ब्लॉक, एक नोड ब्लॉक और एक आईएफ स्टेटमेंट। विवरण (लाइब्रेरी नाम, फ़ंक्शन कॉल, या शर्तें) को अपने उपयोग के मामले में फिट होने के लिए समायोजित करें!