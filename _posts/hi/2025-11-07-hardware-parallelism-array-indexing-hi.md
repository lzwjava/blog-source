---
audio: false
generated: true
image: false
lang: hi
layout: post
model: x-ai/grok-4-fast
title: हार्डवेयर समानांतरता सरणी अनुक्रमण को गति देती है
translated: true
type: note
---

### इंडेक्सिंग बाइनरी सर्च से तेज़ क्यों है?

यिन वांग (王寅) का यह 2013 ब्लॉग पोस्ट उस मूलभूत कारण पर प्रकाश डालता है कि डायरेक्ट ऐरे इंडेक्सिंग (जैसे `arr[i]`) कॉन्स्टेंट टाइम O(1) में क्यों होती है, जबकि एक सॉर्टेड ऐरे पर बाइनरी सर्च O(log n) टाइम लेती है। वह हार्डवेयर स्तर पर एक साधारण सर्किट एनालॉजी का उपयोग करके इसे समझाते हैं, और दिखाते हैं कि इंडेक्सिंग कोई "जादू" नहीं है—यह तो कंप्यूटर की एड्रेसिंग सिस्टम में बेक किया गया एक मासिवेली पैरेलल बाइनरी सर्च है।

#### मुख्य व्याख्या
- **मूल विचार**: ऐरे इंडेक्सिंग एक **एड्रेसिंग सर्किट** का उपयोग करती है ताकि किसी एड्रेस (जैसे एक इंडेक्स) से सीधे मेमोरी लोकेशन को चुना जा सके। 4 मेमोरी लोकेशन (W, X, Y, Z) और एक 2-बिट एड्रेस (बिट्स A और B) के छोटे से उदाहरण के लिए:
  - प्रत्येक एड्रेस बिट बाइनरी सर्च के एक स्टेप की तरह काम करती है, संभावित चयनों को आधा करते हुए।
  - बिट A दो समूहों के बीच निर्णय लेती है: {W, X} या {Y, Z}।
  - बिट B एक और विभाजन के बीच निर्णय लेती है: {W, Y} या {X, Z}।
  - ये बिट्स क्रमिक रूप से नहीं चलतीं—ये **समानांतर रूप से** काम करती हैं, AND गेट्स और वायर्स का उपयोग करके सिग्नल्स को जोड़ती हैं और ठीक एक आउटपुट को सक्रिय करती हैं (उदाहरण के लिए, यदि A=0, B=1 → W चुनें)।

  यह बाइनरी सर्च के 2 स्टेप्स (log₂(4) = 2) की नकल करता है लेकिन एक ही हार्डवेयर "टिक" में पूरा हो जाता है क्योंकि सब कुछ एक साथ होता है।

- **बड़े पैमाने पर**: एक पूर्ण n-बिट एड्रेस (2ⁿ एलिमेंट्स को हैंडल करने वाली) के लिए, सर्किट सभी log₂(n) बाइनरी सर्च स्टेप्स को समानांतर में चलाता है। इसीलिए यह O(1) है: हार्डवेयर सॉफ्टवेयर में लूपिंग या तुलना किए बिना, "सर्च" को तुरंत कर देता है।

- **विजुअल सहायता**: पोस्ट में इनवर्टर्स, वायर्स और AND गेट्स वाले सर्किट का एक डायग्राम शामिल है जो सिग्नल फ्लो दिखाता है। कोई कोड स्निपेट नहीं हैं, लेकिन यह वैचारिक है—इसे एक डिकोडर के रूप में सोचें जो बाइनरी एड्रेस को वन-हॉट सेलेक्शन में बदल देता है।

#### यह महत्वपूर्ण क्यों है
वांग तर्क देते हैं कि यह दर्शाता है कि कैसे लो-लेवल हार्डवेयर ऑप्टिमाइजेशन हाई-लेवल ऑपरेशन्स को सहज महसूस करवाते हैं। बाइनरी सर्च "धीमी" केवल इसलिए है क्योंकि यह इस सर्किट का अनुकरण सॉफ्टवेयर में क्रमिक रूप से करती है; CPU की वास्तविक मेमोरी एक्सेस इसका समानांतर वर्जन है।

यह बिग-O नोटेशन से परे कंप्यूटर साइंस के मूल सिद्धांतों के बारे में जिज्ञासु किसी के लिए भी एक छोटा, गहन पठन है।

[Why is indexing faster than binary search](https://yinwang0.wordpress.com/2013/04/02/indexing/)