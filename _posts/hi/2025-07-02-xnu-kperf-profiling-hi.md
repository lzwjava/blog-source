---
audio: false
generated: true
lang: hi
layout: post
title: एक्सएनयू कर्नल परफॉर्मेंस काउंटर प्रोफाइलिंग
translated: true
type: note
---

आपके द्वारा प्रदान किया गया C कोड macOS और iOS पर **XNU के `kperf` और `kpc` (Kernel Performance Counters) सुविधाओं** के उपयोग का एक प्रदर्शन है, जिसे **निम्न-स्तर पर सिस्टम और एप्लिकेशन प्रदर्शन की प्रोफाइलिंग** के लिए डिज़ाइन किया गया है।

यहाँ कोड का विवरण दिया गया है:

* **परफॉर्मेंस काउंटर एक्सेस:** यह विस्तृत प्रदर्शन मेट्रिक्स (जैसे साइकिल, निर्देश, ब्रांच मिस) को बहुत सूक्ष्म स्तर पर एकत्र करने के लिए कर्नेल के परफॉर्मेंस मॉनिटरिंग यूनिट्स (PMUs) के साथ सीधे इंटरैक्ट करता है। इसका उपयोग आमतौर पर गहन प्रदर्शन विश्लेषण और ऑप्टिमाइज़ेशन के लिए किया जाता है।
* **प्राइवेट फ्रेमवर्क:** यह macOS/iOS के **प्राइवेट फ्रेमवर्क** से फ़ंक्शनों का रिवर्स इंजीनियरिंग और उपयोग करता है:
    * `kperf.framework`: कर्नेल-स्तरीय प्रोफाइलिंग को नियंत्रित करने के लिए इंटरफेस प्रदान करता है, जिसमें सैंपलिंग शुरू/रोकना, टाइमर सेट अप करना और प्रोसेस ID या टास्क द्वारा फ़िल्टर करना शामिल है।
    * `kperfdata.framework`: CPU के PMC (Performance Monitoring Counter) डेटाबेस (`/usr/share/kpep/` में पाए जाने वाले `.plist` फ़ाइलों) तक पहुंचने और उनकी व्याख्या करने के लिए उपयोग किया जाता है। यह डेटाबेस विभिन्न CPU आर्किटेक्चर (Intel, Apple Silicon) पर उपलब्ध विशिष्ट प्रदर्शन इवेंट्स को परिभाषित करता है।
* **Kdebug इंटीग्रेशन:** यह सैंपल किए गए प्रदर्शन डेटा को एकत्र करने के लिए `kdebug` ट्रेसिंग मैकेनिज्म के साथ एकीकृत होता है। `kdebug` एक कर्नेल-स्तरीय लॉगिंग सिस्टम है जो इवेंट्स की उच्च-प्रदर्शन रिकॉर्डिंग की अनुमति देता है।
* **दो प्रदर्शन मोड:**
    * **डेमो 1 (`main` फ़ंक्शन): वर्तमान थ्रेड में एक फ़ंक्शन की प्रोफाइलिंग।** यह मोड वर्तमान प्रोसेस के भीतर निष्पादित एक परिभाषित C फ़ंक्शन (`profile_func`) के लिए विशेष रूप से प्रदर्शन काउंटर्स को मापता है। यह अंतर की गणना करने के लिए काउंटर्स का "पहले" और "बाद" का स्नैपशॉट लेता है।
    * **डेमो 2 (`main2` फ़ंक्शन): एक चयनित प्रोसेस (या सभी थ्रेड्स) की प्रोफाइलिंग।** यह मोड एक निर्दिष्ट `target_pid` (या यदि `target_pid` -1 है तो पूरे सिस्टम) के लिए `total_profile_time` की अवधि में निरंतर प्रदर्शन सैंपलिंग सेट अप करता है। यह लक्ष्य के लिए आवधिक प्रदर्शन काउंटर डेटा एकत्र करने के लिए `kperf` टाइमर और `kdebug` का उपयोग करता है।
* **रूट प्रिविलेज आवश्यक:** कोड स्पष्ट रूप से रूट प्रिविलेज की जाँच करता है क्योंकि कर्नेल प्रदर्शन काउंटर्स और `kperf` के साथ सीधे इंटरैक्शन के लिए उन्नत अनुमतियों की आवश्यकता होती है।
* **CPU आर्किटेक्चर विशिष्टताएँ:** कोड विभिन्न CPU आर्किटेक्चर (Intel, ARM64) और उनके संबंधित PMC डेटाबेस को स्वीकार करता है। यह इन आर्किटेक्चर में उपयुक्त प्रदर्शन इवेंट्स खोजने का प्रयास करता है।

**सार रूप में, यह कोड डेवलपर्स और सिस्टम एडमिनिस्ट्रेटर्स के लिए एक निम्न-स्तरीय टूल प्रदान करता है ताकि वे:**

* **CPU व्यवहार को समझ सकें:** यह जान सकें कि CPU कोड को कैसे निष्पादित कर रहा है, जिसमें निर्देश थ्रूपुट, कैश उपयोग, ब्रांच प्रेडिक्शन सटीकता आदि शामिल हैं।
* **प्रदर्शन बॉटलनेक की पहचान कर सकें:** उन विशिष्ट फ़ंक्शन या कोड सेक्शन की पहचान कर सकें जो सबसे अधिक संसाधनों का उपभोग कर रहे हैं या अक्षम व्यवहार प्रदर्शित कर रहे हैं।
* **ऑप्टिमाइज़ेशन सत्यापित कर सकें:** कोड परिवर्तनों का प्रदर्शन मेट्रिक्स पर प्रभाव माप सकें।
* **प्रदर्शन समस्याओं को डीबग कर सकें:** सिस्टम-व्यापी या प्रोसेस-विशिष्ट प्रदर्शन विशेषताओं का विश्लेषण कर सकें।