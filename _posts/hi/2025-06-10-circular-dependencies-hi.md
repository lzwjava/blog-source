---
audio: false
generated: true
lang: hi
layout: post
title: स्प्रिंग में सर्कुलर डिपेंडेंसी
translated: true
type: note
---

स्प्रिंग या स्प्रिंग बूट में सर्कुलर डिपेंडेंसी तब होती है जब दो या दो से अधिक बीन्स प्रारंभिकरण के दौरान सीधे या अप्रत्यक्ष रूप से एक-दूसरे पर निर्भर होते हैं। इससे एक चक्र बन जाता है जहाँ स्प्रिंग की डिपेंडेंसी इंजेक्शन मैकेनिज्म डिपेंडेंसी को हल नहीं कर पाती क्योंकि प्रत्येक बीन को पूरी तरह से प्रारंभ होने के लिए दूसरे बीन की आवश्यकता होती है। यह समस्या आमतौर पर स्प्रिंग एप्लिकेशन कॉन्टेक्स्ट में बीन निर्माण के दौरान उत्पन्न होती है, जिससे `BeanCurrentlyInCreationException` होता है।

### सर्कुलर डिपेंडेंसी क्यों होती हैं
स्प्रिंग बीन्स को एक डिपेंडेंसी इंजेक्शन कंटेनर में प्रबंधित करता है, और बीन्स आमतौर पर उनकी निर्भरताओं के आधार पर एक विशिष्ट क्रम में बनाई जाती हैं। जब बीन्स चक्रीय तरीके से एक-दूसरे को संदर्भित करती हैं (उदाहरण के लिए, बीन A, बीन B पर निर्भर करती है, और बीन B, बीन A पर निर्भर करती है), तो स्प्रिंग उन्हें इंस्टेंटिएट नहीं कर पाता क्योंकि यह प्रारंभिकरण के दौरान एक अनंत लूप में फंस जाता है। यह जटिल एप्लिकेशन में टाइटली कपल्ड कंपोनेंट्स के साथ विशेष रूप से आम है।

यह समस्या निम्नलिखित परिदृश्यों में होने की अधिक संभावना है:
1. **कंस्ट्रक्टर इंजेक्शन**: जब बीन्स कंस्ट्रक्टर के माध्यम से वायर्ड की जाती हैं, तो स्प्रिंग को इंस्टेंटिएशन समय पर डिपेंडेंसी को हल करना होता है, जो सर्कुलरिटी समस्याओं का कारण बन सकता है यदि बीन्स एक-दूसरे को संदर्भित करती हैं।
2. **फ़ील्ड या सेटर इंजेक्शन ईगर इनिशियलाइज़ेशन के साथ**: यदि बीन्स ईगरली इनिशियलाइज़्ड की जाती हैं (सिंगलटन बीन्स के लिए डिफ़ॉल्ट व्यवहार), तो स्प्रिंग तुरंत डिपेंडेंसी को हल करने का प्रयास करता है, जिससे सर्कुलर डिपेंडेंसी उजागर होती हैं।
3. **गलत कॉन्फ़िगर या अत्यधिक जटिल बीन रिलेशनशिप**: खराब डिज़ाइन या सीपरेशन ऑफ कंसर्न की कमी अनचाहे चक्रों का कारण बन सकती है।
4. **`@Autowired` या `@Component` जैसे एनोटेशन**: टाइटली कपल्ड कंपोनेंट्स में ऑटोमैटिक डिपेंडेंसी इंजेक्शन अनजाने में चक्र बना सकता है।

### सर्कुलर डिपेंडेंसी के सामान्य उदाहरण

#### उदाहरण 1: कंस्ट्रक्टर इंजेक्शन चक्र
```java
@Component
public class BeanA {
    private final BeanB beanB;

    @Autowired
    public BeanA(BeanB beanB) {
        this.beanB = beanB;
    }
}

@Component
public class BeanB {
    private final BeanA beanA;

    @Autowired
    public BeanB(BeanA beanA) {
        this.beanA = beanA;
    }
}
```
**समस्या**: `BeanA` को अपने कंस्ट्रक्टर में `BeanB` की आवश्यकता है, और `BeanB` को अपने कंस्ट्रक्टर में `BeanA` की आवश्यकता है। स्प्रिंग किसी भी बीन को नहीं बना सकता क्योंकि प्रत्येक दूसरे के पूरी तरह से प्रारंभ होने पर निर्भर करता है।

**त्रुटि**: `BeanCurrentlyInCreationException: Error creating bean with name 'beanA': Requested bean is currently in creation: Is there an unresolvable circular reference?`

#### उदाहरण 2: फ़ील्ड इंजेक्शन चक्र
```java
@Component
public class BeanA {
    @Autowired
    private BeanB beanB;
}

@Component
public class BeanB {
    @Autowired
    private BeanA beanA;
}
```
**समस्या**: `BeanA` और `BeanB` दोनों फ़ील्ड के माध्यम से एक-दूसरे को इंजेक्ट करने के लिए `@Autowired` का उपयोग करते हैं। भले ही फ़ील्ड इंजेक्शन कंस्ट्रक्टर इंजेक्शन की तुलना में अधिक लचीला है, स्प्रिंग अभी भी बीन इनिशियलाइज़ेशन के दौरान चक्र का पता लगाता है यदि दोनों सिंगलटन बीन्स (डिफ़ॉल्ट स्कोप) हैं।

#### उदाहरण 3: अप्रत्यक्ष सर्कुलर डिपेंडेंसी
```java
@Component
public class BeanA {
    @Autowired
    private BeanB beanB;
}

@Component
public class BeanB {
    @Autowired
    private BeanC beanC;
}

@Component
public class BeanC {
    @Autowired
    private BeanA beanA;
}
```
**समस्या**: `BeanA`, `BeanB` पर निर्भर करता है, `BeanB`, `BeanC` पर निर्भर करता है, और `BeanC`, `BeanA` पर निर्भर करता है, जिससे एक चक्र बनता है। यह अप्रत्यक्ष निर्भरता देखने में मुश्किल होती है लेकिन फिर भी वही समस्या पैदा करती है।

#### उदाहरण 4: सर्कुलर रेफरेंस वाली `@Configuration` क्लासेस
```java
@Configuration
public class ConfigA {
    @Autowired
    private ConfigB configB;

    @Bean
    public ServiceA serviceA() {
        return new ServiceA(configB);
    }
}

@Configuration
public class ConfigB {
    @Autowired
    private ConfigA configA;

    @Bean
    public ServiceB serviceB() {
        return new ServiceB(configA);
    }
}
```
**समस्या**: `@Configuration` क्लासेस `ConfigA` और `ConfigB` एक-दूसरे पर निर्भर करती हैं, जिससे स्प्रिंग द्वारा इन क्लासेस में परिभाषित बीन्स को प्रारंभ करने का प्रयास करते समय एक चक्र बनता है।

### स्प्रिंग बूट में सामान्य कारण
- **ऑटो-कॉन्फ़िगरेशन**: स्प्रिंग बूट की ऑटो-कॉन्फ़िगरेशन कभी-कभी ऐसी निर्भरताएँ पैदा कर सकती है जो चक्रों का कारण बनती हैं, खासकर जब कस्टम बीन्स ऑटो-कॉन्फ़िगर्ड बीन्स के साथ इंटरैक्ट करती हैं।
- **कंपोनेंट स्कैनिंग**: `@ComponentScan` का अत्यधिक उपयोग या गलत कॉन्फ़िगर पैकेज अनचाही बीन्स को उठा सकते हैं, जिससे चक्रीय निर्भरताएँ बनती हैं।
- **टाइटली कपल्ड डिज़ाइन**: बिजनेस लॉजिक जो सर्विसेज, रिपॉजिटरीज, या कंट्रोलर्स को टाइटली कपल करती है, अनजाने में चक्र बना सकती है।
- **प्रोटोटाइप स्कोप का दुरुपयोग**: हालांकि प्रोटोटाइप-स्कोप्ड बीन्स कभी-कभी सर्कुलर डिपेंडेंसी से बच सकती हैं, लेकिन उन्हें सिंगलटन बीन्स के साथ चक्रीय तरीके से मिलाने पर भी समस्याएँ हो सकती हैं।

### सर्कुलर डिपेंडेंसी कैसे हल करें
1. **`@Lazy` एनोटेशन का उपयोग करें**:
   - निर्भरताओं में से एक को `@Lazy` के साथ एनोटेट करें ताकि इसके प्रारंभिकरण को तब तक विलंबित किया जा सके जब तक कि इसकी वास्तव में आवश्यकता न हो।
   ```java
   @Component
   public class BeanA {
       @Autowired
       @Lazy
       private BeanB beanB;
   }
   ```
   यह `BeanB` के हल होने से पहले `BeanA` को आंशिक रूप से प्रारंभ करने की अनुमति देकर चक्र को तोड़ता है।

2. **सेटर या फ़ील्ड इंजेक्शन पर स्विच करें**:
   - कंस्ट्रक्टर इंजेक्शन के बजाय, बीन्स में से एक के लिए सेटर या फ़ील्ड इंजेक्शन का उपयोग करें ताकि स्प्रिंग को पहले बीन को प्रारंभ करने और बाद में निर्भरताएँ इंजेक्ट करने की अनुमति मिल सके।
   ```java
   @Component
   public class BeanA {
       private BeanB beanB;

       @Autowired
       public void setBeanB(BeanB beanB) {
           this.beanB = beanB;
       }
   }
   ```

3. **चक्र को तोड़ने के लिए कोड को रिफैक्टर करें**:
   - बीन्स को डिकपल करने के लिए एक इंटरफेस या इंटरमीडिएट कंपोनेंट पेश करें।
   - उदाहरण: एक सामान्य निर्भरता को तीसरी बीन में निकालें या इंटरैक्शन को मध्यस्थता करने के लिए एक सर्विस लेयर का उपयोग करें।
   ```java
   public interface Service {
       void performAction();
   }

   @Component
   public class BeanA implements Service {
       @Autowired
       private BeanB beanB;

       public void performAction() {
           // लॉजिक
       }
   }

   @Component
   public class BeanB {
       @Autowired
       private Service service; // सीधे BeanA पर नहीं, इंटरफेस पर निर्भर करता है
   }
   ```

4. **`@DependsOn` एनोटेशन का उपयोग करें**:
   - विशिष्ट मामलों में चक्रों से बचने के लिए बीन प्रारंभिकरण के क्रम को स्पष्ट रूप से नियंत्रित करें।
   ```java
   @Component
   @DependsOn("beanB")
   public class BeanA {
       @Autowired
       private BeanB beanB;
   }
   ```

5. **`@EnableAspectJAutoProxy` के साथ प्रॉक्सीिंग सक्षम करें**:
   - सुनिश्चित करें कि स्प्रिंग निर्भरताओं को संभालने के लिए प्रॉक्सी (CGLIB या JDK डायनामिक प्रॉक्सी) का उपयोग करता है, जो वास्तविक बीन के बजाय एक प्रॉक्सी इंजेक्ट करके कुछ सर्कुलरिटी समस्याओं को हल कर सकता है।

6. **डिज़ाइन का पुनर्मूल्यांकन करें**:
   - सर्कुलर डिपेंडेंसी अक्सर डिज़ाइन दोष का संकेत देती हैं। सिंगल रिस्पॉन्सिबिलिटी प्रिंसिपल या डिपेंडेंसी इनवर्शन प्रिंसिपल का पालन करने के लिए रिफैक्टर करने पर विचार करें।

### सर्कुलर डिपेंडेंसी को कैसे डीबग करें
- **स्टैक ट्रेस जांचें**: `BeanCurrentlyInCreationException` स्टैक ट्रेस चक्र में शामिल बीन्स को इंगित करेगा।
- **डीबग लॉगिंग सक्षम करें**: बीन निर्माण विवरण देखने के लिए `spring.main.lazy-initialization=true` सेट करें या `org.springframework` के लिए डीबग लॉगिंग सक्षम करें।
- **टूल्स का उपयोग करें**: स्प्रिंग बूट एक्ट्यूएटर या आईडीई प्लगइन्स (जैसे, स्प्रिंग टूल्स सूट) जैसे टूल बीन निर्भरताओं को विज़ुअलाइज़ कर सकते हैं।

### सर्कुलर डिपेंडेंसी को रोकना
- **बेस्ट प्रैक्टिसेज का पालन करें**: टाइट कपलिंग को कम करने के लिए इंटरफेस या एब्स्ट्रक्शन जैसे डिपेंडेंसी इंजेक्शन पैटर्न का उपयोग करें।
- **कोड को मॉड्यूलराइज़ करें**: बड़े एप्लिकेशन को छोटे, ढीले युग्मित मॉड्यूल में तोड़ें।
- **जल्दी टेस्ट करें**: विकास के दौरान सर्कुलर डिपेंडेंसी को पकड़ने के लिए इंटीग्रेशन टेस्ट चलाएं।
- **कंपोनेंट स्कैनिंग को सीमित करें**: अनावश्यक बीन्स को उठाने से बचने के लिए `@ComponentScan` के साथ विशिष्ट रहें।

### जब सर्कुलर डिपेंडेंसी की संभावना कम होती है
- **प्रोटोटाइप स्कोप**: प्रोटोटाइप स्कोप वाली बीन्स मांग पर बनाई जाती हैं, जिससे सर्कुलरिटी की संभावना कम हो जाती है (लेकिन पूरी तरह से खत्म नहीं होती)।
- **लेज़ी इनिशियलाइज़ेशन**: ग्लोबल लेज़ी इनिशियलाइज़ेशन (`spring.main.lazy-initialization=true`) को सक्षम करने से बीन निर्माण स्थगित हो सकता है, हालांकि यह केवल समस्या को छिपा सकता है।

### निष्कर्ष
स्प्रिंग/स्प्रिंग बूट में सर्कुलर डिपेंडेंसी बीन्स के बीच टाइट कपलिंग से उत्पन्न होती हैं, जो अक्सर कंस्ट्रक्टर इंजेक्शन या जटिल कॉन्फ़िगरेशन से बढ़ जाती हैं। सामान्य समाधानों में `@Lazy` का उपयोग करना, सेटर/फ़ील्ड इंजेक्शन पर स्विच करना, या चक्र को तोड़ने के लिए रिफैक्टर करना शामिल है। मूल कारण को समझकर और सर्वोत्तम प्रथाओं को लागू करके, आप इन मुद्दों को प्रभावी ढंग से रोक या हल कर सकते हैं। यदि आपको कोई विशिष्ट सर्कुलर डिपेंडेंसी मिलती है, तो प्रासंगिक कोड या त्रुटि विवरण साझा करें, और मैं इसे और अधिक विश्लेषण करने में मदद कर सकता हूँ!