---
audio: false
generated: true
image: false
lang: hi
layout: post
model: x-ai/grok-4-fast
title: कॉन्फ़िग फ़ाइलें खराब भाषाओं में विकसित होती हैं
translated: true
type: note
---

### "लॉजिक इंडिस्ट्रक्टिबिलिटी लॉ" की व्याख्या और क्यों कॉन्फ़िग फाइलें खराब प्रोग्रामिंग भाषाएँ बन जाती हैं

आप जिस पोस्ट का जिक्र कर रहे हैं, वह कंप्यूटर साइंस शोधकर्ता और ब्लॉगर यिनिंग वांग (जिन्हें यिन वांग के नाम से भी जाना जाता है) की है। यह प्रोग्रामिंग दिग्गज गाय स्टील की एक टिप्पणी पर आधारित एक विचारपूर्ण लेख है: **जैसे-जैसे कॉन्फ़िगरेशन फाइलें अधिक जटिल होती जाती हैं, वे अनिवार्य रूप से एक खराब प्रोग्रामिंग भाषा में विकसित हो जाती हैं**। वांग इस बात की व्याख्या करने के लिए "लॉजिक इंडिस्ट्रक्टिबिलिटी लॉ" (तर्क की अविनाशीयता का नियम) नामक एक अवधारणा का उपयोग करते हैं कि यह लगभग हर बार *क्यों* होता है। यह भौतिकी के ऊर्जा संरक्षण के नियम की एक चतुर सादृश्यता है: तर्क गायब नहीं होता; यह बस स्थानांतरित हो जाता है।

#### "लॉजिक इंडिस्ट्रक्टिबिलिटी लॉ" क्या है?
वांग इसे सरलता से परिभाषित करते हैं: **वह तर्क जिसे लोगों को व्यक्त करने की आवश्यकता होती है, हमेशा कहीं न कहीं, मूल रूप से उसी रूप में प्रकट होगा।**

-   संक्षेप में, यदि आपके पास कोई निर्णय लेने या नियम-आधारित सोच (उदाहरण के लिए, "यदि यह शर्त सत्य है, तो वह करें") है, तो वह आपके सिस्टम में *प्रकट होनी ही चाहिए*। यह सिर्फ इसलिए गायब नहीं हो जाएगी क्योंकि आप इसे छिपाने या हटाने की कोशिश करते हैं।
-   यह तर्क आपके मुख्य प्रोग्राम कोड, एक कॉन्फ़िग फाइल, एक स्प्रेडशीट, या यहाँ तक कि एक व्हाइटबोर्ड स्केच में भी समाप्त हो सकती है—लेकिन यह अपने मूल संरचना में अपरिवर्तित बनी रहती है।
-   यह "अविनाशी" है क्योंकि मानवीय आवश्यकताएँ (जैसे व्यवहार को अनुकूलित करना) इसकी माँग करती हैं। इसे नजरअंदाज करने से अजीब समझौते होते हैं।

इसे पानी के अपने स्तर को ढूंढने की तरह समझें: तर्क उस स्थान की ओर बहता है जहाँ इसकी आवश्यकता होती है, चाहे आप इसे रोकने की कितनी भी कोशिश कर लें।

#### यह कैसे बताता है कि कॉन्फ़िग फाइलें "खराब भाषाएँ" क्यों बन जाती हैं?
कॉन्फ़िगरेशन फाइलें सादगी से शुरू होती हैं—मुख्य कोड को छुए बिना सेटिंग्स को समायोजित करने के तरीके के रूप में। लेकिन जैसे-जैसे आवश्यकताएँ बढ़ती हैं, वे कुछ और ही बन जाती हैं। यहाँ चरण-दर-चरण विवरण दिया गया है, जो इस नियम से जुड़ा हुआ है:

1.  **सरल शुरुआत: सिर्फ वेरिएबल्स**
    शुरुआत में, कॉन्फ़िग्स बुनियादी की-वैल्यू जोड़े होते हैं:
    -   `enable_optimization = true`
    -   `max_requests = 1000`
    ये प्रोग्रामिंग में "वेरिएबल्स" (जैसे, `let x = 5;`) की तरह हैं। प्रोग्राम उन्हें पढ़ता है और मानों को अपने तर्क में प्लग कर देता है।
    *क्यों?* अभी तक कोई गहन तर्क नहीं—सिर्फ प्लेसहोल्डर। लेकिन वेरिएबल्स *किसी भी* प्रोग्रामिंग भाषा की मूलभूत इकाई हैं। नियम के अनुसार, यह तर्क (मान निर्दिष्ट करना और उपयोग करना) पहले ही कॉन्फ़िग में घुस चुका है।

2.  **धीरे-धीरे बढ़ना: शाखाएँ जोड़ना**
    जैसे-जैसे उपयोगकर्ता अधिक लचीलेपन की माँग करते हैं (जैसे, "फीचर X को सिर्फ प्रीमियम उपयोगकर्ताओं के लिए सक्षम करें"), डेवलपर्स कॉन्फ़िग में *सशर्त तर्क* एम्बेड करना शुरू कर देते हैं:
    -   कुछ इस तरह: `if user_type == "premium" then enable_feature_X else disable`।
    यह सीधे-सीधे "if-then-else" ब्रांचिंग है—प्रोग्रामिंग का एक और मूलभूत घटक।
    *क्यों?* डेवलपर्स आसान समायोजन के लिए तर्क को मुख्य कोड से कॉन्फ़िग में स्थानांतरित कर देते हैं। लेकिन नियम लागू होता है: तर्क प्रोग्राम से गायब नहीं होता; यह बस स्थानांतरित हो जाता है। अब कॉन्फ़िग सिर्फ डेटा नहीं है—यह निर्णय ले रहा है।

3.  **निर्णायक मोड़: पूर्ण विकसित तर्क अतिभार**
    समय के साथ, कॉन्फ़िग्स में लूप्स, फंक्शन, एरर हैंडलिंग और कस्टम नियम जमा हो जाते हैं। जो एक साधारण फ़्लैट फाइल (YAML, JSON, आदि) के रूप में शुरू हुआ था, वह एक ऐसी सिंटैक्स के साथ समाप्त होता है जो ट्यूरिंग-पूर्ण (किसी भी गणना को व्यक्त करने में सक्षम) है।
    -   परिणाम: एक "भाषा" जो शक्तिशाली तो है लेकिन भयानक है—जिसमें अच्छे टूलिंग, एरर मैसेज, डिबगिंग, या लाइब्रेरीज़ का अभाव है। यह कोड की अधपरी बोली में प्रोग्रामिंग करने जैसा है।
    *क्यों अनिवार्य?* लॉजिक इंडिस्ट्रक्टिबिलिटी। यदि तर्क मौजूद है (और वास्तविक समस्याओं को हल करने के लिए यह होना *ही चाहिए*), तो यह *कहीं न कहीं* प्रकट होगा। इसे मुख्य कोड से बाहर धकेलने से यह कॉन्फ़िग में चला जाता है, जहाँ यह पनपता है।

स्टील की यह बात सटीक बैठती है: कॉन्फ़िग्स भाषाएँ बनना नहीं *चाहते*, लेकिन जटिलता उन्हें ऐसा बनने के लिए मजबूर कर देती है। और वे हमेशा "खराब" होती हैं क्योंकि उन्हें सरलता के लिए डिज़ाइन किया गया है, अभिव्यंजकता के लिए नहीं।

#### डोमेन-स्पेसिफिक लैंग्वेजेज (DSL) से संबंध
वांग इस विचार को आगे बढ़ाने के लिए अपने पहले के निबंध, ["डीएसएल की खामियाँ"](https://yinwang1.substack.com/p/dsl-misconceptions) (विशेष रूप से "डायनामिक लॉजिक लोडिंग" सेक्शन) का हवाला देते हैं। कई DSLs (विशिष्ट कार्यों के लिए कस्टम मिनी-भाषाएँ) इसी इच्छा से उत्पन्न होती हैं: रीकंपाइल किए बिना रनटाइम पर नियम या व्यवहार लोड करना।

-   **गलती:** टीमें सोचती हैं कि उन्हें "डायनामिक लॉजिक" के लिए एक विशेष भाषा की आवश्यकता है, इसलिए वे एक नई भाषा बना लेती हैं—if-then-else को एक भद्दे रैपर में दोबारा बनाते हुए।
-   **समाधान:** इसमें से अधिकांश सरल सशर्तों तक सिमट जाती है। बस किसी मौजूदा भाषा (जैसे, JavaScript के `if` स्टेटमेंट) के स्निपेट को अपनी कॉन्फ़िग में एम्बेड कर दें। पूरी तरह से नई DSL की कोई आवश्यकता नहीं है—यह अति है और उसी "खराब भाषा" के जाल में फंसाती है।
-   *नियम कार्यरत:* तर्क (जैसे, "जाँच करें कि क्या X, फिर Y") को कहीं जाना *ही था*। JS में एक स्निपेट इसे एक *अच्छी* भाषा में रखता है, जिससे कॉन्फ़िग ब्लोट से बचा जा सकता है।

#### यह महत्वपूर्ण क्यों है?
यह सिर्फ सिद्धांत नहीं है—यह सॉफ्टवेयर डिजाइन के लिए एक चेतावनी है। यह बताता है कि Kubernetes YAML या webpack कॉन्फ़िग्स जैसे टूल प्रोग्रामिंग के दुःस्वप्न जैसे क्यों लगते हैं। सबक यह है कि तर्क को उस जगह स्वीकार करें जहाँ वह पनपता है (उचित भाषाओं में), न कि उसे कॉन्फ़िग्स में निर्वासित कर दें। ऐसी प्रणालियाँ डिजाइन करें जो तर्क को *दृश्यमान और प्रबंधनीय* बनाएँ, नहीं तो यह प्रेत के रूप में आपको परेशान करेगा।

यदि आप गहराई से जानना चाहते हैं, तो मूल पोस्ट अधिक बारीकियों के साथ एक त्वरित पठन है।

[मूल पोस्ट: कॉन्फ़िगरेशन फाइल्स और द लॉजिक इंडिस्ट्रक्टिबिलिटी लॉ](https://yinwang1.substack.com/p/224)
[संबंधित: डीएसएल की खामियाँ](https://yinwang1.substack.com/p/dsl-misconceptions)