---
audio: false
generated: true
image: false
lang: hi
layout: post
model: x-ai/grok-4-fast
title: 'माइक्रोसर्विस संचार: तुल्यकालिक बनाम इवेंट-चालित'
translated: true
type: note
---

### माइक्रोसर्विसेज में सिंक्रोनस बनाम इवेंट-ड्रिवन कम्युनिकेशन

माइक्रोसर्विसेज आर्किटेक्चर में, सेवाओं के बीच संचार दो मुख्य तरीकों से हो सकता है: **सिंक्रोनस** (प्रत्यक्ष, सक्रिय कॉल जैसे HTTP/REST APIs) या **असिंक्रोनस/इवेंट-ड्रिवन** (Kafka जैसे टूल्स का उपयोग करके इवेंट्स को प्रकाशित और उपभोग करना)। आपके प्रश्न में एक सामान्य ट्रेड-ऑफ़ को उजागर किया गया है: क्यों न केवल तर्क को एक सेवा ( "कॉलर" ) में केंद्रीकृत कर दिया जाए और इसे सक्रिय रूप से डाउनस्ट्रीम सेवाओं ( "कॉलीज़" ) को इनवोक करने दिया जाए, या यहां तक कि कॉलर को संशोधित करके इसे कई कॉलीज़ को कॉल करने के लिए फैन-आउट करने दिया जाए? इसके बजाय, Kafka जैसी किसी चीज़ का उपयोग इवेंट्स के माध्यम से उन्हें डीकपल क्यों करें?

संक्षिप्त उत्तर: Kafka के साथ इवेंट-ड्रिवन आर्किटेक्चर **लूज़ कपलिंग, स्केलेबिलिटी और रेजिलिएंस** को बढ़ावा देते हैं, जिससे सिस्टम को बनाना, मेंटेन करना और स्केल करना आसान हो जाता है—खासकर जब जटिलता बढ़ती है। सीधे कॉल सरल सेटअप के लिए ठीक काम करते हैं लेकिन डिस्ट्रिब्यूटेड, हाई-वॉल्यूम वातावरण में काम नहीं करते। आइए इसे समझते हैं।

#### केवल एक जगह से सेवाओं को सक्रिय रूप से क्यों न कॉल करें (या कॉलर को संशोधित क्यों न करें)?
यह दृष्टिकोण—एक केंद्रीय "ऑर्केस्ट्रेटर" सेवा (या मूल कॉलर) होना जो सीधे डाउनस्ट्रीम सेवाओं को APIs के माध्यम से इनवोक करती है—पहली बार में सीधा-सादा है। आप जरूरत पड़ने पर कॉलर को "कॉलीज़ जोड़ने" के लिए भी अपडेट कर सकते हैं (उदाहरण के लिए, क्रमिक या समानांतर रूप से कई सेवाओं को फैन-आउट करना)। लेकिन यहां बताया गया है कि यह दृष्टिकोण कम क्यों पड़ता है:

- **टाइट कपलिंग**: कॉलर को हर कॉली के सटीक स्थान (URLs/एंडपॉइंट्स), स्कीमास और उपलब्धता का पता होना चाहिए। यदि कोई डाउनस्ट्रीम सेवा अपना API बदल देती है, डाउन हो जाती है, या उसका नाम बदल दिया जाता है, तो आपको *हर* कॉलर को अपडेट करना होगा। यह निर्भरताओं का एक जाल बना देता है जिसे रिफैक्टर करना मुश्किल होता है।

- **सिंक्रोनस ब्लॉकिंग**: कॉल ब्लॉकिंग होते हैं—आपका कॉलर प्रतिक्रियाओं की प्रतीक्षा करता है। यदि एक कॉली धीमी है या फेल हो जाती है, तो पूरी श्रृंखला रुक जाती है (कैस्केडिंग फेल्योर)। फैन-आउट परिदृश्य में (कॉलर एक साथ कई कॉलीज़ को कॉल कर रहा है), एक सिंगल टाइमआउट सब कुछ देरी कर सकता है।

- **स्केलेबिलिटी की सीमाएं**: हाई ट्रैफिक का मतलब है कि कॉलर एक बॉटलनेक बन जाता है। इसे सभी कोऑर्डिनेशन, रिट्राइज़ और एरर हैंडलिंग को संभालना होता है। अधिक कॉलीज़ जोड़ रहे हैं? आप कॉलर को लॉजिक से भर देते हैं, जो सिंगल-रिस्पॉन्सिबिलिटी सिद्धांतों का उल्लंघन करता है।

- **रिलायबिलिटी समस्याएं**: कोई बिल्ट-इन क्यूइंग या रिट्री मैकेनिज्म नहीं होता। फेल्योर तुरंत प्रसारित होते हैं, और यदि कोई सेवा मिड-कॉल क्रैश हो जाती है तो आप इवेंट्स/डेटा खो देते हैं।

संक्षेप में, यह एक फोन ट्री की तरह है जहां हर कोई सीधे डायल करता है: 3-4 लोगों के लिए कुशल, 100 के लिए अराजक।

#### Kafka के साथ इवेंट-ड्रिवन क्यों? (डाउनस्ट्रीम को इवेंट्स कंज्यूम करने दें)
Kafka एक डिस्ट्रिब्यूटेड इवेंट स्ट्रीमिंग प्लेटफॉर्म है जो इवेंट्स की एक टिकाऊ, क्रमबद्ध लॉग के रूप में कार्य करता है। प्रोड्यूसर्स (अपस्ट्रीम सेवाएं) टॉपिक्स (जैसे, "user-registered") को इवेंट्स प्रकाशित करते हैं, और कंज्यूमर्स (डाउनस्ट्रीम सेवाएं) सब्सक्राइब करती हैं और उन्हें स्वतंत्र रूप से प्रोसेस करती हैं। यह "पुश/पुल कोऑर्डिनेशन" से "पब्लिश/सब्सक्राइब" (पब/सब) में शिफ्ट हो जाता है।

मुख्य लाभ जो इस बदलाव को सार्थक बनाते हैं:

1. **लूज़ कपलिंग और फ्लेक्सिबिलिटी**:
   - सेवाओं को एक-दूसरे के बारे में जानने की आवश्यकता नहीं होती। एक प्रोड्यूसर केवल प्रासंगिक डेटा (जैसे, `{userId: 123, action: "registered"}`) के साथ एक इवेंट प्रकाशित करता है। कोई भी संख्या में कंज्यूमर्स उस टॉपिक की सदस्यता ले सकते हैं बिना प्रोड्यूसर की परवाह किए।
   - एक नई डाउनस्ट्रीम सेवा जोड़ना चाहते हैं (जैसे, ईमेल सूचित करना, एनालिटिक्स अपडेट करना)? बस उसे इवेंट कंज्यूम करने दें—प्रोड्यूसर या मौजूदा कोड में कोई बदलाव नहीं। एक को हटाना है? उसकी सदस्यता रद्द करें। यह विकसित हो रहे सिस्टम के लिए बहुत बड़ी बात है।

2. **असिंक्रोनस और नॉन-ब्लॉकिंग**:
   - प्रोड्यूसर्स फायर-एंड-फॉरगेट करते हैं: इवेंट प्रकाशित करें और तुरंत आगे बढ़ें। डाउनस्ट्रीम प्रोसेसिंग की प्रतीक्षा नहीं।
   - समग्र सिस्टम रिस्पॉन्सिवनेस में सुधार करता है—आपकी यूजर-फेसिंग सेवा लॉगिंग या नोटिफिकेशन जैसे बैकग्राउंड टास्क पर अटकी नहीं रहती।

3. **स्केलेबिलिटी और थ्रूपुट**:
   - Kafka बड़े पैमाने को संभालता है: पार्टीशन्स में लाखों इवेंट्स/सेकंड। एकाधिक कंज्यूमर्स *समान* इवेंट को समानांतर रूप से प्रोसेस कर सकते हैं (जैसे, एक कैशिंग के लिए, एक सर्च इंडेक्सिंग के लिए)।
   - हॉरिजॉन्टल स्केलिंग आसान है—प्रोड्यूसर्स को छुए बिना अधिक कंज्यूमर इंस्टेंस जोड़ें।

4. **रेजिलिएंस और ड्यूरेबिलिटी**:
   - इवेंट्स को Kafka की लॉग में दिनों/हफ्तों के लिए संग्रहीत किया जाता है। यदि कोई कंज्यूमर क्रैश हो जाता है या लैग करता है, तो वह अपने लास्ट ऑफसेट (चेकपॉइंट) से इवेंट्स को रीप्ले करता है।
   - एक्सैक्टली-वन्स सेमेंटिक्स (उचित कॉन्फ़िग के साथ) डुप्लिकेट्स को रोकती हैं। बिल्ट-इन रिट्राइज़, डेड-लेटर कतार, और फॉल्ट टॉलरेंस कॉलर में कस्टम कोड को मात देते हैं।

5. **इवेंट सोर्सिंग और ऑडिटेबिलिटी**:
   - डेटा को इम्यूटेबल इवेंट्स की स्ट्रीम के रूप में मानता है, जो डीबगिंग, कंप्लायंस, या स्टेट को रीबिल्ड करने के लिए रीप्ले को सक्षम बनाता है (जैसे, "किसी बग को ठीक करने के लिए सभी यूजर इवेंट्स को रीप्ले करें")।
   - रियल-टाइम एनालिटिक्स, ML पाइपलाइन्स, या CQRS (कमांड क्वेरी रिस्पॉन्सिबिलिटी सेग्रिगेशन) पैटर्न के लिए बढ़िया।

#### यह दृष्टिकोण कब सबसे अच्छा काम करता है? (ट्रेड-ऑफ़्स)
- **सबसे अच्छा**: हाई-वॉल्यूम, डिस्ट्रिब्यूटेड सिस्टम (जैसे, ई-कॉमर्स ऑर्डर प्रोसेसिंग, IoT डेटा स्ट्रीम्स, यूजर एक्टिविटी फीड्स)। यदि आपके ऐप में 10+ सेवाएं हैं या अप्रत्याशित लोड हैं, तो Kafka "बिग बॉल ऑफ मड" को रोकता है।
- **कमियां**: जटिलता जोड़ता है (Kafka सीखना, टॉपिक्स/पार्टीशन्स का प्रबंधन, इवेंचुअल कंसिस्टेंसी)। इवेंट फ्लो को डीबग करना सीधे कॉल्स की तुलना में पेचीदा हो सकता है। प्रोटोटाइप के लिए सिंक से शुरुआत करें, स्केल करते समय इवेंट्स पर माइग्रेट करें।
- **Kafka के विकल्प**: RabbitMQ (सरल कतारों के लिए), AWS SNS/SQS (मैनेज्ड), या Pulsar (यदि आपको मल्टी-टेनेंसी की आवश्यकता है)। लेकिन Kafka का स्ट्रीमिंग + क्यूइंग का कॉम्बिनेशन इसे एक गो-टो बनाता है।

#### कोड में उदाहरण (स्यूडोकोड)
**सिंक्रोनस कॉलर (भंगुर)**:
```python
def process_user_registration(user_data):
    # कॉलर सीधे कई सेवाओं को कॉल करता है
    email_service.send_welcome(user_data)  # यदि धीमा है तो ब्लॉक करता है
    analytics_service.log_event(user_data)  # फेल? पूरी चीज फेल
    cache_service.invalidate(user_data)     # अधिक जोड़ें? यहां अपडेट करें
```

**Kafka के साथ इवेंट-ड्रिवन (लचीला)**:
```python
# प्रोड्यूसर (अपस्ट्रीम)
from kafka import KafkaProducer
producer = KafkaProducer(bootstrap_servers='localhost:9092')
producer.send('user-events', value={'userId': 123, 'action': 'registered'})

# कंज्यूमर 1 (ईमेल सेवा, स्वतंत्र)
from kafka import KafkaConsumer
consumer = KafkaConsumer('user-events', bootstrap_servers='localhost:9092')
for msg in consumer:
    if msg.value['action'] == 'registered':
        send_welcome(msg.value)  # स्वतंत्र रूप से स्केल/रिट्राई कर सकता है

# कंज्यूमर 2 (एनालिटिक्स, समान टॉपिक की सदस्यता लेता है—प्रोड्यूसर में कोई बदलाव नहीं)
# ... समान, लेकिन DB में लॉग करता है
```

संक्षेप में, कॉलर को संशोधित करके "कॉलीज़ जोड़ना" एक त्वरित समाधान है जो खराब तरीके से स्केल करता है और सब कुछ जोड़ देता है। Kafka के साथ इवेंट-ड्रिवन सेवाओं को स्वतंत्र रूप से विकसित होने देता है, आपके डिस्गाइज में मोनोलिथ को वास्तव में मॉड्यूलर सिस्टम में बदल देता है। यदि आप कुछ विशिष्ट बना रहे हैं, तो टेलर्ड सलाह के लिए अधिक विवरण साझा करें!

**संदर्भ**:
- [Kafka Documentation: Introduction](https://kafka.apache.org/intro)
- [Martin Fowler: Event-Driven Architecture](https://martinfowler.com/articles/201701-event-driven.html)
- [ThoughtWorks: Microservices Patterns (Ch. 11: Event Collaboration)](https://www.oreilly.com/library/view/microservices-patterns/9781492034018/ch11.html)