---
audio: false
generated: true
lang: hi
layout: post
title: जावा मेमोरी मॉडल
translated: true
type: note
---

आइए Java मेमोरी मॉडल (JMM) में गहराई से उतरते हैं! यह एक मौलिक अवधारणा है जो बहु-थ्रेडेड Java प्रोग्राम्स के व्यवहार को समझने के लिए आवश्यक है, खासकर जब साझा डेटा के साथ काम करना हो।

**Java मेमोरी मॉडल (JMM) क्या है?**

Java मेमोरी मॉडल एक अमूर्त विवरण है कि कैसे Java प्रोग्राम में थ्रेड्स मेमोरी के साथ इंटरैक्ट करते हैं। यह उन नियमों को परिभाषित करता है जो यह नियंत्रित करते हैं कि कब और कैसे एक थ्रेड द्वारा साझा वेरिएबल्स में किए गए परिवर्तन अन्य थ्रेड्स के लिए दृश्यमान होते हैं। यह कोई भौतिक मेमोरी आर्किटेक्चर नहीं है, बल्कि नियमों का एक सेट है जिसका JVM को पालन करना होता है ताकि विभिन्न हार्डवेयर प्लेटफॉर्म्स पर समवर्ती प्रोग्राम्स के व्यवहार में स्थिरता और पूर्वानुमेयता सुनिश्चित हो सके।

**Java मेमोरी मॉडल की आवश्यकता क्यों है?**

एक बहु-थ्रेडेड वातावरण में, कई थ्रेड्स साझा वेरिएबल्स को एक्सेस और संशोधित कर सकते हैं। एक सुपरिभाषित मेमोरी मॉडल के बिना, कई समस्याएं उत्पन्न हो सकती हैं:

* **विजिबिलिटी समस्याएं:** एक थ्रेड द्वारा किसी साझा वेरिएबल में किया गया परिवर्तन तुरंत अन्य थ्रेड्स के लिए दृश्यमान नहीं हो सकता है। यह कैशिंग जैसे ऑप्टिमाइजेशन के कारण हो सकता है, जहां प्रत्येक थ्रेड के पास वेरिएबल की अपनी स्थानीय प्रति हो सकती है।
* **ऑर्डरिंग समस्याएं:** सोर्स कोड में ऑपरेशन्स जिस क्रम में दिखाई देते हैं, वह उस क्रम के समान नहीं हो सकता है जिसमें वे वास्तव में प्रोसेसर द्वारा निष्पादित किए जाते हैं। कंपाइलर और प्रोसेसर प्रदर्शन ऑप्टिमाइजेशन के लिए निर्देशों का क्रम बदल सकते हैं। हालांकि सिंगल-थ्रेडेड प्रोग्राम्स में यह आमतौर पर सुरक्षित होता है, लेकिन बहु-थ्रेडेड प्रोग्राम्स में यह अनपेक्षित व्यवहार का कारण बन सकता है यदि सही ढंग से प्रबंधित नहीं किया गया।
* **एटॉमिसिटी समस्याएं:** कुछ ऑपरेशन जो सोर्स कोड में सिंगल ऑपरेशन दिखाई देते हैं, वे प्रोसेसर स्तर पर कई छोटे चरणों में विभाजित हो सकते हैं। एक बहु-थ्रेडेड वातावरण में, ये चरण अन्य थ्रेड्स के ऑपरेशन्स के साथ इंटरलीव हो सकते हैं, जिससे असंगत परिणाम सामने आते हैं।

JMM इन मुद्दों को हल करने के लिए एक रूपरेखा प्रदान करता है और यह सुनिश्चित करता है कि समवर्ती प्रोग्राम अंतर्निहित हार्डवेयर आर्किटेक्चर की परवाह किए बिना सही ढंग से व्यवहार करें।

**JMM की अमूर्त आर्किटेक्चर:**

JMM थ्रेड्स और मुख्य मेमोरी के बीच एक अमूर्त संबंध को परिभाषित करता है:

1.  **मुख्य मेमोरी:** यह वह जगह है जहां सभी साझा वेरिएबल्स रहते हैं। यह सभी डेटा के लिए केंद्रीय भंडारण की तरह है जिसे कई थ्रेड्स द्वारा एक्सेस किया जा सकता है।
2.  **कार्यशील मेमोरी (स्थानीय कैश):** प्रत्येक थ्रेड की अपनी कार्यशील मेमोरी होती है (अवधारणात्मक रूप से CPU कैश के समान)। जब किसी थ्रेड को किसी साझा वेरिएबल को एक्सेस करने की आवश्यकता होती है, तो वह पहले वेरिएबल की एक प्रति मुख्य मेमोरी से अपनी कार्यशील मेमोरी में कॉपी करता है। जब थ्रेड वेरिएबल को संशोधित करता है, तो वह आमतौर पर ऐसा अपनी कार्यशील मेमोरी में करता है, और परिवर्तन अंततः मुख्य मेमोरी में वापस लिख दिया जाता है।

**JMM द्वारा संबोधित प्रमुख चुनौतियाँ:**

* **विजिबिलिटी:** JMM उन नियमों को परिभाषित करता है कि कब और कैसे एक थ्रेड द्वारा अपनी कार्यशील मेमोरी में किसी साझा वेरिएबल में किए गए परिवर्तन अन्य थ्रेड्स के लिए दृश्यमान होते हैं (यानी, मुख्य मेमोरी में वापस लिखे जाते हैं और बाद में अन्य थ्रेड्स द्वारा पढ़े जाते हैं)।
* **ऑर्डरिंग:** JMM यह सुनिश्चित करने के लिए निर्दिष्ट करता है कि कंपाइलर और प्रोसेसर निर्देशों के क्रम को कैसे बदल सकते हैं ताकि यह सुनिश्चित हो सके कि विभिन्न थ्रेड्स में कुछ ऑपरेशन्स के बीच एक सुसंगत "हैपन्स-बिफोर" संबंध बना रहे।

**"हैपन्स-बिफोर" संबंध:**

"हैपन्स-बिफोर" संबंध JMM में सबसे मौलिक अवधारणा है। यह किसी प्रोग्राम में ऑपरेशन्स के आंशिक क्रम को परिभाषित करता है। यदि एक ऑपरेशन किसी दूसरे ऑपरेशन से पहले होता है, तो पहले ऑपरेशन के प्रभाव (जैसे, किसी वेरिएबल में लिखना) दूसरे ऑपरेशन के लिए दृश्यमान होने की गारंटी होती है।

JMM द्वारा परिभाषित कुछ प्रमुख "हैपन्स-बिफोर" नियम यहां दिए गए हैं:

1.  **प्रोग्राम ऑर्डर नियम:** एक ही थ्रेड के भीतर, प्रोग्राम में प्रत्येक एक्शन, प्रोग्राम के क्रम में बाद में आने वाले प्रत्येक एक्शन से पहले होता है।

2.  **मॉनिटर लॉक नियम:** किसी मॉनिटर (जो `synchronized` ब्लॉक या मेथड से जुड़ा लॉक है) पर एक अनलॉक ऑपरेशन, उसी मॉनिटर पर प्रत्येक बाद के लॉक ऑपरेशन से पहले होता है। यह सुनिश्चित करता है कि जब कोई थ्रेड लॉक रिलीज करता है, तो उसके द्वारा सिंक्रोनाइज्ड ब्लॉक के भीतर किए गए कोई भी परिवर्तन अगले थ्रेड के लिए दृश्यमान होते हैं जो उसी लॉक को प्राप्त करता है।

3.  **वोलेटाइल वेरिएबल नियम:** किसी `volatile` वेरिएबल पर राइट ऑपरेशन, उसी वेरिएबल के प्रत्येक बाद के रीड ऑपरेशन से पहले होता है। यह गारंटी देता है कि जब कोई थ्रेड किसी `volatile` वेरिएबल में लिखता है, तो वैल्यू तुरंत मुख्य मेमोरी में लिख दी जाती है, और उस वेरिएबल को पढ़ने वाला कोई भी अन्य थ्रेड नवीनतम वैल्यू प्राप्त करेगा।

4.  **थ्रेड स्टार्ट नियम:** किसी Thread ऑब्जेक्ट की start() मेथड, नए शुरू किए गए थ्रेड में किसी भी एक्शन से पहले होती है।

5.  **थ्रेड टर्मिनेशन नियम:** किसी थ्रेड में सभी एक्शन, जिसमें साझा वेरिएबल्स में लिखना भी शामिल है, उस थ्रेड की join() मेथड से सफल रिटर्न से पहले होते हैं या इससे पहले कि कोई अन्य थ्रेड यह पता लगा ले कि थ्रेड समाप्त हो गया है (जैसे, `isAlive()` चेक करके)।

6.  **ट्रांजिटिविटी:** यदि ऑपरेशन A, ऑपरेशन B से पहले होता है, और ऑपरेशन B, ऑपरेशन C से पहले होता है, तो ऑपरेशन A, ऑपरेशन C से पहले होता है।

7.  **ऑब्जेक्ट क्रिएशन नियम:** किसी ऑब्जेक्ट के कंस्ट्रक्टर का पूरा होना, उस ऑब्जेक्ट का उपयोग करने वाले किसी अन्य ऑपरेशन की शुरुआत से पहले होता है।

**प्रमुख भाषा निर्माण और JMM:**

* **`volatile` कीवर्ड:** किसी वेरिएबल को `volatile` घोषित करने का JMM से संबंधित दो मुख्य प्रभाव होता है:
    * **विजिबिलिटी:** गारंटी देता है कि इस वेरिएबल में सभी लेखन तुरंत मुख्य मेमोरी में वापस लिखे जाएंगे, और सभी रीड नवीनतम वैल्यू मुख्य मेमोरी से प्राप्त करेंगे। यह थ्रेड्स को पुरानी कैश्ड वैल्यू का उपयोग करने से रोकता है।
    * **निर्देश पुन: क्रमबद्धता पर रोक (एक निश्चित सीमा तक):** निर्देशों के उन प्रकारों के पुन: क्रमबद्धता को रोकता है जो बहु-थ्रेडेड प्रोग्राम्स में गलत व्यवहार का कारण बन सकते हैं। विशेष रूप से, किसी `volatile` वेरिएबल में लिखने के *पहले* के ऑपरेशन्स को लिखने के *बाद* पुन: क्रमबद्ध नहीं किया जा सकता है, और किसी `volatile` वेरिएबल से पढ़ने के *बाद* के ऑपरेशन्स को पढ़ने से *पहले* पुन: क्रमबद्ध नहीं किया जा सकता है।

* **`synchronized` कीवर्ड:** जब कोई थ्रेड किसी `synchronized` ब्लॉक या मेथड में प्रवेश करता है, तो वह संबंधित मॉनिटर पर एक लॉक प्राप्त करता है। JMM यह सुनिश्चित करता है:
    * **पारस्परिक अपवर्जन (एटॉमिसिटी):** किसी भी समय एक ही थ्रेड किसी विशेष मॉनिटर के लिए लॉक रख सकता है, यह सुनिश्चित करते हुए कि सिंक्रोनाइज्ड ब्लॉक के भीतर का कोड उसी मॉनिटर पर सिंक्रोनाइज करने वाले अन्य थ्रेड्स के संबंध में परमाणु रूप से निष्पादित होता है।
    * **विजिबिलिटी:** जब कोई थ्रेड लॉक रिलीज करता है (`synchronized` ब्लॉक या मेथड से बाहर निकलकर), तो वह प्रभावी रूप से उस ब्लॉक के भीतर साझा वेरिएबल्स में किए गए किसी भी परिवर्तन को मुख्य मेमोरी में वापस फ्लश कर देता है। जब कोई अन्य थ्रेड उसी लॉक को प्राप्त करता है, तो वह साझा वेरिएबल्स को मुख्य मेमोरी से दोबारा पढ़ेगा, यह सुनिश्चित करते हुए कि उसे नवीनतम अपडेट दिखाई देते हैं।

* **`final` फील्ड्स:** JMM `final` फील्ड्स की विजिबिलिटी के बारे में गारंटी प्रदान करता है। एक बार किसी ऑब्जेक्ट के कंस्ट्रक्टर में `final` फील्ड को ठीक से इनिशियलाइज़ कर दिए जाने के बाद, इसकी वैल्यू स्पष्ट सिंक्रोनाइजेशन की आवश्यकता के बिना अन्य सभी थ्रेड्स के लिए दृश्यमान होगी। ऐसा इसलिए है क्योंकि कंस्ट्रक्टर में `final` फील्ड में लिखना, किसी अन्य थ्रेड द्वारा ऑब्जेक्ट को एक्सेस करने से *पहले* होता है।

**समवर्ती प्रोग्रामिंग के लिए निहितार्थ:**

Java में सही और कुशल समवर्ती प्रोग्राम लिखने के लिए JMM को समझना महत्वपूर्ण है। JMM द्वारा परिभाषित नियमों का पालन करके और उचित सिंक्रोनाइजेशन तंत्र (`volatile`, `synchronized`, `java.util.concurrent` पैकेज से लॉक्स) का उपयोग करके, डेवलपर्स यह सुनिश्चित कर सकते हैं कि साझा डेटा को कई थ्रेड्स द्वारा सुरक्षित रूप से एक्सेस और संशोधित किया जाता है।

**सामान्य खतरे और JMM कैसे मदद करता है:**

* **रेस कंडीशन:** तब होती हैं जब किसी प्रोग्राम का परिणाम इस अप्रत्याशित क्रम पर निर्भर करता है जिसमें कई थ्रेड्स साझा संसाधनों तक पहुंचते हैं। JMM, उचित सिंक्रोनाइजेशन के साथ, यह सुनिश्चित करके रेस कंडीशन को रोकने में मदद करता है कि साझा वेरिएबल्स तक पहुंच ठीक से समन्वित हो।
* **डेटा रेस:** तब होती हैं जब कई थ्रेड्स बिना किसी सिंक्रोनाइजेशन के समान साझा वेरिएबल तक समवर्ती रूप से पहुंचते हैं, और कम से कम एक एक्सेस राइट होता है। JMM परिभाषित करता है कि यदि किसी प्रोग्राम में डेटा रेस है, तो व्यवहार अपरिभाषित है। `volatile` या `synchronized` का उपयोग करने से डेटा रेस को रोकने में मदद मिलती है।
* **आउट-ऑफ-ऑर्डर एक्जिक्यूशन समस्याएं:** JMM की गारंटी के बिना, कंपाइलर या प्रोसेसर ऑपरेशन्स के क्रम को ऐसे तरीके से बदल सकता है जो बहु-थ्रेडेड प्रोग्राम के इच्छित तर्क को तोड़ देता है। JMM पुन: क्रमबद्धता पर प्रतिबंध लगाता है, खासकर `volatile` वेरिएबल्स और सिंक्रोनाइज्ड ब्लॉक्स के आसपास, ऐसी समस्याओं को रोकने के लिए।

**संक्षेप में:**

Java मेमोरी मॉडल नियमों का एक सेट है जो यह नियंत्रित करता है कि Java में थ्रेड्स मेमोरी के साथ कैसे इंटरैक्ट करते हैं। यह बहु-थ्रेडेड प्रोग्राम्स में विजिबिलिटी, ऑर्डरिंग और एटॉमिसिटी से संबंधित चुनौतियों का समाधान करता है। मुख्य अवधारणाओं में मुख्य मेमोरी, कार्यशील मेमोरी और "हैपन्स-बिफोर" संबंध शामिल हैं। `volatile` और `synchronized` जैसे भाषा निर्माण, JMM के विनिर्देशों का पालन करके समवर्ती Java एप्लिकेशन्स में सही और पूर्वानुमेय व्यवहार सुनिश्चित करने के लिए तंत्र प्रदान करते हैं। मजबूत और कुशल बहु-थ्रेडेड Java कोड लिखने के लिए JMM को समझना आवश्यक है।