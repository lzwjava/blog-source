---
audio: false
date: 2025-09-07
generated: true
image: false
lang: hi
layout: post
title: जैकोको एक्जीक्यूशन डेटा फ़ाइलों को समझना
translated: true
type: note
---

यहाँ एक व्यावहारिक, सब-कुछ-शामिल सारांश दिया गया है।

# `jacoco-it.exec` क्या है?

* यह **JaCoCo execution data file** है जो **integration tests** के दौरान बनती है।
* "`-it`" सिर्फ एक **परंपरा** है (`jacoco-maven-plugin` के *report-integration* लक्ष्य और Failsafe चरण से)। यूनिट टेस्ट अक्सर `jacoco.exec` में डेटा डंप करती हैं, जबकि इंटीग्रेशन टेस्ट `jacoco-it.exec` में डंप करती हैं।
* आपके पास कई `.exec` फाइलें (प्रति मॉड्यूल, प्रति चरण, प्रति रन) हो सकती हैं और बाद में उन्हें **मर्ज** करके एक ही कवरेज रिपोर्ट बना सकते हैं।

सामान्य Maven सेटअप:

```xml
<plugin>
  <groupId>org.jacoco</groupId>
  <artifactId>jacoco-maven-plugin</artifactId>
  <version>0.8.12</version>
  <executions>
    <!-- यूनिट टेस्ट के लिए -->
    <execution>
      <id>prepare-agent</id>
      <goals><goal>prepare-agent</goal></goals>
    </execution>
    <!-- इंटीग्रेशन टेस्ट के लिए -->
    <execution>
      <id>prepare-agent-integration</id>
      <goals><goal>prepare-agent-integration</goal></goals>
    </execution>
    <execution>
      <id>report</id>
      <phase>verify</phase>
      <goals><goal>report</goal></goals>
    </execution>
    <execution>
      <id>report-it</id>
      <phase>verify</phase>
      <goals><goal>report-integration</goal></goals>
    </execution>
  </executions>
</plugin>
```

यह आमतौर पर `target/jacoco.exec` (यूनिट) और `target/jacoco-it.exec` (इंटीग्रेशन) लिखती है।

# `.exec` फाइल के अंदर क्या होता है?

* **सिर्फ प्रोब हिट्स**, क्लास के आधार पर कुंजीबद्ध।
* स्पष्ट रूप से: प्रत्येक लोड की गई क्लास के लिए, JaCoCo एक **ID** (बाइटकोड के आधार पर) की गणना करता है और **प्रोब्स का एक बूलियन ऐरे** (कौन से निर्देश/ब्रांच एक्ज़िक्यूट हुए) स्टोर करता है।
* यह एक **सत्र आईडी** और टाइमस्टैम्प्स भी स्टोर करता है।
* **इसमें क्लास बाइटकोड, मेथड नाम, लाइन नंबर, या सोर्स *नहीं* होता है**। वह संरचनात्मक जानकारी बाद में आपकी **क्लास फाइलों** और **सोर्सेज** से आती है जब आप HTML/XML रेंडर करने के लिए `jacoco:report` चलाते हैं।

निहितार्थ:

* यदि आपकी क्लासेज `.exec` बनने के बाद बदल जाती हैं, तो फाइल अब मेल नहीं खा सकती (आईडी मेल नहीं खाएंगी)। रिपोर्ट हमेशा **उसी एक्ज़ैक्ट बिल्ड** की क्लास फाइलों के खिलाफ जनरेट करें जिसने exec बनाई थी।

# क्या इसमें क्लास संरचना की जानकारी होती है?

* **नहीं।** कोई मेथड्स नहीं, कोई लाइन नंबर नहीं, कोई सोर्स नहीं।
* यह प्रति क्लास एक कॉम्पैक्ट, बाइनरी **हिट-मैप** है। रिपोर्टिंग चरण आपकी **कंपाइल्ड क्लासेज** (और वैकल्पिक रूप से सोर्सेज) को पढ़ती है ताकि उन हिट्स को पैकेजेज, क्लासेज, मेथड्स, लाइन्स और ब्रांचेज से मैप किया जा सके।

# क्या यह `-javaagent` के माध्यम से अटैच करने पर अपडेट होगी?

संक्षिप्त उत्तर: **हाँ**, विवरण के साथ:

* जब आप एजेंट के साथ अपनी JVM शुरू करते हैं, तो यह क्लासेज को **ऑन-द-फ्लाई** इंस्ट्रूमेंट करता है और प्रोब हिट्स **मेमोरी में** रिकॉर्ड करता है।
* एजेंट `destfile` में **लिखता है**:

  * **JVM एक्ज़िट पर** (`output=file`, डिफ़ॉल्ट के लिए), या
  * जब आप स्पष्ट रूप से **डंप** करते हैं (TCP/JMX/API के माध्यम से), या
  * जब `append=true` सेट होता है, तो यह मौजूदा फाइल को **ऐपेंड/मर्ज** करेगा, उसे ओवरराइट करने के बजाय।

सामान्य एजेंट विकल्प:

```bash
-javaagent:/path/to/org.jacoco.agent.jar=\
destfile=/path/to/jacoco-it.exec,\
append=true,\
output=file
```

अन्य उपयोगी मोड:

* `output=tcpserver` (एक पोर्ट पर सुनता है; आप कनेक्ट कर सकते हैं और एक डंप ट्रिगर कर सकते हैं)
* `output=tcpclient` (एक सर्वर पर पुश करता है)
* `jmx=true` (डंप/रीसेट करने के लिए एक JMX MBean एक्सपोज़ करता है)
* प्रोग्रामेटिक: `org.jacoco.agent.rt.RT.getAgent().dump(/*reset*/ true|false)`

"अपडेटेड" पर नोट्स:

* `output=file` **और** `append=true` के साथ, **प्रत्येक डंप** प्रोब ऐरे को मौजूदा फाइल में मर्ज करता है (हिट्स का लॉजिकल OR)।
* `append=true` के बिना, अगली बार लिखने पर डंप/एग्ज़िट पर फाइल **ओवरराइट** हो जाती है।
* यदि आपके पास **एकाधिक JVM** (माइक्रोसर्विसेज, फोर्क्ड टेस्ट्स) हैं, तो प्रत्येक को **अलग-अलग फाइलों** की ओर इशारा करें, या कलेक्ट करने और फिर मर्ज करने के लिए TCP/JMX का उपयोग करें।

# सामान्य वर्कफ़्लो

**इंटीग्रेशन टेस्ट चरण (Failsafe):**

* Maven एजेंट को इंटीग्रेशन-टेस्ट JVM(s) से `destfile=target/jacoco-it.exec` के साथ अटैच करता है।
* अंत में, `jacoco:report-integration` चलाता है जो पढ़ता है:

  * `target/jacoco-it.exec` (हिट्स)
  * `target/classes` (संरचना)
  * `src/main/java` (सोर्स लाइन्स के लिए वैकल्पिक)
* आउटपुट: *सिर्फ इंटीग्रेशन टेस्ट्स* के लिए HTML/XML/CSV कवरेज।

**एकाधिक रन मर्ज करना:**

```bash
# Maven के माध्यम से
mvn jacoco:merge -Djacoco.destFile=target/merged.exec \
  -Djacoco.dataFileList="target/jacoco.exec,target/jacoco-it.exec,other.exec"
# फिर
mvn jacoco:report -Djacoco.dataFile=target/merged.exec
```

# व्यावहारिक समस्याएं और सुझाव

* **बिल्ड्स मैच कराएं**: रिपोर्ट्स उन्हीं **कंपाइल्ड क्लासेज** के खिलाफ जनरेट करें जिन्होंने `.exec` बनाई थी।
* **समानांतर फोर्क्स**: जब समानांतर या एकाधिक JVM में टेस्ट चला रहे हों, तो एक ही फाइल के लिए कई राइटर्स से बचें, जब तक कि `append=true` न हो और आप समवर्ती ऐपेंड के साथ सहज हों (अधिक सुरक्षित तरीका है प्रति JVM एक फाइल और फिर मर्ज करना)।
* **लंबे समय तक चलने वाली सेवाएं**: **TCP/JMX** सक्षम करें या रनटाइम API को कॉल करके **समय-समय पर डंप** करें; प्रोसेस एक्ज़िट का इंतज़ार न करें।
* **क्लासलोडर आइसोलेशन**: कुछ ऐप सर्वर एक ही क्लास को दो बार लोड करते हैं; JaCoCo क्लास आईडी के आधार पर डी-डुप्लिकेट करता है, लेकिन जटिल कंटेनरों में सावधान रहें।
* **ऑफ़लाइन इंस्ट्रुमेंटेशन** मौजूद है, लेकिन **javaagent** दृष्टिकोण आमतौर पर सरल और अधिक मजबूत होता है।

---

## आपके सवालों के सीधे जवाब

* **"`jacoco-it.exec` क्या है?"**
  **इंटीग्रेशन टेस्ट्स** के दौरान कैप्चर की गई execution data फाइल (प्रोब हिट्स)। यह सिर्फ एक नामकरण परंपरा है; कार्यात्मक रूप से यह `jacoco.exec` के समान ही फॉर्मेट है।

* **"क्या इसमें क्लास संरचना की जानकारी होती है?"**
  **नहीं।** यह सिर्फ प्रति-क्लास **प्रोब हिट ऐरे** और सत्र मेटाडेटा स्टोर करती है। क्लास/मेथड/लाइन की जानकारी रिपोर्टिंग चरण के दौरान आपकी कंपाइल्ड क्लासेज/सोर्सेज से आती है।

* **"क्या यह `-javaagent` के माध्यम से अटैच करने पर अपडेट होगी?"**
  **हाँ।** `output=file` के साथ, एजेंट **JVM एक्ज़िट** पर या **डिमांड** (TCP/JMX/API) पर लिखता है। `append=true` के साथ, यह किसी भी मौजूदा फाइल के साथ **मर्ज** हो जाती है; इसके बिना, यह **ओवरराइट** कर देती है। मल्टी-जेवीएम रन के लिए, अलग-अलग फाइलों या रिमोट डंप का उपयोग करें और बाद में **मर्ज** करें।