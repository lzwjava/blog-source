---
audio: false
generated: true
lang: hi
layout: post
title: सैक्स (सिंपल एपीआई फॉर एक्सएमएल) का उपयोग
translated: true
type: note
---

XML दस्तावेज़ों को पार्स करने के लिए Java में `org.xml.sax` पैकेज का उपयोग करने के लिए, आप SAX (Simple API for XML) पार्सिंग दृष्टिकोण का उपयोग करके एक सीधी प्रक्रिया का पालन कर सकते हैं। SAX एक इवेंट-ड्रिवेन पार्सर है जो एक XML दस्तावेज़ को क्रमिक रूप से पढ़ता है और कॉलबैक विधियों को ट्रिगर करता है जब यह दस्तावेज़ के विभिन्न हिस्सों जैसे एलिमेंट या टेक्स्ट कंटेंट का सामना करता है। यह इसे मेमोरी-एफिशिएंट बनाता है, खासकर बड़ी XML फाइलों के लिए, क्योंकि यह DOM की तरह पूरे दस्तावेज़ को मेमोरी में लोड नहीं करता है। `org.xml.sax` का उपयोग करने के लिए नीचे एक चरण-दर-चरण मार्गदर्शिका दी गई है।

---

### चरण 1: SAX पार्सर सेट करें
SAX के साथ XML पार्स करना शुरू करने के लिए, आपको `SAXParserFactory` क्लास का उपयोग करके एक `SAXParser` इंस्टेंस बनाने की आवश्यकता है। यह फैक्ट्री आपको पार्सर बनाने से पहले उसके व्यवहार को कॉन्फ़िगर करने की अनुमति देती है।

यहाँ बताया गया है कि `SAXParser` कैसे बनाया जाए:

```java
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;

public class SAXExample {
    public static void main(String[] args) {
        try {
            // एक SAXParserFactory इंस्टेंस बनाएँ
            SAXParserFactory factory = SAXParserFactory.newInstance();

            // वैकल्पिक: फैक्टरी को कॉन्फ़िगर करें (उदाहरण के लिए, नेमस्पेस अवेयरनेस सक्षम करें)
            factory.setNamespaceAware(true); // true पर सेट करें यदि आपकी XML नेमस्पेस का उपयोग करती है

            // एक SAXParser बनाएँ
            SAXParser parser = factory.newSAXParser();

            // अगले चरण यहाँ जाएंगे
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

- **`SAXParserFactory.newInstance()`**: एक नया फैक्टरी इंस्टेंस बनाता है।
- **`factory.setNamespaceAware(true)`**: वैकल्पिक। नेमस्पेस प्रोसेसिंग सक्षम करता है यदि आपकी XML नेमस्पेस का उपयोग करती है। डिफ़ॉल्ट रूप से, यह `false` होता है।
- **`factory.newSAXParser()`**: एक `SAXParser` बनाता है। यह `ParserConfigurationException` या `SAXException` थ्रो कर सकता है यदि पार्सर को कॉन्फ़िगर या इनिशियलाइज़ नहीं किया जा सकता है।

---

### चरण 2: XML इवेंट्स के लिए एक हैंडलर बनाएँ
SAX पार्सिंग XML इवेंट्स को प्रोसेस करने के लिए एक हैंडलर पर निर्भर करता है जिनका यह सामना करता है, जैसे किसी एलिमेंट की शुरुआत, किसी एलिमेंट का अंत, या टेक्स्ट कंटेंट। इसके लिए प्राथमिक इंटरफेस `ContentHandler` है, लेकिन सरलता के लिए, आप `DefaultHandler` क्लास को एक्सटेंड कर सकते हैं, जो `ContentHandler` और अन्य हैंडलर इंटरफेस (`ErrorHandler`, `DTDHandler`, आदि) के खाली इम्प्लीमेंटेशन प्रदान करती है। आपको केवल उन्हीं मेथड्स को ओवरराइड करने की आवश्यकता है जिनकी आपको आवश्यकता है।

यहाँ एक कस्टम हैंडलर का उदाहरण दिया गया है:

```java
import org.xml.sax.Attributes;
import org.xml.sax.helpers.DefaultHandler;

public class MyHandler extends DefaultHandler {
    // टेक्स्ट कंटेंट को जमा करने के लिए वेरिएबल
    private StringBuilder content = new StringBuilder();

    @Override
    public void startElement(String uri, String localName, String qName, Attributes attributes) {
        // नए एलिमेंट के लिए कंटेंट बफ़र साफ़ करें
        content.setLength(0);
        System.out.println("Start element: " + qName);

        // यदि एलिमेंट में एट्रिब्यूट्स हैं, तो उन्हें प्रोसेस करें
        for (int i = 0; i < attributes.getLength(); i++) {
            System.out.println("Attribute: " + attributes.getQName(i) + " = " + attributes.getValue(i));
        }
    }

    @Override
    public void characters(char[] ch, int start, int length) {
        // टेक्स्ट कंटेंट को जमा करें (एलिमेंट के लिए कई बार कॉल किया जा सकता है)
        content.append(ch, start, length);
    }

    @Override
    public void endElement(String uri, String localName, String qName) {
        // जमा किए गए टेक्स्ट कंटेंट को प्रोसेस करें
        String text = content.toString().trim();
        if (!text.isEmpty()) {
            System.out.println("Content: " + text);
        }
        System.out.println("End element: " + qName);
        content.setLength(0); // अगले एलिमेंट के लिए रीसेट करें
    }

    @Override
    public void startDocument() {
        System.out.println("Document parsing started");
    }

    @Override
    public void endDocument() {
        System.out.println("Document parsing completed");
    }
}
```

- **`startElement`**: कॉल की जाती है जब पार्सर किसी एलिमेंट की शुरुआत का सामना करता है। पैरामीटर्स शामिल हैं:
  - `uri`: नेमस्पेस URI (यदि नेमस्पेस-अवेयर है)।
  - `localName`: एलिमेंट का लोकल नाम (बिना प्रीफिक्स के, यदि नेमस्पेस-अवेयर है)।
  - `qName`: क्वालिफाइड नाम (यदि कोई हो तो प्रीफिक्स शामिल है)।
  - `attributes`: एलिमेंट की एट्रिब्यूट्स की सूची।
- **`characters`**: किसी एलिमेंट के भीतर टेक्स्ट कंटेंट के लिए कॉल की जाती है। ध्यान दें कि यह एक एलिमेंट के कंटेंट के लिए कई बार कॉल की जा सकती है, इसलिए इसे जमा करने के लिए `StringBuilder` का उपयोग करें।
- **`endElement`**: कॉल की जाती है जब कोई एलिमेंट समाप्त होता है।
- **`startDocument` और `endDocument`**: XML दस्तावेज़ की शुरुआत और अंत में कॉल की जाती हैं।

---

### चरण 3: XML को पार्स करें
पार्सर और हैंडलर तैयार होने के साथ, आप `SAXParser` पर `parse` मेथड को कॉल करके और अपना हैंडलर पास करके एक XML स्रोत (जैसे फ़ाइल, `InputStream`, या स्ट्रिंग) पार्स कर सकते हैं।

यहाँ बताया गया है कि XML फ़ाइल को कैसे पार्स किया जाए:

```java
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import java.io.File;

public class SAXExample {
    public static void main(String[] args) {
        try {
            // पार्सर बनाएँ
            SAXParserFactory factory = SAXParserFactory.newInstance();
            SAXParser parser = factory.newSAXParser();

            // हैंडलर बनाएँ
            MyHandler handler = new MyHandler();

            // एक XML फ़ाइल पार्स करें
            File xmlFile = new File("example.xml");
            parser.parse(xmlFile, handler);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

- **`parser.parse`**: एक XML स्रोत (जैसे `File`) और एक `DefaultHandler` लेता है। यह `IOException` (इनपुट एरर के लिए) या `SAXException` (पार्सिंग एरर के लिए) थ्रो कर सकता है।

फ़ाइल के बजाय XML स्ट्रिंग के लिए, `InputSource` का उपयोग करें:

```java
import org.xml.sax.InputSource;
import java.io.StringReader;

// मेन मेथड के अंदर
String xml = "<book><title>XML Parsing</title></book>";
InputSource inputSource = new InputSource(new StringReader(xml));
parser.parse(inputSource, handler);
```

---

### चरण 4: एक्सेप्शन्स को हैंडल करें
SAX पार्सिंग में कई एक्सेप्शन्स शामिल हैं जिन्हें आपको हैंडल करना चाहिए:

- **`ParserConfigurationException`**: `newSAXParser()` द्वारा थ्रो की जाती है यदि पार्सर को कॉन्फ़िगर नहीं किया जा सकता है।
- **`SAXException`**: `newSAXParser()` या `parse()` द्वारा सामान्य पार्सिंग एरर के लिए थ्रो की जाती है।
- **`IOException`**: `parse()` द्वारा थ्रो की जाती है यदि इनपुट स्रोत को पढ़ने में कोई समस्या है।

अपने कोड को `try-catch` ब्लॉक में रैप करें:

```java
try {
    SAXParserFactory factory = SAXParserFactory.newInstance();
    SAXParser parser = factory.newSAXParser();
    MyHandler handler = new MyHandler();
    parser.parse(new File("example.xml"), handler);
} catch (ParserConfigurationException e) {
    System.err.println("Parser configuration error: " + e.getMessage());
} catch (SAXException e) {
    System.err.println("SAX error: " + e.getMessage());
} catch (IOException e) {
    System.err.println("IO error: " + e.getMessage());
}
```

---

### चरण 5: वैकल्पिक फीचर्स
#### एरर हैंडलिंग
`DefaultHandler` `ErrorHandler` को भी इम्प्लीमेंट करता है। पार्सिंग एरर को हैंडल करने के लिए इसकी मेथड्स को ओवरराइड करें:

```java
public class MyHandler extends DefaultHandler {
    @Override
    public void error(SAXParseException e) {
        System.err.println("Parsing error: " + e.getMessage());
    }

    @Override
    public void fatalError(SAXParseException e) throws SAXException {
        System.err.println("Fatal error: " + e.getMessage());
        throw e; // पार्सिंग रोकें
    }

    @Override
    public void warning(SAXParseException e) {
        System.out.println("Warning: " + e.getMessage());
    }
    // अन्य मेथड्स ऊपर के अनुसार
}
```

#### नेमस्पेस हैंडलिंग
यदि आपकी XML नेमस्पेस का उपयोग करती है, तो `factory.setNamespaceAware(true)` सेट करें और एलिमेंट्स को सही ढंग से पहचानने के लिए `qName` के बजाय अपनी हैंडलर मेथड्स में `uri` और `localName` का उपयोग करें।

#### वैलिडेशन
XML को DTD या स्कीमा के विरुद्ध वैलिडेट करने के लिए, `factory.setValidating(true)` सेट करें। वैलिडेशन एरर को मैनेज करने के लिए आपको `ErrorHandler` की भी आवश्यकता हो सकती है।

---

### उदाहरण XML और आउटपुट
एक XML फ़ाइल `example.xml` के लिए:
```xml
<book id="123">
    <title>XML Parsing</title>
    <author>John Doe</author>
</book>
```

उपरोक्त कोड चलाने पर आउटपुट हो सकता है:
```
Document parsing started
Start element: book
Attribute: id = 123
Start element: title
Content: XML Parsing
End element: title
Start element: author
Content: John Doe
End element: author
End element: book
Document parsing completed
```

---

### सारांश
`org.xml.sax` का उपयोग करने के लिए:
1. `SAXParserFactory` का उपयोग करके एक `SAXParser` बनाएँ।
2. `DefaultHandler` को एक्सटेंड करके और `startElement`, `endElement`, और `characters` जैसी मेथड्स को ओवरराइड करके एक हैंडलर इम्प्लीमेंट करें।
3. अपने हैंडलर और XML स्रोत के साथ `parser.parse()` को कॉल करके XML पार्स करें।
4. एक्सेप्शन्स को हैंडल करें (`SAXException`, `IOException`, `ParserConfigurationException`)।
5. वैकल्पिक रूप से नेमस्पेस अवेयरनेस, वैलिडेशन, या एरर हैंडलिंग को कॉन्फ़िगर करें।

यह दृष्टिकोण बड़े XML दस्तावेज़ों को कुशलतापूर्वक पार्स करने के लिए आदर्श है जब आपको इन-मेमोरी ट्री बनाए बिना केवल विशिष्ट डेटा निकालने की आवश्यकता होती है।