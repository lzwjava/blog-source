---
audio: false
generated: true
image: false
lang: hi
layout: post
model: x-ai/grok-4-fast
title: NumPy रैखिक बीजगणित पॉकेट गाइड
translated: true
type: note
---

आपके इंजीनियरिंग-केंद्रित ट्यूटर के रूप में, यह गाइड पिछले इंडेक्स-स्पष्ट सूत्रीकरणों पर व्यावहारिक NumPy डेमो को `import numpy as np` और `np.linalg` के माध्यम से एकीकृत करके बनती है। सभी गणित इंडेक्स (जैसे, \\( A = [a_{ij}]_{i=1}^2, j=1^2 \\)) के साथ सत्यापन योग्य बनी हुई है; कोड स्पष्टता के लिए स्पष्ट arrays का उपयोग करता है। आउटपुट सत्यापित एक्जिक्यूशन (उदाहरण के लिए, \\( A = \begin{pmatrix} a_{11}=1 & a_{12}=2 \\ a_{21}=3 & a_{22}=4 \end{pmatrix} \\), \\( B = \begin{pmatrix} 5 & 6 \\ 7 & 8 \end{pmatrix} \\)) के हैं। परीक्षा की तैयारी में त्वरित गणना के लिए इनका उपयोग करें—फॉर्मूलों के विरुद्ध आउटपुट की व्याख्या पर ध्यान केंद्रित करें।

## 1. मैट्रिक्स ऑपरेशन्स
गणित पहले जैसा: \\( (AB)_{ij} = \sum_{k=1}^2 a_{ik} b_{kj} \\), आदि।

**NumPy डेमो**:
```python
import numpy as np
A = np.array([[1, 2], [3, 4]], dtype=float)
B = np.array([[5, 6], [7, 8]], dtype=float)
```
- जोड़: `A + B` देता है \\( \begin{pmatrix} 6 & 8 \\ 10 & 12 \end{pmatrix} \\) (एंट्री-वाइज \\( a_{ij} + b_{ij} \\))।
- स्केलर: `2 * A` देता है \\( \begin{pmatrix} 2 & 4 \\ 6 & 8 \end{pmatrix} \\) (\\( c a_{ij} \\))।
- गुणन: `A @ B` (या `np.dot(A, B)`) देता है \\( \begin{pmatrix} 19 & 22 \\ 43 & 50 \end{pmatrix} \\) (सत्यापन: row1-col1 योग \\( 1\cdot5 + 2\cdot7 = 19 \\))। गैर-कम्यूटेटिविटी नोट करें: `np.allclose(A @ B, B @ A)` है `False`।
- ट्रांसपोज़: `A.T` देता है \\( \begin{pmatrix} 1 & 3 \\ 2 & 4 \end{pmatrix} \\) (\\( (A^T)_{ij} = a_{ji} \\))।
- इनवर्स: `np.linalg.inv(A)` देता है \\( \begin{pmatrix} -2 & 1 \\ 1.5 & -0.5 \end{pmatrix} \\) (सत्यापन: `A @ inv_A` ≈ \\( I = \begin{pmatrix} 1 & 0 \\ 0 & 1 \end{pmatrix} \\), छोटे फ्लोट एरर ~1e-16 के साथ)।

## 2. डिटरमिनेंट्स
गणित: \\( \det A = \sum_{j=1}^2 a_{1j} C_{1j} \\), \\( C_{1j} = (-1)^{1+j} \det(M_{1j}) \\) (उदाहरण के लिए, \\( M_{11} = [4] \\), इसलिए \\( C_{11} = 4 \\); पूर्ण \\( \det A = 1\cdot4 - 2\cdot3 = -2 \\))।

**NumPy डेमो** (ऊपर जारी):
- `np.linalg.det(A)`: -2.0 (फॉर्मूला मेल खाता है; फ्लोट प्रिसिजन -2.0000000000000004)।
- प्रोडक्ट: `np.linalg.det(A @ B)` = 4.0; `det_A * np.linalg.det(B)` ≈ 4.0 (\\( \det(AB) = \det A \cdot \det B \\) सत्यापित करता है)।
- ट्रांसपोज़: `np.linalg.det(A.T)` = -2.0 (\\( \det(A^T) = \det A \\) सत्यापित करता है)।

एडजुगेट/इनवर्स लिंक के लिए: इनवर्स डिनॉम में डिट का उपयोग करता है, जैसा कि फॉर्मूला \\( A^{-1} = \frac{1}{\det A} \adj A \\) में है।

## 3. लीनियर सिस्टम्स और गॉसियन एलिमिनेशन
गणित: ऑगमेंटेड \\( [A | b] \\) with \\( b = [b_i]_{i=1}^2 = [5, 11]^T \\); REF के बाद बैक-सबस्टीट्यूशन द्वारा हल करें।

**NumPy डेमो**:
- `np.linalg.solve(A, b)` देता है [1. 2.] (सटीक: \\( x_1 = \frac{\det A_1}{\det A} \\), जहां \\( A_1 \\) col1 को b से बदलता है, det= -2 समान; क्रैमर का नियम सत्यापित करता है)।
- जांच: `A @ x` = [5. 11.] (रेजिडुअल 0)।
- रैंक: `np.linalg.matrix_rank(A)` = 2 (पूर्ण; सिंगुलर के लिए, रैंक < 2 अनंत/कोई समाधान नहीं दर्शाता है)।

NumPy का `solve` आंतरिक रूप से LU-like फैक्टराइजेशन करता है (स्पष्ट गॉसियन कोड की आवश्यकता नहीं; कस्टम के लिए, `scipy.linalg.lu` का उपयोग करें लेकिन यहां np.linalg पर टिके रहें)।

## 4. वेक्टर स्पेसेस
गणित: रैंक A = # पिवट्स = dim Col(A); नलिटी = 2 - रैंक A।

**NumPy डेमो**:
- रैंक ऊपर जैसा: 2।
- एसवीडी के माध्यम से नलिटी अनुमान: `U, S, Vt = np.linalg.svd(A)`; सिंगुलर वैल्यू > 1e-10 की गिनती: 2, इसलिए नलिटी = 2 - 2 = 0 (Nul(A) = {0})। आधार के लिए, छोटे S वाले Vt पंक्तियों से नलस्पेस वेक्टर।

## 5. लीनियर ट्रांसफॉर्मेशन्स
गणित: T(x)_i = \\( \sum_j a_{ij} x_j \\); मैट्रिक्स प्रतिनिधित्व A है।

**NumPy टाई-इन**: मैट्रिक्स ऑपरेशन्स के समान; उदाहरण के लिए, `T_x = A @ x` ट्रांसफॉर्मेशन लागू करता है (वेक्टराइज्ड)।

## 6. आइगेनवैल्यूज़
गणित: det(A - λ I) = 0 हल करें, (A - λ I)_{ij} = a_{ij} - λ δ_{ij}; फिर (A - λ I) v = 0 v_j के लिए।

**NumPy डेमो**:
- `eigvals, eigvecs = np.linalg.eig(A)`: eigvals ≈ [-0.372, 5.372] (λ² - tr(A)λ + det A = λ² - 5λ -2 =0 के मूल)।
- Eigvecs कॉलम: उदाहरण के लिए, col0 ≈ [-0.825, 0.566]^T λ≈-0.372 के लिए।
- जांच: `A @ eigvecs[:,0]` ≈ λ eigvecs[:,0] (स्केल्ड सत्यापन: `A @ eigvecs[:,0] / eigvals[0]` eigvecs[:,0] से मेल खाता है)।

डायगनलाइजेबल के लिए: पूर्ण रैंक eigvecs (det ≠0)।

## 7. इनर प्रोडक्ट्स और ऑर्थोगोनलाइजेशन
गणित: <u,v> = \\( \sum_i u_i v_i \\); proj = (<v,w>/<w,w>) w (w_i पर स्केलर गुणन)।

**NumPy डेमो** (u=[1,2], v=[3,4]):
- `np.dot(u, v)` = 11 (या `u @ v`)।
- `np.linalg.norm(u)` ≈ 2.236 (√<u,u>)।

ग्राम-श्मिट: मैट्रिक्स V (कॉलम को आधार वेक्टर के रूप में) के लिए `np.linalg.qr(V)` का उपयोग करें; Q = ऑर्थोनॉर्मल।
- उदाहरण V = \\( \begin{pmatrix} 3 & 0 & 0 \\ 1 & 2 & 0 \\ 0 & 0 & 3 \end{pmatrix} \\) (cols v^{(1)}=[3,1,0]^T, आदि)।
- `ortho = np.linalg.qr(V)[0]` देता है ≈ \\( \begin{pmatrix} -0.949 & -0.316 & 0 \\ -0.316 & 0.949 & 0 \\ 0 & 0 & 1 \end{pmatrix} \\) (साइन फ्लिप ठीक)।
- जांच: `np.allclose(ortho.T @ ortho, np.eye(3))` = True (δ_{ij})।

क्वाड्रैटिक फॉर्म: `u @ A @ u` = 27.0 (x^T A x with x_i = u_i; पॉजिटिव डेफिनिट के लिए, सभी आइगेनवैल्यू >0—यहां मिश्रित चिह्न)।

**त्वरित सत्यापन टिप**: फ्लोट्स के लिए हमेशा `np.allclose` का उपयोग करें; छोटे n के लिए मैन्युअल रूप से row-reduce करें, फिर `solve` या `eig` से मिलान करें। अभ्यास: अपनी 3×3 मैट्रिक्स को स्वैप करें।

[NumPy linalg डॉक्यूमेंटेशन](https://numpy.org/doc/stable/reference/routines.linalg.html)  
[NumPy में लीनियर अलजेब्रा - SciPy लेक्चर नोट्स](https://scipy-lectures.org/intro/numpy/auto_examples/plot_linear_algebra.html)