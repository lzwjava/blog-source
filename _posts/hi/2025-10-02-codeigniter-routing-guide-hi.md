---
audio: false
generated: true
image: false
lang: hi
layout: post
model: x-ai/grok-code-fast-1
title: कोडइग्नाइटर रूटिंग गाइड
translated: true
type: note
---

### CodeIgniter रूटिंग का अवलोकन

CodeIgniter की रूटिंग प्रणाली आपको URL (URI) को विशिष्ट नियंत्रक कक्षाओं और विधियों से मैप करने की अनुमति देती है, जो `example.com/controller/method/id/` के डिफ़ॉल्ट URL पैटर्न को ओवरराइड करती है। यह SEO-अनुकूल URL बनाने, RESTful API को हैंडल करने, या केवल यह अनुकूलित करने के लिए उपयोगी है कि अनुरोधों को कैसे संसाधित किया जाता है।

प्रदान किया गया कोड स्निपेट CodeIgniter की `routes.php` कॉन्फ़िगरेशन फ़ाइल से है। यह एक साहचर्य सरणी `$route` को परिभाषित करता है जहां प्रत्येक कुंजी एक URI पैटर्न है, और मान या तो एक स्ट्रिंग (`controller/method`) है या एक सरणी है जो HTTP विधि (जैसे, GET, POST) द्वारा अलग-अलग व्यवहार निर्दिष्ट करती है। यह सेटअप मानक रूटिंग और विधि-विशिष्ट रूटिंग दोनों का समर्थन करता है।

मैं **रूट कैसे परिभाषित किए जाते हैं**, **वे कैसे काम करते हैं**, और **उनका उपयोग कैसे करें** को तोड़कर समझाऊंगा, CodeIgniter के मानक व्यवहार और आपके कोड में उदाहरण के आधार पर। पूर्ण विवरण के लिए, आधिकारिक CodeIgniter उपयोगकर्ता गाइड में रूटिंग पर जाएं: https://codeigniter.com/userguide4/general/routing.html।

#### 1. **रूट कैसे परिभाषित करें**
रूट `application/config/routes.php` में एक सरणी के रूप में परिभाषित किए जाते हैं। आप `$route[]` में प्रविष्टियाँ जोड़ते हैं। यहाँ सिंटैक्स है:

- **बेसिक रूट**: किसी भी HTTP विधि को एक नियंत्रक/विधि से मैप करता है।
  ```
  $route['uri_segment'] = 'controller/method';
  ```
  - उदाहरण: `$route['login'] = 'users/login';` का मतलब है कि `/login` का कोई भी अनुरोध `Users::login()` पर रूट होता है।

- **विधि-विशिष्ट रूट**: RESTful API के लिए, आप HTTP विधि (GET, POST, PUT, आदि) के अनुसार अलग-अलग नियंत्रक/विधियाँ निर्दिष्ट कर सकते हैं। यह एक सरणी का उपयोग करता है।
  ```
  $route['uri_segment'] = array(
      'METHOD1' => 'controller/method1',
      'METHOD2' => 'controller/method2'
  );
  ```
  - आपके कोड से उदाहरण: `$route['self'] = array('POST' => 'users/update', 'GET' => 'users/self');` का मतलब है:
    - POST `/self` → `Users::update()`.
    - GET `/self` → `Users::self()`.

- **वाइल्डकार्ड प्लेसहोल्डर**: URL के गतिशील भागों को कैप्चर करने के लिए regex जैसे पैटर्न का उपयोग करें (विधि को पैरामीटर के रूप में पास किया गया)।
  - `(:any)`: कोई भी वर्ण मिलाता है (स्लैश को छोड़कर) – जैसे, स्लग या स्ट्रिंग।
  - `(:num)` या `(\d+)`: केवल अंक मिलाता है – ID के लिए।
  - कस्टम regex: विशिष्ट मिलान के लिए कोष्ठक में लपेटें, जैसे, `(foo|bar)`।
  - आपके कोड से उदाहरण:
    - `$route['users/(\d+)']['GET'] = 'users/one/$1';`: GET `/users/123`, `Users::one(123)` पर रूट होता है।
    - `$route['lives/(\d+)/notify'] = 'lives/notifyLiveStart/$1';`: किसी भी विधि से `/lives/123/notify`, `Lives::notifyLiveStart(123)` पर रूट होता है।

- **आरक्षित रूट**:
  - `$route['default_controller'] = 'welcome';`: वह नियंत्रक जो लोड होता है यदि कोई URI नहीं दिया गया है (जैसे, रूट URL → `Welcome` नियंत्रक)।
  - `$route['404_override'] = 'errors/page_missing';`: बिना मिलान वाले रूट के लिए नियंत्रक/विधि (कस्टम 404)।
  - `$route['translate_uri_dashes'] = FALSE;`: यदि TRUE, तो नियंत्रक/विधि नामों के लिए URI में डैश को अंडरस्कोर में बदल देता है (जैसे, `my-controller` → `my_controller`)।

- **क्रम मायने रखता है**: रूट जिस क्रम में दिखाई देते हैं, उसी क्रम में मिलान किए जाते हैं। टकराव से बचने के लिए सामान्य वाले से पहले विशिष्ट रूट (वाइल्डकार्ड के साथ) परिभाषित करें।
- **HTTP विधियाँ**: यदि निर्दिष्ट नहीं है, तो एक रूट सभी विधियों पर लागू होता है। आपका कोड विशिष्टता के लिए सरणियों का उपयोग करता है, जो API के लिए बहुत अच्छा है।

**आपके कोड में रूट परिभाषित करने के लिए सुझाव**:
- नए रूट अंत में, `$route['translate_uri_dashes']` से पहले जोड़ें।
- API रूट के लिए Postman जैसे टूल के साथ परीक्षण करें ताकि यह सुनिश्चित हो सके कि सही नियंत्रक/विधि हिट हो रही है।
- जटिल ऐप्स के लिए, रूट को अनुभाग द्वारा समूहित करें (जैसा कि आपने `// users` जैसी टिप्पणियों के साथ किया है)।

#### 2. **रूट कैसे काम करते हैं**
CodeIgniter का राउटर प्रत्येक आने वाले अनुरोध को इस क्रम में संसाधित करता है:
1. **URI पार्स करें**: URL को सेगमेंट में तोड़ता है (जैसे, `/users/123/edit` → सेगमेंट: `users`, `123`, `edit`)।
2. **रूट के विरुद्ध मिलान करें**: `$route` सरणी को ऊपर से नीचे तक जांचता है। यह पहले सटीक मिलान की तलाश करता है, फिर वाइल्डकार्ड वाले पैटर्न की।
   - यदि कोई मिलान मिलता है, तो यह निर्दिष्ट नियंत्रक/विधि से मैप होता है, गतिशील भागों (जैसे, `123`) को विधि तर्क के रूप में पास करता है।
   - यदि कोई मिलान नहीं है, तो यह डिफ़ॉल्ट पैटर्न (`Controller::method/id/`) पर फॉलबैक होता है।
3. **नियंत्रक और विधि लोड करें**: CodeIgniter नियंत्रक को इंस्टेंटिएट करता है, विधि को कॉल करता है, और किसी भी URI सेगमेंट या कैप्चर किए गए समूहों को पास करता है।
4. **विधि-विशिष्ट हैंडलिंग**: यदि रूट एक सरणी है (जैसे आपके कोड में), तो यह अनुरोध से HTTP विधि (GET, POST, आदि) की जांच करता है।
5. **फॉलबैक**: बिना मिलान वाले अनुरोध 404 ट्रिगर करते हैं, या `$route['404_override']` यदि सेट है।

**उदाहरण प्रवाह**:
- अनुरोध: `POST https://example.com/lives`
- मिलान: `$route['lives']['POST'] = 'lives/create';`
- परिणाम: `Lives::create()` को बिना तर्क के कॉल करता है।
- यदि अनुरोध `GET https://example.com/lives/456` था, तो यह `$route['lives/(\d+)']['GET'] = 'lives/one/$1';` से मेल खाएगा → `Lives::one(456)`।

**मुख्य यांत्रिकी**:
- **गतिशील पैरामीटर**: कैप्चर किए गए समूह (जैसे, `$1`) तर्क के रूप में विधि को पास किए जाते हैं। सुनिश्चित करें कि आपकी नियंत्रक विधि उनकी अपेक्षा करती है।
- **सुरक्षा**: रूट URL को अस्पष्ट करके संवेदनशील नियंत्रकों तक सीधी पहुंच को रोकने में मदद करते हैं।
- **प्रदर्शन**: सरल सरणी लुकअप; जब तक आपके पास सैकड़ों रूट नहीं हैं, तब तक कोई बड़ा ओवरहेड नहीं।

#### 3. **रूट का उपयोग कैसे करें**
रूट का उपयोग करने का मतलब है कि उन्हें ऊपर बताए अनुसार सेटअप करना, और फिर उन्हें अपने एप्लिकेशन (नियंत्रक, दृश्य, आदि) में लाभ उठाना।

- **नियंत्रकों में**: मान लें कि रूट URL मैपिंग को संभालता है; रूट किए गए अनुरोधों की अपेक्षा करने वाली विधियाँ लिखें।
  - उदाहरण: `$route['login']['POST'] = 'users/login';` के लिए, एक `Users.php` नियंत्रक बनाएं जिसमें एक `login()` विधि हो जो POST डेटा (जैसे, `$this->input->post()` के माध्यम से) को संभालती है।

- **URL जनरेट करना**: लिंक/बटन के लिए अपनी रूट कुंजियों के साथ CodeIgniter के `site_url()` या `base_url()` का उपयोग करें।
  - उदाहरण: एक दृश्य में, `<a href="<?= site_url('login'); ?>">लॉगिन</a>` रूट किए गए URL की ओर इशारा करता है, लेकिन आपका कोड परिभाषित करता है कि यह किस नियंत्रक को हिट करता है।

- **रूट का परीक्षण**:
  - URL जैसे `/users/register` को हिट करने के लिए अपने वेब ब्राउज़र या API टूल (जैसे, Postman) का उपयोग करें।
  - यदि रूट विफल होते हैं तो त्रुटियों के लिए `application/logs/log-{date}.php` की जांच करें।
  - डीबग जोड़ें: अस्थायी रूप से `$route['404_override']` को रीसेट करें और पैरामीटर देखने के लिए एक परीक्षण नियंत्रक में var_dump का उपयोग करें।

- **RESTful उपयोग (आपके कोड की तरह)**: आपके रूट एक API जैसी संरचना के लिए सेटअप हैं। उदाहरण के लिए:
  - एक संसाधन बनाना: POST को `/lives` पर भेजें → एक लाइव इवेंट बनाता है।
  - पढ़ना: GET `/lives/123` → लाइव इवेंट #123 फ़ेच करता है।
  - अपडेट करना: POST `/lives/123` → लाइव इवेंट #123 अपडेट करता है।

- **सामान्य गलतियाँ और सुझाव**:
  - **डुप्लिकेट**: ओवरलैपिंग रूट (जैसे, `lives` और `lives/(\d+)`) से बचें; विशिष्ट को पहले रखें।
  - **विधियाँ निर्दिष्ट नहीं**: यदि एक रूट एक स्ट्रिंग है, तो यह सभी HTTP विधियों के लिए काम करता है। सटीकता के लिए सरणियों का उपयोग करें।
  - **विकास के लिए**: रूटिंग को डीबग करने के लिए एक नियंत्रक में CodeIgniter के प्रोफाइलर (`$this->output->enable_profiler(TRUE);`) को सक्षम करें।
  - **वर्जन कंट्रोल**: आपकी routes.php वर्जन कंट्रोल में है – परिवर्तन रूटिंग को लाइव प्रभावित करते हैं।
  - **एक्सटेंशन**: यदि आपको उन्नत सुविधाओं (जैसे, नेमस्पेस सपोर्ट) की आवश्यकता है, तो CodeIgniter 4 या तीसरे पक्ष के लाइब्रेरी पर विचार करें, क्योंकि CI 3 (आपका कोड) पुराना है।

यदि आपकी फ़ाइल में किसी रूट के बारे में कोई विशिष्ट प्रश्न हैं (जैसे, क्यों `(\d+)` का उपयोग किया गया है या नया कैसे जोड़ें), तो अधिक विवरण प्रदान करें! CodeIgniter सेटअप के लिए, सुनिश्चित करें कि आपके index.php में `CI_VERSION` परिभाषित है।