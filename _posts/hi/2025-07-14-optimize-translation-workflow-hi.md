---
audio: false
generated: true
lang: hi
layout: post
title: पैराग्राफ हैशिंग के साथ अनुवाद का अनुकूलन
translated: true
type: note
---

### अपने अनुवाद वर्कफ़्लो को ऑप्टिमाइज़ करने पर विचार

आपका लक्ष्य स्पष्ट है: Jekyll ब्लॉग पोस्ट (Markdown में लिखित) का 8 भाषाओं में अनुवाद करते समय AI टोकन उपयोग को कम से कम करना, केवल बदले हुए या नए पैराग्राफ़ का पुनः अनुवाद करके, जबकि अपरिवर्तित पैराग्राफ़ को कैश करके रखना। आप संपादन के लिए Markdown से जुड़े रहना चाहते हैं, मुख्य सामग्री के लिए डेटाबेस/JSON/YAML से बचना चाहते हैं, और विशेष एलिमेंट्स जैसे कोड ब्लॉक (जिनका अनुवाद नहीं होना चाहिए) को हैंडल करना चाहते हैं। एक पैराग्राफ़-आधारित दृष्टिकोण समझ में आता है क्योंकि यह आपके लिखने और संपादन के तरीके से मेल खाता है—इस स्तर पर अनुवाद वाक्यों की तुलना में अधिक संदर्भ-सटीक हो सकते हैं।

मुख्य चुनौतियाँ:
- **परिवर्तनों की पहचान करना**: वर्जन कंट्रोल डिफ़्स के बिना, आपको यह पता लगाने का तरीका चाहिए कि क्या नया/बदला हुआ/अपरिवर्तित है। पैराग्राफ़ को हैश करना (जैसे, सामान्यीकृत अंग्रेजी टेक्स्ट पर SHA-256 का उपयोग) कुशल और स्टेटलेस है—पूरे पुराने वर्जन स्टोर करने की आवश्यकता नहीं है।
- **Markdown स्ट्रक्चर को हैंडल करना**: आप केवल `\n\n` पर स्प्लिट नहीं कर सकते क्योंकि कोड ब्लॉक, हेडर, लिस्ट, या अन्य सिंटैक्स चीजों को तोड़ सकते हैं। बेसिक पोस्ट के लिए एक साधारण रेगेक्स-आधारित स्प्लिटर काम कर सकता है, लेकिन स्ट्रक्चर को प्रिज़र्व करने और गैर-अनुवाद योग्य भागों को छोड़ने के लिए एक हल्का Markdown पार्सर बेहतर है।
- **कैशिंग**: इसे फ़ाइल-आधारित और सरल रखें (जैसे, एक JSON फ़ाइल या फ़ाइलों की डायरेक्टरी) ताकि डेटाबेस से बचा जा सके। कैश प्रति-पैराग्राफ़-हैश, प्रति-भाषा रखें।
- **टोकन बचत**: लंबी पोस्ट के लिए, मामूली संपादनों पर यह उपयोग को 80-90% तक काट सकता है, क्योंकि केवल प्रभावित पैराग्राफ़ ही AI API को हिट करते हैं।
- **एज केस**: जोड़े/हटाए गए पैराग्राफ़ (नए सिरे से हैशिंग द्वारा हैंडल करें); मामूली बदलाव (जैसे, टाइपो फिक्स) री-ट्रांसलेशन को ट्रिगर करेंगे जब तक कि आप व्हाइटस्पेस/विराम चिह्नों को सामान्य नहीं करते; कोड ब्लॉक या इनलाइन कोड को बाहर रखा जाना चाहिए; यदि पैराग्राफ़ पुनः व्यवस्थित होते हैं, तो हैश मेल नहीं खाएंगे, लेकिन यह ठीक है यदि आप उन्हें "नया" मानते हैं।
- **एकीकरण**: इसे अपने Jekyll वर्कफ़्लो में एक प्री-बिल्ड स्क्रिप्ट के रूप में चलाएं (जैसे, एक बैश स्क्रिप्ट या Git हुक के माध्यम से)। Jekyll प्लगइन्स की आवश्यकता नहीं है यदि आप अलग से अनुवादित Markdown फ़ाइलें जनरेट करते हैं।

यह वाक्य-स्तर (AI के लिए कम सटीक संदर्भ) या पूरी-पोस्ट (कोई बचत नहीं) से बेहतर है। लिखने के विचारों के लिए YAML/JSON वास्तव में बोझिल होगा—Markdown से जुड़े रहें।

### प्रस्तावित सर्वोत्तम तरीका: कैशिंग और Markdown-अवेयर पार्सिंग के साथ पैराग्राफ-हैशिंग

एक Python स्क्रिप्ट का उपयोग करें:
1. अंग्रेजी Markdown को "अनुवाद योग्य इकाइयों" (पैराग्राफ़, कोड ब्लॉक, हेडर आदि को छोड़कर) में पार्स करें।
2. प्रत्येक इकाई के अंग्रेजी टेक्स्ट को हैश करें (सामान्यीकृत, जैसे, अतिरिक्त व्हाइटस्पेस हटाएं)।
3. मौजूदा अनुवादों के लिए हैश/भाषा द्वारा एक फ़ाइल-आधारित कैश चेक करें।
4. अपने AI टूल (जैसे, DeepSeek/Mistral API) के माध्यम से गायब अनुवादों का अनुवाद करें।
5. नए अनुवादों को कैश करें।
6. गैर-अनुवाद योग्य भागों को प्रिज़र्व करते हुए, अनुवादित Markdown फ़ाइलों को पुनः असेंबल करें।

**यह सर्वोत्तम क्यों है**:
- **सरल और कम-ओवरहेड**: कोई DB नहीं, केवल फ़ाइलें। AI कॉल्स को छोड़कर स्थानीय/ऑफ़लाइन चलता है।
- **लचीला**: कोड ब्लॉक को छोड़कर उन्हें हैंडल करता है। अन्य Markdown एलिमेंट्स के लिए एक्स्टेंडेबल (जैसे, हेडर का अनुवाद न करें यदि वे छोटे हैं)।
- **लागत-प्रभावी**: केवल नए/बदले गए पैराग्राफ़ के लिए भुगतान करता है। 10-पैराग्राफ़ वाली पोस्ट के लिए, एक को संपादित करने पर ~90% टोकन बचाता है।
- **रखरखाव योग्य**: अंग्रेजी Markdown को स्वाभाविक रूप से संपादित करें; स्क्रिप्ट बाकी को हैंडल करती है।
- **आवश्यक टूल्स**: Python (संभवतः आपके पास है)। लाइब्रेरीज़: `hashlib` (हैशिंग के लिए बिल्ट-इन), `markdown` या `mistune` पार्सिंग के लिए (यदि आवश्यक हो; अपने "कोई विशेष सिंटैक्स नहीं" केस के लिए रेगेक्स से सरल शुरुआत करें)।

#### चरण-दर-चरण कार्यान्वयन

1. **सेटअप**:
   - एक `translations_cache.json` फ़ाइल बनाएँ (या स्केलेबिलिटी के लिए hash.json फ़ाइलों वाली एक डायरेक्टरी जैसे `cache/`)।
   - स्ट्रक्चर: `{ "hash1": { "fr": "translated text", "es": "...", ... }, "hash2": { ... } }`
   - इसे अपने ब्लॉग रेपो में स्टोर करें (संवेदनशील होने पर git-ignore करें) या एक अलग डायरेक्टरी में।
   - अपनी 8 भाषाओं को स्क्रिप्ट में सूचीबद्ध करें (जैसे, ['fr', 'es', 'de', ...])।

2. **Markdown पार्स करना**:
   - सरल केस के लिए (पैराग्राफ़ + कोड ब्लॉक): फेंस्ड कोड ब्लॉक (``````` या `~~~`) और इंडेंटेड कोड (>3 स्पेस) का पता लगाने के लिए लाइन-बाय-लाइन प्रोसेसिंग का उपयोग करें।
   - "पैराग्राफ़" को लगातार गैर-कोड, गैर-खाली लाइनों के ब्लॉक के रूप में एकत्र करें।
   - बेहतर: HTML में कन्वर्ट करने के लिए Python की `markdown` लाइब्रेरी का उपयोग करें, फिर टेक्स्ट निकालें, लेकिन यह पुनः असेंबली के लिए लॉसी है। इसके बजाय, AST (अमूर्त वाक्यवृक्ष) प्राप्त करने के लिए `mistune` (एक तेज़ Markdown पार्सर) का उपयोग करें, जो आपको अनुवाद योग्य नोड्स (जैसे, 'paragraph' नोड्स) को ट्रैवर्स और मॉडिफ़ाई करने देता है।
   - यदि आवश्यक हो तो `mistune` इंस्टॉल करें (लेकिन आपके एनवी में बेसिक्स हैं; मान लें कि आप इसे स्थानीय रूप से pip कर सकते हैं)।

3. **हैशिंग**:
   - सामान्यीकृत करें: `text.strip().lower()` या केवल `.strip()` व्हाइटस्पेस परिवर्तनों को अनदेखा करने के लिए (लेकिन यह जानबूझकर किए गए संपादनों को छोड़ सकता है)।
   - हैश: `hashlib.sha256(normalized.encode()).hexdigest()`

4. **अनुवाद**:
   - अपने AI API रैपर का उपयोग करें (जैसे, DeepSeek के लिए: प्रॉम्प्ट भेजें जैसे "इस पैराग्राफ़ का French में अनुवाद करें: {text}")।
   - यदि संभव हो तो बैच करें, लेकिन चूंकि पैराग्राफ़ छोटे हैं, सीक्वेंशियल ठीक है।

5. **पुनः असेंबली**:
   - अनुवाद योग्य ब्लॉक को कैश/नए अनुवादों से बदलकर Markdown को रीबिल्ड करें, कोड/हेडर को बरकरार रखते हुए।

6. **स्क्रिप्ट निष्पादन**:
   - चलाएँ: `python translate_blog.py path/to/english.md`
   - आउटपुट: `path/to/fr.md`, `path/to/es.md`, आदि।
   - Jekyll के लिए: इन्हें लैंग प्रीफ़िक्स के साथ `_posts/` में रखें, या हैंडल करने के लिए `jekyll-polyglot` जैसे मल्टीलिंगुअल प्लगइन का उपयोग करें।

#### नमूना Python स्क्रिप्ट

यहाँ लाइन-बाय-लाइन पार्सिंग (बिल्ट-इन्स के अलावा कोई एक्सटर्नल लाइब्रेरी नहीं) का उपयोग करते हुए एक बेसिक वर्जन है। यह सरल Markdown मानता है: खाली लाइनों से अलग किए गए पैराग्राफ़, फेंस्ड कोड ब्लॉक। कॉम्प्लेक्स सिंटैक्स के लिए `mistune` पर अपग्रेड करें।

```python
import hashlib
import json
import os
import sys
# मान लें कि आपके पास एक AI अनुवाद फ़ंक्शन है; अपने DeepSeek/Mistral API कॉल से बदलें
def ai_translate(text, lang):
    # प्लेसहोल्डर: API कॉल का परिणाम लौटाएं
    return f"Translated to {lang}: {text}"  # वास्तविक API से बदलें

CACHE_FILE = 'translations_cache.json'
LANGUAGES = ['fr', 'es', 'de', 'it', 'pt', 'zh', 'ja', 'ko']  # आपकी 8 भाषाएँ

def load_cache():
    if os.path.exists(CACHE_FILE):
        with open(CACHE_FILE, 'r') as f:
            return json.load(f)
    return {}

def save_cache(cache):
    with open(CACHE_FILE, 'w') as f:
        json.dump(cache, f, indent=4)

def compute_hash(text):
    normalized = text.strip()  # सामान्यीकरण को कस्टमाइज़ करें
    return hashlib.sha256(normalized.encode('utf-8')).hexdigest()

def parse_markdown(md_text):
    lines = md_text.splitlines()
    blocks = []
    current_block = []
    in_code = False
    for line in lines:
        if line.strip().startswith('```') or line.strip().startswith('~~~'):
            in_code = not in_code
            if current_block:
                blocks.append(('text', '\n'.join(current_block)))
                current_block = []
            blocks.append(('code', line))
            continue
        if in_code:
            blocks.append(('code', line))
        else:
            if line.strip():  # गैर-खाली
                current_block.append(line)
            else:
                if current_block:
                    blocks.append(('text', '\n'.join(current_block)))
                    current_block = []
    if current_block:
        blocks.append(('text', '\n'.join(current_block)))
    return blocks

def translate_post(english_md_path):
    with open(english_md_path, 'r') as f:
        md_text = f.read()
    
    blocks = parse_markdown(md_text)
    cache = load_cache()
    
    for lang in LANGUAGES:
        translated_blocks = []
        for block_type, content in blocks:
            if block_type == 'code':
                translated_blocks.append(content)
            else:  # text
                h = compute_hash(content)
                if h not in cache:
                    cache[h] = {}
                if lang not in cache[h]:
                    translation = ai_translate(content, lang)
                    cache[h][lang] = translation
                translated_blocks.append(cache[h][lang])
        
        # Markdown फ़ॉर्मेटिंग के लिए न्यूलाइन्स के साथ पुनः असेंबल करें
        translated_md = '\n\n'.join(translated_blocks)  # Markdown फ़ॉर्मेटिंग के लिए एडजस्ट करें
        output_path = english_md_path.replace('.md', f'_{lang}.md')
        with open(output_path, 'w') as f:
            f.write(translated_md)
    
    save_cache(cache)
    print("Translations updated.")

if __name__ == '__main__':
    if len(sys.argv) < 2:
        print("Usage: python script.py path/to/english.md")
    else:
        translate_post(sys.argv[1])
```

**उपयोग कैसे करें**:
- `ai_translate` को अपने API लॉजिक से बदलें।
- संपादन के बाद अपनी पोस्ट फ़ाइल पर चलाएँ।
- हेडर/लिस्ट के लिए: पता लगाने के लिए `parse_markdown` को एक्सटेंड करें (जैसे, `#` या `-` से शुरू होने वाली लाइनों को अलग ब्लॉक के रूप में)।
- यदि पोस्ट में इमेज/लिंक हैं: वे अपरिवर्तित रहते हैं क्योंकि वे टेक्स्ट ब्लॉक में हैं।
- सामान्यीकरण टिप: यदि आप मामूली विराम चिह्न परिवर्तनों को अनदेखा करना चाहते हैं, तो हैशिंग से पहले उन्हें हटाने के लिए रेगेक्स का उपयोग करें।

#### एन्हांसमेंट
- **Git एकीकरण**: बदली हुई लाइनों को पहले से पहचानने के लिए `git diff` का उपयोग करें, लेकिन हैशिंग सरल है।
- **बैच अनुवाद**: यदि API सपोर्ट करता है, तो एक साथ कई नए पैराग्राफ़ भेजें।
- **एरर हैंडलिंग**: विफल API कॉल को रिट्राई करें; अनुवादों को वैलिडेट करें।
- **एडवांस्ड पार्सिंग**: `mistune` को pip करें और कस्टमाइज़ करने के लिए इसके रेंडरर का उपयोग करें (जैसे, 'code_block' नोड्स को छोड़ें)।
- **टेस्टिंग**: SHA-256 के साथ हैश टकराव दुर्लभ हैं; नमूना पोस्ट पर परीक्षण करें।

यह आपके वर्कफ़्लो को जटिल किए बिना आपके टोकन बचाएगा। यदि आपका Markdown अधिक जटिल है, तो इससे शुरुआत करें और इटरेट करें। यदि आपको API एकीकरण के साथ ट्वीक्स या मदद की आवश्यकता है तो मुझे बताएं!