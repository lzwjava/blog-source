---
audio: false
date: 2025-09-08
generated: true
image: false
lang: hi
layout: post
title: मॉड्यूलर स्प्रिंग ऐप्स के लिए आईटी कवरेज
translated: true
type: note
---

### आपके सेटअप का समग्र मूल्यांकन

आपका वर्तमान कॉन्फ़िगरेशन इस तरह के एक छोटे मल्टी-मॉड्यूल प्रोजेक्ट के लिए मजबूत है, खासकर जब से आपके पास मुख्य फ्लो पहले से ही काम कर रहा है: Jetty से JaCoCo एजेंट को अटैच करना, Exec प्लगइन के माध्यम से बाहरी Python इंटीग्रेशन टेस्ट चलाना, और `PlaygroundWeb` मॉड्यूल में एक रिपोर्ट जनरेट करना। यह Python के `unittest` द्वारा टेस्ट किए गए API एंडपॉइंट्स से रनटाइम कवरेज कैप्चर करता है, जो कि एक Spring वेब ऐप में इंटीग्रेशन टेस्ट (IT) कवरेज के लिए आपको बिल्कुल जरूरत है।

मुख्य सशक्त पक्ष:
- **मॉड्यूलर और फेज-बाउंड**: Maven फेजेज (`pre-integration-test` Jetty स्टार्ट के लिए, `integration-test` Python टेस्ट के लिए, `post-integration-test` स्टॉप के लिए, `verify` रिपोर्ट के लिए) का उपयोग विश्वसनीयता और पुनरुत्पादन सुनिश्चित करता है।
- **एजेंट अटैचमेंट**: Jetty पर JVM arg (`-javaagent:...`) रनटाइम को सही ढंग से इंस्ट्रूमेंट करता है, `jacoco.it.exec` में कवरेज कैप्चर करता है।
- **बाहरी टेस्ट्स इंटीग्रेशन**: Exec प्लगइन Python को अच्छी तरह हैंडल करता है, और टेस्ट्स को रेपो रूट (`${project.parent.basedir}/tests`) पर रखना उन्हें Java मॉड्यूल्स से डीकपल करता है।
- **कोई अनावश्यक डुप्लिकेशन नहीं**: आप `PlaygroundUtils` (जिसमें कोई कंट्रोलर नहीं है) में Jetty/Python चलाने से बचते हैं, जो कुशल है।

आपके द्वारा पहचानी गई चुनौतियाँ:
- **`PlaygroundUtils` जैसे लाइब्रेरी मॉड्यूल्स के लिए कवरेज**: चूंकि utils कोड `PlaygroundWeb` JVM (WAR में एक डिपेंडेंसी के रूप में) में चलता है, यह इंस्ट्रूमेंटेड होता है और `PlaygroundWeb` के `jacoco.it.exec` में दिखाई देता है। लेकिन आपकी रिपोर्ट्स मॉड्यूल-विशिष्ट हैं, इसलिए `PlaygroundUtils` कवरेज दिखाई नहीं देता जब तक कि एग्रीगेट न किया जाए या शामिल न किया जाए।
- **JaCoCo की गैर-स्व-निहित प्रकृति**: Checkstyle/Spotless (जो सिर्फ सोर्स/स्टैटिक आर्टिफैक्ट्स का विश्लेषण करते हैं) के विपरीत, JaCoCo को बाहरी टेस्ट्स और एजेंट अटैचमेंट से रनटाइम डेटा (`.exec` फाइल्स) की आवश्यकता होती है। यह इसे सावधानीपूर्वक समन्वय के बिना मल्टी-मॉड्यूल सेटअप्स के लिए नाजुक बनाता है।
- **एग्रीगेट गोल की सीमाएँ**: `jacoco:report-aggregate` को प्रति-मॉड्यूल `.exec` फाइल्स (जैसे, यूनिट टेस्ट्स से) की अपेक्षा होती है, लेकिन आपकी कवरेज एक मॉड्यूल में शुद्ध रूप से IT से है। एग्रीगेशन को फोर्स करने से `PlaygroundUtils` जैसी लाइब्रेरीज़ के लिए खाली रिपोर्ट्स हो सकती हैं।
- **10+ मॉड्यूल्स तक स्केलेबिलिटी**: मॉड्यूल्स में Jetty/Python सेटअप्स को डुप्लिकेट करना अपव्ययी होगा (अतिरेक सर्वर/टेस्ट)। हैकी वर्कअराउंड जैसे `.exec` फाइल्स को कॉपी करना या सब कुछ दो बार चलाना (जैसा आपने उल्लेख किया) मेंटेनेंस ओवरहेड और बिल्ड टाइम बढ़ाते हैं।

प्रति-मॉड्यूल रिपोर्ट्स पर आपका फॉलबैक व्यावहारिक है, लेकिन हम डुप्लिकेशन के बिना कवरेज इन्क्लूजन के लिए ऑप्टिमाइज़ कर सकते हैं।

### अनुशंसित रणनीति

**ऐप को चलाने वाले मॉड्यूल** (`PlaygroundWeb` यहाँ) में **एक एकल, व्यापक IT कवरेज रिपोर्ट जनरेट करने** पर ध्यान केंद्रित करें, जबकि **`PlaygroundUtils` जैसे डिपेंडेंट मॉड्यूल्स के लिए कवरेज डेटा को शामिल करें**। यह टेस्ट्स को कई बार चलाने से बचाता है और इस तथ्य का लाभ उठाता है कि सारा कोड एक JVM में एक्सेक्यूट होता है।

एग्रीगेशन पर यह रणनीति क्यों?
- एग्रीगेशन (`report-aggregate`) मॉड्यूल्स में वितरित यूनिट टेस्ट कवरेज के लिए बेहतर है। एकल रनटाइम (आपका केस) से IT कवरेज के लिए, यह ओवरकिल है और स्वाभाविक रूप से फिट नहीं होता।
- एक एकीकृत रिपोर्ट ऐप के कवरेज का समग्र दृष्टिकोण देती है, जो अक्सर साइलोड प्रति-मॉड्यूल रिपोर्ट्स (जैसे, "80% समग्र, लेकिन utils लेयर 60% पर है") से अधिक उपयोगी होती है।
- बड़े प्रोजेक्ट्स के लिए, यह "ऐप मॉड्यूल" (WAR/EAR) को कवरेज हब के रूप में मानकर, डिपेंडेंसीज को शामिल करते हुए स्केल करता है।

#### आपके 2-मॉड्यूल प्रोजेक्ट के लिए चरण-दर-चरण कार्यान्वयन

छोटा शुरू करें: इसे अपने मौजूदा सेटअप (1 ऐप मॉड्यूल + 1 लाइब्रेरी) पर लागू करें। इसे टेस्ट करें, फिर विस्तार करें।

1.  **IT एक्सेक्यूशन को सिर्फ `PlaygroundWeb` में रखें**:
    - यहाँ कोई बदलाव की जरूरत नहीं है। Jetty WAR (जो `PlaygroundUtils` को एम्बेड करती है) स्टार्ट करती है, Python टेस्ट एंडपॉइंट्स को हिट करते हैं, कवरेज `${project.build.directory}/jacoco.it.exec` में कैप्चर होती है।
    - पुष्टि करें कि utils कोड एक्सरसाइज हो रहा है: यदि आपके Python टेस्ट उन एंडपॉइंट्स को कॉल करते हैं जो `PlaygroundUtils` क्लासेज (जैसे, `SystemUtils`) का उपयोग करते हैं, तो उनकी कवरेज `.exec` फाइल में होगी।

2.  **`PlaygroundWeb` में JaCoCo रिपोर्ट को `PlaygroundUtils` को शामिल करने के लिए बढ़ाएँ**:
    - `report` गोल में JaCoCo के `<additionalClassesDirectories>` और `<additionalSourceDirectories>` का उपयोग करें। यह JaCoCo को एक ही `.exec` फाइल के विरुद्ध `PlaygroundUtils` से क्लासेज/सोर्सेज को स्कैन करने के लिए कहता है।
    - `PlaygroundWeb` के POM को अपडेट करें (`jacoco-maven-plugin` कॉन्फ़िगरेशन में):

      ```xml
      <plugin>
          <groupId>org.jacoco</groupId>
          <artifactId>jacoco-maven-plugin</artifactId>
          <executions>
              <!-- मौजूदा prepare-agent -->
              <execution>
                  <id>prepare-agent</id>
                  <goals>
                      <goal>prepare-agent</goal>
                  </goals>
              </execution>
              <!-- बढ़ी हुई रिपोर्ट: utils मॉड्यूल शामिल करें -->
              <execution>
                  <id>report-it</id>
                  <phase>verify</phase>
                  <goals>
                      <goal>report</goal>
                  </goals>
                  <configuration>
                      <dataFile>${jacoco.it.exec}</dataFile>
                      <outputDirectory>${project.reporting.outputDirectory}/jacoco-it</outputDirectory>
                      <!-- PlaygroundUtils कवरेज शामिल करने के लिए इन्हें जोड़ें -->
                      <additionalClassesDirectories>
                          <directory>${project.parent.basedir}/PlaygroundUtils/target/classes</directory>
                      </additionalClassesDirectories>
                      <additionalSourceDirectories>
                          <directory>${project.parent.basedir}/PlaygroundUtils/src/main/java</directory>
                      </additionalSourceDirectories>
                  </configuration>
              </execution>
          </executions>
      </plugin>
      ```

    - यह दोनों मॉड्यूल्स को कवर करते हुए एक रिपोर्ट जनरेट करता है ( `PlaygroundWeb/target/site/jacoco-it` में)। आप utils से `org.lzw` सहित पैकेज/क्लास द्वारा ब्रेकडाउन देखेंगे।

3.  **`PlaygroundUtils` से JaCoCo को डिसेबल/हटाएँ**:
    - चूंकि इसका अपना कोई IT नहीं है, किसी भी JaCoCo कॉन्फ़िग/प्रॉपर्टीज (जैसे, `<jacoco.it.exec>`, `<it.report.skip>`) को हटा दें। इसको अपनी रिपोर्ट जनरेट करने की जरूरत नहीं है—कवरेज अपस्ट्रीम में हैंडल हो जाती है।
    - अगर utils में यूनिट टेस्ट्स हैं, तो यूनिट कवरेज (डिफॉल्ट `jacoco.exec`) के लिए एक अलग `prepare-agent` + `report` रखें, लेकिन इसे IT से अलग करें।

4.  **बिल्ड और वेरिफाई करें**:
    - पैरेंट से `mvn clean verify` चलाएँ।
    - Jetty/Python सिर्फ एक बार ( `PlaygroundWeb` में) चलती है।
    - `PlaygroundWeb/target/site/jacoco-it/index.html` चेक करें: इसे दोनों मॉड्यूल्स की क्लासेज के लिए कवरेज दिखाना चाहिए।
    - अगर utils कवरेज 0% है, तो सुनिश्चित करें कि आपके Python टेस्ट उन क्लासेज को एक्सरसाइज करते हैं (जैसे, एक टेस्ट जोड़ें जो एक एंडपॉइंट के माध्यम से `SystemUtils` को ट्रिगर करता है)।

5.  **ऑप्शनल: कवरेज थ्रेशोल्ड लागू करें**:
    - `PlaygroundWeb` के JaCoCo प्लगइन में एक `check` एक्सेक्यूशन जोड़ें ताकि बिल्ड फेल हो जाए अगर कवरेज एक थ्रेशोल्ड (जैसे, 70% लाइन कवरेज समग्र) से नीचे गिरती है।
      ```xml
      <execution>
          <id>check-it</id>
          <goals>
              <goal>check</goal>
          </goals>
          <configuration>
              <dataFile>${jacoco.it.exec}</dataFile>
              <rules>
                  <rule>
                      <element>BUNDLE</element>
                      <limits>
                          <limit>
                              <counter>LINE</counter>
                              <value>COVEREDRATIO</value>
                              <minimum>0.70</minimum>
                          </limit>
                      </limits>
                  </rule>
              </rules>
          </configuration>
      </execution>
      ```

#### एक बड़े प्रोजेक्ट (जैसे, 10 मॉड्यूल) तक स्केलिंग
10+ मॉड्यूल्स (जैसे, मल्टीपल लाइब्रेरीज़ + 1-2 ऐप/WAR मॉड्यूल्स) के लिए, जटिलता से बचने के लिए उपरोक्त को विस्तारित करें:

- **ऐप मॉड्यूल्स में IT को केंद्रीकृत करें**: अगर आपके पास एक मुख्य WAR (जैसे `PlaygroundWeb`) है, तो उसे "कवरेज हब" बनाएं। सभी डिपेंडेंट लाइब्रेरीज़ के लिए `<additionalClassesDirectories>` और `<additionalSourceDirectories>` जोड़ें (जैसे, पैरेंट POM में लूप या प्रॉपर्टी लिस्ट्स के माध्यम से)।
  - उदाहरण: पैरेंट प्रॉपर्टीज में पाथ्स डिफाइन करें:
    ```xml
    <properties>
        <lib1.classes>${project.basedir}/Lib1/target/classes</lib1.classes>
        <lib1.sources>${project.basedir}/Lib1/src/main/java</lib1.sources>
        <!-- 10 लाइब्रेरीज़ के लिए दोहराएं -->
    </properties>
    ```
  - WAR के JaCoCo रिपोर्ट कॉन्फ़िग में: उन्हें डायनामिकली रेफरेंस करें।

- **अगर मल्टीपल ऐप्स/WARs हैं**: डेडिकेटेड IT मॉड्यूल्स (जैसे, `App1-IT`, `App2-IT`) बनाएं जो WAR पर डिपेंड करते हैं, वहाँ Jetty/Exec/JaCoCo कॉन्फ़िगर करें, और सिर्फ प्रासंगिक डिपेंडेंसी की क्लासेज/सोर्सेज शामिल करें। यह बिल्ड्स को मॉड्यूलर रखता है (जैसे, टार्गेटेड कवरेज के लिए `mvn verify -pl App1-IT`)।

- **प्रति-मॉड्यूल IT डुप्लिकेशन से बचें**: लाइब्रेरी मॉड्यूल्स में कभी भी Jetty/Python न चलाएँ—यह अपव्ययी है। अगर किसी लाइब्रेरी को आइसोलेटेड IT की जरूरत है (दुर्लभ), तो उसे अपना खुद का मिनी-सर्वर/टेस्ट सूट दें।

- **रिपोर्टिंग के लिए एग्रीगेशन (अगर जरूरत हो)**: अगर आप अलग प्रति-मॉड्यूल रिपोर्ट्स पर जोर देते हैं:
  - ऐप मॉड्यूल में `.exec` जनरेट करें।
  - प्रत्येक लाइब्रेरी के `target/` में `.exec` को कॉपी करने के लिए (जैसे, `jacoco-it.exec` के रूप में) पैरेंट `post-integration-test` में Maven के `dependency:copy` या कस्टम स्क्रिप्ट (Exec प्लगइन के माध्यम से) का उपयोग करें।
  - फिर, प्रत्येक लाइब्रेरी में `report` को उस कॉपी की गई फाइल का उपयोग करने के लिए कॉन्फ़िगर करें।
  - लेकिन यह अधिक जटिल है—स्टेकहोल्डर्स द्वारा प्रति-मॉड्यूल मेट्रिक्स की मांग किए जाने तक एकीकृत रिपोर्ट को प्राथमिकता दें।

- **स्केल के लिए टूलिंग टिप्स**:
  - **Maven प्रोफाइल्स**: तेज डेव बिल्ड्स के लिए IT/रिपोर्टिंग को टॉगल करने के लिए प्रोफाइल्स (जैसे, `-Pcoverage`) का उपयोग करें।
  - **CI ऑप्टिमाइजेशन**: CI (जैसे, GitHub Actions) में, Maven डिपेंडेंसीज कैश करें और टेस्ट्स/एंडपॉइंट्स में बदलाव पर ही IT चलाएँ।
  - **विकल्प अगर JaCoCo बहुत जटिल हो जाए**: एग्रीगेटेड एनालिसिस के लिए SonarQube पर विचार करें (यह मॉड्यूल्स में JaCoCo डेटा इन्जेस्ट करता है)। या रनटाइम टूल्स जैसे OpenClover पर स्विच करें, लेकिन अगर आप हब एप्रोच पर बने रहते हैं तो JaCoCo ठीक है।
  - **टेस्ट्स का टेस्टिंग**: सर्वर स्टार्टअप को वेरिफाई करने के लिए Python में एक स्मोक टेस्ट जोड़ें (जैसे, `http://localhost:8080/health` को पोल करें)।

यह रणनीति रन्स को मिनिमाइज करती है (प्रति ऐप एक Jetty/Python), JaCoCo की डिपेंडेंसीज को साफ तरीके से हैंडल करती है, और विस्फोट के बिना स्केल करती है। यदि आप और अधिक विवरण साझा करते हैं (जैसे, utils का एंडपॉइंट्स में उपयोग कैसे किया जाता है), तो मैं POM स्निपेट्स को और परिष्कृत कर सकता हूँ।