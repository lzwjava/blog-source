---
audio: false
generated: true
lang: hi
layout: post
title: वेबअसेंबली
translated: true
type: note
---

आइए WebAssembly (Wasm) की एक व्यापक गाइड में गोता लगाते हैं। मैं इसे आसानी से समझ में आने वाले भागों में बांटूंगा: यह क्या है, यह कैसे काम करता है, यह क्यों महत्वपूर्ण है, इसका उपयोग कैसे करें, और इसका भविष्य क्या है। अंत तक, आपकी WebAssembly की मजबूत समझ बन जाएगी और आप इसके साथ शुरुआत कैसे कर सकते हैं, यह भी पता चल जाएगा।

---

### **1. WebAssembly क्या है?**
WebAssembly एक बाइनरी इंस्ट्रक्शन फॉर्मेट है जिसे प्रोग्रामिंग भाषाओं के लिए एक पोर्टेबल, हाई-परफॉर्मेंस कंपाइलेशन टार्गेट के रूप में डिज़ाइन किया गया है। यह एक निम्न-स्तरीय, असेंबली जैसी भाषा है जिसका एक कॉम्पैक्ट बाइनरी प्रतिनिधित्व होता है, लेकिन इसे सीधे मनुष्यों द्वारा लिखने का इरादा नहीं है—बल्कि, यह C, C++, Rust, Go, या यहाँ तक कि Python जैसी उच्च-स्तरीय भाषाओं को कंपाइल करके जनरेट किया जाता है।

- **मुख्य विशेषताएँ:**
  - **परफॉर्मेंस:** हार्डवेयर क्षमताओं का लाभ उठाकर नेटिव स्पीड के करीब चलता है।
  - **पोर्टेबिलिटी:** प्लेटफॉर्म्स (ब्राउज़र, सर्वर, IoT डिवाइस, आदि) पर लगातार चलता है।
  - **सुरक्षा:** एक सैंडबॉक्स्ड वातावरण में संचालित होता है, जो इसे होस्ट सिस्टम से अलग करता है।
  - **इंटरऑपरेबिलिटी:** JavaScript के साथ मिलकर काम करता है, इसके खिलाफ नहीं।

- **इतिहास:**
  - 2015 में Mozilla, Google, Microsoft, और Apple के सहयोग से पेश किया गया।
  - 2019 में W3C रिकमेंडेशन बना, जिसने इसे एक आधिकारिक वेब मानक के रूप में चिह्नित किया।

- **उपयोग के मामले:**
  - वेब गेम्स (जैसे, Unity या Unreal Engine एक्सपोर्ट)।
  - परफॉर्मेंस-क्रिटिकल ऐप्स (जैसे, Figma या Photoshop जैसे टूल्स)।
  - सर्वर-साइड एप्लिकेशन (जैसे, Node.js के साथ)।
  - आधुनिक वातावरण में लेगेसी कोडबेस चलाना।

---

### **2. WebAssembly कैसे काम करता है?**
WebAssembly उच्च-स्तरीय कोड और मशीन एक्ज़िक्यूशन के बीच की खाई को पाटता है। प्रक्रिया इस प्रकार है:

1. **सोर्स कोड:** आप C++ या Rust जैसी भाषा में कोड लिखते हैं।
2. **कंपाइलेशन:** एक कंपाइलर (जैसे, C/C++ के लिए Emscripten या Rust के लिए `wasm-pack`) इसे WebAssembly के बाइनरी फॉर्मेट (`.wasm` फाइल्स) में ट्रांसलेट करता है।
3. **एक्ज़िक्यूशन:**
   - ब्राउज़र में, `.wasm` फाइल फ़ेच की जाती है (अक्सर JavaScript के माध्यम से), वैलिडेट की जाती है, और ब्राउज़र के Wasm रनटाइम द्वारा मशीन कोड में कंपाइल की जाती है।
   - रनटाइम इसे एक सैंडबॉक्स में एक्ज़िक्यूट करता है, जो सुरक्षा सुनिश्चित करता है।

- **टेक्स्ट फॉर्मेट (WAT):** WebAssembly का एक ह्यूमन-रीडेबल टेक्स्ट रिप्रेजेंटेशन (`.wat`) भी होता है, जो डीबगिंग या सीखने के लिए उपयोगी है। उदाहरण के लिए:
  ```wat
  (module
    (func (export "add") (param i32 i32) (result i32)
      local.get 0
      local.get 1
      i32.add)
  )
  ```
  यह एक `add` फंक्शन को डिफाइन करता है जो दो 32-बिट इंटीजर लेता है और उनका योग रिटर्न करता है।

- **मेमोरी मॉडल:** Wasm एक लीनियर मेमोरी मॉडल का उपयोग करता है—बाइट्स की एक फ्लैट ऐरे जिसे प्रोग्राम पढ़/लिख सकता है। इसका प्रबंधन मैन्युअल रूप से या सोर्स लैंग्वेज के रनटाइम के माध्यम से किया जाता है।

- **JavaScript के साथ इंटरैक्शन:** आप JavaScript में `WebAssembly.instantiate()` या `fetch()` का उपयोग करके Wasm मॉड्यूल लोड करते हैं और एक्सपोर्टेड फंक्शन को कॉल करते हैं। Wasm JavaScript में वापस भी कॉल कर सकता है।

---

### **3. WebAssembly का उपयोग क्यों करें?**
- **स्पीड:** प्री-कंपाइल्ड बाइनरी, इंटरप्रेटेड JavaScript से तेज चलती हैं।
- **भाषा लचीलापन:** JavaScript में लॉक होने के बजाय C, Rust, आदि का उपयोग करें।
- **साइज़ दक्षता:** `.wasm` फाइलें समकक्ष JavaScript से छोटी होती हैं, जिससे लोड समय कम होता है।
- **क्रॉस-प्लेटफॉर्म:** एक बार लिखें, कहीं भी चलाएँ—ब्राउज़र, सर्वर, या एम्बेडेड डिवाइस।
- **सुरक्षा:** सैंडबॉक्सिंग दुर्भावनापूर्ण कोड को होस्ट सिस्टम तक पहुंचने से रोकती है।

**ट्रेड-ऑफ:**
- डायरेक्ट DOM एक्सेस नहीं (उसके लिए आपको JavaScript की आवश्यकता है)।
- शुरुआती लोगों के लिए टूलिंग जटिल हो सकती है।
- JavaScript की तुलना में डीबगिंग अधिक पेचीदा है।

---

### **4. WebAssembly के साथ शुरुआत करना**
आइए एक सरल उदाहरण के माध्यम से चलते हैं: एक C फंक्शन को WebAssembly में कंपाइल करना और इसे ब्राउज़र में चलाना।

#### **चरण 1: टूल्स इंस्टॉल करें**
- **Emscripten:** C/C++ को WebAssembly में कंपाइल करने के लिए एक टूलचेन।
  - इंस्टॉल करें: [Emscripten गाइड](https://emscripten.org/docs/getting_started/downloads.html) का पालन करें (Python, CMake, आदि की आवश्यकता होती है)।
- **Node.js:** वैकल्पिक, ब्राउज़र के बाहर Wasm चलाने के लिए।
- **एक वेब सर्वर:** ब्राउज़र को `.wasm` फाइल्स की HTTP के माध्यम से सर्व करने की आवश्यकता होती है (जैसे, `python -m http.server` का उपयोग करें)।

#### **चरण 2: कोड लिखें**
`add.c` नामक एक फाइल बनाएँ:
```c
int add(int a, int b) {
    return a + b;
}
```

#### **चरण 3: WebAssembly में कंपाइल करें**
यह Emscripten कमांड चलाएँ:
```bash
emcc add.c -s EXPORTED_FUNCTIONS='["_add"]' -s EXPORT_ES6=1 -s MODULARIZE=1 -o add.js
```
- `add.js` (एक ग्लू स्क्रिप्ट) और `add.wasm` (बाइनरी) आउटपुट करता है।

#### **चरण 4: HTML में उपयोग करें**
`index.html` बनाएँ:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
</head>
<body>
    <script type="module">
        import init, { add } from './add.js';
        async function run() {
            await init();
            console.log(add(5, 3)); // आउटपुट 8
        }
        run();
    </script>
</body>
</html>
```

#### **चरण 5: सर्व करें और टेस्ट करें**
- एक लोकल सर्वर शुरू करें: `python -m http.server 8080`
- ब्राउज़र में `http://localhost:8080` खोलें, और कंसोल चेक करें।

Rust के लिए, आप `cargo` और `wasm-pack` का उपयोग करेंगे—समान प्रक्रिया, अलग टूलचेन।

---

### **5. इकोसिस्टम और टूल्स**
- **भाषाएँ:**
  - **C/C++:** Emscripten।
  - **Rust:** `wasm-pack`, `wasm-bindgen`।
  - **Go:** बिल्ट-इन Wasm सपोर्ट (`GOOS=js GOARCH=wasm`)।
  - **AssemblyScript:** Wasm के लिए TypeScript जैसा सिंटैक्स।

- **रनटाइम:**
  - **ब्राउज़र:** Chrome, Firefox, Safari, Edge।
  - **Node.js:** `--experimental-wasm-modules` के साथ।
  - **स्टैंडअलोन:** Wasmtime, Wasmer, WasmEdge।

- **लाइब्रेरीज़:**
  - **WebGL:** ग्राफिक्स के लिए (जैसे, गेम्स)।
  - **WASI:** गैर-वेब उपयोग के मामलों (फाइल I/O, आदि) के लिए WebAssembly सिस्टम इंटरफेस।

---

### **6. एडवांस्ड फीचर्स**
- **थ्रेड्स:** समानांतरता के लिए SharedArrayBuffer के साथ सपोर्टेड।
- **SIMD:** मैथ-हेवी टास्क्स (जैसे, इमेज प्रोसेसिंग) के लिए वेक्टर इंस्ट्रक्शन।
- **WASI:** वेब से परे Wasm को बढ़ाता है, सिस्टम कॉल जोड़ता है।
- **डायनामिक लिंकिंग:** मल्टीपल `.wasm` मॉड्यूल लोड करें और उन्हें रनटाइम पर लिंक करें।

---

### **7. WebAssembly का भविष्य**
- **व्यापक अपनान:** अधिक भाषाएँ और फ्रेमवर्क Wasm सपोर्ट जोड़ रहे हैं।
  - **सर्वरलेस कंप्यूटिंग:** Wasm की हल्की प्रकृति एज कंप्यूटिंग के लिए उपयुक्त है।
  - **मानकीकरण:** गार्बेज कलेक्शन और एक्सेप्शन हैंडलिंग जैसे प्रस्ताव प्रगति पर हैं।
  - **गैर-वेब विकास:** WASI और Wasmer जैसे रनटाइम Wasm को IoT, डेस्कटॉप ऐप्स, और अधिक में धकेल रहे हैं।

---

### **8. अधिक सीखने के लिए संसाधन**
- **ऑफिशियल साइट:** [webassembly.org](https://webassembly.org/)
- **MDN डॉक्स:** [WebAssembly on MDN](https://developer.mozilla.org/en-US/docs/WebAssembly)
- **ट्यूटोरियल्स:** "Rust and WebAssembly" बुक (rustwasm.github.io/book) या Emscripten डॉक्स।
- **X पोस्ट्स:** रीयल-वर्ल्ड उदाहरणों और चर्चाओं के लिए X पर #WebAssembly सर्च करें।

---

### **त्वरित पुनर्कथन**
WebAssembly परफॉर्मेंस और पोर्टेबिलिटी के लिए एक गेम-चेंजर है। आप अपनी पसंदीदा भाषा में लिखते हैं, `.wasm` में कंपाइल करते हैं, और इसे कहीं भी चलाते हैं—तेजी से। यह कोई सिल्वर बुलेट नहीं है (JavaScript अभी भी वेब की इंटरैक्टिविटी पर राज करती है), लेकिन यह आधुनिक डेवलपर के टूलकिट में एक शक्तिशाली टूल है।

क्या आप कोई विशिष्ट उदाहरण आजमाना चाहते हैं, किसी उपयोग के मामले को एक्सप्लोर करना चाहते हैं, या कुछ ट्रबलशूट करना चाहते हैं? मुझे बताएं