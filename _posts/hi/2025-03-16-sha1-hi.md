---
audio: false
generated: true
lang: hi
layout: post
title: एसएचए-1 हैश फ़ंक्शन
translated: true
type: note
---

आइए दिए गए कोड स्निपेट के काम करने के तरीके को समझते हैं, विशेष रूप से इन पंक्तियों को:

```python
hash_obj = hashlib.sha1(piece)
hashes.append(hash_obj.hexdigest())
return hashes
```

यूजर ने हमें `hashlib` लाइब्रेरी का उपयोग किए बिना इसे समझाने के लिए कहा है, इसलिए मैं पहले यह समझाऊंगा कि यह कोड `hashlib` लाइब्रेरी के साथ क्या करता है, और फिर यह पता लगाऊंगा कि इसके बिना समान कार्यक्षमता कैसे हासिल की जा सकती है।

---

### `hashlib` के साथ कोड को समझना

यह स्निपेट डेटा के एक टुकड़े (piece) के लिए एक हैश की गणना करता है और इसे एक सूची में संग्रहीत करता है। यहां चरण दर चर्ण विवरण दिया गया है कि क्या हो रहा है:

1. **`hash_obj = hashlib.sha1(piece)`**
   - **यह क्या करता है**: यह पंक्ति Python के `hashlib` मॉड्यूल का उपयोग एक SHA-1 हैश ऑब्जेक्ट बनाने के लिए करती है। SHA-1 (Secure Hash Algorithm 1) एक क्रिप्टोग्राफ़िक हैश फ़ंक्शन है जो एक इनपुट (यहाँ, `piece`) लेता है और एक 160-बिट (20-बाइट) हैश मान उत्पन्न करता है।
   - **इनपुट**: `piece` डेटा का एक हिस्सा है, संभवतः बाइट्स में, जो एक फ़ाइल या किसी अन्य स्रोत से पढ़ा गया है।
   - **प्रक्रिया**: `hashlib.sha1()` फ़ंक्शन एक हैश ऑब्जेक्ट को इनिशियलाइज़ करता है और तुरंत इसे `piece` में डेटा के साथ अपडेट करता है। इसे एक हैशिंग मशीन में डेटा फीड करने के रूप में सोचें जो नंबरों को प्रोसेस करना शुरू कर देती है।

2. **`hashes.append(hash_obj.hexdigest())`**
   - **यह क्या करता है**: `hexdigest()` मेथड हैश ऑब्जेक्ट द्वारा गणना किए गए हैश मान को पुनः प्राप्त करती है और इसे एक हेक्साडेसिमल स्ट्रिंग (0-9 अंकों और a-f अक्षरों का उपयोग करने वाले मानव-पठनीय फॉर्मेट) में परिवर्तित करती है।
   - **आउटपुट**: SHA-1 के लिए, यह स्ट्रिंग 40 वर्ण लंबी होती है क्योंकि 20 बाइट्स में से प्रत्येक को दो हेक्साडेसिमल अंकों द्वारा दर्शाया जाता है (उदाहरण के लिए, 255 के बाइट मान को "ff" बन जाता है)।
   - **संग्रहण**: परिणामी स्ट्रिंग को `hashes` नामक एक सूची में जोड़ा जाता है, जो संभवतः डेटा के कई टुकड़ों के लिए हैश एकत्र करती है।

3. **`return hashes`**
   - **यह क्या करता है**: सभी टुकड़ों को प्रोसेस करने के बाद (यह मानते हुए कि यह कोड एक लूप या फ़ंक्शन में है), सभी हेक्साडेसिमल हैश स्ट्रिंग्स वाली सूची `hashes` वापस की जाती है।

**संक्षेप में**: प्रत्येक डेटा `piece` के लिए, कोड `hashlib.sha1()` का उपयोग करके इसके SHA-1 हैश की गणना करता है, `hexdigest()` के साथ हैश को हेक्साडेसिमल स्ट्रिंग में बदलता है, और इसे `hashes` सूची में संग्रहीत करता है, जिसे बाद में वापस कर दिया जाता है।

---

### लाइब्रेरी का उपयोग किए बिना: SHA-1 को स्क्रैच से कंप्यूट करना

यूजर के "lib का उपयोग न करें" निर्देश से पता चलता है कि वे यह समझना चाहते हैं कि `hashlib` पर भरोसा किए बिना यह कैसे काम कर सकता है। SHA-1 को स्क्रैच से लागू करना जटिल है, लेकिन मैं प्रक्रिया को स्पष्ट रूप से समझाऊंगा और एक सरलीकृत संस्करण प्रदान करूंगा जिस पर आप आगे बना सकते हैं।

#### SHA-1 क्या है?
SHA-1 एक हैश फ़ंक्शन है जो:
- कोई भी इनपुट डेटा (जैसे, `piece`) लेता है।
- एक निश्चित 160-बिट (20-बाइट) आउटपुट उत्पन्न करता है।
- इनपुट को बदलने के लिए बिटवाइज़ ऑपरेशन्स, रोटेशन्स और जोड़ की एक श्रृंखला का उपयोग करता है।

`hashlib` के बिना, हमें इस एल्गोरिदम को स्वयं दोहराने की आवश्यकता होगी। दिए गए कोड के लिए यह कैसे काम कर सकता है यहां बताया गया है:

#### चरण दर चरण SHA-1 प्रक्रिया

1. **इनपुट तैयार करें (Padding)**
   - SHA-1 डेटा को 512-बिट (64-बाइट) ब्लॉकों में प्रोसेस करता है। यदि `piece` बिल्कुल 64 बाइट्स का नहीं है, तो हम इसे पैड करते हैं:
     - एक `1` बिट जोड़ें (उदाहरण के लिए, बाइट्स में `0x80`)।
     - लंबाई को 512 का 448 बिट (56 बाइट्स) मॉड्यूलो बनाने के लिए पर्याप्त `0` बिट जोड़ें।
     - `piece` की मूल लंबाई (बिट्स में) को 64-बिट इंटीजर के रूप में जोड़ें।
   - सरलता के लिए, यदि `piece` 64 बाइट्स से छोटा है, तो हम इसे एक ब्लॉक में पैड कर सकते हैं।

2. **हैश वैल्यूज़ को इनिशियलाइज़ करें**
   - SHA-1 पाँच 32-बिट वेरिएबल्स (कुल 160 बिट्स) का उपयोग करता है, जो विशिष्ट स्थिरांकों पर इनिशियलाइज़ किए जाते हैं:
     - `h0 = 0x67452301`
     - `h1 = 0xEFCDAB89`
     - `h2 = 0x98BADCFE`
     - `h3 = 0x10325476`
     - `h4 = 0xC3D2E1F0`

3. **डेटा ब्लॉक को प्रोसेस करें**
   - 64-बाइट ब्लॉक को 16 32-बिट शब्दों (प्रत्येक 4 बाइट्स) में विभाजित करें।
   - इन्हें इस फॉर्मूले का उपयोग करके 80 शब्दों में विस्तारित करें:
     ```python
     w[i] = left_rotate(w[i-3] ^ w[i-8] ^ w[i-14] ^ w[i-16], 1)  # i = 16 से 79 के लिए
     ```
     जहां `left_rotate` बिट्स को बाईं ओर शिफ्ट करता है और उन्हें चारों ओर लपेटता है।
   - 80 राउंड के लिए, अस्थायी वेरिएबल्स `a`, `b`, `c`, `d`, `e` (जो `h0` से `h4` की प्रतियां हैं) को अपडेट करें:
     - राउंड नंबर (0-19, 20-39, आदि) के आधार पर विभिन्न फ़ंक्शन और स्थिरांक का उपयोग करें।
     - राउंड 0-19 के लिए उदाहरण:
       ```python
       f = (b & c) | (~b & d)
       k = 0x5A827999
       temp = (left_rotate(a, 5) + f + e + k + w[i]) & 0xFFFFFFFF
       ```
     - वेरिएबल्स को शिफ्ट करें: `e = d`, `d = c`, `c = left_rotate(b, 30)`, `b = a`, `a = temp`.

4. **हैश वैल्यूज़ को अपडेट करें**
   - 80 राउंड के बाद, परिणामों को प्रारंभिक हैश मानों में जोड़ें:
     ```python
     h0 = (h0 + a) & 0xFFFFFFFF
     h1 = (h1 + b) & 0xFFFFFFFF
     # ...और इसी तरह h2, h3, h4 के लिए
     ```

5. **हेक्साडेसिमल आउटपुट उत्पन्न करें**
   - `h0` से `h4` को 160-बिट मान के रूप में जोड़ें और इसे 40-वर्ण हेक्साडेसिमल स्ट्रिंग में बदलें।

#### सरलीकृत Python इम्प्लीमेंटेशन

यहां एक बुनियादी संस्करण दिया गया है कि आप `hashlib` के बिना कोड को कैसे फिर से लिख सकते हैं:

```python
def left_rotate(value, shift):
    """एक 32-बिट इंटीजर को 'shift' बिट्स द्वारा बाईं ओर घुमाएं।"""
    return ((value << shift) | (value >> (32 - shift))) & 0xFFFFFFFF

def custom_sha1(piece):
    """'piece' का SHA-1 हैश कंप्यूट करें और इसे हेक्स स्ट्रिंग के रूप में वापस करें।"""
    # सरलता के लिए, मान लें कि piece 56 बाइट्स से छोटा है और इसे एक ब्लॉक में पैड करें
    message = piece + b'\x80' + (b'\x00' * (55 - len(piece))) + (len(piece) * 8).to_bytes(8, 'big')
    
    # हैश वैल्यूज़ को इनिशियलाइज़ करें
    h0, h1, h2, h3, h4 = (
        0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0
    )
    
    # 16 32-बिट शब्दों में विभाजित करें
    w = [int.from_bytes(message[i:i+4], 'big') for i in range(0, 64, 4)]
    
    # 80 शब्दों में विस्तारित करें
    for i in range(16, 80):
        w.append(left_rotate(w[i-3] ^ w[i-8] ^ w[i-14] ^ w[i-16], 1))
    
    # वर्किंग वेरिएबल्स को इनिशियलाइज़ करें
    a, b, c, d, e = h0, h1, h2, h3, h4
    
    # प्रोसेसिंग के 80 राउंड
    for i in range(80):
        if 0 <= i < 20:
            f = (b & c) | (~b & d)
            k = 0x5A827999
        elif 20 <= i < 40:
            f = b ^ c ^ d
            k = 0x6ED9EBA1
        elif 40 <= i < 60:
            f = (b & c) | (b & d) | (c & d)
            k = 0x8F1BBCDC
        else:
            f = b ^ c ^ d
            k = 0xCA62C1D6
        
        temp = (left_rotate(a, 5) + f + e + k + w[i]) & 0xFFFFFFFF
        e = d
        d = c
        c = left_rotate(b, 30)
        b = a
        a = temp
    
    # हैश वैल्यूज़ को अपडेट करें
    h0 = (h0 + a) & 0xFFFFFFFF
    h1 = (h1 + b) & 0xFFFFFFFF
    h2 = (h2 + c) & 0xFFFFFFFF
    h3 = (h3 + d) & 0xFFFFFFFF
    h4 = (h4 + e) & 0xFFFFFFFF
    
    # 40-वर्ण हेक्स स्ट्रिंग के रूप में वापस करें
    return f"{h0:08x}{h1:08x}{h2:08x}{h3:08x}{h4:08x}"

# hashlib के बिना फिर से लिखा गया कोड
def compute_hashes(pieces):
    hashes = []
    for piece in pieces:  # मानते हुए कि pieces बाइट चंक्स की एक सूची है
        hash_value = custom_sha1(piece)
        hashes.append(hash_value)
    return hashes

# उपयोग का उदाहरण
pieces = [b"hello", b"world"]
hashes = compute_hashes(pieces)
print(hashes)
```

#### यह मूल कोड से कैसे मेल खाता है
- **`hash_obj = hashlib.sha1(piece)`**: `custom_sha1(piece)` द्वारा प्रतिस्थापित, जो SHA-1 हैश को मैन्युअल रूप से कंप्यूट करता है।
- **`hashes.append(hash_obj.hexdigest())`**: `custom_sha1` फ़ंक्शन सीधे हेक्स स्ट्रिंग लौटाता है, इसलिए हम इसे `hashes` में जोड़ते हैं।
- **`return hashes`**: वही रहता है, हैश स्ट्रिंग्स की सूची वापस करता है।

---

### मुख्य अंतर और चेतावनियां
- **सरलीकरण**: यह इम्प्लीमेंटेशन मानता है कि प्रत्येक `piece` एक 512-बिट ब्लॉक (पैडिंग के कारण 56 बाइट्स से कम) में फिट बैठता है। एक पूर्ण SHA-1 इम्प्लीमेंटेशन कई ब्लॉकों को हैंडल करेगा।
- **प्रदर्शन**: एक मैन्युअल इम्प्लीमेंटेशन `hashlib` की तुलना में धीमा और कम ऑप्टिमाइज़्ड होता है।
- **विश्वसनीयता**: `hashlib` जैसी लाइब्रेरियां परीक्षणित और सुरक्षित होती हैं; एक कस्टम संस्करण में तब तक बग्स हो सकते हैं जब तक कि उसका पूरी तरह से सत्यापन न किया गया हो।

संक्षेप में, मूल कोड SHA-1 हैश की कुशलतापूर्वक गणना करने के लिए एक शॉर्टकट के रूप में `hashlib` का उपयोग करता है, जबकि लाइब्रेरी के बिना करने के लिए पूरे SHA-1 एल्गोरिदम को मैन्युअल रूप से कोड करने, पैडिंग को हैंडल करने और परिणाम को हेक्साडेसिमल फॉर्मेट में बदलने की आवश्यकता होती है। लॉजिक वही रहता है: प्रत्येक टुकड़े को प्रोसेस करें, उसके हैश की गणना करें, उसे स्टोर करें, और संग्रह को वापस करें।