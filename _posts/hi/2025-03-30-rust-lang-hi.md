---
audio: false
generated: true
lang: hi
layout: post
title: रस्ट प्रोग्रामिंग भाषा
translated: true
type: note
---

ठीक है, यहाँ रस्ट प्रोग्रामिंग भाषा का एक व्यापक मार्गदर्शिका है, जो इसकी मूल अवधारणाओं, सिंटैक्स और उन्नत सुविधाओं को कवर करती है। रस्ट सुरक्षा, गति और समवर्तीता (concurrency) पर केंद्रित एक सिस्टम्स प्रोग्रामिंग भाषा है।

**I. रस्ट का परिचय**

* **रस्ट क्या है?**
    * रस्ट एक बहु-प्रतिमान (multi-paradigm), स्टैटिकली टाइप की गई, कंपाइल्ड प्रोग्रामिंग भाषा है जिसे परफॉर्मेंस और सुरक्षा के लिए डिज़ाइन किया गया है, विशेष रूप से सिस्टम्स प्रोग्रामिंग, गेम इंजन, वेब असेंबली और एम्बेडेड सिस्टम जैसे क्षेत्रों में।
    * यह स्वामित्व (ownership), उधार (borrowing), और जीवनकाल (lifetimes) की एक प्रणाली के माध्यम से गार्बेज कलेक्टर के बिना मेमोरी सुरक्षा प्राप्त करती है।
    * रस्ट जीरो-कॉस्ट एब्स्ट्रक्शन पर जोर देती है, जिसका अर्थ है कि आपको महत्वपूर्ण रनटाइम ओवरहेड के बिना उच्च-स्तरीय सुविधाएँ मिलती हैं।
* **मुख्य विशेषताएँ और डिज़ाइन सिद्धांत:**
    * **मेमोरी सुरक्षा:** कंपाइल टाइम पर नल पॉइंटर डेरिफरेंस, डेटा रेस और बफर ओवरफ्लो जैसी सामान्य बग्स को रोकती है।
    * **डेटा रेस के बिना समवर्तीता (Concurrency):** स्वामित्व प्रणाली सुरक्षित समवर्ती कोड लिखना आसान बनाती है।
    * **प्रदर्शन (Performance):** निम्न-स्तरीय नियंत्रण, जीरो-कॉस्ट एब्स्ट्रक्शन और कुशल कंपाइलेशन उत्कृष्ट प्रदर्शन की ओर ले जाते हैं, जो अक्सर C++ के तुलनीय होता है।
    * **व्यंजक टाइप सिस्टम (Expressive Type System):** शक्तिशाली टाइप इंफरेंस, जेनरिक्स, ट्रेट्स (इंटरफेस या टाइप क्लासेस के समान), और बीजगणितीय डेटा प्रकार (algebraic data types)।
    * **उत्कृष्ट टूलिंग:** कार्गो (बिल्ड सिस्टम और पैकेज मैनेजर), rustfmt (कोड फॉर्मेटर), क्लिप्पी (लिंटर)।
    * **बढ़ता हुआ इकोसिस्टम:** पुस्तकालयों और फ्रेमवर्क की बढ़ती संख्या के साथ एक जीवंत और सक्रिय समुदाय।
* **उपयोग के मामले:**
    * ऑपरेटिंग सिस्टम
    * गेम इंजन
    * वेब असेंबली (Wasm)
    * एम्बेडेड सिस्टम
    * कमांड-लाइन टूल्स
    * नेटवर्क प्रोग्रामिंग
    * क्रिप्टोकरेंसी
    * हाई-परफॉर्मेंस कंप्यूटिंग

**II. अपने रस्ट वातावरण की स्थापना**

* **इंस्टालेशन:**
    * रस्ट इंस्टॉल करने का अनुशंसित तरीका `rustup` का उपयोग करना है, जो आधिकारिक रस्ट टूलचेन इंस्टॉलर है।
    * [https://rustup.rs/](https://rustup.rs/) पर जाएं और अपने ऑपरेटिंग सिस्टम के लिए निर्देशों का पालन करें।
    * यूनिक्स-जैसी प्रणालियों पर, आप आमतौर पर इस तरह का एक कमांड चलाएंगे: `curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh`
* **इंस्टालेशन सत्यापन:**
    * अपना टर्मिनल या कमांड प्रॉम्प्ट खोलें और चलाएँ:
        * `rustc --version`: रस्ट कंपाइलर संस्करण दिखाता है।
        * `cargo --version`: कार्गो संस्करण दिखाता है।
* **कार्गो: रस्ट बिल्ड सिस्टम और पैकेज मैनेजर:**
    * रस्ट प्रोजेक्ट्स को प्रबंधित करने के लिए कार्गो आवश्यक है। यह संभालता है:
        * आपके कोड का निर्माण (building)।
        * निर्भरताओं (crates) का प्रबंधन।
        * टेस्ट चलाना।
        * लाइब्रेरीज प्रकाशित करना।
    * **नया प्रोजेक्ट बनाना:** `cargo new <project_name>` (एक बाइनरी प्रोजेक्ट बनाता है)। `cargo new --lib <library_name>` (एक लाइब्रेरी प्रोजेक्ट बनाता है)।
    * **प्रोजेक्ट संरचना:** एक विशिष्ट कार्गो प्रोजेक्ट में होता है:
        * `Cargo.toml`: मैनिफेस्ट फ़ाइल जिसमें प्रोजेक्ट मेटाडेटा और निर्भरताएँ शामिल होती हैं।
        * `src/main.rs`: बाइनरी प्रोजेक्ट्स के लिए एंट्री पॉइंट।
        * `src/lib.rs`: लाइब्रेरी प्रोजेक्ट्स के लिए एंट्री पॉइंट।
        * `Cargo.lock`: प्रोजेक्ट में उपयोग की गई निर्भरताओं के सटीक संस्करणों को रिकॉर्ड करता है।
    * **बिल्डिंग:** `cargo build` (प्रोजेक्ट को डीबग मोड में बनाता है)। `cargo build --release` (रिलीज़ के लिए ऑप्टिमाइज़ेशन के साथ प्रोजेक्ट बनाता है)।
    * **रनिंग:** `cargo run` (बाइनरी को बनाता है और चलाता है)।
    * **निर्भरताएँ जोड़ना:** `Cargo.toml` के `[dependencies]` सेक्शन में क्रेट नाम और संस्करण जोड़ें। कार्गो स्वचालित रूप से उन्हें डाउनलोड और बिल्ड करेगा।
    * **निर्भरताएँ अपडेट करना:** `cargo update`।

**III. बुनियादी रस्ट सिंटैक्स और अवधारणाएँ**

* **Hello, World!**
    ```rust
    fn main() {
        println!("Hello, world!");
    }
    ```
    * `fn main()`: मुख्य फ़ंक्शन जहां प्रोग्राम निष्पादन शुरू होता है।
    * `println!()`: एक मैक्रो (`!` द्वारा इंगित) जो कंसोल पर टेक्स्ट प्रिंट करता है।
* **चर और परिवर्तनशीलता (Variables and Mutability):**
    * चर डिफ़ॉल्ट रूप से अपरिवर्तनीय (immutable) होते हैं। एक चर को परिवर्तनशील (mutable) बनाने के लिए, `mut` कीवर्ड का उपयोग करें।
    * घोषणा: `let variable_name = value;` (टाइप इंफरेंस)। `let variable_name: Type = value;` (स्पष्ट टाइप एनोटेशन)।
    * परिवर्तनशील चर: `let mut counter = 0; counter = 1;`
    * स्थिरांक (Constants): `const` के साथ घोषित, इसमें टाइप एनोटेशन होना चाहिए, और इसका मान कंपाइल टाइम पर ज्ञात होना चाहिए। `const MAX_POINTS: u32 = 100_000;`
    * छायांकन (Shadowing): आप पिछले वाले के समान नाम के साथ एक नया चर घोषित कर सकते हैं; नया चर पुराने वाले को ओवरशैडो करता है।
* **डेटा प्रकार:**
    * **स्केलर प्रकार (Scalar Types):** एक एकल मान का प्रतिनिधित्व करते हैं।
        * **पूर्णांक (Integers):** `i8`, `i16`, `i32`, `i64`, `i128`, `isize` (पॉइंटर-साइज्ड साइन्ड); `u8`, `u16`, `u32`, `u64`, `u128`, `usize` (पॉइंटर-साइज्ड अनसाइन्ड)। पूर्णांक लिटरल्स में सफ़िक्स हो सकते हैं (जैसे, `10u32`)।
        * **फ्लोटिंग-पॉइंट नंबर:** `f32` (सिंगल-प्रिसिजन), `f64` (डबल-प्रिसिजन)।
        * **बूलियन:** `bool` (`true`, `false`)।
        * **कैरेक्टर:** `char` (यूनिकोड स्केलर वैल्यू, 4 बाइट्स)।
        * **यूनिट टाइप:** `()` (एक खाली टपल या मान की अनुपस्थिति का प्रतिनिधित्व करता है)।
    * **कंपाउंड प्रकार (Compound Types):** एकाधिक मानों को समूहित करते हैं।
        * **टपल (Tuples):** संभावित रूप से अलग-अलग प्रकार के तत्वों के फिक्स्ड-साइज ऑर्डर्ड अनुक्रम। `let my_tuple = (1, "hello", 3.14); let (x, y, z) = my_tuple; let first = my_tuple.0;`
        * **ऐरे (Arrays):** एक ही प्रकार के तत्वों के फिक्स्ड-साइज संग्रह। `let my_array = [1, 2, 3, 4, 5]; let months: [&str; 12] = ["...", "..."]; let first = my_array[0];`
        * **स्लाइस (Slices):** किसी ऐरे या दूसरी स्लाइस में तत्वों के सन्निकट अनुक्रम (contiguous sequence) में डायनामिकली साइज्ड व्यू। `let slice = &my_array[1..3];`
    * **अन्य महत्वपूर्ण प्रकार:**
        * **स्ट्रिंग्स:**
            * `String`: बढ़ने योग्य, परिवर्तनशील, स्वामित्व वाली स्ट्रिंग डेटा। `String::from("...")` का उपयोग करके या अन्य स्ट्रिंग प्रकारों को कनवर्ट करके बनाई जाती है।
            * `&str`: स्ट्रिंग स्लाइस, स्ट्रिंग डेटा में एक अपरिवर्तनीय व्यू। अक्सर "स्ट्रिंग लिटरल" कहलाता है जब सीधे कोड में एम्बेडेड होता है (जैसे, `"hello"`)।
        * **वेक्टर (`Vec<T>`):** आकार बदलने योग्य ऐरे जो बढ़ या सिकुड़ सकते हैं। `let mut my_vec: Vec<i32> = Vec::new(); my_vec.push(1); let another_vec = vec![1, 2, 3];`
        * **हैश मैप (`HashMap<K, V>`):** कुंजी-मान जोड़े संग्रहीत करते हैं जहां कुंजियाँ अद्वितीय और हैश करने योग्य प्रकार की होती हैं। इसके लिए `use std::collections::HashMap;` की आवश्यकता होती है।
* **ऑपरेटर्स:**
    * **अंकगणित (Arithmetic):** `+`, `-`, `*`, `/`, `%`।
    * **तुलना (Comparison):** `==`, `!=`, `>`, `<`, `>=`, `<=`।
    * **तार्किक (Logical):** `&&` (AND), `||` (OR), `!` (NOT)।
    * **बिटवाइज़ (Bitwise):** `&` (AND), `|` (OR), `^` (XOR), `!` (NOT), `<<` (Left Shift), `>>` (Right Shift)।
    * **असाइनमेंट (Assignment):** `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`।
* **नियंत्रण प्रवाह (Control Flow):**
    * **`if`, `else if`, `else`:** सशर्त निष्पादन।
        ```rust
        let number = 7;
        if number < 5 {
            println!("condition was true");
        } else if number == 7 {
            println!("number is seven");
        } else {
            println!("condition was false");
        }
        ```
    * **`loop`:** अनंत लूप (बाहर निकलने के लिए `break` का उपयोग करें)।
        ```rust
        loop {
            println!("again!");
            break;
        }
        ```
    * **`while`:** लूप जो तब तक जारी रहता है जब तक एक शर्त सत्य है।
        ```rust
        let mut counter = 0;
        while counter < 5 {
            println!("counter is {}", counter);
            counter += 1;
        }
        ```
    * **`for`:** संग्रहों पर पुनरावृत्ति (iterating)।
        ```rust
        let a = [10, 20, 30, 40, 50];
        for element in a.iter() {
            println!("the value is: {}", element);
        }

        for number in 1..5 { // 1 से 5 तक (5 शामिल नहीं) पुनरावृत्ति करता है
            println!("{}", number);
        }
        ```
    * **`match`:** एक शक्तिशाली नियंत्रण प्रवाह कंस्ट्रक्ट जो एक मान की तुलना पैटर्न की एक श्रृंखला से करता है।
        ```rust
        let number = 3;
        match number {
            1 => println!("one"),
            2 | 3 => println!("two or three"),
            4..=6 => println!("four, five, or six"),
            _ => println!("something else"), // वाइल्डकार्ड पैटर्न
        }
        ```
    * **`if let`:** एनम या ऑप्शन को हैंडल करने का एक अधिक संक्षिप्त तरीका जहां आप केवल एक या कुछ वेरिएंट की परवाह करते हैं।
        ```rust
        let some_value = Some(5);
        if let Some(x) = some_value {
            println!("The value is: {}", x);
        }
        ```

**IV. स्वामित्व, उधार, और जीवनकाल (Ownership, Borrowing, and Lifetimes)**

यह रस्ट की मेमोरी सुरक्षा गारंटी का मूल है।

* **स्वामित्व (Ownership):**
    * रस्ट में प्रत्येक मान का एक चर होता है जो उसका *मालिक* होता है।
    * एक समय में एक मान का केवल एक ही मालिक हो सकता है।
    * जब मालिक स्कोप से बाहर हो जाता है, तो मान ड्रॉप हो जाएगा (उसकी मेमोरी डीअलोकेट हो जाती है)।
* **उधार (Borrowing):**
    * स्वामित्व स्थानांतरित करने के बजाय, आप किसी मान के संदर्भ (references) बना सकते हैं। इसे *उधार* कहा जाता है।
    * **अपरिवर्तनीय उधार (`&`):** आपके पास एक ही समय में एक मान के कई अपरिवर्तनीय संदर्भ हो सकते हैं। अपरिवर्तनीय उधार उधार लिए गए मान में संशोधन की अनुमति नहीं देते हैं।
    * **परिवर्तनशील उधार (`&mut`):** आपके पास एक समय में किसी मान का अधिकतम एक परिवर्तनशील संदर्भ हो सकता है। परिवर्तनशील उधार उधार लिए गए मान में संशोधन की अनुमति देते हैं।
    * **उधार के नियम:**
        1.  किसी भी समय, आपके पास *या तो* एक परिवर्तनशील संदर्भ *या* कोई भी संख्या में अपरिवर्तनीय संदर्भ हो सकते हैं।
        2.  संदर्भ हमेशा वैध होने चाहिए।
* **जीवनकाल (Lifetimes):**
    * जीवनकाल एनोटेशन हैं जो उस स्कोप का वर्णन करते हैं जिसके लिए एक संदर्भ वैध है। रस्ट कंपाइलर यह सुनिश्चित करने के लिए जीवनकाल जानकारी का उपयोग करता है कि संदर्भ उस डेटा से अधिक समय तक जीवित न रहें जिसकी वे ओर इशारा करते हैं (डैंगलिंग पॉइंटर्स)।
    * कई मामलों में, कंपाइलर स्वचालित रूप से जीवनकाल का अनुमान लगा सकता है (लाइफटाइम एलिजन)।
    * आपको फ़ंक्शन सिग्नेचर या स्ट्रक्ट डेफिनिशन में जीवनकाल को स्पष्ट रूप से एनोटेट करने की आवश्यकता हो सकती है जब संदर्भों के जीवनकाल स्पष्ट नहीं होते हैं।
    * स्पष्ट जीवनकाल एनोटेशन का उदाहरण:
        ```rust
        fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
            if x.len() > y.len() {
                x
            } else {
                y
            }
        }
        ```
        `'a` इंगित करता है कि लौटाई गई स्ट्रिंग स्लाइस कम से कम उतने ही समय तक जीवित रहेगी जितने समय तक दोनों इनपुट स्ट्रिंग स्लाइस जीवित रहती हैं।

**V. स्ट्रक्ट्स, एनम्स, और मॉड्यूल्स**

* **स्ट्रक्ट्स (Structs):** उपयोगकर्ता-परिभाषित डेटा प्रकार जो नामित फ़ील्ड्स को एक साथ समूहित करते हैं।
    ```rust
    struct User {
        active: bool,
        username: String,
        email: String,
        sign_in_count: u64,
    }

    fn main() {
        let mut user1 = User {
            active: true,
            username: String::from("someusername123"),
            email: String::from("someone@example.com"),
            sign_in_count: 1,
        };

        user1.email = String::from("another@example.com");

        let user2 = User {
            email: String::from("another@example.com"),
            ..user1 // स्ट्रक्ट अपडेट सिंटैक्स, user1 से शेष फ़ील्ड्स
        };
    }
    ```
    * टपल स्ट्रक्ट्स: बिना नामित फ़ील्ड वाले नामित टपल। `struct Color(i32, i32, i32);`
    * यूनिट-लाइक स्ट्रक्ट्स: बिना फ़ील्ड वाली स्ट्रक्ट्स। `struct AlwaysEqual;`
* **एनम्स (Enumerations):** इसके संभावित वेरिएंट्स को गिनाकर एक प्रकार को परिभाषित करते हैं।
    ```rust
    enum Message {
        Quit,
        Move { x: i32, y: i32 }, // अनाम स्ट्रक्ट
        Write(String),
        ChangeColor(i32, i32, i32), // टपल-लाइक
    }

    fn main() {
        let q = Message::Quit;
        let m = Message::Move { x: 10, y: 5 };
        let w = Message::Write(String::from("hello"));

        match m {
            Message::Quit => println!("Quit"),
            Message::Move { x, y } => println!("Move to x={}, y={}", x, y),
            Message::Write(text) => println!("Write: {}", text),
            Message::ChangeColor(r, g, b) => println!("Change color to r={}, g={}, b={}", r, g, b),
        }
    }
    ```
    * एनम्स अपने वेरिएंट्स के भीतर सीधे डेटा रख सकते हैं।
* **मॉड्यूल्स (Modules):** क्रेट्स (पैकेज) के भीतर कोड को व्यवस्थित करते हैं।
    * एक मॉड्यूल को परिभाषित करने के लिए `mod` कीवर्ड का उपयोग करें।
    * मॉड्यूल में अन्य मॉड्यूल, स्ट्रक्ट्स, एनम्स, फ़ंक्शन आदि शामिल हो सकते हैं।
    * `pub` (सार्वजनिक) और निजी (डिफ़ॉल्ट) के साथ दृश्यता नियंत्रित करें।
    * मॉड्यूल पथ का उपयोग करके मॉड्यूल के भीतर आइटम्स तक पहुंचें (जैसे, `my_module::my_function()`)।
    * `use` कीवर्ड के साथ आइटम्स को वर्तमान स्कोप में लाएं (जैसे, `use std::collections::HashMap;`)।
    * अलग-अलग फाइलों में मॉड्यूल को अलग करें (कन्वेंशन: `my_module` नामक एक मॉड्यूल `src/my_module.rs` या `src/my_module/mod.rs` में जाता है)।

**VI. ट्रेट्स और जेनरिक्स**

* **ट्रेट्स (Traits):** अन्य भाषाओं में इंटरफेस या टाइप क्लासेस के समान। वे विधियों के एक सेट को परिभाषित करते हैं जिन्हें एक निश्चित अनुबंध को पूरा करने के लिए एक प्रकार को लागू करना होगा।
    ```rust
    pub trait Summary {
        fn summarize(&self) -> String;
    }

    pub struct NewsArticle {
        pub headline: String,
        pub location: String,
        pub author: String,
        pub content: String,
    }

    impl Summary for NewsArticle {
        fn summarize(&self) -> String {
            format!("{}, by {} ({})", self.headline, self.author, self.location)
        }
    }

    pub struct Tweet {
        pub username: String,
        pub content: String,
        pub reply: bool,
        pub retweet: bool,
    }

    impl Summary for Tweet {
        fn summarize(&self) -> String {
            format!("{}: {}", self.username, self.content)
        }
    }

    fn main() {
        let tweet = Tweet {
            username: String::from("horse_ebooks"),
            content: String::from("of course, as you probably already know, people"),
            reply: false,
            retweet: false,
        };

        println!("New tweet available! {}", tweet.summarize());
    }
    ```
    * ट्रेट्स में विधियों के लिए डिफ़ॉल्ट कार्यान्वयन हो सकते हैं।
    * ट्रेट्स का उपयोग जेनरिक प्रकारों के लिए बाउंड्स के रूप में किया जा सकता है।
* **जेनरिक्स (Generics):** ऐसा कोड लिखें जो कंपाइल टाइम पर विशिष्ट प्रकारों को जाने बिना कई प्रकारों के साथ काम कर सके।
    ```rust
    fn largest<T: PartialOrd + Copy>(list: &[T]) -> T {
        let mut largest = list[0];

        for &item in list.iter() {
            if item > largest {
                largest = item;
            }
        }

        largest
    }

    fn main() {
        let number_list = vec![34, 50, 25, 100, 65];
        let result = largest(&number_list);
        println!("The largest number is {}", result);

        let char_list = vec!['y', 'm', 'a', 'q'];
        let result = largest(&char_list);
        println!("The largest char is {}", result);
    }
    ```
    * टाइप पैरामीटर को एंगल ब्रैकेट्स `<T>` के भीतर घोषित किया जाता है।
    * ट्रेट बाउंड्स (`T: PartialOrd + Copy`) निर्दिष्ट करते हैं कि जेनरिक प्रकार को क्या कार्यक्षमता लागू करनी होगी।
    * `PartialOrd` `>` का उपयोग करके तुलना की अनुमति देता है, और `Copy` का अर्थ है कि प्रकार को मान द्वारा कॉपी किया जा सकता है।

**VII. त्रुटि प्रबंधन (Error Handling)**

रस्ट स्पष्ट त्रुटि प्रबंधन पर जोर देता है।

* **`Result` एनम:** या तो सफलता (`Ok`) या विफलता (`Err`) का प्रतिनिधित्व करता है।
    ```rust
    enum Result<T, E> {
        Ok(T),
        Err(E),
    }
    ```
    * `T` सफलता मान का प्रकार है।
    * `E` त्रुटि मान का प्रकार है।
    * आमतौर पर उन ऑपरेशनों के लिए उपयोग किया जाता है जो विफल हो सकते हैं (जैसे, फ़ाइल I/O, नेटवर्क अनुरोध)।
    * `?` ऑपरेटर `Result` मानों को हैंडल करने के लिए सिंटैक्टिक शुगर है। यदि `Result` `Ok` है, तो यह मान को अनरैप करता है; यदि यह `Err` है, तो यह त्रुटि को वर्तमान फ़ंक्शन से जल्दी लौटा देता है।
* **`panic!` मैक्रो:** प्रोग्राम को तुरंत क्रैश करने का कारण बनता है। आम तौर पर अपूरणीय त्रुटियों के लिए उपयोग किया जाता है।
    ```rust
    fn main() {
        let v = vec![1, 2, 3];
        // v[99]; // यह रनटाइम पर पैनिक का कारण बनेगा
        panic!("Crash and burn!");
    }
    ```
* **`Option` एनम:** एक ऐसे मान का प्रतिनिधित्व करता है जो मौजूद हो भी सकता है और नहीं भी।
    ```rust
    enum Option<T> {
        Some(T),
        None,
    }
    ```
    * नल पॉइंटर्स से बचने के लिए उपयोग किया जाता है।
    * `Option` मानों के साथ काम करने के लिए `unwrap()`, `unwrap_or()`, `map()`, और `and_then()` जैसी विधियों का उपयोग किया जाता है।
    ```rust
    fn divide(a: i32, b: i32) -> Option<i32> {
        if b == 0 {
            None
        } else {
            Some(a / b)
        }
    }

    fn main() {
        let result1 = divide(10, 2);
        match result1 {
            Some(value) => println!("Result: {}", value),
            None => println!("Cannot divide by zero"),
        }

        let result2 = divide(5, 0);
        println!("Result 2: {:?}", result2.unwrap_or(-1)); // None होने पर -1 लौटाता है
    }
    ```

**VIII. क्लोजर्स और इटरेटर्स**

* **क्लोजर्स (Closures):** अनाम फ़ंक्शन जो अपने आसपास के स्कोप से चर को कैप्चर कर सकते हैं।
    ```rust
    fn main() {
        let x = 4;
        let equal_to_x = |z| z == x; // क्लोजर जो x को कैप्चर करता है

        println!("Is 5 equal to x? {}", equal_to_x(5));
    }
    ```
    * क्लोजर सिंटैक्स: `|parameters| -> return_type { body }` (रिटर्न टाइप का अक्सर अनुमान लगाया जा सकता है)।
    * क्लोजर संदर्भ (`&`), परिवर्तनशील संदर्भ (`&mut`), या मान द्वारा (स्वामित्व स्थानांतरित करके) चर को कैप्चर कर सकते हैं। रस्ट कैप्चर प्रकार का अनुमान लगाता है। स्वामित्व स्थानांतरित करने के लिए `move` कीवर्ड का उपयोग करें।
* **इटरेटर्स (Iterators):** तत्वों के अनुक्रम को प्रोसेस करने का एक तरीका प्रदान करते हैं।
    * वेक्टर, ऐरे और हैश मैप जैसे संग्रहों पर `iter()` विधि को कॉल करके बनाए जाते हैं (अपरिवर्तनीय पुनरावृत्ति के लिए), परिवर्तनशील पुनरावृत्ति के लिए `iter_mut()`, और संग्रह का उपभोग करने और उसके तत्वों का स्वामित्व लेने के लिए `into_iter()`।
    * इटरेटर्स आलसी (lazy) होते हैं; वे केवल तभी मान उत्पन्न करते हैं जब स्पष्ट रूप से उपभोग किए जाते हैं।
    * सामान्य इटरेटर एडेप्टर्स (ऐसी विधियाँ जो इटरेटर्स को रूपांतरित करती हैं): `map()`, `filter()`, `take()`, `skip()`, `zip()`, `enumerate()