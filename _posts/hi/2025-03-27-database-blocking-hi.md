---
audio: false
generated: true
lang: hi
layout: post
title: डेटाबेस ब्लॉकिंग
translated: true
type: note
---

मैं मान रहा हूं कि आप डेटाबेस प्रबंधन प्रणालियों (DBMS) के संदर्भ में डेटाबेस ब्लॉकिंग के उदाहरण मांग रहे हैं। ब्लॉकिंग तब होती है जब डेटाबेस में एक लेन-देन (transaction) दूसरे लेन-देन को आगे बढ़ने से रोकता है क्योंकि वे समवर्ती रूप से (concurrently) एक ही डेटा तक पहुंचने या उसे संशोधित करने का प्रयास कर रहे होते हैं। यह आमतौर पर डेटा स्थिरता और अखंडता सुनिश्चित करने के लिए लॉक्स (locks) का उपयोग करके प्रबंधित किया जाता है। नीचे डेटाबेस ब्लॉकिंग परिदृश्यों के कुछ उदाहरण दिए गए हैं:

---

### उदाहरण 1: रीड-राइट ब्लॉकिंग (Read-Write Blocking)
- **परिदृश्य**: लेन-देन T1 एक टेबल में एक पंक्ति को अपडेट कर रहा है (जैसे, किसी ग्राहक का बैलेंस बदलना), और लेन-देन T2 उसी पंक्ति को पढ़ने का प्रयास करता है।
- **क्या होता है**: T1 अपडेट पूरा होने तक अन्य लेन-देन को उस पंक्ति को पढ़ने या संशोधित करने से रोकने के लिए उस पंक्ति पर एक एक्सक्लूसिव लॉक (exclusive lock) प्राप्त कर लेता है। T2 ब्लॉक हो जाता है और उसे T1 के कमिट (commit) या रोल बैक (roll back) होने तक इंतजार करना पड़ता है।
- **SQL उदाहरण**:
  ```sql
  -- लेन-देन T1
  BEGIN TRANSACTION;
  UPDATE Accounts SET Balance = Balance - 100 WHERE AccountID = 1;

  -- लेन-देन T2 (ब्लॉक हो गया)
  SELECT Balance FROM Accounts WHERE AccountID = 1;
  ```
  T2, T1 के खत्म होने तक इंतजार करता है क्योंकि पंक्ति पर एक्सक्लूसिव लॉक है।

---

### उदाहरण 2: राइट-राइट ब्लॉकिंग (Write-Write Blocking)
- **परिदृश्य**: लेन-देन T1 किसी उत्पाद की स्टॉक मात्रा को अपडेट कर रहा है, और लेन-देन T2 उसी समय उसी उत्पाद की स्टॉक को अपडेट करने का प्रयास करता है।
- **क्या होता है**: T1 पंक्ति पर एक्सक्लूसिव लॉक रखता है, और T2 तब तक ब्लॉक रहता है जब तक T1 पूरा नहीं हो जाता। यह उन विरोधी अपडेट्स को रोकता है जो डेटा असंगति (data inconsistency) का कारण बन सकते हैं।
- **SQL उदाहरण**:
  ```sql
  -- लेन-देन T1
  BEGIN TRANSACTION;
  UPDATE Products SET Stock = Stock - 5 WHERE ProductID = 100;

  -- लेन-देन T2 (ब्लॉक हो गया)
  UPDATE Products SET Stock = Stock + 10 WHERE ProductID = 100;
  ```
  T1 के कमिट या रोल बैक होने तक T2 ब्लॉक रहता है।

---

### उदाहरण 3: डेडलॉक (ब्लॉकिंग के कारण गतिरोध)
- **परिदृश्य**: लेन-देन T1, Row A को लॉक करता है और Row B को अपडेट करने की आवश्यकता है, जबकि लेन-देन T2, Row B को लॉक करता है और Row A को अपडेट करने की आवश्यकता है।
- **क्या होता है**: T1, Row B पर T2 के लॉक द्वारा ब्लॉक हो जाता है, और T2, Row A पर T1 के लॉक द्वारा ब्लॉक हो जाता है। इससे एक डेडलॉक (deadlock) बन जाता है, और DBMS को हस्तक्षेप करना पड़ता है (जैसे, एक लेन-देन को रोल बैक करके)।
- **SQL उदाहरण**:
  ```sql
  -- लेन-देन T1
  BEGIN TRANSACTION;
  UPDATE Table1 SET Value = 10 WHERE ID = 1;  -- Row A को लॉक करता है
  UPDATE Table2 SET Value = 20 WHERE ID = 2;  -- T2 द्वारा ब्लॉक हो गया

  -- लेन-देन T2
  BEGIN TRANSACTION;
  UPDATE Table2 SET Value = 30 WHERE ID = 2;  -- Row B को लॉक करता है
  UPDATE Table1 SET Value = 40 WHERE ID = 1;  -- T1 द्वारा ब्लॉक हो गया
  ```
  DBMS द्वारा डेडलॉक को हल किए जाने तक कोई भी लेन-देन आगे नहीं बढ़ सकता।

---

### उदाहरण 4: टेबल-लेवल ब्लॉकिंग (Table-Level Blocking)
- **परिदृश्य**: लेन-देन T1 उचित इंडेक्सिंग (indexing) के बिना पूरी टेबल पर एक बड़ा अपडेट कर रहा है, और लेन-देन T2 उसी टेबल से एक ही पंक्ति को पढ़ने का प्रयास करता है।
- **क्या होता है**: T1 अपने रो-लेवल लॉक्स (row-level locks) को एक टेबल-लेवल लॉक (table-level lock) में बदल सकता है, जिससे T2, T1 के पूरा होने तक असंबंधित पंक्तियों को पढ़ने से भी ब्लॉक हो जाता है।
- **SQL उदाहरण**:
  ```sql
  -- लेन-देन T1
  BEGIN TRANSACTION;
  UPDATE Employees SET Salary = Salary * 1.1;  -- पूरी टेबल को लॉक करता है

  -- लेन-देन T2 (ब्लॉक हो गया)
  SELECT Name FROM Employees WHERE EmployeeID = 5;
  ```
  T2 ब्लॉक हो जाता है क्योंकि T1 के पास टेबल-लेवल एक्सक्लूसिव लॉक है।

---

### ब्लॉकिंग का प्रबंधन कैसे किया जाता है
- **लॉक्स (Locks)**: डेटाबेस पहुंच नियंत्रित करने के लिए शेयर्ड लॉक्स (shared locks - पढ़ने के लिए) और एक्सक्लूसिव लॉक्स (exclusive locks - लिखने के लिए) का उपयोग करते हैं।
- **आइसोलेशन लेवल (Isolation Levels)**: उच्च आइसोलेशन लेवल (जैसे, Serializable) स्थिरता सुनिश्चित करने के लिए ब्लॉकिंग बढ़ाते हैं, जबकि निचले स्तर (जैसे, Read Uncommitted) ब्लॉकिंग को कम करते हैं लेकिन डर्टी रीड्स (dirty reads) का जोखिम बढ़ाते हैं।
- **टाइमआउट (Timeouts)**: लेन-देन बहुत लंबे समय तक ब्लॉक रहने पर टाइमआउट हो सकते हैं, जिससे रोल बैक (rollback) हो जाता है।
- **डेडलॉक डिटेक्शन (Deadlock Detection)**: DBMS डेडलॉक का पता लगाता है और एक लेन-देन को समाप्त करके उन्हें हल करता है।

मुझे बताएं यदि आप किसी विशेष डेटाबेस सिस्टम (जैसे, MySQL, PostgreSQL, SQL Server) के लिए अधिक विवरण या उदाहरण चाहते हैं!