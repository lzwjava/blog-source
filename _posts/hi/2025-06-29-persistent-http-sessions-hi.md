---
audio: false
generated: true
image: false
lang: hi
layout: post
model: x-ai/grok-code-fast-1
title: लगातार HTTP सत्रों के लिए requests.Session का उपयोग
translated: true
type: note
---

### requests.Session कैसे काम करता है

Python की `requests` लाइब्रेरी में, `requests.Session` एक क्लास है जो आपको कई HTTP रिक्वेस्ट्स के बीच एक स्थायी सत्र बनाए रखने की अनुमति देती है। यह अलग-अलग `requests.get()` या इसी तरह के कॉल करने की तुलना में कई लाभ प्रदान करती है:

- **कुकीज़ की स्थिरता**: यह डिफ़ॉल्ट रूप से सर्वर से प्राप्त कुकीज़ को स्वचालित रूप से संग्रहीत करती है और बाद की रिक्वेस्ट्स में भेजती है। यह सत्र-आधारित इंटरैक्शन को सक्षम बनाता है, जैसे एक बार लॉग इन करना और प्रमाणित बने रहना।
- **कनेक्शन पूलिंग**: यह एक ही होस्ट के लिए अंतर्निहित TCP कनेक्शनों का पुन: उपयोग करती है, नए कनेक्शन स्थापित करने के ओवरहेड से बचकर प्रदर्शन में सुधार करती है।
- **साझा कॉन्फ़िगरेशन**: आप डिफ़ॉल्ट हेडर, प्रमाणीकरण, प्रॉक्सी, या अन्य पैरामीटर सेट कर सकते हैं जो सत्र के भीतर सभी रिक्वेस्ट्स पर लागू होते हैं।
- **अंतर्निहित तंत्र**: यह HTTP हैंडलिंग के लिए `urllib3` लाइब्रेरी का उपयोग करती है। जब आप एक `Session` बनाते हैं, तो यह `cookies` (एक `RequestsCookieJar` इंस्टेंस), `headers`, और अन्य जैसी विशेषताओं को इनिशियलाइज़ करती है। उदाहरण के लिए, एक प्रतिक्रिया से कुकीज़ स्वचालित रूप से उसी डोमेन की अगली रिक्वेस्ट में शामिल हो जाती हैं।

यहाँ एक सत्र बनाने और उपयोग करने का एक बुनियादी उदाहरण दिया गया है:

```python
import requests

# एक सत्र बनाएं
session = requests.Session()

# इस सत्र में सभी रिक्वेस्ट्स के लिए एक डिफ़ॉल्ट हेडर सेट करें
session.headers.update({'User-Agent': 'MyApp/1.0'})

# कई रिक्वेस्ट्स करें, सत्र साझा करते हुए
response1 = session.get('https://example.com/login')
response2 = session.post('https://example.com/data', data={'key': 'value'})

# सत्र में संग्रहीत कुकीज़ तक पहुंचें
print(session.cookies)
```

यह सुनिश्चित करता है कि कुकीज़ (जैसे सत्र आईडी) मैन्युअल हस्तक्षेप के बिना पारदर्शी रूप से संभाली जाती हैं।

### Java/Spring प्रोजेक्ट्स की API को कॉल करने के लिए Python का उपयोग करना

Java/Spring (आमतौर पर Spring MVC या Spring Boot के माध्यम से RESTful endpoints) का उपयोग करके बनाई गई API के साथ इंटरैक्ट करने के लिए, आप किसी भी HTTP API की तरह ही `requests.Session` का उपयोग करते हैं। Spring प्रोजेक्ट्स अक्सर HTTP/HTTPS पर API एक्सपोज़ करते हैं, और यदि लागू किया गया हो तो `requests` प्रमाणीकरण, CSRF टोकन, या दर सीमित करने को संभाल सकता है।

- **प्रमाणीकरण**: Spring फॉर्म, JWT, या OAuth के साथ Spring Security का उपयोग कर सकता है। सत्र-आधारित प्रमाणीकरण (जैसे, लॉगिन फॉर्म के माध्यम से) के लिए, लॉगिन रिक्वेस्ट के बाद `requests.Session` कुकी हैंडलिंग को स्वचालित करता है।
- **कॉल करना**: मानक HTTP मेथड जैसे `GET`, `POST`, आदि का उपयोग करें। यदि Spring API को JSON पेलोड की आवश्यकता होती है, तो `json=your_data` पास करें।

एक Spring-प्रमाणित API में लॉग इन करने और दूसरे एंडपॉइंट को कॉल करने का उदाहरण:

```python
import requests

session = requests.Session()

# लॉग इन करें (मान लें कि /login को username/password के साथ एक POST)
login_payload = {'username': 'user', 'password': 'pass'}
response = session.post('https://spring-api.example.com/login', data=login_payload)

if response.ok:
    # अब एक और API एंडपॉइंट को कॉल करें, सत्र कुकीज़ बनी रहती हैं
    data_response = session.get('https://spring-api.example.com/api/data')
    print(data_response.json())
else:
    print("Login failed")
```

Spring API डिफ़ॉल्ट रूप से स्टेटलेस होते हैं लेकिन सर्वर-साइड स्टोरेज (जैसे, Tomcat या एम्बेडेड सर्वर में) के माध्यम से सत्रों का प्रबंधन कर सकते हैं। सुनिश्चित करें कि आपका Python क्लाइंट Spring द्वारा आवश्यक किसी भी CORS, CSRF, या कस्टम हेडर को संभालता है।

### Java/Spring साइड में JSESSIONID से संबंध

- **JSESSIONID क्या है?**: Java वेब एप्लिकेशन (जिसमें Spring शामिल है, जो अक्सर Servlet कंटेनर जैसे Tomcat पर चलता है) में, JSESSIONID एक मानक HTTP कुकी है जिसका उपयोग कंटेनर द्वारा उपयोगकर्ता सत्रों को ट्रैक करने के लिए किया जाता है। यह तब सेट होती है जब एक सत्र बनाया जाता है (जैसे, लॉगिन के बाद) और प्रतिक्रियाओं में वापस भेजी जाती है। क्लाइंट साइड पर, ब्राउज़र (या HTTP क्लाइंट जैसे `requests`) राज्य बनाए रखने के लिए, जैसे उपयोगकर्ता प्रमाणीकरण या शॉपिंग कार्ट डेटा, बाद की रिक्वेस्ट्स में इसे शामिल करते हैं।
- **यह requests.Session से कैसे संबंधित है**: `requests.Session` JSESSIONID को किसी अन्य कुकी की तरह मानती है—यह इसे सर्वर के "Set-Cookie" हेडर से स्वचालित रूप से संग्रहीत करती है और भविष्य की रिक्वेस्ट्स के "Cookie" हेडर में शामिल करती है। यह कुकीज़ को मैन्युअल रूप से पार्स/निकाले बिना स्टेटफ़ुल Spring API के साथ सहज इंटरैक्शन को सक्षम बनाता है।
- **सर्वर-साइड हैंडलिंग**: Java/Spring साइड पर, ServletContext सत्रों का प्रबंधन करता है। जब आपका Python क्लाइंट JSESSIONID के साथ एक रिक्वेस्ट भेजता है, तो Spring का HttpSession संबंधित सर्वर-साइड डेटा पुनर्प्राप्त करता है। यदि यह समाप्त हो गया है या अमान्य है, तो Spring पुन: प्रमाणीकरण की आवश्यकता हो सकती है। सुरक्षित सत्रों के लिए, सुनिश्चित करें कि आपका सेटअप HTTPS का उपयोग करता है, क्योंकि JSESSIONID HTTP पर चोरी के लिए असुरक्षित हो सकता है।
- **संभावित समस्याएं**: यदि Spring CSRF टोकन या अन्य सुरक्षा उपायों को लागू करता है, तो आपको उन्हें निकालने और शामिल करने की आवश्यकता हो सकती है (जैसे, छिपे हुए फॉर्म फ़ील्ड से)। स्टेटलेस JWT-आधारित Spring API के लिए, `requests.Session` अभी भी हेडर में ऑथ टोकन जमा करके मदद करता है, लेकिन JSESSIONID कम प्रासंगिक हो जाता है।

यदि आपको Spring API को कॉल करते समय विशिष्ट त्रुटियाँ (जैसे, 401 अनअथॉराइज्ड) का सामना करना पड़ता है, तो कुकी समस्याओं के लिए नेटवर्क लॉग्स की जाँच करें या `import logging; logging.basicConfig(level=logging.DEBUG)` के साथ `requests` डिबगिंग सक्षम करें। Spring Security के बारे में अधिक जानकारी के लिए, उनके आधिकारिक दस्तावेज़ देखें।