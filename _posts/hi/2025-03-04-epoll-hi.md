---
audio: false
generated: true
lang: hi
layout: post
title: लिनक्स में ईपोल का उपयोग
translated: true
type: note
---

`epoll` एक Linux सिस्टम कॉल है जो इवेंट्स के लिए कई फ़ाइल डिस्क्रिप्टर्स की कुशलता से निगरानी करने के लिए डिज़ाइन किया गया है, जैसे कि जब डेटा पढ़ने के लिए उपलब्ध हो या कोई सॉकेट लिखने के लिए तैयार हो। यह नेटवर्क प्रोग्रामिंग में विशेष रूप से उपयोगी है, जहाँ एक सर्वर को एक साथ कई कनेक्शन हैंडल करने की आवश्यकता हो सकती है। `select` या `poll` जैसी पुरानी तंत्रों की तुलना में, `epoll` बड़ी संख्या में फ़ाइल डिस्क्रिप्टर्स के साथ बेहतर स्केल करता है क्योंकि यह रेडीनेस के लिए सभी डिस्क्रिप्टर्स को बार-बार स्कैन करने से बचता है।

यहाँ Linux में `epoll` का उपयोग करने के लिए एक चरण-दर-चरण मार्गदर्शिका दी गई है, जिसके बाद एक सरल सर्वर का उदाहरण दिया गया है जो कनेक्शन स्वीकार करता है और डेटा को वापस इको करता है।

---

## `epoll` का उपयोग करने के चरण

### 1. **एक Epoll इंस्टेंस बनाएँ**
`epoll` का उपयोग शुरू करने के लिए, आपको एक epoll इंस्टेंस बनाने की आवश्यकता होती है, जिसे एक फ़ाइल डिस्क्रिप्टर द्वारा दर्शाया जाता है। `epoll_create1` सिस्टम कॉल का उपयोग करें:

```c
int epoll_fd = epoll_create1(0);
```
- **पैरामीटर**: बेसिक उपयोग के लिए `0` पास करें (कोई विशेष फ्लैग नहीं)। उन्नत परिदृश्यों के लिए `EPOLL_CLOEXEC` जैसे फ्लैग्स का उपयोग किया जा सकता है।
- **रिटर्न वैल्यू**: सफलता पर एक फ़ाइल डिस्क्रिप्टर (`epoll_fd`) लौटाता है, या त्रुटि पर `-1` लौटाता है (विवरण के लिए `errno` जांचें)।

पुराना `epoll_create` फ़ंक्शन समान है लेकिन एक साइज़ हिंट लेता है (अब नजरअंदाज कर दिया जाता है), इसलिए `epoll_create1` को प्राथमिकता दी जाती है।

### 2. **निगरानी के लिए फ़ाइल डिस्क्रिप्टर्स जोड़ें**
फ़ाइल डिस्क्रिप्टर्स (जैसे, सॉकेट्स) को epoll इंस्टेंस के साथ पंजीकृत करने और उन इवेंट्स को निर्दिष्ट करने के लिए जिन्हें आप निगरानी करना चाहते हैं, `epoll_ctl` का उपयोग करें:

```c
struct epoll_event ev;
ev.events = EPOLLIN;  // पठनीयता के लिए निगरानी करें
ev.data.fd = some_fd; // निगरानी के लिए फ़ाइल डिस्क्रिप्टर
epoll_ctl(epoll_fd, EPOLL_CTL_ADD, some_fd, &ev);
```
- **पैरामीटर्स**:
  - `epoll_fd`: Epoll इंस्टेंस फ़ाइल डिस्क्रिप्टर।
  - `EPOLL_CTL_ADD`: एक फ़ाइल डिस्क्रिप्टर जोड़ने का ऑपरेशन।
  - `some_fd`: निगरानी के लिए फ़ाइल डिस्क्रिप्टर (जैसे, एक सॉकेट)।
  - `&ev`: एक `struct epoll_event` का पॉइंटर जो इवेंट्स और वैकल्पिक यूजर डेटा को परिभाषित करता है।
- **सामान्य इवेंट्स**:
  - `EPOLLIN`: पढ़ने के लिए डेटा उपलब्ध।
  - `EPOLLOUT`: लिखने के लिए तैयार।
  - `EPOLLERR`: त्रुटि हुई।
  - `EPOLLHUP`: हंग-अप (जैसे, कनेक्शन बंद)।
- **यूजर डेटा**: `struct epoll_event` में `data` फ़ील्ड एक फ़ाइल डिस्क्रिप्टर (जैसा कि दिखाया गया है) या अन्य डेटा (जैसे, एक पॉइंटर) स्टोर कर सकती है ताकि इवेंट्स होने पर स्रोत की पहचान की जा सके।

### 3. **इवेंट्स की प्रतीक्षा करें**
निगरानी किए गए फ़ाइल डिस्क्रिप्टर्स पर इवेंट्स के लिए ब्लॉक करने और प्रतीक्षा करने के लिए `epoll_wait` का उपयोग करें:

```c
struct epoll_event events[MAX_EVENTS];
int nfds = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);
```
- **पैरामीटर्स**:
  - `epoll_fd`: Epoll इंस्टेंस।
  - `events`: ट्रिगर किए गए इवेंट्स को स्टोर करने के लिए ऐरे।
  - `MAX_EVENTS`: लौटाए जाने वाले इवेंट्स की अधिकतम संख्या (ऐरे का आकार)।
  - `-1`: मिलीसेकंड में टाइमआउट (`-1` का मतलब है अनिश्चित काल तक प्रतीक्षा करें; `0` तुरंत लौटता है)।
- **रिटर्न वैल्यू**: इवेंट्स वाले फ़ाइल डिस्क्रिप्टर्स की संख्या (`nfds`), या त्रुटि पर `-1`।

### 4. **इवेंट्स को हैंडल करें**
`epoll_wait` द्वारा लौटाए गए इवेंट्स के माध्यम से लूप करें और उन्हें प्रोसेस करें:

```c
for (int i = 0; i < nfds; i++) {
    if (events[i].events & EPOLLIN) {
        // फ़ाइल डिस्क्रिप्टर events[i].data.fd पठनीय है
    }
}
```
- इवेंट प्रकार निर्धारित करने के लिए बिटवाइज़ ऑपरेशंस (जैसे, `events[i].events & EPOLLIN`) का उपयोग करके `events` फ़ील्ड की जांच करें।
- यह पहचानने के लिए कि किस फ़ाइल डिस्क्रिप्टर ने इवेंट ट्रिगर किया है, `events[i].data.fd` का उपयोग करें।

### 5. **फ़ाइल डिस्क्रिप्टर्स का प्रबंधन करें (वैकल्पिक)**
- **हटाएँ**: किसी फ़ाइल डिस्क्रिप्टर की निगरानी बंद करने के लिए `EPOLL_CTL_DEL` के साथ `epoll_ctl` का उपयोग करें:
  ```c
  epoll_ctl(epoll_fd, EPOLL_CTL_DEL, some_fd, NULL);
  ```
- **संशोधित करें**: `EPOLL_CTL_MOD` के साथ इवेंट्स समायोजित करें:
  ```c
  ev.events = EPOLLOUT; // लिखने की क्षमता की निगरानी के लिए बदलें
  epoll_ctl(epoll_fd, EPOLL_CTL_MOD, some_fd, &ev);
  ```

---

## मुख्य अवधारणाएँ

### **लेवल-ट्रिगर्ड बनाम एज-ट्रिगर्ड**
- **लेवल-ट्रिगर्ड (डिफ़ॉल्ट)**: `epoll` तब तक बार-बार सूचित करता है जब तक स्थिति बनी रहती है (जैसे, डेटा अनपढ़ा रहता है)। अधिकांश मामलों के लिए सरल।
- **एज-ट्रिगर्ड (`EPOLLET`)**: केवल एक बार सूचित करता है जब स्थिति बदलती है (जैसे, नया डेटा आता है)। इवेंट्स को खोने से बचने के लिए सभी डेटा को `EAGAIN` तक पढ़ने/लिखने की आवश्यकता होती है; अधिक कुशल लेकिन पेचीदा।
- एज-ट्रिगर्ड मोड का उपयोग करने पर `ev.events` में `EPOLLET` सेट करें (जैसे, `EPOLLIN | EPOLLET`)।

### **नॉन-ब्लॉकिंग I/O**
`epoll` को अक्सर I/O ऑपरेशंस पर ब्लॉक होने से रोकने के लिए नॉन-ब्लॉकिंग फ़ाइल डिस्क्रिप्टर्स के साथ जोड़ा जाता है। एक सॉकेट को नॉन-ब्लॉकिंग मोड में सेट करें:

```c
fcntl(fd, F_SETFL, fcntl(fd, F_GETFL) | O_NONBLOCK);
```

---

## उदाहरण: सरल इको सर्वर

नीचे एक सर्वर का एक बुनियादी उदाहरण दिया गया है जो कनेक्शन स्वीकार करने और क्लाइंट को डेटा वापस इको करने के लिए `epoll` का उपयोग करता है। यह सरलता के लिए लेवल-ट्रिगर्ड मोड का उपयोग करता है।

```c
#include <sys/epoll.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>

#define MAX_EVENTS 10
#define PORT 8080

int main() {
    // लिसनिंग सॉकेट बनाएँ
    int listen_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (listen_fd == -1) { perror("socket"); exit(1); }

    struct sockaddr_in addr = { .sin_family = AF_INET, .sin_addr.s_addr = INADDR_ANY, .sin_port = htons(PORT) };
    if (bind(listen_fd, (struct sockaddr*)&addr, sizeof(addr)) == -1) { perror("bind"); exit(1); }
    if (listen(listen_fd, 5) == -1) { perror("listen"); exit(1); }

    // लिसनिंग सॉकेट को नॉन-ब्लॉकिंग पर सेट करें
    fcntl(listen_fd, F_SETFL, fcntl(listen_fd, F_GETFL) | O_NONBLOCK);

    // Epoll इंस्टेंस बनाएँ
    int epoll_fd = epoll_create1(0);
    if (epoll_fd == -1) { perror("epoll_create1"); exit(1); }

    // Epoll में लिसनिंग सॉकेट जोड़ें
    struct epoll_event ev, events[MAX_EVENTS];
    ev.events = EPOLLIN; // लेवल-ट्रिगर्ड
    ev.data.fd = listen_fd;
    if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, listen_fd, &ev) == -1) { perror("epoll_ctl"); exit(1); }

    // इवेंट लूप
    while (1) {
        int nfds = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);
        if (nfds == -1) { perror("epoll_wait"); exit(1); }

        for (int i = 0; i < nfds; i++) {
            int fd = events[i].data.fd;

            if (fd == listen_fd) {
                // नया कनेक्शन स्वीकार करें
                int client_fd = accept(listen_fd, NULL, NULL);
                if (client_fd == -1) { perror("accept"); continue; }

                // क्लाइंट सॉकेट को नॉन-ब्लॉकिंग पर सेट करें
                fcntl(client_fd, F_SETFL, fcntl(client_fd, F_GETFL) | O_NONBLOCK);

                // Epoll में क्लाइंट सॉकेट जोड़ें
                ev.events = EPOLLIN;
                ev.data.fd = client_fd;
                if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, client_fd, &ev) == -1) {
                    perror("epoll_ctl: client_fd");
                    close(client_fd);
                }
            } else {
                // क्लाइंट डेटा को हैंडल करें
                char buf[1024];
                ssize_t n = read(fd, buf, sizeof(buf));
                if (n <= 0) {
                    // त्रुटि या EOF: बंद करें और epoll से हटाएँ
                    if (n == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) continue;
                    close(fd);
                    epoll_ctl(epoll_fd, EPOLL_CTL_DEL, fd, NULL);
                } else {
                    // डेटा को वापस इको करें
                    write(fd, buf, n); // नोट: रियल ऐप्स में, आंशिक राइट्स को हैंडल करें
                }
            }
        }
    }

    close(epoll_fd);
    close(listen_fd);
    return 0;
}
```

### उदाहरण पर नोट्स
- **लिसनिंग सॉकेट**: नए कनेक्शनों का पता लगाने के लिए `EPOLLIN` की निगरानी करता है।
- **क्लाइंट सॉकेट**: आने वाले डेटा का पता लगाने के लिए `EPOLLIN` की भी निगरानी करते हैं।
- **सरलीकरण**: मानता है कि `write` पूरी तरह से पूरा हो जाता है। प्रोडक्शन में, आंशिक राइट्स के लिए डेटा को बफ़र करें और `EPOLLOUT` का उपयोग करें।
- **त्रुटि हैंडलिंग**: त्रुटियों या EOF पर सॉकेट्स को बंद करता है और उन्हें epoll से हटा देता है।

---

## सारांश
`epoll` Linux में कई फ़ाइल डिस्क्रिप्टर्स को हैंडल करने का एक कुशल तरीका प्रदान करता है:
1. `epoll_create1` के साथ एक इंस्टेंस बनाएँ।
2. `epoll_ctl` के साथ फ़ाइल डिस्क्रिप्टर्स और इवेंट्स पंजीकृत करें।
3. `epoll_wait` के साथ इवेंट्स की प्रतीक्षा करें।
4. आवश्यकतानुसार निगरानी किए गए इवेंट्स को समायोजित करते हुए या डिस्क्रिप्टर्स को हटाते हुए, एक लूप में इवेंट्स को प्रोसेस करें।

सरल अनुप्रयोगों के लिए, लेवल-ट्रिगर्ड मोड की सिफारिश की जाती है। उच्च-प्रदर्शन आवश्यकताओं के लिए, सभी उपलब्ध डेटा के सावधानीपूर्वक हैंडलिंग के साथ एज-ट्रिगर्ड मोड पर विचार करें। सर्वोत्तम परिणामों के लिए `epoll` को हमेशा नॉन-ब्लॉकिंग I/O के साथ जोड़ें।