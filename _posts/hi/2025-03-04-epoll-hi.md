---
audio: false
generated: true
lang: hi
layout: post
title: epoll का उपयोग Linux में
translated: true
---

# Linux में `epoll` का उपयोग करने ka tarika

`epoll` Linux mein ek system call hai jo multiple file descriptors ko events ke liye efficiently monitor karne ke liye design kiya gaya hai, jaise ki data read karne ke liye available hai ya socket write karne ke liye ready hai. Yeh particularly network programming mein useful hai, jahan ek server ko bahut saare connections ko simultaneously handle karna padta hai. Older mechanisms jaise `select` ya `poll` ke muqable, `epoll` bahut saare file descriptors ke saath better scale karta hai kyunki yeh repeatedly scan karne se bachaata hai sab descriptors ke liye readiness.

Yahan ek step-by-step guide hai `epoll` ka Linux mein use karne ke liye, uske baad ek simple example hai ek server jo connections ko accept karta hai aur data ko wapas echo karta hai.

---

## `epoll` ka use karne ke steps

### 1. **Epoll Instance Banayein**
`epoll` ka use shuru karne ke liye, aapko ek epoll instance banani padti hai, jo ek file descriptor ke roop mein represent hota hai. `epoll_create1` system call ka use karein:

```c
int epoll_fd = epoll_create1(0);
```
- **Parameter**: Basic usage ke liye `0` pass karein (kisi special flags ke bina). Flags jaise `EPOLL_CLOEXEC` advanced scenarios ke liye use hote hain.
- **Return Value**: Success par ek file descriptor (`epoll_fd`) return karta hai, ya `-1` error par (details ke liye `errno` check karein).

Purana `epoll_create` function similar hai lekin ek size hint leta hai (ab ignore kiya jaata hai), to `epoll_create1` preferred hai.

### 2. **File Descriptors ko Monitor karne ke liye Add karein**
`epoll_ctl` ka use karein file descriptors (jaise sockets) ko epoll instance ke saath register karne ke liye aur events specify karein jo aap monitor karna chahte hain:

```c
struct epoll_event ev;
ev.events = EPOLLIN;  // Readability ke liye monitor karein
ev.data.fd = some_fd; // Monitor karne ke liye file descriptor
epoll_ctl(epoll_fd, EPOLL_CTL_ADD, some_fd, &ev);
```
- **Parameters**:
  - `epoll_fd`: Epoll instance file descriptor.
  - `EPOLL_CTL_ADD`: File descriptor ko add karne ke liye operation.
  - `some_fd`: Monitor karne ke liye file descriptor (jaise ek socket).
  - `&ev`: Pointer ek `struct epoll_event` jo events aur optional user data define karta hai.
- **Common Events**:
  - `EPOLLIN`: Data read karne ke liye available hai.
  - `EPOLLOUT`: Ready to write.
  - `EPOLLERR`: Error hua.
  - `EPOLLHUP`: Hang-up (jaise connection closed).
- **User Data**: `data` field `struct epoll_event` mein ek file descriptor (jaise dikhaya gaya) ya aur data (jaise ek pointer) store kar sakta hai jo source ko identify karne ke liye events occur hote hain.

### 3. **Events ke liye Wait karein**
`epoll_wait` ka use karein aur monitored file descriptors par events ke liye block aur wait karein:

```c
struct epoll_event events[MAX_EVENTS];
int nfds = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);
```
- **Parameters**:
  - `epoll_fd`: Epoll instance.
  - `events`: Triggered events ko store karne ke liye array.
  - `MAX_EVENTS`: Return karne ke liye maximum number of events (array ka size).
  - `-1`: Timeout in milliseconds (`-1` means wait indefinitely; `0` immediately return karta hai).
- **Return Value**: Events ke saath file descriptors ka number (`nfds`), ya `-1` error par.

### 4. **Events ko Handle karein**
`epoll_wait` se events ko return karne ke baad unhe loop mein process karein:

```c
for (int i = 0; i < nfds; i++) {
    if (events[i].events & EPOLLIN) {
        // File descriptor events[i].data.fd readable hai
    }
}
```
- Bitwise operations ka use karein (jaise `events[i].events & EPOLLIN`) event type ko determine karne ke liye.
- `events[i].data.fd` ka use karein jo file descriptor event ko trigger karta hai.

### 5. **File Descriptors ko Manage karein (Optional)**
- **Remove**: `epoll_ctl` ka use karein `EPOLL_CTL_DEL` ke saath ek file descriptor ko monitor karne se rokne ke liye:
  ```c
  epoll_ctl(epoll_fd, EPOLL_CTL_DEL, some_fd, NULL);
  ```
- **Modify**: Events ko `EPOLL_CTL_MOD` ke saath adjust karein:
  ```c
  ev.events = EPOLLOUT; // Writability ke liye change karein
  epoll_ctl(epoll_fd, EPOLL_CTL_MOD, some_fd, &ev);
  ```

---

## Key Concepts

### **Level-Triggered vs. Edge-Triggered**
- **Level-Triggered (Default)**: `epoll` repeatedly notify karta hai jab tak condition persist karta hai (jaise data unread rehta hai). Most cases ke liye simpler hai.
- **Edge-Triggered (`EPOLLET`)**: Sirf ek baar notify karta hai jab state change hota hai (jaise new data aata hai). Reading/writing sab data tak `EAGAIN` ko avoid karne ke liye zaroori hai; efficient hai lekin tricky.
- `EPOLLET` ko `ev.events` mein set karein (jaise `EPOLLIN | EPOLLET`) agar edge-triggered mode ka use kar rahe hain.

### **Non-Blocking I/O**
`epoll` ko often non-blocking file descriptors ke saath pair kiya jaata hai taaki I/O operations par blocking se bacha ja sake. Ek socket ko non-blocking mode mein set karein:

```c
fcntl(fd, F_SETFL, fcntl(fd, F_GETFL) | O_NONBLOCK);
```

---

## Example: Simple Echo Server

Yahan ek basic example hai ek server jo `epoll` ka use karta hai connections ko accept karne aur data ko clients ko wapas echo karne ke liye. Yeh level-triggered mode ka use karta hai simplicity ke liye.

```c
#include <sys/epoll.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>

#define MAX_EVENTS 10
#define PORT 8080

int main() {
    // Listening socket banayein
    int listen_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (listen_fd == -1) { perror("socket"); exit(1); }

    struct sockaddr_in addr = { .sin_family = AF_INET, .sin_addr.s_addr = INADDR_ANY, .sin_port = htons(PORT) };
    if (bind(listen_fd, (struct sockaddr*)&addr, sizeof(addr)) == -1) { perror("bind"); exit(1); }
    if (listen(listen_fd, 5) == -1) { perror("listen"); exit(1); }

    // Listening socket ko non-blocking mode mein set karein
    fcntl(listen_fd, F_SETFL, fcntl(listen_fd, F_GETFL) | O_NONBLOCK);

    // Epoll instance banayein
    int epoll_fd = epoll_create1(0);
    if (epoll_fd == -1) { perror("epoll_create1"); exit(1); }

    // Listening socket ko epoll mein add karein
    struct epoll_event ev, events[MAX_EVENTS];
    ev.events = EPOLLIN; // Level-triggered
    ev.data.fd = listen_fd;
    if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, listen_fd, &ev) == -1) { perror("epoll_ctl"); exit(1); }

    // Event loop
    while (1) {
        int nfds = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);
        if (nfds == -1) { perror("epoll_wait"); exit(1); }

        for (int i = 0; i < nfds; i++) {
            int fd = events[i].data.fd;

            if (fd == listen_fd) {
                // New connection accept karein
                int client_fd = accept(listen_fd, NULL, NULL);
                if (client_fd == -1) { perror("accept"); continue; }

                // Client socket ko non-blocking mode mein set karein
                fcntl(client_fd, F_SETFL, fcntl(client_fd, F_GETFL) | O_NONBLOCK);

                // Client socket ko epoll mein add karein
                ev.events = EPOLLIN;
                ev.data.fd = client_fd;
                if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, client_fd, &ev) == -1) {
                    perror("epoll_ctl: client_fd");
                    close(client_fd);
                }
            } else {
                // Client data handle karein
                char buf[1024];
                ssize_t n = read(fd, buf, sizeof(buf));
                if (n <= 0) {
                    // Error ya EOF: close aur epoll se remove karein
                    if (n == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) continue;
                    close(fd);
                    epoll_ctl(epoll_fd, EPOLL_CTL_DEL, fd, NULL);
                } else {
                    // Data ko wapas echo karein
                    write(fd, buf, n); // Note: Real apps mein partial writes handle karein
                }
            }
        }
    }

    close(epoll_fd);
    close(listen_fd);
    return 0;
}
```

### Example par Notes
- **Listening Socket**: `EPOLLIN` ko monitor karta hai new connections ko detect karne ke liye.
- **Client Sockets**: Bhi `EPOLLIN` ko monitor karta hai incoming data ko detect karne ke liye.
- **Simplification**: `write` ko fully complete hone ka assumption karta hai. Production mein buffer data aur `EPOLLOUT` ke liye partial writes handle karein.
- **Error Handling**: Errors ya EOF par sockets ko close karein aur unhe epoll se remove karein.

---

## Summary
`epoll` Linux mein multiple file descriptors ko handle karne ka ek efficient tarika provide karta hai:
1. `epoll_create1` ke saath ek instance banayein.
2. `epoll_ctl` ke saath file descriptors aur events ko register karein.
3. `epoll_wait` ke saath events ke liye wait karein.
4. Events ko loop mein process karein, monitored events ko adjust karte hue ya descriptors ko remove karte hue jitna zaroori hai.

Simple applications ke liye level-triggered mode recommended hai. High-performance needs ke liye edge-triggered mode ka soch sakte hain saath saath sab available data ko carefully handle karte hue. Hamesha `epoll` ko non-blocking I/O ke saath pair karein best results ke liye.