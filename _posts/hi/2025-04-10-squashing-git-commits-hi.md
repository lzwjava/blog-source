---
audio: false
generated: true
image: false
lang: hi
layout: post
model: x-ai/grok-code-fast-1
title: लेखक द्वारा गिट कमिट्स को स्क्वाश करना
translated: true
type: note
---

### लक्ष्य को समझना
Git में एक अंतर्निहित "लेखक द्वारा स्क्वॉश" कमांड नहीं है, लेकिन आप इंटरैक्टिव रीबेस का उपयोग करके कमिट्स को मैन्युअल रूप से समूहित और स्क्वॉश कर सकते हैं। विचार यह है कि अंतिम 10 कमिट्स (मान लें कि इनमें 3 अलग-अलग लेखक शामिल हैं) को लिया जाए और प्रत्येक लेखक की कमिट्स को प्रति लेखक एक सिंगल कमिट में मर्ज किया जाए, जिसके परिणामस्वरूप कुल 3 कमिट्स होंगी।

यह मानता है:
- आप उन कमिट्स वाली ब्रांच पर हैं (जैसे, main या feature ब्रांच)।
- कमिट्स रैखिक हैं (कोई मर्ज नहीं)।
- आप पहले से लेखकों को जानते हैं।

यदि कमिट्स गैर-रैखिक या जटिल हैं, तो संघर्षों से बचने के लिए सावधानीपूर्वक हैंडलिंग की आवश्यकता हो सकती है।

### लेखक द्वारा कमिट्स को स्क्वॉश करने के चरण
1. **नवीनतम 10 कमिट्स की जांच करें**  
   अंतिम 10 कमिट्स को देखने के लिए `git log --oneline -10` चलाएं, जिसमें उनके हैश, लेखक और संदेश शामिल होंगे। लेखकों की पहचान करें (उदाहरण के लिए, अद्वितीय लेखकों की सूची बनाने के लिए `git log --format="%an" -10 | sort | uniq` चलाकर)।

2. **एक इंटरैक्टिव रीबेस शुरू करें**  
   10वीं कमिट से पहले वाली कमिट की पहचान करें। यदि आपकी नवीनतम कमिट HEAD पर है, और 10 कमिट्स हैं, तो आधार `HEAD~10` है। चलाएं:  
   ```
   git rebase -i HEAD~10
   ```  
   यह एक एडिटर (डिफ़ॉल्ट रूप से vim) खोलता है जिसमें अंतिम 10 कमिट्स की सूची होती है। यह इस तरह दिखती है:  
   ```
   pick abc123 लेखक A द्वारा पहली कमिट  
   pick def456 लेखक A द्वारा दूसरी कमिट  
   pick ghi789 लेखक B द्वारा कमिट  
   pick jkl012 लेखक C द्वारा कमिट  
   ... (और कमिट्स)
   ```  
   - प्रत्येक पंक्ति `pick` से शुरू होती है।

3. **लेखक द्वारा स्क्वॉश की जाने वाली कमिट्स को चिह्नित करें**  
   प्रत्येक लेखक के लिए, उनकी सभी कमिट्स पर `pick` को `s` (squash) में बदलें, सिवाय उस पहली कमिट के जिसे आप उस लेखक के लिए रखना चाहते हैं। तय करें:
   - प्रति लेखक एक "रखने वाली" कमिट (आधार के रूप में सबसे पुरानी या सबसे प्रासंगिक कमिट चुनें)।
   - उस लेखक द्वारा की गई बाकी सभी कमिट्स को `s` में बदलें ताकि वे उसमें स्क्वॉश हो जाएं।  
   उदाहरण (3 लेखकों के लिए):  
   ```
   pick abc123 लेखक A द्वारा पहली कमिट (इसे रखें)  
   s    def456 लेखक A द्वारा दूसरी कमिट (ऊपर वाली में स्क्वॉश करें)  
   pick ghi789 लेखक B द्वारा कमिट (इसे रखें)  
   pick jkl012 लेखक C द्वारा पहली कमिट (इसे रखें)  
   s    mno345 लेखक C द्वारा दूसरी कमिट (ऊपर वाली में स्क्वॉश करें)  
   ```  
   एडिटर को सेव करें और बाहर निकलें। यह रीबेस शुरू करता है।

4. **रीबेस के दौरान कमिट संदेशों को संपादित करें**  
   प्रत्येक स्क्वॉश ऑपरेशन के लिए, Git रुक जाएगा और आपको कमिट संदेश (स्क्वॉश की गई कमिट्स को मिलाकर) संपादित करने देगा। इसे "लेखक A द्वारा स्क्वॉश की गई कमिट्स: विवरण" जैसे कुछ में अपडेट करें। सेव करें और जारी रखें।  
   यदि और स्क्वॉश हैं, तो प्रत्येक लेखक के लिए दोहराएं। प्रत्येक संपादन के बाद `git rebase --continue` चलाएं।  
   यदि संघर्ष उत्पन्न होते हैं (सरल स्क्वॉश में दुर्लभ), तो उन्हें `git add <file>` फिर `git rebase --continue` से हल करें।

5. **सत्यापित करें और पुश करें**  
   रीबेस पूरा होने के बाद, लॉग की जांच करें: `git log --oneline -10`। आपको 3 कमिट्स दिखनी चाहिए, प्रत्येक एक लेखक से।  
   यदि किसी साझा ब्रांच पर पुश कर रहे हैं (विनाशकारी रीबेस): `git push --force-with-lease origin branch-name`।  
   **चेतावनी:** केवल तभी फोर्स-पुश करें जब आपको यकीन हो कि पुरानी कमिट्स की कहीं और आवश्यकता नहीं है, क्योंकि यह इतिहास को फिर से लिखता है।

### सुझाव और चेतावनियाँ
- यदि लेखकों की कई कमिट्स हैं, तो उन्हें रीबेस सूची में कुशलतापूर्वक समूहित करें (लेखक A की सभी एक साथ, आदि)।
- ऑटोमेशन के लिए, `git-interactive-rebase-tool` या स्क्रिप्ट्स मदद कर सकते हैं, लेकिन मैन्युअल रीबेस सीधा-साधा है।
- यदि आपको सटीक लेखक द्वारा फ़िल्टर करने की आवश्यकता है, तो पहले पुष्टि करने के लिए `git log --author="Author Name"` का उपयोग करें।
- डेटा हानि से बचने के लिए पहले एक बैकअप ब्रांच पर परीक्षण करें।

रीबेस के बारे में अधिक जानकारी के लिए: `git help rebase`। यदि यह आपके सटीक परिदृश्य से मेल नहीं खाता है, तो कमिट संरचना के बारे में अधिक विवरण प्रदान करें।