---
audio: false
generated: true
lang: hi
layout: post
title: एसआर लैच और फ्लिप-फ्लॉप संशोधन बेन ईटर द्वारा
translated: true
type: note
---

एक पिछले वीडियो में, मैंने SR लैच के बारे में चर्चा की थी, और अगर आप इससे अपरिचित हैं तो मैं आपको उस वीडियो को देखने की सलाह देता हूँ। संक्षेप में, SR लैच के दो इनपुट होते हैं: **R** (रीसेट) और **S** (सेट)। जब रीसेट इनपुट हाई हो जाता है, तो आउटपुट **Q** लो (ऑफ) हो जाता है, जिससे लैच रीसेट हो जाता है। जब सेट इनपुट हाई हो जाता है, तो आउटपुट **Q** हाई (ऑन) हो जाता है, जिससे लैच सेट हो जाता है। एक पूरक आउटपुट **Q̅** (Q-बार) भी होता है, जो हमेशा **Q** के विपरीत होता है, सिवाय एक मामले के: जब **R** और **S** दोनों इनपुट एक साथ हाई होते हैं। इस स्थिति में, **Q** और **Q̅** दोनों लो हो जाते हैं, जिसे एक अमान्य स्थिति माना जाता है, क्योंकि आपको लैच को एक साथ सेट और रीसेट नहीं करना चाहिए। यदि दोनों इनपुट रिलीज़ कर दिए जाते हैं, तो लैच की स्थिति अप्रत्याशित हो जाती है, क्योंकि यह इस बात पर निर्भर करती है कि कौन सा इनपुट पहले रिलीज़ हुआ है। आम तौर पर, SR लैच अपनी दो स्थिर अवस्थाओं में से किसी एक में लैच रहेगा।

इस वीडियो में, मैं बुनियादी SR लैच सर्किट में संशोधनों पर चर्चा करूंगा। पहला संशोधन **SR लैच with Enable** है। इस संस्करण में **R** और **S** दोनों इनपुट में **AND गेट** जोड़े जाते हैं, जो एक **Enable** सिग्नल द्वारा नियंत्रित होते हैं। जब Enable सिग्नल हाई (1) होता है, तो AND गेट **R** और **S** इनपुट को बिना बदले पास कर देते हैं। उदाहरण के लिए, यदि **Enable** 1 है और **Reset** 1 है, तो AND गेट का आउटपुट 1 होगा; यदि **Reset** 0 है, तो इसका आउटपुट 0 होगा। हालाँकि, यदि **Enable** सिग्नल लो (0) है, तो AND गेट के आउटपुट हमेशा 0 होते हैं, चाहे **R** और **S** इनपुट कुछ भी हों। इसके कारण लैच अपनी अंतिम अवस्था में बना रहता है, प्रभावी रूप से इनपुट को अनदेखा करते हुए। इस प्रकार, Enable सिग्नल आपको या तो लैच को उसके **R** और **S** इनपुट के प्रति उत्तरदायी बनाने या उसे वर्तमान स्थिति में रोककर अक्षम करने की अनुमति देता है।

आगे, हम इस अवधारणा को विस्तारित करके एक **SR फ्लिप-फ्लॉप** बना सकते हैं। एक लैच और एक फ्लिप-फ्लॉप के बीच मुख्य अंतर यह है कि एक लैच के आउटपुट तब बदलते हैं जब उसके इनपुट बदलते हैं, जबकि एक फ्लिप-फ्लॉप के आउटपुट केवल एक विशिष्ट ट्रिगर पर बदलते हैं, जो आमतौर पर एक क्लॉक पल्स होता है। एक SR फ्लिप-फ्लॉप में, एक **Clock** इनपुट (जो डायग्राम में एक त्रिकोण प्रतीक द्वारा दर्शाया जाता है) नियंत्रित करता है कि आउटपुट कब अपडेट होंगे। विशेष रूप से, आउटपुट **Q** और **Q̅** केवल तब बदलते हैं जब क्लॉक लो से हाई में परिवर्तित होता है (राइजिंग एज)। अन्य सभी समय पर, इनपुट **R** और **S** को अनदेखा कर दिया जाता है, और फ्लिप-फ्लॉप अपनी पिछली स्थिति बनाए रखता है।

SR फ्लिप-फ्लॉप यह क्लॉक सर्किट में एक कैपेसिटर का उपयोग करके प्राप्त करता है। जब क्लॉक लो से हाई में परिवर्तित होता है, तो कैपेसिटर के चार्ज होने पर एक संक्षिप्त करंट प्रवाहित होता है, जिससे AND गेट के इनपुट पर एक छोटा वोल्टेज पल्स बनता है। यह पल्स प्रभावी रूप से SR लैच with Enable को केवल उसी क्षण के लिए सक्रिय करता है, जिससे **R** और **S** इनपुट आउटपुट **Q** और **Q̅** को प्रभावित कर पाते हैं। एक बार कैपेसिटर पूरी तरह चार्ज हो जाने के बाद, पल्स रुक जाता है, और फ्लिप-फ्लॉप अगले राइजिंग एज तक आगे के इनपुट परिवर्तनों को अनदेखा कर देता है।

यहाँ बताया गया है कि क्लॉक के राइजिंग एज के दौरान SR फ्लिप-फ्लॉप कैसा व्यवहार करता है:
- यदि **R** हाई है और **S** लो है, तो **Q** लो (रीसेट) हो जाता है, और **Q̅** हाई हो जाता है।
- यदि **S** हाई है और **R** लो है, तो **Q** हाई (सेट) हो जाता है, और **Q̅** लो हो जाता है।
- यदि **R** और **S** दोनों लो हैं, तो फ्लिप-फ्लॉप अपनी पिछली अवस्था में बना रहता है।
- यदि **R** और **S** दोनों हाई हैं (SR लैच की अमान्य स्थिति), तो व्यवहार अप्रत्याशित होता है। SR लैच के समान, **Q** और **Q̅** दोनों पल्स के दौरान लो हो सकते हैं, लेकिन जब इनपुट रिलीज़ किए जाते हैं, तो फ्लिप-फ्लॉप किसी एक अवस्था में स्थिर हो जाता है, यह इस बात पर निर्भर करता है कि कौन सा इनपुट पहले ड्रॉप होता है। यह आउटपुट को अनिश्चित बना देता है, क्योंकि यह समय के अंतर (जैसे, कुछ नैनोसेकंड) पर निर्भर करता है, जिससे यह एक अमान्य और अप्रत्याशित स्थिति बन जाती है।

इस अनिश्चितता को दूर करने के लिए, हम एक **JK फ्लिप-फ्लॉप** का उपयोग कर सकते हैं, जो SR फ्लिप-फ्लॉप के समान है लेकिन इसमें आउटपुट **Q** और **Q̅** से इनपुट तक फीडबैक शामिल होता है। JK फ्लिप-फ्लॉप तीन-इनपुट AND गेट का उपयोग करता है जिसमें **J** (**S** के अनुरूप), **K** (**R** के अनुरूप), और फीडबैक सिग्नल **Q** और **Q̅** शामिल होते हैं। अक्षर **J** और **K** मनमाने हैं और किसी विशिष्ट शब्द के लिए नहीं खड़े होते, लेकिन वे इस सर्किट को SR फ्लिप-फ्लॉप से अलग करते हैं।

JK फ्लिप-फ्लॉप निम्नानुसार कार्य करता है:
- यदि **J** और **K** दोनों 0 हैं, तो AND गेट के आउटपुट 0 होते हैं, इसलिए फ्लिप-फ्लॉप क्लॉक पल्स के दौरान भी अपनी पिछली अवस्था में बना रहता है।
- यदि लैच वर्तमान में सेट है (**Q** = 1, **Q̅** = 0) और आप इसे रीसेट करना चाहते हैं (**K** = 1, **J** = 0), तो **K** से जुड़ा AND गेट क्लॉक पल्स के दौरान 1 आउटपुट करता है (क्योंकि **Q** = 1), जिससे फ्लिप-फ्लॉप रीसेट हो जाता है (**Q** = 0, **Q̅** = 1)।
- यदि लैच पहले से ही रीसेट है (**Q** = 0, **Q̅** = 1) और **K** = 1, **J** = 0, तो AND गेट के आउटपुट 0 रहते हैं, इसलिए फ्लिप-फ्लॉप रीसेट अवस्था में बना रहता है, जो वांछित व्यवहार है।
- इसी तरह, यदि लैच रीसेट है (**Q** = 0, **Q̅** = 1) और आप इसे सेट करना चाहते हैं (**J** = 1, **K** = 0), तो **J** से जुड़ा AND गेट क्लॉक पल्स के दौरान 1 आउटपुट करता है (क्योंकि **Q̅** = 1), जिससे फ्लिप-फ्लॉप सेट हो जाता है (**Q** = 1, **Q̅** = 0)।
- यदि लैच पहले से ही सेट है और **J** = 1, **K** = 0, तो यह अपनी सेट अवस्था में बना रहता है, जैसा कि अपेक्षित है।

JK फ्लिप-फ्लॉप की अनूठी विशेषता तब सामने आती है जब **J** और **K** दोनों 1 होते हैं। फीडबैक के कारण, एक समय में केवल एक AND गेट सक्रिय हो सकता है (क्योंकि **Q** और **Q̅** दोनों एक साथ 1 नहीं हो सकते)। यदि **Q** 1 है, तो **K** के लिए AND गेट सक्रिय होता है, और फ्लिप-फ्लॉप अगले क्लॉक पल्स पर रीसेट हो जाता है (**Q** = 0, **Q̅** = 1)। यदि **Q** 0 है, तो **J** के लिए AND गेट सक्रिय होता है, और फ्लिप-फ्लॉप अगले क्लॉक पल्स पर सेट हो जाता है (**Q** = 1, **Q̅** = 0)। यह एक **टॉगल** व्यवहार बनाता है: यदि **J** = **K** = 1, तो फ्लिप-फ्लॉप प्रत्येक क्लॉक पल्स पर अपनी अवस्था बदलता है (**Q** 0 से 1 या 1 से 0 में बदल जाता है)। यह अनुमानित टॉगलिंग SR फ्लिप-फ्लॉप की अमान्य, अप्रत्याशित स्थिति को समाप्त कर देती है, जिससे JK फ्लिप-फ्लॉप अधिक मजबूत और बहुमुखी बन जाता है।