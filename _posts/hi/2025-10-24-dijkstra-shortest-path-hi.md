---
audio: false
generated: true
image: false
lang: hi
layout: post
model: x-ai/grok-4-fast
title: डिजक्स्ट्रा का शॉर्टेस्ट पाथ एल्गोरिदम को समझना
translated: true
type: note
---

### डिजक्स्ट्रा के शॉर्टेस्ट पाथ एल्गोरिदम को समझना

डिजक्स्ट्रा का एल्गोरिदम ग्राफ़ में नोड्स के बीच सबसे छोटा रास्ता खोजने का एक मौलिक तरीका है जहाँ किनारों पर गैर-नकारात्मक वज़न (जैसे दूरी या लागत) होते हैं। इसका नाम एड्सगर डब्ल्यू. डिजक्स्ट्रा के नाम पर रखा गया है और इसका व्यापक रूप से जीपीएस नेविगेशन, नेटवर्क रूटिंग, और अन्य जगहों पर उपयोग किया जाता है। मुख्य अंतर्ज्ञान: यह ग्राफ़ को लालची तरीके से एक्सप्लोर करता है, हमेशा निकटतम अनदेखे नोड को चुनता है और वहाँ से रास्तों को अपडेट करता है, जैसे शुरुआती बिंदु से एक लहर प्रभाव।

#### त्वरित पूर्वापेक्षाएँ
- **ग्राफ़ बेसिक्स**: एक ग्राफ़ को शहरों (नोड्स) का एक नक्शा समझें जो सड़कों (एज) से जुड़े हैं जिनकी लंबाई (वज़न) है। हम मानते हैं कि वज़न सकारात्मक हैं—कोई नकारात्मक दूरी नहीं!
- **डायरेक्टेड बनाम अंडायरेक्टेड**: दोनों के लिए काम करता है, लेकिन सादगी के लिए यहाँ उदाहरण अंडायरेक्टेड ग्राफ़ के हैं।
- **शॉर्टेस्ट पाथ**: स्रोत से लक्ष्य तक न्यूनतम कुल वज़न वाला रास्ता।

यदि ग्राफ़ नए हैं, तो एक सोशल नेटवर्क की कल्पना करें: लोग (नोड्स), "स्ट्रेंथ" स्कोर (वज़न) वाली दोस्ती।

#### यह कैसे काम करता है: चरण-दर-चरण अंतर्ज्ञान
डिजक्स्ट्रा सबसे छोटे रास्ते को क्रमिक रूप से बनाता है, एक **प्रायोरिटी क्यू** (जैसे वर्तमान सबसे छोटी ज्ञात दूरी के आधार पर क्रमबद्ध, तात्कालिकता वाली टू-डू लिस्ट) का उपयोग करके। यह एक बार विज़िट किए गए नोड्स पर दोबारा नहीं जाता, जिससे यह कुशल बनता है।

1. **इनिशियलाइज़ करें**:
   - एक शुरुआती नोड (स्रोत) चुनें। इसकी दूरी 0 पर सेट करें।
   - अन्य सभी नोड्स की दूरी अनंत (∞) पर सेट करें।
   - प्रत्येक नोड का "पाथ टू" ट्रैक करें (शुरू में कोई नहीं)।

2. **जब तक अनविज़िटेड नोड्स हैं**:
   - सबसे छोटी वर्तमान दूरी वाला अनविज़िटेड नोड चुनें (प्रायोरिटी क्यू से)।
   - इसे "सेटल" करें: इसे विज़िटेड के रूप में चिह्नित करें। यह दूरी अंतिम है—गैर-नकारात्मक वज़न के कारण, बाद में कोई छोटा रास्ता नहीं मिल सकता।
   - इस नोड के प्रत्येक पड़ोसी के लिए:
     - संभावित नई दूरी की गणना करें: (सेटल नोड की दूरी) + (पड़ोसी तक एज वेट)।
     - यदि यह पड़ोसी की वर्तमान दूरी से छोटी है, तो इसे अपडेट करें और नोट करें कि रास्ता सेटल नोड के माध्यम से आया है।
   - तब तक दोहराएं जब तक कि सभी नोड्स विज़िट न हो जाएँ या टार्गेट सेटल न हो जाए।

यदि आपको केवल एक टार्गेट नोड की परवाह है तो एल्गोरिदम जल्दी रुक जाता है।

**यह क्यों काम करता है**: यह ब्रेड्थ-फर्स्ट सर्च जैसा है लेकिन वेटेड—हमेशा सबसे सस्ते फ्रंटियर को पहले एक्सपैंड करता है। प्रूफ इस तथ्य पर निर्भर करता है कि एक बार एक नोड सेटल हो जाने पर, उसकी दूरी में सुधार नहीं हो सकता (ग्रीडी चॉइस प्रॉपर्टी)।

#### सरल उदाहरण
4 शहरों वाले एक ग्राफ़ की कल्पना करें: A (स्टार्ट), B, C, D. एज और वज़न:

- A → B: 4
- A → C: 2
- B → C: 1
- B → D: 5
- C → D: 8

ASCII विज़ुअलाइज़ेशन:
```
   4
A ----- B
 \     / \
  2   1   5
  \   /     |
   C ------- D
     8
```

A से डिजक्स्ट्रा चलाएं:

- **शुरू**: dist[A]=0, dist[B]=∞, dist[C]=∞, dist[D]=∞. क्यू: A.
- **A सेटल करें** (dist=0).
  - B अपडेट करें: 0+4=4
  - C अपडेट करें: 0+2=2
  - क्यू: C(2), B(4)
- **C सेटल करें** (dist=2).
  - D अपडेट करें: 2+8=10
  - क्यू: B(4), D(10)
- **B सेटल करें** (dist=4).
  - C अपडेट करें: 4+1=5 (लेकिन 2<5, कोई बदलाव नहीं)
  - D अपडेट करें: 4+5=9 (9<10, 9 पर अपडेट करें)
  - क्यू: D(9)
- **D सेटल करें** (dist=9).

अंतिम दूरियाँ: A=0, B=4, C=2, D=9.
D का रास्ता: A → B → D (कुल 9, A → C → D=10 से छोटा)।

आप "पिछला नोड" ऐरे का उपयोग करके रास्तों को ट्रेस बैक कर सकते हैं।

#### स्यूडोकोड
यहाँ एक सरल इम्प्लीमेंटेशन आउटलाइन दी गई है (Python जैसा):

```python
import heapq  # प्रायोरिटी क्यू के लिए

def dijkstra(graph, start):
    distances = {node: float('inf') for node in graph}
    distances[start] = 0
    previous = {node: None for node in graph}
    pq = [(0, start)]  # (distance, node)
    
    while pq:
        current_dist, current = heapq.heappop(pq)
        if current_dist > distances[current]:
            continue  # पुरानी एंट्री
        
        for neighbor, weight in graph[current].items():
            distance = current_dist + weight
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                previous[neighbor] = current
                heapq.heappush(pq, (distance, neighbor))
    
    # टार्गेट (जैसे, 'D') के लिए रास्ता रीकन्स्ट्रक्ट करें
    path = []
    node = 'D'
    while node is not None:
        path.append(node)
        node = previous[node]
    return path[::-1], distances['D']  # स्टार्ट-टू-एंड पाने के लिए रिवर्स करें
```

- `graph`: डिक्ट ऑफ डिक्ट्स, जैसे, `{'A': {'B':4, 'C':2}, ...}`
- टाइम कॉम्प्लेक्सिटी: O((V+E) log V) बाइनरी हीप के साथ (V=वर्टिसेस, E=एज)। स्पार्स ग्राफ़ के लिए बढ़िया।

#### इसे गहराई से समझने के टिप्स
- **विज़ुअलाइज़ करें**: अपना ग्राफ़ कागज़ पर बनाएं, दूरी/विज़िटेड की एक टेबल के साथ चरणों का सिमुलेशन करें।
- **कॉमन पिटफॉल्स**: नेगेटिव वेट के साथ फेल हो जाता है (इसके बजाय बेलमैन-फोर्ड का उपयोग करें)। कनेक्टेड ग्राफ़ मानता है।
- **प्रैक्टिस**: छोटे ग्राफ़ पर कोशिश करें, फिर इसे मैप डेटासेट के लिए कोड करें।
- **वेरिएंट**: A* ह्यूरिस्टिक्स जोड़ता है तेज सर्च के लिए (जैसे, गेम्स में)।

यह क्लिक करना चाहिए—उदाहरण से शुरू करें, इसे मानसिक रूप से कुछ बार चलाएं!

[Wikipedia: Dijkstra's Algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)  
[GeeksforGeeks: Visual Explanation](https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/)