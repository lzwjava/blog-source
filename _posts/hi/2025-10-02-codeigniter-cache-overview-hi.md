---
audio: false
generated: true
image: false
lang: hi
layout: post
model: x-ai/grok-code-fast-1
title: कोडइग्नाइटर कैश प्रणाली का अवलोकन
translated: true
type: note
---

### CodeIgniter की कैश लाइब्रेरी का अवलोकन

CodeIgniter की `CI_Cache` क्लास एक लचीली कैशिंग प्रणाली है जो विभिन्न बैकएंड (जैसे इन-मेमोरी, फ़ाइल-आधारित, या बाहरी सेवाओं) में डेटा संग्रहीत करने और पुनर्प्राप्त करने के लिए एक एकीकृत इंटरफेस प्रदान करती है। यह `CI_Driver_Library` का विस्तार करती है, जो ड्राइवरों को गतिशील रूप से लोड करती है। यह क्लास कैश ऑपरेशन्स को सार प्रदान करती है, जिससे डेवलपर्स कॉन्फ़िगरेशन के माध्यम से आसानी से बैकएंड बदल सकते हैं बिना एप्लिकेशन कोड में बदलाव किए। सभी विधियां सक्रिय "एडाप्टर" (एक ड्राइवर क्लास) को सौंपती हैं, जिसमें विश्वसनीयता के लिए फॉलबैक सपोर्ट शामिल है।

यह सिस्टम प्रदर्शन, पोर्टेबिलिटी और फॉल्ट टॉलरेंस पर जोर देता है—उदाहरण के लिए, यदि अन्य ड्राइवर विफल होते हैं तो यह डिफ़ॉल्ट रूप से एक "डमी" (नो-ऑप) ड्राइवर पर स्विच करता है, यह सुनिश्चित करते हुए कि कैश समस्याओं के कारण ऐप न टूटे।

### समर्थित कैश ड्राइवर और एडाप्टर

यह क्लास कई ड्राइवरों को सपोर्ट करती है, जिन्हें `$valid_drivers` में परिभाषित किया गया है:
- **apc**: इन-मेमोरी स्टोरेज के लिए PHP के APC (Alternative PHP Cache) का उपयोग करता है (तेज़, बिल्ट-इन)।
- **dummy**: एक प्लेसहोल्डर जो कुछ नहीं करता (हमेशा TRUE या FALSE लौटाता है); डेवलपमेंट/टेस्टिंग के लिए फॉलबैक के रूप में उपयोग किया जाता है।
- **file**: डेटा को एक डायरेक्टरी में सीरियलाइज़्ड फाइलों के रूप में संग्रहीत करता है (`$_cache_path` द्वारा निर्दिष्ट), कम-ट्रैफ़िक वाली साइटों के लिए उपयुक्त।
- **memcached**: वितरित, इन-मेमोरी कैशिंग के लिए Memcached सेवा का इंटरफेस (उच्च-प्रदर्शन, स्केलेबल)।
- **redis**: Redis का इंटरफेस, एक और इन-मेमोरी की-वैल्यू स्टोर जिसमें pub/sub और atomic operations जैसी सुविधाएँ शामिल हैं।
- **wincache**: IIS के लिए Windows-विशिष्ट (Microsoft WinCache का उपयोग करता है)।

प्रत्येक ड्राइवर एक अलग क्लास होती है (जैसे `CI_Cache_memcached`) जो `get()`, `save()`, आदि जैसी विधियों को लागू करती है। लाइब्रेरी कंस्ट्रक्टर को पास किए गए `$config['adapter']` ऐरे के आधार पर ड्राइवर को गतिशील रूप से लोड करती है।

### आरंभीकरण और कॉन्फ़िगरेशन

- **कंस्ट्रक्टर**: एक `$config` ऐरे लेता है जिसमें `adapter` (प्राथमिक ड्राइवर), `backup` (फॉलबैक ड्राइवर), और `key_prefix` (नेमस्पेसिंग/अलगाव के लिए सभी कैश कुंजियों में जोड़ा जाने वाला स्ट्रिंग) के लिए कुंजियाँ शामिल होती हैं।
  - उदाहरण कॉन्फ़िग: `array('adapter' => 'redis', 'backup' => 'file', 'key_prefix' => 'myapp_')`।
- **फॉलबैक लॉजिक**: आरंभीकरण के बाद, यह जांचता है कि क्या प्राथमिक एडाप्टर `is_supported($driver)` का उपयोग करके समर्थित है (जो ड्राइवर की `is_supported()` विधि को कॉल करता है, आवश्यक PHP एक्सटेंशन या सेवाओं के लिए परीक्षण करता है)।
  - यदि प्राथमिक विफल होता है, तो यह बैकअप ड्राइवर पर स्विच करता है। यदि दोनों विफल होते हैं, तो यह एक त्रुटि लॉग करता है और डिफ़ॉल्ट रूप से "डमी" पर सेट हो जाता है (`log_message()` के माध्यम से)।
  - यह सुनिश्चित करता है कि कैश में हमेशा एक कार्यशील एडाप्टर हो, जिससे क्रैश होने से बचा जा सके।

`$_cache_path` फ़ाइल-आधारित ड्राइवरों के लिए सेट किया जाता है, लेकिन यह यहाँ आरंभीकृत नहीं होता है—संभवतः फ़ाइल ड्राइवर क्लास में संभाला जाता है।

### प्रमुख विधियाँ और उनका संचालन

विधियाँ अद्वितीय स्कोपिंग के लिए ID में `key_prefix` जोड़ती हैं (जैसे `'myapp_user123'`) और सक्रिय एडाप्टर को सौंपती हैं। सभी ऑपरेशन सफलता/विफलता पर बूलियन, ऐरे, या मिश्रित डेटा लौटाते हैं।

- **get($id)**: ID द्वारा कैश किए गए डेटा को पुनर्प्राप्त करता है।
  - उदाहरण: `$data = $cache->get('user_profile');` — एडाप्टर की `get()` विधि को कॉल करता है।
  - यदि कुंजी मौजूद है और इसकी समय सीमा समाप्त नहीं हुई है, तो डेटा लौटाता है; अन्यथा FALSE लौटाता है।
  - यहाँ कोई प्रत्यक्ष TTL लागू करना नहीं है; ड्राइवर द्वारा संभाला जाता है (जैसे, Redis या Memcached आंतरिक रूप से TTL लागू करते हैं)।

- **save($id, $data, $ttl = 60, $raw = FALSE)**: सेकंड में एक समय-सीमा (TTL) के साथ डेटा संग्रहीत करता है।
  - उदाहरण: `$cache->save('user_profile', $profile_data, 3600);` — 1-घंटे की समय सीमा के साथ संग्रहीत करता है।
  - `$raw` फ्लैग (डिफ़ॉल्ट रूप से false) इंगित करता है कि क्या डेटा सीरियलाइज़्ड है—ड्राइवर आवश्यकता पड़ने पर सीरियलाइज़ेशन संभालते हैं (जैसे, ऐरे/ऑब्जेक्ट स्ट्रिंग बन जाते हैं)।
  - सफलता पर TRUE लौटाता है, सशर्त लॉजिक को सुविधाजनक बनाता है (जैसे, यदि सेविंग विफल होती है तो डेटा जनरेट करें और कैश करें)।

- **delete($id)**: एक विशिष्ट कैश आइटम को हटाता है।
  - उदाहरण: `$cache->delete('user_profile');` — स्थायी रूप से हटाना।

- **increment($id, $offset = 1)** और **decrement($id, $offset = 1)**: संख्यात्मक मानों के लिए atomic operations (काउंटरों के लिए उपयोगी)।
  - उदाहरण: `$new_counter = $cache->increment('hits', 5);` — यदि ड्राइवर द्वारा समर्थित है तो 5 से बढ़ाता है (जैसे, Redis/Memcached atomic हैं; फ़ाइल-आधारीय अनुकरण कर सकते हैं)।
  - सभी ड्राइवर raw/inc/dec का समर्थन नहीं करते (डमी हमेशा विफल रहता है); नया मान या FALSE लौटाता है।

- **clean()**: वर्तमान ड्राइवर के लिए सभी कैश डेटा साफ़ करता है।
  - उदाहरण: `$cache->clean();` — अपडेट के बाद फ्लश करने के लिए उपयोगी।
  - "user" प्रकार उपयोगकर्ता-विशिष्ट डेटा को लक्षित करता है, सिस्टम कैश को नहीं।

- **cache_info($type = 'user')**: कैश के बारे में मेटाडेटा लौटाता है (जैसे, सर्वर स्टैट्स, कुंजी गणना, या फ़ाइल पथ)।
  - उदाहरण: `$info = $cache->cache_info();` — ड्राइवर से विवरणों का एक ऐरे।

- **get_metadata($id)**: किसी विशिष्ट कैश आइटम के बारे में विवरण प्राप्त करता है (जैसे, समाप्ति समय, आकार)।
  - उदाहरण: `$meta = $cache->get_metadata('key');` — डीबग या ऑप्टिमाइज़ करने में मदद करता है।

- **is_supported($driver)**: ड्राइवर की उपलब्धता की जांच करता है (बार-बार जांच से बचने के लिए स्थिर `$support` ऐरे का उपयोग करके परिणाम कैश करता है)।

### अतिरिक्त यांत्रिकी

- **कुंजी उपसर्ग**: सभी ID पर स्वचालित रूप से लागू होता है (जैसे, ऐप अलगाव या मल्टी-टेनेंसी के लिए)। विभिन्न वातावरणों में कुंजी टकराव को रोकने के लिए कॉन्फ़िग के माध्यम से सक्षम किया गया।
- **लॉगिंग**: डीबग/त्रुटि संदेशों के लिए `log_message()` का उपयोग करता है (जैसे, फॉलबैक), CodeIgniter की लॉगिंग प्रणाली के साथ एकीकृत।
- **लचीलापन और दोष सहिष्णुता**: बैकएंड को सार प्रदान करके, आप न्यूनतम परिवर्तनों के साथ फ़ाइल कैशिंग (सस्ती, स्थानीय) से Redis (तेज़, वितरित) पर स्विच कर सकते हैं। डमी फॉलबैक का मतलब है कि कैश विफलताएं ऐप को रोकती नहीं हैं—विधियाँ केवल FALSE लौटाती हैं, कोड को आगे बढ़ने देती हैं (जैसे, DB से फ़ेच करना)।
- **प्रदर्शन नोट्स**: APC/Redis जैसे ड्राइवर इन-मेमोरी में होते हैं (तेज़ पहुंच, सब-मिलीसेकंड)। फ़ाइल-आधारित डिस्क I/O के कारण धीमा होता है। TTL आम तौर पर ड्राइवरों द्वारा माना जाता है सिवाय दुर्लभ ड्राइवर-विशिष्ट एज केस के।

यह डिज़ाइन CodeIgniter की कैशिंग को मॉड्यूलर और विश्वसनीय बनाता है। विशिष्ट ड्राइवरों के विवरण के लिए, ड्राइवर फाइलों (जैसे `Cache_memcached.php`) की जांच करें। हमेशा संस्करण-विशिष्ट बारीकियों के लिए आधिकारिक CodeIgniter दस्तावेज़ों को देखें, क्योंकि यह कोड एक पुराने संस्करण (लगभग 2.0-3.x) का है। यदि आपके पास कोई विशिष्ट विधि या ड्राइवर है, तो मैं गहराई से जा सकता हूं!