---
audio: false
date: 2025-09-11
generated: true
image: false
lang: hi
layout: post
model: google/gemini-2.5-flash
title: पायथन कोड उदाहरणों का परिचय
translated: true
type: note
---

ठीक है, "कुछ Python कोड" का मतलब बहुत कुछ हो सकता है! Python अविश्वसनीय रूप से बहुमुखी है। मैं आपको कुछ सामान्य उदाहरण देता हूँ, बहुत ही बुनियादी से लेकर थोड़े और जटिल तक, जो विभिन्न अवधारणाओं को कवर करते हैं।

---

### 1. हैलो वर्ल्ड (क्लासिक शुरुआत)

यह सबसे सरल संभव Python प्रोग्राम है।

```python
# यह एक टिप्पणी है। Python द्वारा टिप्पणियों को नजरअंदाज कर दिया जाता है।
print("Hello, World!")
```

**स्पष्टीकरण:**
*   `print()` एक बिल्ट-इन फ़ंक्शन है जो दिए गए आर्गुमेंट को कंसोल पर आउटपुट करता है।
*   `"Hello, World!"` एक स्ट्रिंग (टेक्स्ट) है।

---

### 2. वेरिएबल्स, बेसिक अंकगणित और यूजर इनपुट

यह कोड दर्शाता है कि डेटा को वेरिएबल्स में कैसे स्टोर करें, सरल गणित करें और यूजर से इनपुट कैसे प्राप्त करें।

```python
# डेटा स्टोर करने के लिए वेरिएबल्स
name = input("What is your name? ") # यूजर से इनपुट प्राप्त करें
age_str = input("How old are you? ")

# गणना के लिए उम्र को स्ट्रिंग से इंटीजर में बदलें
age = int(age_str)

# बेसिक अंकगणित
year_of_birth = 2023 - age # सरलता के लिए मान लेते हैं कि चालू वर्ष 2023 है
# आप यह भी उपयोग कर सकते हैं: import datetime; year_of_birth = datetime.date.today().year - age

# f-स्ट्रिंग (फॉर्मेटेड स्ट्रिंग लिटरल) का उपयोग करके फॉर्मेटेड आउटपुट प्रिंट करें
print(f"Hello, {name}! You are {age} years old.")
print(f"You were likely born in {year_of_birth}.")

# एक सरल सशर्त जांच
if age < 18:
    print("You are a minor.")
else:
    print("You are an adult.")
```

**स्पष्टीकरण:**
*   `input()`: यूजर को टेक्स्ट इनपुट के लिए प्रॉम्प्ट करता है और इसे स्ट्रिंग के रूप में लौटाता है।
*   `name`, `age_str`, `age`, `year_of_birth`: ये वेरिएबल्स हैं जो विभिन्न प्रकार के डेटा (स्ट्रिंग, इंटीजर) को स्टोर करते हैं।
*   `int()`: एक स्ट्रिंग को इंटीजर में बदलता है। यह आवश्यक है क्योंकि `input()` हमेशा एक स्ट्रिंग लौटाता है, और आप सीधे स्ट्रिंग के साथ गणित नहीं कर सकते।
*   `f-strings`: स्ट्रिंग लिटरल्स के अंदर एक्सप्रेशन एम्बेड करने का एक सुविधाजनक तरीका। ओपनिंग कोट से पहले `f` पर ध्यान दें।
*   `if/else`: कंट्रोल फ्लो स्टेटमेंट्स जो एक कंडीशन के आधार पर कोड के अलग-अलग ब्लॉक्स को एक्ज़िक्यूट करते हैं।

---

### 3. लिस्ट्स और लूप्स

लिस्ट्स आइटम्स के क्रमबद्ध संग्रह होते हैं। लूप्स का उपयोग कोड के एक ब्लॉक को कई बार दोहराने के लिए किया जाता है।

```python
# फलों की एक सूची
fruits = ["apple", "banana", "cherry", "date"]

print("\nMy favorite fruits:")

# 'for' लूप का उपयोग करके सूची के माध्यम से लूप करें
for fruit in fruits:
    print(f"- {fruit.capitalize()}") # .capitalize() पहले अक्षर को बड़ा करता है

# इंडेक्स द्वारा एलिमेंट्स तक पहुंच (लिस्ट्स जीरो-इंडेक्स्ड होती हैं)
print(f"\nThe first fruit is: {fruits[0]}")
print(f"The last fruit is: {fruits[-1]}") # नेगेटिव इंडेक्स अंत से एक्सेस करता है

# एक एलिमेंट जोड़ें
fruits.append("elderberry")
print(f"Updated list: {fruits}")

# एक एलिमेंट हटाएं
fruits.remove("banana")
print(f"List after removing banana: {fruits}")

# इंडिसेस प्राप्त करने के लिए 'range' का उपयोग करके लूप करें
print("\nFruits with their indices:")
for i in range(len(fruits)): # len() सूची में आइटम्स की संख्या देता है
    print(f"Index {i}: {fruits[i]}")
```

**स्पष्टीकरण:**
*   `[]`: एक लिस्ट को डिफाइन करने के लिए उपयोग किया जाता है।
*   `for ... in ...`: एक `for` लूप जो एक सीक्वेंस (जैसे लिस्ट) में प्रत्येक आइटम पर पुनरावृति करता है।
*   `fruit.capitalize()`: एक स्ट्रिंग मेथड जो स्ट्रिंग की एक कॉपी लौटाता है जिसका पहला कैरेक्टर कैपिटलाइज्ड होता है।
*   `fruits[0]`: पहले एलिमेंट (इंडेक्स 0) तक पहुंचता है।
*   `fruits[-1]`: अंतिम एलिमेंट तक पहुंचता है।
*   `list.append()`: लिस्ट के अंत में एक आइटम जोड़ता है।
*   `list.remove()`: किसी निर्दिष्ट आइटम की पहली घटना को हटाता है।
*   `range(len(fruits))`: 0 से लेकर (लेकिन लिस्ट की लंबाई को शामिल किए बिना) तक की संख्याओं का एक सीक्वेंस जनरेट करता है, जो एलिमेंट्स तक उनके इंडेक्स द्वारा पहुंचने के लिए उपयोगी है।

---

### 4. फ़ंक्शन्स

फ़ंक्शन पुन: प्रयोज्य कोड के ब्लॉक होते हैं जो एक विशिष्ट कार्य करते हैं।

```python
# एक फ़ंक्शन को परिभाषित करें जो आर्गुमेंट्स लेता है
def greet_person(name, age):
    """
    यह फ़ंक्शन किसी व्यक्ति का अभिवादन करता है और उसे उसकी उम्र बताता है।
    इस तरह एक डॉकस्ट्रिंग शामिल करना एक अच्छा अभ्यास है।
    """
    return f"Hello, {name}! You are {age} years old."

# फ़ंक्शन को कॉल करें
message1 = greet_person("Alice", 30)
print(message1)

# इसे अलग आर्गुमेंट्स के साथ फिर से कॉल करें
message2 = greet_person("Bob", 25)
print(message2)

# डिफॉल्ट पैरामीटर वाला एक फ़ंक्शन परिभाषित करें
def calculate_area(length, width=10):
    """आयत के क्षेत्रफल की गणना करता है।"""
    return length * width

print(f"\nArea of a 5x10 rectangle: {calculate_area(5)}") # डिफॉल्ट चौड़ाई का उपयोग करता है
print(f"Area of a 5x7 rectangle: {calculate_area(5, 7)}") # डिफॉल्ट चौड़ाई को ओवरराइड करता है
```

**स्पष्टीकरण:**
*   `def`: फ़ंक्शन को परिभाषित करने की कीवर्ड।
*   `greet_person(name, age)`: फ़ंक्शन का नाम और उसके पैरामीटर्स (इनपुट)।
*   `return`: फ़ंक्शन से एक वैल्यू वापस भेजता है।
*   डॉकस्ट्रिंग्स (`"""Docstring goes here"""`): बताते हैं कि फ़ंक्शन क्या करता है। डॉक्युमेंटेशन के लिए अच्छा है।
*   `calculate_area(length, width=10)`: एक डिफॉल्ट पैरामीटर दिखाता है। यदि फ़ंक्शन को कॉल करते समय `width` प्रदान नहीं किया जाता है, तो यह डिफॉल्ट रूप से 10 हो जाता है।

---

### 5. डिक्शनरीज़

डिक्शनरी डेटा को की-वैल्यू जोड़े में स्टोर करती हैं। वे अनऑर्डर्ड होती हैं (पुराने Python वर्जन में, Python 3.7+ में ऑर्डर्ड)।

```python
# एक व्यक्ति का प्रतिनिधित्व करने वाली एक डिक्शनरी
person = {
    "first_name": "Charlie",
    "last_name": "Smith",
    "age": 40,
    "city": "London",
    "occupations": ["Engineer", "Teacher"] # एक लिस्ट एक वैल्यू हो सकती है
}

print("\nPerson's details:")

# कुंजी द्वारा मानों तक पहुंच
print(f"Name: {person['first_name']} {person['last_name']}")
print(f"Lives in: {person.get('city', 'Unknown')}") # .get() अधिक सुरक्षित है, यदि कुंजी नहीं मिलती है तो None/डिफॉल्ट लौटाता है
print(f"First occupation: {person['occupations'][0]}")

# एक मान को संशोधित करना
person["age"] = 41
print(f"New age: {person['age']}")

# एक नया की-वैल्यू पेयर जोड़ना
person["email"] = "charlie.smith@example.com"
print(f"Email: {person['email']}")

# एक डिक्शनरी के माध्यम से लूपिंग
print("\nAll keys:")
for key in person: # डिफ़ॉल्ट रूप से कुंजियों के माध्यम से लूप करता है
    print(key)

print("\nAll values:")
for value in person.values():
    print(value)

print("\nAll key-value pairs:")
for key, value in person.items():
    print(f"{key}: {value}")
```

**स्पष्टीकरण:**
*   `{}`: डिक्शनरी को परिभाषित करने के लिए उपयोग किया जाता है।
*   `"key": value`: की-वैल्यू जोड़े। कुंजियाँ अद्वितीय और अपरिवर्तनीय (जैसे स्ट्रिंग्स या नंबर्स) होनी चाहिए। वैल्यू कोई भी डेटा टाइप हो सकती है।
*   `person['key']`: `key` से जुड़े वैल्यू तक पहुंचता है।
*   `person.get('key', 'default_value')`: एक्सेस करने का एक सुरक्षित तरीका, यदि कुंजी मौजूद नहीं है तो `KeyError` से बचाता है, इसके बजाय `default_value` लौटाता है।
*   `dict.values()`: एक व्यू ऑब्जेक्ट लौटाता है जो डिक्शनरी के सभी वैल्यू की एक सूची प्रदर्शित करता है।
*   `dict.items()`: एक व्यू ऑब्जेक्ट लौटाता है जो डिक्शनरी के की-वैल्यू ट्यूपल जोड़े की एक सूची प्रदर्शित करता है।

---

यह सिर्फ सतह को छू रहा है, लेकिन ये उदाहरण कई मौलिक Python अवधारणाओं को कवर करते हैं जिनका आप अक्सर उपयोग करेंगे!