---
audio: false
generated: true
image: false
lang: hi
layout: post
model: x-ai/grok-code-fast-1
title: मेमकैश्ड इन-मेमोरी कैशिंग सिस्टम अवलोकन
translated: true
type: note
---

### Memcached क्या है?

Memcached एक ओपन-सोर्स, हाई-परफॉर्मेंस, डिस्ट्रिब्यूटेड मेमोरी ऑब्जेक्ट कैशिंग सिस्टम है। इसका मुख्य उपयोग डायनामिक वेब एप्लिकेशन (जैसे कि PHP फ्रेमवर्क जैसे CodeIgniter से बने एप्लिकेशन) की गति बढ़ाने के लिए किया जाता है, जहाँ यह डेटाबेस क्वेरी रिजल्ट्स, API रिस्पॉन्सेस, या अन्य कम्प्यूटेशनली महंगे डेटा को RAM में कैश करके रखता है। इससे डेटाबेस पर लोड कम होता है और एप्लिकेशन की रिस्पॉन्स टाइम में सुधार होता है। यह एक पूर्ण डेटाबेस नहीं है, बल्कि अस्थायी डेटा स्टोरेज के लिए डिज़ाइन किया गया एक साधारण की-वैल्यू स्टोर है।

### Memcached कैसे काम करता है?

Memcached एक डेमन (बैकग्राउंड प्रोसेस) के रूप में काम करता है जो एक या अधिक सर्वर पर चलता है, आमतौर पर `memcached -p 11211 -m 64` (पोर्ट और मेमोरी लिमिट निर्दिष्ट करते हुए) जैसे कमांड्स से शुरू किया जाता है। यहाँ एक सरल अवलोकन दिया गया है:

1.  **इन-मेमोरी स्टोरेज**: यह डेटा को की-वैल्यू पेयर्स के रूप में पूरी तरह से RAM में स्टोर करता है ताकि एक्सेस तेज़ हो। प्रत्येक वैल्यू अधिकतम 1 MB तक की हो सकती है, और कीज़ 250 कैरेक्टर तक की स्ट्रिंग्स होती हैं। डेटा वोलेटाइल होता है—अगर सर्वर रीस्टार्ट होता है, तो कैश किया गया डेटा खो जाता है।

2.  **क्लाइंट-सर्वर मॉडल**: एप्लिकेशन (क्लाइंट) TCP या UDP प्रोटोकॉल के जरिए Memcached से कनेक्ट होते हैं। प्रदान किया गया CodeIgniter कॉन्फ़िगरेशन स्निपेट एक PHP सेटअप दिखाता है जो एक लोकल Memcached इंस्टेंस से कनेक्ट हो रहा है:
    *   **होस्टनाम**: '127.0.0.1' (लोकलहोस्ट, मतलब आपके एप के समान सर्वर)।
    *   **पोर्ट**: '11211' (Memcached का डिफ़ॉल्ट पोर्ट)।
    *   **वेट**: '1' (क्लस्टर में सर्वर की प्राथमिकता को परिभाषित करता है; अधिक वैल्यू का मतलब अधिक लोड)।

3.  **ऑपरेशन्स**:
    *   सेट: एक की-वैल्यू पेयर को एक वैकल्पिक एक्सपायरेशन टाइम के साथ स्टोर करना (उदाहरण के लिए, `set app_name 0 3600 13\n"cached_data"` टेलनेट के जरिए)।
    *   गेट: की के द्वारा वैल्यू को पुनः प्राप्त करना।
    *   डिलीट: की के द्वारा हटाना।
    यह क्लस्टर्ड सेटअप में कीज़ को सर्वर के बीच वितरित करने के लिए एक साधारण हैशिंग एल्गोरिदम का उपयोग करता है (उदाहरण के लिए, सर्वर के जुड़ने/हटने को हैंडल करने के लिए कंसिस्टेंट हैशिंग)।

4.  **एविक्शन और स्केलिंग**: अगर मेमोरी भर जाती है, तो यह पुराने डेटा को हटाने के लिए LRU (Least Recently Used) पॉलिसी का उपयोग करता है। स्केलिंग में कई सर्वर इंस्टेंस शामिल होते हैं, जिन्हें अक्सर moxi जैसे टूल्स या एक्सटर्नल शार्डिंग के जरिए ऑटो-डिस्कवर किया जाता है।

परफॉर्मेंस प्रति सेकंड लाखों ऑपरेशन्स पर पीक करती है, लेकिन यह रीड-हैवी वर्कलोड के लिए ऑप्टिमाइज़्ड है। memcached-top जैसे मॉनिटरिंग टूल उपयोग को ट्रैक कर सकते हैं।

### Redis से तुलना

हालाँकि Memcached और Redis दोनों ही इन-मेमोरी, की-वैल्यू डेटा स्टोर हैं जिनका उपयोग कैशिंग और हाई-स्पीड डेटा एक्सेस के लिए किया जाता है, लेकिन वे फीचर्स, आर्किटेक्चर और उपयोग के मामले में अलग-अलग हैं:

| पहलू          | Memcached                              | Redis                                                  |
|---------------|----------------------------------------|--------------------------------------------------------|
| **डेटा टाइप्स** | साधारण स्ट्रिंग्स (सिर्फ की/वैल्यू)। | स्ट्रिंग्स, हैशेस, लिस्ट्स, सेट्स, सॉर्टेड सेट्स, बिटमैप्स, हाइपरलॉगलॉग्स और भी बहुत कुछ सपोर्ट करता है। कॉम्प्लेक्स डेटा स्ट्रक्चर्स (जैसे JSON ऑब्जेक्ट्स या काउंटर्स) की अनुमति देता है। |
| **परसिस्टेंस**| कोई नहीं—डेटा प्योर RAM में होता है; रीस्टार्ट पर खो जाता है। | वैकल्पिक परसिस्टेंस (AOF या RDB स्नैपशॉट्स) डिस्क पर, जो डेटा रिकवरी को सक्षम बनाता है। |
| **एविक्शन**   | सिर्फ LRU।                             | LRU, LFU (Least Frequently Used), या वोलेटाइल TTL-आधारित एविक्शन। |
| **ऑपरेशन्स** | बेसिक सेट/गेट/डिलीट/मल्टीगेट।         | हजारों कमांड्स (जैसे, pub/sub, ट्रांजैक्शन्स, Lua स्क्रिप्टिंग, जियोस्पेशियल क्वेरीज)। इंक्रीमेंट जैसे एटॉमिक ऑपरेशन्स को सपोर्ट करता है। |
| **परफॉर्मेंस**| साधारण रीड/राइट के लिए थोड़ा तेज़ (मल्टीगेट्स मदद करते हैं)। | कुल मिलाकर बेहतरीन, लेकिन कॉम्प्लेक्स स्ट्रक्चर्स के लिए थोड़ा ओवरहेड। बेंचमार्क्स दिखाते हैं कि कम-कॉम्प्लेक्सिटी सिनेरियो में शुद्ध कैशिंग के लिए Memcached बेहतर है। |
| **स्केलिंग और क्लस्टरिंग** | बिल्ट-इन कंसिस्टेंट हैशिंग के जरिए; कोई नेटिव क्लस्टरिंग नहीं (एक्सटर्नल पार्टीशनिंग का उपयोग करें)। | नेटिव क्लस्टरिंग, रेप्लिकेशन (मास्टर-स्लेव), और ऑटोमैटिक पार्टीशनिंग के लिए Redis क्लस्टर को सपोर्ट करता है। |
| **उपयोग के मामले** | वेब ऐप कैशिंग (जैसे, सेशन या क्वेरी कैश) के लिए आदर्श, जैसे कि CodeIgniter सेटअप्स में। सरल और हल्का। | व्यापक: कैशिंग, सेशन स्टोरेज, मैसेज क्यू, रियल-टाइम एनालिटिक्स, या यहाँ तक कि एक पूर्ण डेटाबेस विकल्प के रूप में। |
| **मेमोरी एफिशिएंसी** | फिक्स्ड-साइज डेटा के लिए कारगर; कोई कम्प्रेशन नहीं। | बड़े डेटासेट्स के लिए कम्प्रेशन ऑप्शन्स (Redis 5+) के साथ बेहतर। |
| **प्रोटोकॉल**   | कस्टम बाइनरी/टेक्स्ट प्रोटोकॉल।         | बेहतर एरर हैंडलिंग के साथ RESP (Redis Serialization Protocol)। |
| **लाइसेंसिंग और इकोसिस्टम** | ओपन-सोर्स (BSD), LAMP स्टैक्स में व्यापक रूप से उपयोग किया जाता है। | ओपन-सोर्स (BSD), RedisInsight जैसे टूल्स के साथ बड़ा कम्युनिटी। |

संक्षेप में, बेसिक कैशिंग (जैसा कि आपके CodeIgniter कॉन्फ़िग में दिखाया गया है) में सरलता और गति के लिए Memcached चुनें। अगर आपको परसिस्टेंस, एडवांस्ड डेटा टाइप्स, या pub/sub मैसेजिंग जैसी फीचर्स की जरूरत है तो Redis चुनें। अगर Memcached से माइग्रेट कर रहे हैं, तो redis-memcached जैसी प्रोजेक्ट्स कंपैटिबिलिटी लेयर ऑफर करती हैं, लेकिन अपनी बहुमुखी प्रतिभा के कारण Redis अक्सर Memcached की जगह ले लेता है। CodeIgniter के लिए विशेष रूप से, कॉन्फ़िग ड्राइवरों के बीच सीमलेस स्वैपिंग की अनुमति देता है।