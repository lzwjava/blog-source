---
audio: false
generated: true
lang: hi
layout: post
title: वॉशिंग मशीन मॉनिटरिंग के लिए रास्पबेरी पाई बनाम अरडुइनो टेलीग्राम अलर्ट्स के
  साथ
translated: true
type: note
---

अपनी Maytag MHW8630HW वॉशिंग मशीन के रुकने का पता लगाने और एक टेलीग्राम नोटिफिकेशन भेजने के लिए Arduino (जैसे ESP32-CAM) के बजाय Raspberry Pi का उपयोग करना एक व्यवहार्य विकल्प है, जो बढ़ी हुई जटिलता और बिजली की खपत की कीमत पर अधिक प्रसंस्करण शक्ति और लचीलापन प्रदान करता है। नीचे, मैं Raspberry Pi के दृष्टिकोण की Arduino समाधान के साथ तुलना करूंगा, अन्य माइक्रोकंट्रोलर विकल्पों की रूपरेखा दूंगा, और Raspberry Pi के साथ सिस्टम को लागू करने के लिए एक विस्तृत गाइड प्रदान करूंगा। मैं वैकल्पिक दृष्टिकोणों (जैसे, अन्य हार्डवेयर या सेंसर) पर भी चर्चा करूंगा ताकि एक व्यापक प्रतिक्रिया सुनिश्चित की जा सके।

---

### तुलना: Raspberry Pi बनाम Arduino बनाम अन्य विकल्प

| **फीचर**                | **Raspberry Pi**                                                                 | **Arduino (ESP32-CAM)**                                                  | **अन्य विकल्प (जैसे, NodeMCU, ESP8266)**                              |
|----------------------------|----------------------------------------------------------------------------------|-------------------------------------------------------------------------|-------------------------------------------------------------------------|
| **प्रोसेसिंग पावर**       | High (quad-core CPU, 1-8GB RAM) – एडवांस्ड इमेज प्रोसेसिंग, OpenCV को सपोर्ट करता है।    | Limited (dual-core, 520KB SRAM) – केवल बेसिक इमेज प्रोसेसिंग।           | Very limited – कैमरा-आधारित प्रोसेसिंग के लिए उपयुक्त नहीं।                 |
| **कैमरा सपोर्ट**         | USB वेबकैम या Pi कैमरा मॉड्यूल (जैसे, 8MP Pi कैमरा v2) के साथ आसान।             | बिल्ट-इन OV2640 (2MP) कैमरा, लेकिन कम रिज़ॉल्यूशन और क्वालिटी।          | एक्सटर्नल कैमरा मॉड्यूल की आवश्यकता, इंटीग्रेशन जटिल।                  |
| **Wi-Fi**                 | बिल्ट-इन (अधिकांश मॉडल, जैसे, Pi 4, Zero 2 W)।                                   | बिल्ट-इन (ESP32-CAM)।                                                  | बिल्ट-इन (जैसे, ESP8266), लेकिन कोई नेटिव कैमरा सपोर्ट नहीं।                 |
| **प्रोग्रामिंग**            | Python, OpenCV, बहुमुखी लेकिन OS सेटअप (Raspberry Pi OS) की आवश्यकता।              | Arduino IDE में C++, शुरुआती लोगों के लिए सरल।                              | C++ या Lua (जैसे, NodeMCU), इमेज प्रोसेसिंग के लिए सीमित लाइब्रेरी।     |
| **बिजली की खपत**      | अधिक (~2.5W Pi Zero के लिए, ~5-10W Pi 4 के लिए)।                                    | कम (~1-2W ESP32-CAM के लिए)।                                           | सबसे कम (~0.5-1W ESP8266 के लिए)।                                          |
| **लागत**                   | $10 (Pi Zero W) से $35+ (Pi 4) + $15 Pi कैमरा के लिए।                            | ~$10 (कैमरा के साथ ESP32-CAM)।                                          | ~$5-10 (ESP8266/NodeMCU) + सेंसर लागत।                               |
| **सेटअप की आसानी**          | मध्यम (OS सेटअप, Python कोडिंग)।                                             | आसान (Arduino IDE, सिंगल स्केच)।                                      | सरल सेंसर के लिए आसान, कैमरा के लिए जटिल।                           |
| **सर्वोत्तम उपयोग का मामला**          | एडवांस्ड इमेज प्रोसेसिंग, भविष्य के विस्तार के लिए लचीला (जैसे, ML मॉडल)।    | सरल, कम लागत वाली लाइट डिटेक्शन के साथ टेलीग्राम इंटीग्रेशन।             | गैर-कैमरा समाधान (जैसे, वाइब्रेशन या करंट सेंसर)।              |

**Raspberry Pi के फायदे**:
- मजबूत लाइट डिटेक्शन के लिए OpenCV के साथ उत्कृष्ट इमेज प्रोसेसिंग।
- डीबग और विस्तार करना आसान (जैसे, वेब इंटरफेस या एकाधिक सेंसर जोड़ें)।
- अलग-अलग लाइट कंडीशन में बेहतर सटीकता के लिए उच्च-गुणवत्ता वाले कैमरा को सपोर्ट करता है।

**Raspberry Pi के नुकसान**:
- अधिक सेटअप की आवश्यकता (OS इंस्टालेशन, Python एनवायरनमेंट)।
- अधिक बिजली की खपत, बैटरी-संचालित सेटअप के लिए कम आदर्श।
- ESP32-CAM की तुलना में अधिक महंगा।

**अन्य विकल्प**:
- **NodeMCU/ESP8266**: गैर-कैमरा समाधानों के लिए उपयुक्त (जैसे, वाइब्रेशन सेंसर या करंट सेंसर का उपयोग करना)। सीमित प्रोसेसिंग पावर कैमरा इंटीग्रेशन को अव्यावहारिक बनाती है।
- **वाइब्रेशन सेंसर**: पैनल लाइट के बजाय मशीन के कंपन का पता लगाता है। सरल लेकिन सूक्ष्म चक्र परिवर्तनों को छोड़ सकता है।
- **करंट सेंसर**: मशीन के रुकने का पता लगाने के लिए बिजली की खपत को मापता है (जैसे, ACS712 मॉड्यूल)। गैर-आक्रामक लेकिन इलेक्ट्रिकल सेटअप की आवश्यकता होती है।

---

### Raspberry Pi इम्प्लीमेंटेशन गाइड

#### टेक स्टैक
**हार्डवेयर**:
1. **Raspberry Pi**:
   - **Raspberry Pi Zero 2 W** ($15, कॉम्पैक्ट, Wi-Fi सक्षम) या **Raspberry Pi 4** ($35+, अधिक शक्तिशाली)।
2. **कैमरा**:
   - **Raspberry Pi कैमरा मॉड्यूल v2** ($15, 8MP) या एक USB वेबकैम।
3. **पावर सप्लाई**:
   - 5V USB-C (Pi 4) या micro-USB (Pi Zero) with 2-3A आउटपुट।
4. **माउंटिंग**:
   - वाशिंग मशीन के पैनल लाइट की ओर कैमरा रखने के लिए एन्क्लोजर या चिपकने वाला माउंट।

**सॉफ्टवेयर**:
1. **OS**: Raspberry Pi OS (दक्षता के लिए Lite, आसान सेटअप के लिए Full)।
2. **प्रोग्रामिंग लैंग्वेज**: Python।
3. **लाइब्रेरी**:
   - **OpenCV**: पैनल लाइट का पता लगाने के लिए इमेज प्रोसेसिंग के लिए।
   - **python-telegram-bot**: टेलीग्राम नोटिफिकेशन के लिए।
   - **picamera2** (Pi कैमरा के लिए) या **fswebcam** (USB वेबकैम के लिए)।
4. **टेलीग्राम बॉट**: Arduino के समान सेटअप (बॉट टोकन और चैट आईडी के लिए BotFather का उपयोग करें)।

#### अल्गोरिदम
अल्गोरिदम Arduino दृष्टिकोण के समान है लेकिन अधिक मजबूत इमेज प्रोसेसिंग के लिए OpenCV का लाभ उठाता है:
1. **इमेज कैप्चर**: समय-समय पर (जैसे, हर 10 सेकंड) इमेज कैप्चर करने के लिए Pi कैमरा या वेबकैम का उपयोग करें।
2. **रिजन ऑफ इंटरेस्ट (ROI)**: इमेज में पैनल लाइट के चारों ओर एक आयताकार क्षेत्र को परिभाषित करें।
3. **इमेज प्रोसेसिंग**:
   - ग्रेस्केल में कन्वर्ट करें।
   - शोर कम करने के लिए Gaussian ब्लर लागू करें।
   - बैकग्राउंड के खिलाफ चमकदार पैनल लाइट का पता लगाने के लिए adaptive थ्रेशोल्डिंग का उपयोग करें।
   - ROI में औसत पिक्सेल तीव्रता की गणना करें या चमकदार पिक्सेल गिनें।
4. **स्टेट मशीन**:
   - यदि ROI चमकीला है (लाइट ON), तो मशीन को चलती हुई चिह्नित करें।
   - यदि ROI अंधेरा है (लाइट OFF) 5 मिनट के लिए, तो मशीन को रुकी हुई चिह्नित करें और एक टेलीग्राम नोटिफिकेशन भेजें।
5. **डिबाउंसिंग**: यह पुष्टि करने के लिए कि मशीन रुक गई है, 5-मिनट की देरी लागू करें।

#### इम्प्लीमेंटेशन स्टेप्स
1. **Raspberry Pi सेट अप करें**:
   - Raspberry Pi इमेजर का उपयोग करके एक SD कार्ड पर **Raspberry Pi OS** (Lite या Full) डाउनलोड करें और फ्लैश करें।
   - `/etc/wpa_supplicant/wpa_supplicant.conf` को एडिट करके या GUI का उपयोग करके Pi को Wi-Fi से कनेक्ट करें।
   - `raspi-config` (Interfacing Options > Camera) के माध्यम से कैमरा इंटरफेस सक्षम करें।

2. **डिपेंडेंसी इंस्टॉल करें**:
   ```bash
   sudo apt update
   sudo apt install python3-opencv python3-picamera2 python3-pip
   pip3 install python-telegram-bot
   ```

3. **कैमरा पोजिशन करें**:
   - वाशिंग मशीन के पैनल लाइट की ओर Pi कैमरा या USB वेबकैम माउंट करें।
   - कैमरा का परीक्षण इसके साथ करें:
     ```bash
     libcamera-still -o test.jpg
     ```
     या USB वेबकैम के लिए:
     ```bash
     fswebcam test.jpg
     ```

4. **Python स्क्रिप्ट**:
नीचे पैनल लाइट का पता लगाने और टेलीग्राम नोटिफिकेशन भेजने के लिए Raspberry Pi की एक सैंपल Python स्क्रिप्ट दी गई है।

```python
import cv2
import numpy as np
from picamera2 import Picamera2
import telegram
import asyncio
import time

# Telegram bot configuration
BOT_TOKEN = "your_bot_token"
CHAT_ID = "your_chat_id"
bot = telegram.Bot(token=BOT_TOKEN)

# Camera configuration
picam2 = Picamera2()
picam2.configure(picam2.create_still_configuration(main={"size": (640, 480)}))
picam2.start()

# ROI configuration (camera view के आधार पर adjust करें)
ROI_X, ROI_Y, ROI_WIDTH, ROI_HEIGHT = 200, 150, 50, 50
THRESHOLD = 150  # Brightness threshold (0-255)
STOP_DELAY = 300  # 5 minutes in seconds

machine_running = False
last_on_time = 0

async def send_telegram_message(message):
    await bot.send_message(chat_id=CHAT_ID, text=message)

def is_light_on(frame):
    # Convert to grayscale
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    # Apply Gaussian blur
    gray = cv2.GaussianBlur(gray, (5, 5), 0)
    # Extract ROI
    roi = gray[ROI_Y:ROI_Y+ROI_HEIGHT, ROI_X:ROI_X+ROI_WIDTH]
    # Calculate average brightness
    avg_brightness = np.mean(roi)
    return avg_brightness > THRESHOLD

async def main():
    global machine_running, last_on_time
    while True:
        # Capture image
        frame = picam2.capture_array()
        # Check if light is on
        if is_light_on(frame):
            if not machine_running:
                machine_running = True
                print("Machine is ON")
            last_on_time = time.time()
        else:
            if machine_running and (time.time() - last_on_time > STOP_DELAY):
                machine_running = False
                print("Machine stopped")
                await send_telegram_message("Washing machine stopped! Time to hang up clothes.")
        time.sleep(10)  # Check every 10 seconds

if __name__ == "__main__":
    asyncio.run(main())
```

5. **स्क्रिप्ट कस्टमाइज़ करें**:
   - `BOT_TOKEN` और `CHAT_ID` को अपने टेलीग्राम क्रेडेंशियल्स से बदलें।
   - एक टेस्ट इमेज कैप्चर करके और पैनल लाइट का पता लगाने के लिए GIMP या Python जैसे टूल से उसका विश्लेषण करके `ROI_X`, `ROI_Y`, `ROI_WIDTH`, `ROI_HEIGHT` को एडजस्ट करें।
   - टेस्ट इमेज के आधार पर `THRESHOLD` को ट्यून करें (चमकदार लाइट के लिए उच्चतर)।
   - यदि आवश्यक हो तो `STOP_DELAY` को संशोधित करें।

6. **स्क्रिप्ट रन करें**:
   ```bash
   python3 washer_monitor.py
   ```
   - विश्वसनीयता के लिए `nohup python3 washer_monitor.py &` के साथ बैकग्राउंड में रन करें या systemd सर्विस का उपयोग करें।

7. **टेस्ट और डिप्लॉय करें**:
   - वाशिंग मशीन चलाएं और स्क्रिप्ट के आउटपुट की निगरानी करें।
   - टेलीग्राम नोटिफिकेशन सत्यापित करें।
   - Pi और कैमरा को एक स्थायी सेटअप में सुरक्षित करें।

---

### अन्य विकल्प
1. **वाइब्रेशन सेंसर**:
   - **हार्डवेयर**: ESP8266 या Raspberry Pi के साथ वाइब्रेशन सेंसर (जैसे, SW-420) का उपयोग करें।
   - **सेटअप**: मशीन के कंपन का पता लगाने के लिए सेंसर को वाशिंग मशीन से अटैच करें।
   - **अल्गोरिदम**: मशीन के रुकने का पता लगाने के लिए निरंतर कंपन की अनुपस्थिति (जैसे, 5 मिनट) की निगरानी करें।
   - **फायदे**: सरल, कम लागत, परिवेश के प्रकाश से अप्रभावित।
   - **नुकसान**: लंबे विराम (जैसे, सोकिंग) वाले चक्रों को छोड़ सकता है।
   - **कोड उदाहरण (ESP8266)**:
     ```cpp
     #include <ESP8266WiFi.h>
     #include <UniversalTelegramBot.h>
     #define VIBRATION_PIN D5
     #define BOT_TOKEN "your_bot_token"
     #define CHAT_ID "your_chat_id"
     WiFiClientSecure client;
     UniversalTelegramBot bot(BOT_TOKEN, client);
     bool machineRunning = false;
     unsigned long lastVibrationTime = 0;
     void setup() {
       pinMode(VIBRATION_PIN, INPUT);
       WiFi.begin("ssid", "password");
       while (WiFi.status() != WL_CONNECTED) delay(500);
       client.setInsecure();
     }
     void loop() {
       if (digitalRead(VIBRATION_PIN)) {
         machineRunning = true;
         lastVibrationTime = millis();
       } else if (machineRunning && (millis() - lastVibrationTime > 300000)) {
         machineRunning = false;
         bot.sendMessage(CHAT_ID, "Washing machine stopped!", "");
       }
       delay(1000);
     }
     ```

2. **करंट सेंसर**:
   - **हार्डवेयर**: ESP8266 या Raspberry Pi के साथ ACS712 करंट सेंसर का उपयोग करें।
   - **सेटअप**: वाशिंग मशीन के पावर कॉर्ड के चारों ओर गैर-आक्रामक रूप से सेंसर क्लैंप करें।
   - **अल्गोरिदम**: एक थ्रेशोल्ड (जैसे, <0.5A) से नीचे करंट गिरने का 5 मिनट तक पता लगाएं।
   - **फायदे**: सटीक, गैर-आक्रामक।
   - **नुकसान**: मशीन की बिजली खपत के लिए केलिब्रेशन की आवश्यकता, इलेक्ट्रिकल ज्ञान की आवश्यकता।

3. **माइक्रोफोन**:
   - **हार्डवेयर**: Raspberry Pi के साथ माइक्रोफोन मॉड्यूल (जैसे, KY-038) का उपयोग करें।
   - **अल्गोरिदम**: मशीन के शोर के रुकने का पता लगाने के लिए साउंड लेवल का विश्लेषण करें।
   - **फायदे**: गैर-विजुअल, कम रोशनी वाली स्थितियों में काम करता है।
   - **नुकसान**: परिवेश के शोर के प्रति संवेदनशील, सिग्नल प्रोसेसिंग की आवश्यकता।

---

### सिफारिश
- **Raspberry Pi**: मजबूत इमेज प्रोसेसिंग और भविष्य की विस्तार योग्यता के लिए सर्वश्रेष्ठ। उपयोग करें यदि आप Python के साथ सहज हैं और अलग-अलग रोशनी की स्थितियों में उच्च विश्वसनीयता चाहते हैं।
- **Arduino (ESP32-CAM)**: कम लागत, सरल सेटअप के लिए सर्वश्रेष्ठ। आदर्श यदि आप न्यूनतम कॉन्फ़िगरेशन चाहते हैं और बेसिक इमेज प्रोसेसिंग से ठीक हैं।
- **वाइब्रेशन या करंट सेंसर**: गैर-कैमरा समाधानों के लिए सर्वश्रेष्ठ, खासकर यदि पैनल लाइट अविश्वसनीय है (जैसे, मंद या अवरुद्ध)। सरलता के लिए ESP8266 के साथ उपयोग करें।
- **माइक्रोफोन**: परिवेश के शोर के कारण कम विश्वसनीय, लेकिन एक सेकेंडरी सेंसर के रूप में व्यवहार्य।

आपके दो-मंजिला घर के लिए, Raspberry Pi या ESP32-CAM with कैमरा आदर्श है क्योंकि आप दूसरी मंजिल पर हैं और टेलीग्राम के माध्यम से विश्वसनीय रिमोट नोटिफिकेशन की आवश्यकता है। Raspberry Pi लाइट डिटेक्शन के लिए बेहतर सटीकता प्रदान करता है, जबकि ESP32-CAM तैनात करने के लिए सस्ता और सरल है। यदि आप गैर-कैमरा दृष्टिकोण पसंद करते हैं, तो ESP8266 के साथ एक वाइब्रेशन सेंसर सबसे आसान विकल्प है।

मुझे बताएं कि क्या आप किसी विशिष्ट दृष्टिकोण में गहराई से उतरना चाहते हैं, सेटअप में सहायता चाहते हैं, या किसी वैकल्पिक सेंसर के लिए कोड चाहते हैं!