---
audio: false
generated: true
lang: hi
layout: post
title: कोडफोर्सेस 2108एफ
translated: true
type: note
---

आइए समझते हैं कि दिया गया Java कोड "Fallen Towers" समस्या को कैसे हल करता है। इस समस्या में \\( n \\) टावरों की एक सरणी होती है, जहाँ प्रत्येक टावर की ऊँचाई \\( a_i \geq 0 \\) होती है। आप स्थिति \\( i \\) पर मौजूद टावर को गिरा सकते हैं, जो अगले \\( a_i \\) टावरों की ऊँचाई 1 से बढ़ा देता है (या कम अगर बचे हुए टावर पर्याप्त नहीं हैं), और फिर \\( a_i \\) को 0 पर सेट कर देता है। लक्ष्य है सभी \\( n \\) टावरों को किसी भी क्रम में ठीक एक बार गिराना, यह सुनिश्चित करते हुए कि अंतिम सरणी गैर-घटती हुई हो (यानी, किसी भी \\( i < j \\) के लिए, स्थिति \\( i \\) पर ऊँचाई, स्थिति \\( j \\) पर ऊँचाई से कम या बराबर हो)। आउटपुट अंतिम सरणी का अधिकतम MEX है, जहाँ MEX सरणी में मौजूद न होने वाला सबसे छोटा गैर-ऋणात्मक पूर्णांक है।

---

### समस्या का विश्लेषण

1. **ऑपरेशन की परिभाषा**:
   - ऊँचाई \\( a_i \\) वाले टावर \\( i \\) को गिराना:
     - स्थितियों \\( i+1, i+2, \dots, i+a_i \\) पर मौजूद टावरों की ऊँचाई 1 से बढ़ा देता है (यदि वे मौजूद हों)।
     - \\( a_i \\) को 0 पर सेट कर देता है।
   - प्रत्येक टावर को किसी भी क्रम में ठीक एक बार गिराना होगा।
   - यदि \\( a_i = 0 \\) है, तो टावर \\( i \\) को गिराने का अन्य टावरों पर कोई प्रभाव नहीं पड़ता।

2. **गैर-घटती हुई अंतिम सरणी**:
   - सभी ऑपरेशनों के बाद, अंतिम सरणी \\( b_1, b_2, \dots, b_n \\) को \\( b_i \leq b_{i+1} \\) सभी \\( i < n \\) के लिए संतुष्ट करना होगा।

3. **MEX**:
   - अंतिम सरणी का MEX सबसे छोटा गैर-ऋणात्मक पूर्णांक \\( m \\) है जो \\( \{b_1, b_2, \dots, b_n\} \\) में मौजूद नहीं है।
   - चूँकि सरणी गैर-घटती हुई है, यदि सरणी में मान \\( 0, 1, 2, \dots, k-1 \\) (संभवतः दोहराव के साथ) मौजूद हैं लेकिन \\( k \\) नहीं है, तो MEX \\( k \\) है।
   - लक्ष्य है इस MEX को अधिकतम करना।

4. **MEX की व्याख्या**:
   - MEX के \\( m \\) होने के लिए, अंतिम सरणी में 0 से \\( m-1 \\) तक के सभी पूर्णांक कम से कम एक बार अवश्य शामिल होने चाहिए, और \\( m \\) नहीं दिखना चाहिए।
   - चूँकि सरणी गैर-घटती हुई है, MEX का \\( m \\) होने का अर्थ है कि अंतिम सरणी के मान कुछ इस प्रकार होंगे: \\( 0, 0, \dots, 1, 1, \dots, m-1, m-1 \\), जहाँ 0 से \\( m-1 \\) तक का प्रत्येक पूर्णांक कम से कम एक बार आता है, और कोई भी मान \\( m \\) या उससे अधिक का नहीं होता।

5. **मुख्य अंतर्दृष्टि**:
   - MEX \\( m \\) का अर्थ है कि 0 से \\( m-1 \\) तक के प्रत्येक मान के लिए कम से कम एक स्थिति होनी चाहिए।
   - दूसरे शब्दों में, MEX \\( m \\) के लिए, हमें अंतिम सरणी में कम से कम \\( m \\) ऐसी स्थितियों की आवश्यकता होती है जहाँ स्थिति \\( i \\) का मान कम से कम \\( i - (n - m) \\) हो, क्योंकि:
     - अंतिम \\( m \\) स्थितियों (सूचकांक \\( n-m+1 \\) से \\( n \\) तक) को 0 से \\( m-1 \\) तक के मानों को कवर करना होगा।
     - स्थिति \\( n-m+1 \\) का मान कम से कम 0 होना चाहिए, स्थिति \\( n-m+2 \\) का मान कम से कम 1 होना चाहिए, ..., स्थिति \\( n \\) का मान कम से कम \\( m-1 \\) होना चाहिए।
   - इसका तात्पर्य है कि स्थिति \\( i \\) पर अंतिम ऊँचाई कम से कम \\( \max(0, m - (n - i + 1)) = \max(0, m - n + i) \\) होनी चाहिए।

---

### समाधान का दृष्टिकोण

कोड अधिकतम संभव MEX \\( m \\) खोजने के लिए बाइनरी सर्च का उपयोग करता है। प्रत्येक उम्मीदवार \\( m \\) के लिए, यह जाँचता है कि क्या एक अंतिम गैर-घटती हुई सरणी प्राप्त करना संभव है जहाँ प्रत्येक स्थिति \\( i \\) की ऊँचाई कम से कम \\( \max(0, m - n + i) \\) हो। यह सुनिश्चित करता है कि अंतिम \\( m \\) स्थितियाँ 0 से \\( m-1 \\) तक के मानों को कवर कर सकती हैं, जिससे MEX कम से कम \\( m \\) हो जाता है।

#### बाइनरी सर्च
- **सीमा**: MEX \\( m \\) कम से कम 0 (खाली सरणी के मामले में) और अधिकतम \\( n \\) (क्योंकि हमें 0 से \\( m-1 \\) तक के मानों के लिए कम से कम \\( m \\) स्थितियों की आवश्यकता होती है) हो सकता है। इस प्रकार, \\( m \\) के लिए \\( [0, n] \\) में खोजें।
- **चेक फ़ंक्शन**: किसी दिए गए \\( m \\) के लिए, निर्धारित करें कि क्या टावरों को गिराने का कोई ऐसा क्रम मौजूद है कि अंतिम सरणी संतुष्ट करे:
  - \\( b_i \geq \max(0, m - n + i) \\) सभी \\( i \\) के लिए।
  - सरणी गैर-घटती हुई हो।

#### चेक फ़ंक्शन
चेक फ़ंक्शन एक डिफरेंस एरे दृष्टिकोण का उपयोग करके सिम्युलेट करता है कि क्या टावरों को किसी भी क्रम में गिराकर आवश्यक ऊँचाइयाँ प्राप्त की जा सकती हैं।

1. **आवश्यक ऊँचाइयाँ**:
   - MEX \\( m \\) के लिए, स्थिति \\( i \\) को एक अंतिम ऊँचाई \\( b_i \geq \text{need}_i \\) की आवश्यकता होती है, जहाँ:
     \\[
     \text{need}_i = \max(0, m - n + i)
     \\]
   - यह सुनिश्चित करता है कि स्थितियाँ \\( n-m+1 \\) से \\( n \\) तक की ऊँचाइयाँ क्रमशः कम से कम 0, 1, ..., \\( m-1 \\) हों।

2. **डिफरेंस एरे**:
   - कोड ऑपरेशनों के संचयी प्रभाव को ट्रैक करने के लिए एक डिफरेंस एरे \\( d \\) का उपयोग करता है।
   - सभी \\( i \\) के लिए \\( d[i] = 0 \\) इनिशियलाइज़ करें।
   - प्रत्येक स्थिति \\( i \\) के लिए:
     - संचयी योग की गणना करें: \\( d[i] += d[i-1] \\) (यदि \\( i > 0 \\)), जो स्थिति \\( i \\) पर एक्स्ट्रा ब्लॉक्स की वर्तमान संख्या को दर्शाता है।
     - जाँचें कि क्या \\( d[i] \geq \text{need}_i \\)। यदि नहीं, तो आवश्यक ऊँचाई प्राप्त करना असंभव है, इसलिए \\( false \\) लौटाएँ।
     - टावर \\( i \\) को गिराने से प्रभावित रेंज की लंबाई की गणना करें:
       \\[
       \text{len} = d[i] - \text{need}_i + a_i
       \\]
       - \\( d[i] - \text{need}_i \\): न्यूनतम आवश्यकता को पूरा करने के बाद उपलब्ध अतिरिक्त ब्लॉक।
       - \\( a_i \\): टावर \\( i \\) की ऊँचाई द्वारा योगदान किए गए ब्लॉकों की संख्या।
       - यह \\( \text{len} \\) दर्शाता है कि टावर \\( i \\) को गिराने पर \\( i \\) के दाईं ओर की कितनी स्थितियों को बढ़ाया जा सकता है।
     - डिफरेंस एरे को अपडेट करें:
       - \\( d[i+1] \\) को इंक्रीमेंट करें (यदि \\( i+1 < n \\)) ताकि टावर \\( i \\) को गिराने के प्रभाव की शुरुआत हो सके।
       - \\( d[i + \text{len} + 1] \\) को डिक्रीमेंट करें (यदि \\( i + \text{len} + 1 < n \\)) ताकि \\( \text{len} \\) स्थितियों के बाद प्रभाव समाप्त हो जाए।

3. **संभाव्यता**:
   - डिफरेंस एरे वर्तमान स्थिति के आधार पर संशोधित ऊँचाई के साथ टावर \\( i \\) को गिराने के प्रभाव का सिमुलेशन करता है।
   - यदि लूप बिना \\( false \\) लौटाए पूरा हो जाता है, तो MEX \\( m \\) के लिए आवश्यक ऊँचाइयाँ प्राप्त करना संभव है।

4. **यह क्यों काम करता है**:
   - चेक फ़ंक्शन वास्तविक ऑपरेशनों के क्रम का सिमुलेशन नहीं करता बल्कि यह सत्यापित करता है कि क्या कोई ऐसा क्रम मौजूद है जो ऊँचाई की आवश्यकताओं को संतुष्ट करता है।
   - डिफरेंस एरे दृष्टिकोण यह सुनिश्चित करता है कि प्रत्येक स्थिति में जोड़े गए ब्लॉकों की संख्या किसी वैध ऑपरेशन अनुक्रम के साथ सुसंगत है।
   - गैर-घटती हुई शर्त अप्रत्यक्ष रूप से संतुष्ट हो जाती है क्योंकि आवश्यक ऊँचाइयाँ \\( \text{need}_i = \max(0, m - n + i) \\) गैर-घटती हुई हैं (क्योंकि \\( i \\) बढ़ने पर, \\( m - n + i \\) बढ़ता है या 0 रहता है)।

#### मुख्य लूप
- टेस्ट केस की संख्या \\( t \\) पढ़ें।
- प्रत्येक टेस्ट केस के लिए:
  - \\( n \\) और सरणी \\( a \\) पढ़ें।
  - \\( m \\) पर 0 से \\( n \\) तक बाइनरी सर्च करें।
  - यह निर्धारित करने के लिए चेक फ़ंक्शन का उपयोग करें कि क्या MEX \\( m \\) प्राप्त करना संभव है।
  - \\( lo \\) (यदि प्राप्त करना संभव है) या \\( hi \\) (यदि नहीं) को अपडेट करें।
- प्रत्येक टेस्ट केस के लिए अधिकतम \\( m \\) (यानी, \\( lo \\)) आउटपुट करें।

---

### कोड समस्या को क्यों हल करता है

1. **बाइनरी सर्च की शुद्धता**:
   - बाइनरी सर्च अधिकतम \\( m \\) ढूंढता है जिसके लिए चेक फ़ंक्शन \\( true \\) लौटाता है।
   - चूँकि MEX \\( m \\) की संभाव्यता छोटे MEX मानों (कम \\( m \\) के लिए कम स्थितियों और कम ऊँचाइयों की आवश्यकता होती है) की संभाव्यता को दर्शाती है, बाइनरी सर्च सही ढंग से अधिकतम संभव MEX की पहचान करता है।

2. **चेक फ़ंक्शन की सटीकता**:
   - चेक फ़ंक्शन यह सुनिश्चित करता है कि प्रत्येक स्थिति \\( i \\) में सभी ऑपरेशनों के बाद कम से कम \\( \max(0, m - n + i) \\) ब्लॉक हो सकते हैं।
   - डिफरेंस एरे टावरों को गिराने के संचयी प्रभाव का सिमुलेशन करता है, यह ध्यान में रखते हुए कि प्रत्येक टावर अगले \\( a_i \\) स्थितियों में \\( a_i \\) ब्लॉकों का योगदान देता है।
   - स्थितियों को बाएँ से दाएँ प्रोसेस करके और डिफरेंस एरे को एडजस्ट करके, यह सत्यापित करता है कि क्या प्रारंभिक ऊँचाइयाँ \\( a_i \\) को आवश्यक ऊँचाइयों को पूरा करने के लिए पुनर्वितरित किया जा सकता है।

3. **गैर-घटती हुई बाध्यता को संभालना**:
   - आवश्यक ऊँचाइयाँ \\( \max(0, m - n + i) \\) गैर-घटती हुई हैं, जो समस्या की गैर-घटती हुई अंतिम सरणी की आवश्यकता के अनुरूप है।
   - यदि चेक फ़ंक्शन सफल होता है, तो परिणामी सरणी को यह सुनिश्चित करके गैर-घटती हुई बनाया जा सकता है कि प्रत्येक स्थिति आवश्यक ऊँचाई को पूरा करती है या उससे अधिक है।

4. **दक्षता**:
   - **बाइनरी सर्च**: \\( O(\log n) \\) इटरेशन (क्योंकि \\( m \leq n \\))।
   - **चेक फ़ंक्शन**: प्रति कॉल \\( O(n) \\), क्योंकि यह प्रत्येक स्थिति को एक बार प्रोसेस करता है और डिफरेंस एरे को प्रति स्थिति स्थिर समय में अपडेट करता है।
   - **प्रति टेस्ट केस कुल**: \\( O(n \log n) \\)।
   - **सभी टेस्ट केस के लिए कुल**: चूँकि \\( \sum n \leq 10^5 \\), समग्र जटिलता \\( O(t \cdot n \log n) \\) है, जो 3-सेकंड की समय सीमा के भीतर फिट बैठती है।

5. **एज केस**:
   - **\\( n = 1 \\)**: यदि \\( a_1 = 0 \\), MEX = 1 (सरणी [0] बन जाती है)। यदि \\( a_1 > 0 \\), MEX = 0 (सरणी [0] बन जाती है)। कोड इसे सही ढंग से संभालता है।
   - **बड़े \\( a_i \\)**: चूँकि \\( a_i \leq 10^9 \\), लेकिन केवल पहली \\( n-i \\) स्थितियाँ प्रभावित होती हैं, कोड एरे सीमाओं का उपयोग करके प्रभाव को सही ढंग से बाउंड करता है।
   - **सभी \\( a_i = 0 \\)**: अंतिम सरणी सभी शून्य होती है, MEX = 1। चेक फ़ंक्शन इसे पुष्टि करता है।
   - **मिश्रित मान**: बाइनरी सर्च और चेक फ़ंक्शन मनमाने \\( a_i \geq 0 \\) को संभालते हैं।

---

### Java कोड की विशिष्टताएँ

Java कोड, अनुरोध के अनुसार, कुशल I/O के लिए `BufferedReader` और `PrintWriter` का उपयोग करके C++ लॉजिक को अपनाता है। मुख्य पहलू:

1. **इनपुट हैंडलिंग**:
   - इंटीजर्स को पार्स करने के लिए `BufferedReader` का उपयोग लाइनें पढ़ने और `StringTokenizer` का उपयोग करता है।
   - \\( t \\) पढ़ता है, फिर प्रत्येक टेस्ट केस के लिए, \\( n \\) और सरणी \\( a \\) पढ़ता है।

2. **चेकर क्लास**:
   - C++ लैम्ब्डा फ़ंक्शन की नकल करने के लिए चेक लॉजिक को एनकैप्सुलेट करता है।
   - डिफरेंस एरे दृष्टिकोण का सिमुलेशन करने के लिए एक एरे \\( d \\) का उपयोग करता है।

3. **आउटपुट**:
   - प्रत्येक टेस्ट केस के लिए परिणाम आउटपुट करने के लिए `PrintWriter` का उपयोग करता है, यह सुनिश्चित करने के लिए `out.flush()` का उपयोग करता है कि सभी आउटपुट लिखे गए हैं।

4. **प्रदर्शन**:
   - Java कोड प्रति टेस्ट केस समान \\( O(n \log n) \\) जटिलता बनाए रखता है।
   - `BufferedReader` और `PrintWriter` यह सुनिश्चित करते हैं कि I/O \\( \sum n \leq 10^5 \\) के लिए पर्याप्त तेज़ है।

---

### निष्कर्ष

कोड "Fallen Towers" समस्या को इस प्रकार हल करता है:
- अधिकतम MEX \\( m \\) खोजने के लिए बाइनरी सर्च का उपयोग करके।
- यह सत्यापित करने के लिए एक डिफरेंस एरे-आधारित चेक फ़ंक्शन का उपयोग करके कि क्या प्रारंभिक टावर ऊँचाइयों को आवश्यक ऊँचाइयों वाली एक गैर-घटती हुई सरणी प्राप्त करने के लिए पुनर्वितरित किया जा सकता है।
- आवश्यक ऊँचाइयों की गैर-घटती हुई प्रकृति और ऑपरेशन अनुक्रमों की संभाव्यता के माध्यम से शुद्धता सुनिश्चित करके।
- सभी एज केस को संभालना और समय और मेमोरी बाध्यताओं के भीतर फिट होना।

Java इम्प्लीमेंटेशन C++ लॉजिक का विश्वसनीय रूप से अनुवाद करता है, समस्या की आवश्यकताओं को पूरा करने के लिए कुशल I/O का उपयोग करता है।