---
audio: false
generated: true
image: false
lang: hi
layout: post
model: x-ai/grok-4-fast
title: त्वरित क्रमबद्धता बनाम मर्ज क्रमबद्धता
translated: true
type: note
---

### क्विक सॉर्ट कठिन क्यों लगता है (और मर्ज सॉर्ट नहीं)

आप बिल्कुल सही कह रहे हैं — बिना संदर्भ के क्विक सॉर्ट को शुरुआत से लागू करना एक चिकने सुअर से कुश्ती लड़ने जैसा लग सकता है, जबकि मर्ज सॉर्ट कपड़े तह करने जैसा है: व्यवस्थित और अनुमेय। मर्ज सॉर्ट का "विभाजित करो, जीतो, संयोजित करो" प्रवाह रैखिक और एक साफ-सुथरे तरीके से पुनरावर्ती होता है, जिसमें मर्ज करने के चरण में कोई आश्चर्य नहीं होता। दूसरी ओर, क्विक सॉर्ट, *इन-प्लेस* होता है और एक चतुर पार्टीशनिंग ट्रिक पर निर्भर करता है जिसमें एक "पिवट" (एक चुना हुआ विभाजन बिंदु) के आसपास एलिमेंट्स की अदला-बदली शामिल होती है। पहली बार में यह अराजक लगता है क्योंकि पिवट स्थिर नहीं होता — यह एक रेफरी की तरह है जो खेल के दौरान इधर-उधर होता रहता है। लेकिन एक बार जब आप इसकी अंतर्दृष्टि को समझ जाते हैं, तो यह सुरुचिपूर्ण रूप से कुशल होता है (औसत O(n log n) समय, सबसे खराब स्थिति O(n²) अगर पिवट खराब चुने गए हों)।

मैं क्विक सॉर्ट को एक प्राकृतिक, कहानी जैसे लेंस के माध्यम से पेश करता हूं: ऊंचाई के हिसाब से एक अलमारी पर किताबों के अव्यवस्थित ढेर को सॉर्ट करने की कल्पना करें। ढेर को आधे में बांटने, सब कुछ मापने और फिर मर्ज करने (यह मर्ज सॉर्ट है) के बजाय, आप एक किताब को "बेंचमार्क" (पिवट) के रूप में चुनते हैं, फिर दूसरी किताबों को इस तरह से पुनर्व्यवस्थित करते हैं कि सभी छोटी किताबें इसके बाईं ओर और सभी लंबी किताबें इसके दाईं ओर आ जाएं। पिवट अपने *अंतिम* स्थान पर पहुंच जाता है, और आप केवल बाएं और दाएं उप-ढेरों पर पुनरावर्ती रूप से काम करते हैं। कोई अतिरिक्त जगह की आवश्यकता नहीं — बस अलमारी पर अदला-बदली। यह डच "क्विकसॉर्ट" झंडा फहराने के समारोह जैसा है (इसीलिए यह नाम), जहां आप तीन समूहों में विभाजित करते हैं: छोटा, बेंचमार्क, लंबा।

### यह काम क्यों करता है: पार्टीशनिंग का जादू

क्विक सॉर्ट काम करता है **एक गारंटी के साथ डिवाइड-एंड-कॉन्कर** के कारण: प्रत्येक पार्टीशन चरण *कम से कम एक एलिमेंट* (पिवट) को उसकी सही अंतिम स्थिति में रख देता है, हर बार समस्या को कम से कम उतना ही सिकोड़ते हुए। सबसे अच्छे मामले में, पिवट ऐरे को समान रूप से विभाजित करता है (मर्ज सॉर्ट में आधे में बांटने की तरह), जिससे संतुलित पुनरावृत्ति होती है। सबसे खराब मामले में (जैसे, पहले से सॉर्टेड ऐरे जिसमें पिवट का खराब चयन हो), यह O(n²) तक बिगड़ सकता है जैसे बबल सॉर्ट — लेकिन अच्छे पिवट चयन व्यवहार में इसे अत्यंत तेज बना देते हैं।

मुख्य अंतर्दृष्टि: **पार्टीशनिंग इनवेरिएंट्स को लागू करती है**। एक पार्टीशन के बाद:
- पिवट के बाईं ओर की हर चीज ≤ पिवट होती है।
- पिवट के दाईं ओर की हर चीज ≥ पिवट होती है।
- पिवट अब हमेशा के लिए सॉर्टेड है — इसे दोबारा छूने की आवश्यकता नहीं है।

यह प्रगति की गारंटी देता है: पुनरावृत्ति ट्री की गहराई औसतन अधिकतम log n होती है, और प्रत्येक स्तर पर कुल मिलाकर O(n) काम होता है (स्कैनिंग और स्वैपिंग)।

### पिवट कैसे चुनें (और यह तुलना के दौरान क्यों "चलता" है)

पिवट पवित्र नहीं है — यह सिर्फ कोई भी एलिमेंट है जिसे आप बेंचमार्क के रूप में चुनते हैं। खराब चयन (जैसे हमेशा पहला एलिमेंट) चीजों को असंतुलित कर सकते हैं, इसलिए यहां रणनीतियों का एक प्राकृतिक क्रम है, सरल से मजबूत तक:

1.  **नाइव: पहला (या आखिरी) एलिमेंट चुनें।**
    - कोड करना आसान, लेकिन जोखिम भरा। एक सॉर्टेड ऐरे `[1,2,3,4,5]` पर, पिवट=1 का मतलब है बायां खाली है, दायां 4 एलिमेंट्स का है — पुनरावृत्ति गहरी हो जाती है।
    - "चलना": पार्टीशन के दौरान, आप बाकी हर चीज की तुलना इस पिवट वैल्यू से करते हैं, लेकिन आप एलिमेंट्स को इसकी पोजीशन *के आसपास* स्वैप करते हैं। सीमाएं जैसे-जैसे इसे पार करती हैं, पिवट स्वयं अपनी जगह पर स्वैप हो जाता है।

2.  **बेहतर: मध्य एलिमेंट चुनें।**
    - इसे अस्थायी रूप से अंत में स्वैप करें, पिवट के रूप में उपयोग करें। सहज रूप से अधिक संतुलित (माध्यिका के करीब), लेकिन फिर भी सॉर्टेड/रिवर्स-सॉर्टेड इनपुट के प्रति संवेदनशील।

3.  **अभ्यास के लिए सर्वोत्तम: एक यादृच्छिक एलिमेंट चुनें।**
    - इसे अंत में स्वैप करें, पार्टीशन करें। यादृच्छिकता खराब मामलों को औसत कर देती है, जिससे सबसे खराब स्थिति की संभावना कम हो जाती है (उच्च संभावना के साथ, फिर भी O(n log n))। अधिकांश लाइब्रेरीज़ यही उपयोग करती हैं।

4.  **फैंसी (इंटरव्यू के लिए): मीडियन-ऑफ-थ्री।**
    - पहले/मध्य/अंतिम का माध्यिका पिवट के रूप में चुनें। गणना में तेज, आम खामियों से बचाता है।

कोड में, आप अक्सर पिवट को पहले अंत में स्वैप करके "फिक्स" करते हैं, इसके *वैल्यू* (पोजीशन नहीं) के आसपास पार्टीशन करते हैं, फिर इसे वापस उस जगह पर स्वैप कर देते हैं जहां इसका स्थान होना चाहिए। इसीलिए ऐसा लगता है कि पिवट "चलता" है — यह स्थिर नहीं है; पार्टीशन प्रक्रिया दो पॉइंटर्स (बाएं और दाएं) के माध्यम से गतिशील रूप से इसकी जगह ढूंढती है जो एक-दूसरे की ओर लीपफ्रॉग करते हुए उल्लंघन करने वालों को स्वैप करते हैं।

### एक प्रायोगिक उदाहरण: [3, 7, 1, 9, 4] को लास्ट एलिमेंट को पिवट मानकर सॉर्ट करना

आइए एक पार्टीशन चरण से गुजरते हैं। ऐरे: `[3, 7, 1, 9, 4]`। पिवट = अंतिम = 4। (हम इसे जरूरत के अनुसार स्वैप करते रहेंगे।)

- बाएं पॉइंटर को इंडेक्स 0 (वैल्यू 3) पर, दाएं को इंडेक्स 3 (वैल्यू 9, क्योंकि पिवट 4 पर है) पर शुरू करें।
- बाएं से स्कैन करें: 3 < 4? हां, इसे छोड़ दें। अगला, 7 > 4? हां, लेकिन रुकिए — हम इसे दाएं से पहले >4 वाले के साथ स्वैप करते हैं।
- असल में, मानक लोमुटो पार्टीशन (सिंगल-पॉइंटर स्टाइल):
  1. i = -1 (< पिवट के लिए सीमा)।
  2. j को 0 से n-2 तक के लिए (पिवट को छोड़कर):
     - अगर arr[j] ≤ पिवट (4), तो arr[++i] को arr[j] से स्वैप करें। (बाएं तरफ को बढ़ाएं।)
  3. अंत में, पिवट को arr[++i] से स्वैप करके रखें।

चरण-दर-चरण:
- j=0: 3 ≤4? हां। i=0, arr[0] को arr[0] से स्वैप करें (कोई बदलाव नहीं)। ऐरे: [3,7,1,9,4]
- j=1: 7 ≤4? नहीं। छोड़ें।
- j=2: 1 ≤4? हां। i=1, arr[1] (7) को arr[2] (1) से स्वैप करें। ऐरे: [3,1,7,9,4]
- j=3: 9 ≤4? नहीं। छोड़ें।
- अंत: पिवट (4 इंडेक्स 4 पर) को arr[++i=2] (7) से स्वैप करें। ऐरे: [3,1,4,9,7]

अब: 4 (इंडेक्स 2) के बायीं ओर [3,1] है (दोनों ≤4, अनसॉर्टेड), दायीं ओर [9,7] है (दोनों ≥4, अनसॉर्टेड)। पिवट=4 *हो गया*। बाएं [3,1] और दाएं [9,7] पर पुनरावृत्ति करें।

- बायां: पिवट=1, [1,3] में पार्टीशन होता है।
- दायां: पिवट=7, [7,9] में पार्टीशन होता है।

पूर्ण सॉर्ट: [1,3,4,7,9]। देखा? प्रत्येक चरण प्रगति को स्थिर करता है, और स्वैप पिवट को उसके घर "ले जाते" हैं।

### स्यूडोकोड स्केच (कार्यान्वयन को आसान बनाने के लिए)

```
quicksort(arr, low, high):
    if low < high:
        pivot_idx = partition(arr, low, high)
        quicksort(arr, low, pivot_idx-1)
        quicksort(arr, pivot_idx+1, high)

partition(arr, low, high):  # लोमुटो स्टाइल, पिवट हाई पर
    pivot = arr[high]
    i = low - 1
    for j in low to high-1:
        if arr[j] <= pivot:
            i += 1
            swap arr[i], arr[j]
    swap arr[i+1], arr[high]
    return i+1
```

"चलना" उन स्वैप में होता है: एलिमेंट्स एक-दूसरे के पास से होकर तब तक गुजरते हैं जब तक कि पिवट स्थिर नहीं हो जाता। कागज पर 5-6 एलिमेंट्स के साथ अभ्यास करें — एक बार पार्टीशन क्लिक हो जाने पर, पुनरावृत्ति स्वाभाविक लगने लगती है। यदि आप अटक जाते हैं, तो इसे मानसिक रूप से उस किताब-सॉर्टिंग अलमारी के रूप में एनिमेट करने का प्रयास करें।

गहन जानकारी के लिए:
[क्विक सॉर्ट विज़ुअलाइज़ेशन](https://visualgo.net/en/sorting?slide=9)
[क्विकसॉर्ट पर CLRS अध्याय](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-20.html#%_sec_3.3)