---
audio: false
date: 2025-09-11
generated: true
image: false
lang: hi
layout: post
model: mistralai/mistral-medium-3.1
title: Pytest फिक्स्चर के उपयोग को समझना
translated: true
type: note
---

## `@pytest.fixture` क्या है?

`@pytest.fixture` एक डेकोरेटर है जो किसी फ़ंक्शन को एक **फिक्स्चर** के रूप में चिह्नित करता है - एक विशेष फ़ंक्शन जो आपके टेस्ट को टेस्ट डेटा, सेटअप, या टीयरडाउन फंक्शनैलिटी प्रदान करता है। फिक्स्चर pytest की सबसे शक्तिशाली विशेषताओं में से एक हैं और एक मुख्य कारण है कि कई डेवलपर Python के बिल्ट-इन `unittest` मॉड्यूल पर pytest को प्राथमिकता देते हैं।

## फिक्स्चर कैसे काम करते हैं

फिक्स्चर एक सरल लेकिन शक्तिशाली पैटर्न का पालन करते हैं:

1. **सेटअप**: `yield` स्टेटमेंट से पहले का कोड टेस्ट से पहले चलता है
2. **टेस्ट एक्सेक्यूशन**: टेस्ट तब चलता है जब वह `yield` स्टेटमेंट तक पहुँचता है
3. **टीयरडाउन**: `yield` स्टेटमेंट के बाद का कोड टेस्ट के पूरा होने के बाद चलता है

### बेसिक फिक्स्चर उदाहरण

```python
import pytest

@pytest.fixture
def sample_data():
    # सेटअप कोड
    data = {"name": "John", "age": 30}
    yield data  # टेस्ट यहाँ चलता है
    # टीयरडाउन कोड (टेस्ट के बाद चलता है)
    print("Cleaning up sample data")
```

## हमें फिक्स्चर की आवश्यकता क्यों है

फिक्स्चर कई सामान्य टेस्टिंग समस्याओं का समाधान करते हैं:

1. **टेस्ट आइसोलेशन**: सुनिश्चित करें कि प्रत्येक टेस्ट ताज़ा, पूर्वानुमेय डेटा के साथ चले
2. **कोड पुन: उपयोग**: कई टेस्ट में सेटअप/टीयरडाउन कोड को दोहराने से बचें
3. **रिसोर्स मैनेजमेंट**: डेटाबेस कनेक्शन, फ़ाइलों, या नेटवर्क कनेक्शन जैसे संसाधनों को ठीक से संभालें
4. **टेस्ट स्पष्टता**: टेस्ट फ़ंक्शन को उस पर ध्यान केंद्रित रखें जिसका वे परीक्षण कर रहे हैं, सेटअप पर नहीं
5. **डिपेंडेंसी इंजेक्शन**: प्रत्येक टेस्ट को ठीक वही प्रदान करें जिसकी उसे आवश्यकता है

## फिक्स्चर की मुख्य विशेषताएं

### 1. डिपेंडेंसी इंजेक्शन

फिक्स्चर अन्य फिक्स्चर पर निर्भर हो सकते हैं, एक निर्भरता ग्राफ बनाते हुए:

```python
@pytest.fixture
def database_connection():
    # डेटाबेस कनेक्शन सेटअप करें
    conn = create_connection()
    yield conn
    conn.close()

@pytest.fixture
def user_table(database_connection):
    # database_connection फिक्स्चर का उपयोग करता है
    create_table(database_connection, "users")
    yield
    drop_table(database_connection, "users")
```

### 2. स्कोप कंट्रोल

फिक्स्चर की अलग-अलग लाइफटाइम हो सकती हैं:

```python
@pytest.fixture(scope="function")  # डिफ़ॉल्ट - प्रति टेस्ट एक बार चलता है
def per_test_fixture():
    pass

@pytest.fixture(scope="module")  # प्रति मॉड्यूल एक बार चलता है
def per_module_fixture():
    pass

@pytest.fixture(scope="session")  # प्रति टेस्ट सत्र एक बार चलता है
def per_session_fixture():
    pass
```

### 3. ऑटोयूज़ फिक्स्चर

फिक्स्चर बिना अनुरोध किए स्वचालित रूप से चल सकते हैं:

```python
@pytest.fixture(autouse=True)
def always_run_this():
    # यह मॉड्यूल में हर टेस्ट से पहले चलता है
    yield
    # यह हर टेस्ट के बाद चलता है
```

### 4. पैरामीट्राइज्ड फिक्स्चर

फिक्स्चर डेटा के कई सेट उत्पन्न कर सकते हैं:

```python
@pytest.fixture(params=[1, 2, 3])
def number(request):
    return request.param  # टेस्ट 1, 2, और 3 के साथ चलेंगे
```

## API टेस्टिंग के साथ प्रैक्टिकल उदाहरण

यहाँ बताया गया है कि फिक्स्चर आपके वित्तीय हेडर टेस्टिंग परिदृश्य में कैसे मदद करते हैं:

```python
import pytest
import requests

@pytest.fixture
def financial_header():
    # सेटअप - हेडर बनाएं
    headers = create_financial_header()  # आपकी क्रिएशन लॉजिक
    yield headers  # टेस्ट इन हेडर के साथ यहाँ चलता है

    # टीयरडाउन - हेडर डिलीट करें
    delete_financial_header(headers)  # आपकी क्लीनअप लॉजिक

def test_submit_transaction(financial_header):
    # फिक्स्चर हेडर स्वचालित रूप से प्रदान करता है
    response = requests.post(
        "https://api.example.com/transactions",
        headers=financial_header,
        json={"amount": 100}
    )
    assert response.status_code == 201

def test_validate_header(financial_header):
    # एक ही फिक्स्चर का उपयोग दूसरे टेस्ट में किया गया
    response = requests.get(
        "https://api.example.com/validate",
        headers=financial_header
    )
    assert response.json()["valid"] is True
```

## unittest के साथ तुलना

| विशेषता               | pytest फिक्स्चर                     | unittest setUp/tearDown          |
|-----------------------|-------------------------------------|----------------------------------|
| डिपेंडेंसी इंजेक्शन  | ✅ हाँ                              | ❌ नहीं                          |
| स्कोप कंट्रोल         | ✅ फ़ंक्शन, क्लास, मॉड्यूल, सत्र | ❌ केवल मेथड/क्लास लेवल         |
| साफ़ सिंटैक्स          | ✅ सरल डेकोरेटर                    | ❌ इनहेरिटेंस की आवश्यकता       |
| टेस्ट आइसोलेशन        | ✅ प्रत्येक टेस्ट को ताज़ा फिक्स्चर मिलते हैं | ❌ शेयर्ड स्टेट समस्याएं पैदा कर सकता है |
| पैरामीट्राइजेशन       | ✅ बिल्ट-इन सपोर्ट                  | ❌ मैनुअल इम्प्लीमेंटेशन की आवश्यकता |

## फिक्स्चर का उपयोग कब करें

फिक्स्चर का उपयोग करें जब आपको आवश्यकता हो:
- टेस्ट डेटा या ऑब्जेक्ट सेटअप करने की
- बाहरी संसाधनों (DB कनेक्शन, फ़ाइलें, आदि) को प्रबंधित करने की
- टेस्ट के बाद सफाई करने की
- सामान्य टेस्ट निर्भरताओं को साझा करने की
- अलग-अलग टेस्ट वातावरण बनाने की
- जटिल सेटअप/टीयरडाउन लॉजिक लागू करने की

फिक्स्चर API टेस्टिंग (आपके वित्तीय हेडर केस की तरह) में विशेष रूप से मूल्यवान हैं क्योंकि वे टेस्ट संसाधनों के जीवनचक्र को साफ और पूर्वानुमेय तरीके से प्रबंधित करने में मदद करते हैं।