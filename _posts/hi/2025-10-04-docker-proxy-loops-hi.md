---
audio: false
generated: true
image: false
lang: hi
layout: post
model: x-ai/grok-4-fast
title: डॉकर डेमॉन प्रॉक्सी लूप से बचाव
translated: true
type: note
---

### Docker के `daemon.json` में `"no-proxy": "localhost,127.0.0.1,.local"` क्यों महत्वपूर्ण है

जब आप Docker के डेमन को `"http-proxy": "http://localhost:7890"` जैसी प्रॉक्सी सेटिंग्स के साथ कॉन्फ़िगर करते हैं (जो स्थानीय रूप से चलने वाले Clash जैसे टूल्स के लिए आम है), तो डेमन ये नियम डिफ़ॉल्ट रूप से **सभी** आउटगोइंग नेटवर्क ट्रैफ़िक पर लागू कर देता है। इसमें बाहरी रजिस्ट्रियों (जैसे, `hello-world` जैसी इमेज पुल करने के लिए `registry-1.docker.io`) से कनेक्शन शामिल हैं।

हालाँकि, `no-proxy` डायरेक्टिव के बिना, Docker डेमन **स्थानीय कनेक्शनों**—जैसे कि आपके प्रॉक्सी सर्वर से स्वयं `localhost:7890` पर प्रारंभिक TCP हैंडशेक—को भी उसी प्रॉक्सी के माध्यम से रूट करने का प्रयास करता है। इससे एक क्लासिक **प्रॉक्सी लूप** बन जाता है:

1.  Docker को `registry-1.docker.io` से एक इमेज फ़ेच करनी है।
2.  यह `localhost:7890` पर प्रॉक्सी के माध्यम से कनेक्ट होने का प्रयास करता है।
3.  लेकिन `localhost:7890` तक पहुँचने के लिए, प्रॉक्सी सेटिंग्स फिर से सक्रिय हो जाती हैं, जिससे Docker को... `localhost:7890` पर प्रॉक्सी के माध्यम से कनेक्ट होने के लिए मजबूर होना पड़ता है।
4.  यह अनंत पुनरावृत्ति TCP लेवल पर विफल हो जाती है क्योंकि प्रॉक्सी स्वयं से कनेक्शन को प्रॉक्सी नहीं कर सकता (यह बिना किसी रिज़ॉल्यूशन के एक स्व-संदर्भित लूप की ओर ले जाता है)।
5.  कनेक्शन अप्रत्याशित रूप से समाप्त हो जाता है, जिसके परिणामस्वरूप `proxyconnect tcp: EOF` एरर आती है (EOF का मतलब "एंड ऑफ़ फाइल" है, जो प्रॉक्सी नेगोशिएशन/हैंडशेक के दौरान समय से पहले क्लोजर का संकेत देता है)।

`"no-proxy": "localhost,127.0.0.1,.local"` जोड़ने से डेमन को स्पष्ट रूप से निर्देश मिलता है कि वह निम्नलिखित के लिए ट्रैफ़िक को **प्रॉक्सी को बायपास** करे:
-   `localhost` (आपके मशीन का लूपबैक होस्टनाम),
-   `127.0.0.1` (IPv4 लूपबैक एड्रेस),
-   `.local` डोमेन (mDNS/स्थानीय नेटवर्क रिज़ॉल्यूशन के लिए आम)।

यह Docker को स्वयं के माध्यम से लूप किए बिना, सीधे localhost पर प्रॉक्सी सर्वर से **सीधे** कनेक्ट होने की अनुमति देता है। एक बार कनेक्ट हो जाने के बाद, प्रॉक्सी Docker रजिस्ट्री के लिए बाहरी रिक्वेस्ट को ठीक से हैंडल कर सकता है (जैसे, HTTPS ट्रैफ़िक के लिए HTTP CONNECT के माध्यम से)।

संक्षेप में: यह डेमन को "प्रॉक्सी को प्रॉक्सी करने" से रोकता है, यह सुनिश्चित करता है कि स्थानीय प्रॉक्सी एक्सेस काम करे जबकि इंटरनेट-बाउंड ट्रैफ़िक (जैसे इमेज पुल) अभी भी इसके माध्यम से रूट हो।

यदि आपके सेटअप में अन्य स्थानीय सेवाएँ शामिल हैं (जैसे, आंतरिक रजिस्ट्री या स्थानीय रूप से संचार करने वाले कंटेनर), तो उन डोमेन/IPs को `no-proxy` में जोड़ने से समान समस्याओं को रोका जा सकता है।

[Docker Daemon Proxy Configuration](https://docs.docker.com/engine/daemon/proxy/)
[Docker Proxy Settings Forum Discussion](https://forums.docker.com/t/proxy-settings-for-the-docker-daemon/132089)
[Docker Proxy Guide for Corporate Firewalls](https://www.datacamp.com/tutorial/docker-proxy)