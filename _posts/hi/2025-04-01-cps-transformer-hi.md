---
audio: false
generated: true
lang: hi
layout: post
title: सीपीएस ट्रांसफॉर्मर
translated: true
type: note
---

```scheme
;; एक सरल CPS ट्रांसफॉर्मर जो उचित टेल-कॉल करता है और if-एक्सप्रेशन्स के लिए कॉन्टेक्स्ट डुप्लिकेट नहीं करता।
;; लेखक: Yin Wang (yw21@cs.indiana.edu)
(load "pmatch.scm") ; Scheme के लिए एक पैटर्न मिलान लाइब्रेरी लोड करता है, जिससे विभिन्न एक्सप्रेशन संरचनाओं को हैंडल करना आसान हो जाता है।

(define cps
  (lambda (exp)
    (letrec
        ([trivial? (lambda (x) (memq x '(zero? add1 sub1)))] ; जाँचता है कि कोई दिया गया प्रतीक आदिम ऑपरेटरों में से एक है या नहीं: zero?, add1, sub1। इन्हें ट्रांसफॉर्मेशन में विशेष रूप से ट्रीट किया जाता है।
         [id (lambda (v) v)] ; आइडेंटिटी फंक्शन, टॉप-लेवल एक्सप्रेशन के लिए प्रारंभिक कंटिन्यूएशन के रूप में प्रयुक्त।
         [ctx0 (lambda (v) `(k ,v))]      ; टेल कॉन्टेक्स्ट। यह एक कंटिन्यूएशन बनाता है जो सीधे वर्तमान कंटिन्यूएशन 'k' को एक वैल्यू 'v' पर एप्लाई करता है। इसका उपयोग तब किया जाता है जब वर्तमान कॉल टेल पोजीशन में हो।
         [fv (let ([n -1]) ; फ्रेश वेरिएबल नामों के लिए एक जनरेटर बनाता है।
               (lambda ()
                 (set! n (+ 1 n))
                 (string->symbol (string-append "v" (number->string n)))))]
         [cps1
          (lambda (exp ctx) ; कोर रिकर्सिव फंक्शन जो CPS ट्रांसफॉर्मेशन करता है। यह एक एक्सप्रेशन 'exp' और एक कंटिन्यूएशन 'ctx' को आर्गुमेंट के रूप में लेता है। कंटिन्यूएशन यह रिप्रेजेंट करता है कि 'exp' के मूल्यांकन के परिणाम के साथ क्या करना है।
            (pmatch exp ; एक्सप्रेशन की संरचना का विश्लेषण करने के लिए पैटर्न मिलान का उपयोग करता है।
              [,x (guard (not (pair? x))) (ctx x)] ; बेस केस: यदि एक्सप्रेशन 'x' एक पेयर नहीं है (यानी, यह एक लिटरल या वेरिएबल है), तो इसका मतलब है कि यह पहले से ही एक वैल्यू है। वर्तमान कंटिन्यूएशन 'ctx' को इस वैल्यू पर एप्लाई करें।

              [(if ,test ,conseq ,alt) ; एक 'if' एक्सप्रेशन से मेल खाता है जिसमें एक टेस्ट, कंसीक्वेंट और अल्टरनेटिव होता है।
               (cps1 test ; 'test' एक्सप्रेशन को रिकर्सिवली ट्रांसफॉर्म करता है।
                     (lambda (t) ; 'test' एक्सप्रेशन के लिए कंटिन्यूएशन। यह टेस्ट के परिणाम (जो एक बूलियन वैल्यू होगा) को 't' के रूप में लेता है।
                       (cond
                        [(memq ctx (list ctx0 id)) ; यदि वर्तमान कॉन्टेक्स्ट 'ctx' या तो टेल कॉन्टेक्स्ट 'ctx0' है या प्रारंभिक आइडेंटिटी कॉन्टेक्स्ट 'id' है, तो इसका मतलब है कि 'if' एक्सप्रेशन स्वयं एक टेल पोजीशन में है।
                         `(if ,t ,(cps1 conseq ctx) ,(cps1 alt ctx))] ; इस केस में, 'if' एक्सप्रेशन CPSed कोड में एक 'if' एक्सप्रेशन ही रहता है। कंसीक्वेंट और अल्टरनेटिव को उसी कॉन्टेक्स्ट 'ctx' के साथ CPSed किया जाता है। यह कॉन्टेक्स्ट को डुप्लिकेट होने से बचाता है।
                        [else ; यदि वर्तमान कॉन्टेक्स्ट एक टेल कॉन्टेक्स्ट नहीं है, तो इसका मतलब है कि 'if' एक्सप्रेशन के परिणाम को किसी आगे की गणना में पास करने की आवश्यकता है।
                         (let ([u (fv)]) ; 'if' एक्सप्रेशन के परिणाम को रखने के लिए एक फ्रेश वेरिएबल नाम 'u' जनरेट करता है।
                           `(let ([k (lambda (,u) ,(ctx u))]) ; एक नया कंटिन्यूएशन 'k' बनाता है जो परिणाम 'u' को लेता है और मूल कॉन्टेक्स्ट 'ctx' को उस पर एप्लाई करता है।
                              (if ,t ,(cps1 conseq ctx0) ,(cps1 alt ctx0))))])))] ; 'if' एक्सप्रेशन को एक 'let' में रैप किया जाता है जो नए कंटिन्यूएशन 'k' को इंट्रोड्यूस करता है। कंसीक्वेंट और अल्टरनेटिव को टेल कॉन्टेक्स्ट 'ctx0' के साथ CPSed किया जाता है, क्योंकि उनके परिणाम तुरंत 'k' को पास कर दिए जाएंगे।

              [(lambda (,x) ,body) ; एक लैम्ब्डा एक्सप्रेशन से मेल खाता है जिसमें एक सिंगल आर्गुमेंट 'x' और एक बॉडी होती है।
               (ctx `(lambda (,x k) ,(cps1 body ctx0)))] ; लैम्ब्डा एक्सप्रेशन को एक नए लैम्ब्डा एक्सप्रेशन में ट्रांसफॉर्म किया जाता है जो एक अतिरिक्त आर्गुमेंट 'k' (कंटिन्यूएशन) लेता है। मूल लैम्ब्डा की बॉडी को टेल कॉन्टेक्स्ट 'ctx0' के साथ CPSed किया जाता है, क्योंकि इसका परिणाम इस कंटिन्यूएशन 'k' को पास किया जाएगा।

              [(,op ,a ,b) ; एक एक्सप्रेशन से मेल खाता है जिसमें एक बाइनरी ऑपरेटर 'op' और दो ऑपरेंड 'a' और 'b' होते हैं।
               (cps1 a ; पहले ऑपरेंड 'a' को रिकर्सिवली ट्रांसफॉर्म करता है।
                     (lambda (v1) ; 'a' के लिए कंटिन्यूएशन। यह परिणाम 'v1' को लेता है।
                       (cps1 b ; दूसरे ऑपरेंड 'b' को रिकर्सिवली ट्रांसफॉर्म करता है।
                             (lambda (v2) ; 'b' के लिए कंटिन्यूएशन। यह परिणाम 'v2' को लेता है।
                                   (ctx `(,op ,v1 ,v2))))))] ; ऑपरेटर 'op' और ऑपरेंड के CPSed परिणामों 'v1' और 'v2' से बने एक्सप्रेशन पर मूल कॉन्टेक्स्ट 'ctx' को एप्लाई करता है।

              [(,rator ,rand) ; एक फंक्शन एप्लिकेशन से मेल खाता है जिसमें एक रेटर (फंक्शन) और एक रैंड (आर्गुमेंट) होता है।
               (cps1 rator ; रेटर को रिकर्सिवली ट्रांसफॉर्म करता है।
                     (lambda (r) ; रेटर के लिए कंटिन्यूएशन। यह परिणाम 'r' (फंक्शन) को लेता है।
                       (cps1 rand ; ऑपरेंड को रिकर्सिवली ट्रांसफॉर्म करता है।
                             (lambda (d) ; ऑपरेंड के लिए कंटिन्यूएशन। यह परिणाम 'd' (आर्गुमेंट) को लेता है।
                               (cond
                                [(trivial? r) (ctx `(,r ,d))] ; यदि रेटर 'r' एक ट्रिवियल ऑपरेटर है (जैसे zero?, add1, sub1), तो वर्तमान कॉन्टेक्स्ट 'ctx' को ऑपरेटर के ऑपरेंड पर एप्लिकेशन पर एप्लाई करें।
                                [(eq? ctx ctx0) `(,r ,d k)]  ; टेल कॉल। यदि वर्तमान कॉन्टेक्स्ट टेल कॉन्टेक्स्ट 'ctx0' है, तो इसका मतलब है कि यह फंक्शन एप्लिकेशन एक टेल पोजीशन में है। CPSed फंक्शन 'r' को CPSed आर्गुमेंट 'd' और वर्तमान कंटिन्यूएशन 'k' के साथ कॉल किया जाता है।
                                [else ; यदि फंक्शन एप्लिकेशन एक टेल पोजीशन में नहीं है।
                                 (let ([u (fv)]) ; परिणाम के लिए एक फ्रेश वेरिएबल नाम 'u' जनरेट करता है।
                                   `(,r ,d (lambda (,u) ,(ctx u))))])))))]))]) ; CPSed फंक्शन 'r' को CPSed आर्गुमेंट 'd' और एक नए कंटिन्यूएशन के साथ कॉल किया जाता है जो परिणाम 'u' को लेता है और मूल कॉन्टेक्स्ट 'ctx' को उस पर एप्लाई करता है।

      (cps1 exp id))));; इनपुट एक्सप्रेशन 'exp' और प्रारंभिक आइडेंटिटी कंटिन्यूएशन 'id' के साथ 'cps1' को कॉल करके CPS ट्रांसफॉर्मेशन शुरू करता है।

;;; टेस्ट
;; var
(cps 'x) ; वेरिएबल 'x' को ट्रांसफॉर्म करता है। परिणाम '(k x)' होगा क्योंकि प्रारंभिक कॉन्टेक्स्ट 'id' है, और 'id' को 'x' पर एप्लाई किया जाता है।

(cps '(lambda (x) x)) ; एक साधारण आइडेंटिटी लैम्ब्डा फंक्शन को ट्रांसफॉर्म करता है। परिणाम '(lambda (x k) (k x))' होगा।

(cps '(lambda (x) (x 1))) ; एक लैम्ब्डा फंक्शन को ट्रांसफॉर्म करता है जो अपने आर्गुमेंट को 1 पर एप्लाई करता है। परिणाम '(lambda (x k) (x 1 k))' होगा।

;; no lambda (टॉपलेवल पर वापस लौटने के लिए आइडेंटिटी फंक्शन जनरेट करेगा)
(cps '(if (f x) a b)) ; एक if एक्सप्रेशन को ट्रांसफॉर्म करता है जहाँ टेस्ट एक फंक्शन कॉल है।

(cps '(if x (f a) b)) ; एक if एक्सप्रेशन को ट्रांसफॉर्म करता है जहाँ टेस्ट एक वेरिएबल है।

;; if स्टैंड-अलोन (टेल)
(cps '(if x (f a) b)) ; यहाँ, 'if' टॉप लेवल पर है, इसलिए यह एक टेल कॉन्टेक्स्ट में है।

;; if इनसाइड if-टेस्ट (नॉन-टेल)
(cps '(lambda (x) (if (f x) a b))) ; 'if' एक लैम्ब्डा के अंदर है, और इसके परिणाम का उपयोग लैम्ब्डा द्वारा किया जाता है (इम्प्लिसिटली रिटर्न किया जाता है), इसलिए यह टेल कॉन्टेक्स्ट में नहीं है।

(cps '(lambda (x) (if (if x (f a) b) c d))) ; नेस्टेड 'if' एक्सप्रेशन। इनर 'if' आउटर 'if' के टेस्ट में है।

;; दोनों ब्रांचेज ट्रिवियल हैं, कुछ और ऑप्टिमाइजेशन करने चाहिए
(cps '(lambda (x) (if (if x (zero? a) b) c d)))

;; if इनसाइड if-ब्रांच (टेल)
(cps '(lambda (x) (if t (if x (f a) b) c))) ; इनर 'if' आउटर 'if' के कंसीक्वेंट ब्रांच में है। यदि आउटर 'if' एक टेल कॉन्टेक्स्ट में है, तो इनर भी होगा।

;; if इनसाइड if-ब्रांच, लेकिन फिर से किसी दूसरे if-टेस्ट के अंदर (नॉन-टेल)
(cps '(lambda (x) (if (if t (if x (f a) b) c) e w)))

;; if ऑपरेंड के रूप में (नॉन-टेल)
(cps '(lambda (x) (h (if x (f a) b)))) ; 'if' एक्सप्रेशन के परिणाम का उपयोग 'h' के आर्गुमेंट के रूप में किया जाता है।

;; if ऑपरेटर के रूप में (नॉन-टेल)
(cps '(lambda (x) ((if x (f g) h) c))) ; 'if' एक्सप्रेशन के परिणाम का उपयोग उस फंक्शन के रूप में किया जाता है जिसे कॉल किया जाना है।

;; हमें दो से अधिक नामों की आवश्यकता क्यों है
(cps '(((f a) (g b)) ((f c) (g d)))) ; यह उदाहरण संभवतः फ्रेश वेरिएबल नाम जनरेटर ('fv') की आवश्यकता को प्रदर्शित करता है ताकि कॉम्प्लेक्स नेस्टेड एक्सप्रेशन को ट्रांसफॉर्म करते समय नामों के टकराव से बचा जा सके।

;; factorial
(define fact-cps
  (cps
   '(lambda (n)
      ((lambda (fact)
         ((fact fact) n))
       (lambda (fact)
         (lambda (n)
           (if (zero? n)
               1
               (* n ((fact fact) (sub1 n))))))))));; CPSed फंक्शन प्रिंट करें

(pretty-print fact-cps);; =>
;; '(lambda (n k)
;;    ((lambda (fact k) (fact fact (lambda (v0) (v0 n k))))
;;     (lambda (fact k)
;;       (k
;;        (lambda (n k)
;;          (if (zero? n)
;;            (k 1)
;;            (fact
;;             fact
;;             (lambda (v1) (v1 (sub1 n) (lambda (v2) (k (* n v2))))))))));
;;     k))

((eval fact-cps) 5 (lambda (v) v));; => 120
```

**CPS ट्रांसफॉर्मर की व्याख्या:**

यह Scheme कोड Scheme भाषा के एक सरल सबसेट के लिए एक कंटिन्यूएशन-पासिंग स्टाइल (CPS) ट्रांसफॉर्मेशन इम्प्लीमेंट करता है। यहाँ मुख्य अवधारणाओं और कोड के काम करने के तरीके का विवरण दिया गया है:

**1. कंटिन्यूएशन-पासिंग स्टाइल (CPS):**

* CPS में, एक फंक्शन सीधे वैल्यू रिटर्न नहीं करता। इसके बजाय, यह एक अतिरिक्त आर्गुमेंट लेता है जिसे **कंटिन्यूएशन** कहा जाता है।
* कंटिन्यूएशन एक फंक्शन होता है जो वर्तमान फंक्शन के परिणाम के साथ किए जाने वाले शेष कम्प्यूटेशन को रिप्रेजेंट करता है।
* जब एक CPS फंक्शन अपनी गणना पूरी कर लेता है, तो वह परिणाम के साथ कंटिन्यूएशन को कॉल करता है।

**CPS का उपयोग क्यों करें?**

* **एक्सप्लिसिट कंट्रोल फ्लो:** CPS कंट्रोल फ्लो को एक्सप्लिसिट बनाता है। फंक्शन कॉल और रिटर्न को कंटिन्यूएशन के कॉल से रिप्लेस कर दिया जाता है।
* **टेल-कॉल ऑप्टिमाइजेशन:** CPS उचित टेल-कॉल ऑप्टिमाइजेशन के इम्प्लीमेंटेशन को आसान बनाता है। ट्रांसफॉर्म्ड कोड में, टेल पोजीशन में फंक्शन कॉल अंतिम ऑपरेशन बन जाते हैं, जिससे स्टैक डेप्थ बढ़ाए बिना कुशल एक्जीक्यूशन संभव होता है।
* **एडवांस्ड कंट्रोल स्ट्रक्चर्स का इम्प्लीमेंटेशन:** CPS का उपयोग कंपाइलर्स में एक इंटरमीडिएट रिप्रेजेंटेशन के रूप में एक्सेप्शन, कोरोटीन और बैकट्रैकिं जैसी सुविधाओं को इम्प्लीमेंट करने के लिए किया जा सकता है।

**2. `cps` फंक्शन:**

* ट्रांसफॉर्मेशन के लिए मुख्य एंट्री पॉइंट। यह इनपुट के रूप में एक एक्सप्रेशन `exp` लेता है।
* यह कई म्यूचुअली रिकर्सिव हेल्पर फंक्शन को डिफाइन करने के लिए `letrec` का उपयोग करता है।
* यह इनपुट एक्सप्रेशन और प्रारंभिक कंटिन्यूएशन के रूप में आइडेंटिटी फंक्शन `id` के साथ `cps1` को कॉल करके ट्रांसफॉर्मेशन को इनिशियलाइज़ करता है। इसका मतलब है कि ट्रांसफॉर्म्ड एक्सप्रेशन का अंतिम परिणाम सीधे रिटर्न कर दिया जाएगा।

**3. हेल्पर फंक्शन:**

* **`trivial?`:** `zero?`, `add1`, और `sub1` जैसे आदिम ऑपरेटरों की पहचान करता है। इन्हें ट्रांसफॉर्मेशन में विशेष रूप से हैंडल किया जाता है।
* **`id`:** आइडेंटिटी फंक्शन `(lambda (v) v)`। यह प्रारंभिक कंटिन्यूएशन है, जिसका मतलब है "बस वैल्यू रिटर्न करो"।
* **`ctx0`:** एक "टेल कॉन्टेक्स्ट" बनाता है। एक वैल्यू `v` दिए जाने पर, यह `(k v)` रिटर्न करता है, जहाँ `k` वर्तमान कंटिन्यूएशन है। यह दर्शाता है कि वर्तमान कम्प्यूटेशन एक टेल पोजीशन में है, और परिणाम सीधे इंतजार कर रहे कंटिन्यूएशन को पास किया जाना चाहिए।
* **`fv`:** फ्रेश वेरिएबल नाम जनरेट करता है (जैसे, `v0`, `v1`, `v2`, ...)। नए कंटिन्यूएशन इंट्रोड्यूस करते समय वेरिएबल कैप्चर से बचने के लिए यह महत्वपूर्ण है।

**4. `cps1` फंक्शन (कोर ट्रांसफॉर्मेशन):**

* यह फंक्शन इनपुट एक्सप्रेशन को रिकर्सिवली ट्रैवर्स करता है और इसे CPS में ट्रांसफॉर्म करता है।
* यह दो आर्गुमेंट लेता है: ट्रांसफॉर्म किए जाने वाला एक्सप्रेशन `exp` और वर्तमान कंटिन्यूएशन `ctx`।
* यह विभिन्न प्रकार के एक्सप्रेशन को हैंडल करने के लिए पैटर्न मिलान के लिए `pmatch` लाइब्रेरी का उपयोग करता है:

    * **लिटरल और वेरिएबल:** यदि एक्सप्रेशन एक पेयर नहीं है (एक लिटरल या वेरिएबल), तो यह पहले से ही एक वैल्यू है। वर्तमान कंटिन्यूएशन `ctx` को इस वैल्यू पर एप्लाई किया जाता है: `(ctx x)`।

    * **`if` एक्सप्रेशन:** यह ट्रांसफॉर्मर का एक महत्वपूर्ण हिस्सा है जो टेल कॉल को हैंडल करता है और कॉन्टेक्स्ट डुप्लिकेशन से बचाता है।
        * यह पहले `test` एक्सप्रेशन को एक कंटिन्यूएशन के साथ ट्रांसफॉर्म करता है जो टेस्ट के परिणाम (`t`) को लेता है।
        * यदि वर्तमान कॉन्टेक्स्ट `ctx` एक टेल कॉन्टेक्स्ट (`ctx0`) है या प्रारंभिक आइडेंटिटी कॉन्टेक्स्ट (`id`) है, तो इसका मतलब है कि `if` एक्सप्रेशन स्वयं एक टेल पोजीशन में है। इस केस में, `if` स्ट्रक्चर को प्रिजर्व किया जाता है, और `conseq` और `alt` ब्रांचेज को उसी कॉन्टेक्स्ट `ctx` के साथ CPSed किया जाता है।
        * यदि वर्तमान कॉन्टेक्स्ट एक टेल कॉन्टेक्स्ट नहीं है, तो इसका मतलब है कि `if` एक्सप्रेशन के परिणाम का बाद में उपयोग किया जाना है। एक नया कंटिन्यूएशन `k` बनाया जाता है जो `if` के परिणाम को लेता है और मूल कॉन्टेक्स्ट `ctx` को उस पर एप्लाई करता है। `conseq` और `alt` ब्रांचेज को फिर टेल कॉन्टेक्स्ट `ctx0` के साथ CPSed किया जाता है, और पूरे `if` एक्सप्रेशन को एक `let` में रैप किया जाता है जो `k` को इंट्रोड्यूस करता है।

    * **`lambda` एक्सप्रेशन:** एक `lambda` एक्सप्रेशन `(lambda (x) body)` को एक नए `lambda` एक्सप्रेशन में ट्रांसफॉर्म किया जाता है जो एक अतिरिक्त आर्गुमेंट `k` (कंटिन्यूएशन) लेता है: `(lambda (x k) (cps1 body ctx0))`। मूल लैम्ब्डा की बॉडी को टेल कॉन्टेक्स्ट `ctx0` के साथ CPSed किया जाता है।

    * **बाइनरी ऑपरेशन (`op a b`):** ऑपरेंड `a` और `b` को सीक्वेंशियली CPSed किया जाता है। `a` के लिए कंटिन्यूएशन उसके परिणाम `v1` को लेता है, और फिर `b` को एक कंटिन्यूएशन के साथ CPS करता है जो उसके परिणाम `v2` को लेता है। अंत में, मूल कॉन्टेक्स्ट `ctx` को ऑपरेटर `op` और CPSed परिणामों `v1` और `v2` से बने एक्सप्रेशन पर एप्लाई किया जाता है।

    * **फंक्शन एप्लिकेशन (`rator rand`):** `rator` (फंक्शन) और `rand` (आर्गुमेंट) को सीक्वेंशियली CPSed किया जाता है।
        * यदि `rator` एक `trivial?` ऑपरेटर है, तो वर्तमान कॉन्टेक्स्ट `ctx` को ऑपरेटर के ऑपरेंड पर एप्लिकेशन के परिणाम पर सीधे एप्लाई किया जाता है।
        * यदि वर्तमान कॉन्टेक्स्ट एक टेल कॉन्टेक्स्ट (`ctx0`) है, तो CPSed फंक्शन `r` को CPSed आर्गुमेंट `d` और वर्तमान कंटिन्यूएशन `k` के साथ कॉल किया जाता है। यह उचित टेल कॉल सुनिश्चित करता है।
        * अन्यथा (नॉन-टेल कॉल), एक नया कंटिन्यूएशन बनाया जाता है जो फंक्शन कॉल के परिणाम को लेता है और मूल कॉन्टेक्स्ट `ctx` को उस पर एप्लाई करता है। CPSed फंक्शन `r` को CPSed आर्गुमेंट `d` और इस नए कंटिन्यूएशन के साथ कॉल किया जाता है।

**5. टेस्ट:**

* कोड में कई टेस्ट केस शामिल हैं जो विभिन्न प्रकार के एक्सप्रेशन के ट्रांसफॉर्मेशन को प्रदर्शित करते हैं, जिनमें वेरिएबल, लैम्ब्डा फंक्शन, विभिन्न कॉन्टेक्स्ट में `if` एक्सप्रेशन और फंक्शन एप्लिकेशन शामिल हैं।

**6. फैक्टोरियल उदाहरण:**

* `fact-cps` डेफिनिशन दर्शाती है कि CPS ट्रांसफॉर्मर को एक रिकर्सिव फैक्टोरियल फंक्शन पर कैसे एप्लाई किया जा सकता है।
* `pretty-print` आउटपुट फैक्टोरियल फंक्शन के CPSed वर्जन को दिखाता है, जो अब एक अतिरिक्त कंटिन्यूएशन आर्गुमेंट `k` लेता है।
* अंतिम पंक्ति इनपुट `5` और एक टॉप-लेवल कंटिन्यूएशन `(lambda (v) v)` के साथ CPSed फैक्टोरियल फंक्शन का मूल्यांकन करती है जो सीधे अंतिम वैल्यू रिटर्न करता है।

**संक्षेप में, यह कोड एक CPS ट्रांसफॉर्मेशन इम्प्लीमेंट करता है जिसका लक्ष्य है:**

* एक्सप्रेशन को कंटिन्यूएशन-पासिंग स्टाइल में कन्वर्ट करना।
* वर्तमान कंटिन्यूएशन को एक्सप्लिसिटली पास करके उचित टेल-कॉल ऑप्टिमाइजेशन सुनिश्चित करना।
* `if` एक्सप्रेशन को कुशलतापूर्वक हैंडल करना, जब `if` स्वयं एक टेल पोजीशन में हो तो आसपास के कॉन्टेक्स्ट को डुप्लिकेट किए बिना। यह `if` स्ट्रक्चर को रखकर और ब्रांचेज को उसी कॉन्टेक्स्ट के साथ CPS करके हासिल किया जाता है। जब `if` एक टेल पोजीशन में नहीं होता है, तो यह परिणाम को हैंडल करने के लिए एक नया कंटिन्यूएशन इंट्रोड्यूस करता है।