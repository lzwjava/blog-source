---
audio: false
generated: true
image: false
lang: hi
layout: post
model: x-ai/grok-4.1-fast
title: 'वेबस्फीयर बनाम स्प्रिंग बूट: अनुरोध फ़िल्टर तुलना'
translated: true
type: note
---

### अवलोकन
आईबीएम वेबस्फीयर एप्लिकेशन सर्वर (WAS, पारंपरिक या लिबर्टी) और स्प्रिंग बूट दोनों ही मानक जावा सर्वलेट एपीआई के `javax.servlet.Filter` और `FilterChain` पर आधारित **रिक्वेस्ट प्रोसेसिंग चेन** की अवधारणा का समर्थन करते हैं। यह वह जगह है जहां आने वाले HTTP रिक्वेस्ट सर्वलेट्स (या कंट्रोलर/हैंडलर) तक पहुंचने से पहले फिल्टर की एक श्रृंखला से गुजरते हैं, और प्रतिक्रियाओं को वापस आते समय संशोधित किया जा सकता है।

- फिल्टर रिक्वेस्ट/रिस्पॉन्स के प्री-प्रोसेसिंग (जैसे, प्रमाणीकरण, लॉगिंग, संपीड़न) और पोस्ट-प्रोसेसिंग की अनुमति देते हैं।
- मूल तंत्र — `Filter` को लागू करना, आगे बढ़ने के लिए `chain.doFilter(request, response)` को कॉल करना — **समान** है क्योंकि दोनों एक सर्वलेट कंटेनर में चलते हैं (WAS के पास अपना पूर्ण Java EE वेब कंटेनर है; स्प्रिंग बूट डिफ़ॉल्ट रूप से टॉमकैट/जेटी/अंडरटो को एम्बेड करता है)।

एक बुनियादी "रिक्वेस्ट चेन फिल्टर" कैसे काम करता है, इसमें कोई मौलिक अंतर नहीं है। हालाँकि, प्रत्येक प्लेटफ़ॉर्म की वास्तुकला के कारण आप फ़िल्टर को कॉन्फ़िगर, ऑर्डर और एकीकृत करने का तरीका काफ़ी भिन्न होता है।

### मुख्य तुलना

| पहलू                  | आईबीएम वेबस्फीयर एप्लिकेशन सर्वर (पारंपरिक/लिबर्टी) | स्प्रिंग बूट |
|-------------------------|---------------------------------------------------------|-------------|
| **अंतर्निहित तंत्र** | मानक सर्वलेट फिल्टर (`javax.servlet.Filter`)। कुछ परिदृश्यों में (जैसे, पोर्टल या कस्टम आईबीएम एपीआई) आंतरिक रिक्वेस्ट फॉरवर्डिंग/चेनिंग के लिए WAS में `ChainedRequest`/`ChainedResponse` जैसे मालिकाना एक्सटेंशन भी होते हैं। | मानक सर्वलेट फिल्टर। स्प्रिंग बूट किसी भी `@Component` फिल्टर बीन को ऑटो-रजिस्टर करता है या आप `FilterRegistrationBean` के माध्यम से स्पष्ट रूप से रजिस्टर करते हैं। |
| **कॉन्फ़िगरेशन**       | मुख्य रूप से `web.xml` (घोषणात्मक) या प्रोग्रामेटिक पंजीकरण के माध्यम से। वैश्विक फिल्टर (सभी ऐप्स में) के लिए: जटिल — साझा लाइब्रेरी, कस्टम लिस्टनर, या आईबीएम-विशिष्ट एक्सटेंशन की आवश्यकता होती है (टॉमकैट की तरह कोई सरल सर्वर-वाइड web.xml नहीं)। | कन्वेंशन-ओवर-कॉन्फिगरेशन: स्वचालित पंजीकरण के लिए `@Component` + `@Order` के साथ एनोटेट करें, या बारीक नियंत्रण (URL पैटर्न, डिस्पैचर प्रकार) के लिए `FilterRegistrationBean` का उपयोग करें। डेवलपर के लिए बहुत अनुकूल। |
| **ऑर्डरिंग**            | `web.xml` क्रम में परिभाषित या प्रोग्रामेटिक होने पर `@Order` के माध्यम से। वैश्विक ऑर्डरिंग मुश्किल है। | `@Order(n)` (कम = पहले) या `Ordered` इंटरफेस के साथ आसान। स्प्रिंग बूट चेन को स्वचालित रूप से प्रबंधित करता है। |
| **सुरक्षा फिल्टर चेन** | मानक सर्वलेट फिल्टर या आईबीएम-विशिष्ट सुरक्षा (जैसे, TAI, JEE भूमिकाएँ) का उपयोग करता है। स्प्रिंग सिक्योरिटी की तरह कोई अंतर्निहित सुरक्षा चेन नहीं। | स्प्रिंग सिक्योरिटी एक शक्तिशाली `SecurityFilterChain` (`FilterChainProxy` के माध्यम से) प्रदान करती है जिसमें 15+ ऑर्डर किए गए फिल्टर (CSRF, प्रमाणीकरण, सत्र प्रबंधन, आदि) होते हैं। प्रति पथ कई चेन के साथ अत्यधिक अनुकूलन योग्य। |
| **कस्टम फिल्टर जोड़ने में आसानी** | अधिक वर्बोज़, विशेष रूप से वैश्विक/क्रॉस-ऐप फिल्टर के लिए। अक्सर एडमिन कंसोल ट्वीक या शेयर्ड लाइब्रेरी की आवश्यकता होती है। | अत्यंत सरल — बस एक `@Component` बीन या कॉन्फ़िग क्लास। एम्बेडेड कंटेनर में स्वचालित रूप से एकीकृत। |
| **डिप्लॉयमेंट मॉडल**    | पारंपरिक पूर्ण Java EE सर्वर। ऐप्स WAR/EAR के रूप में डिप्लॉय किए जाते हैं। भारी एंटरप्राइज़ सुविधाओं (क्लस्टरिंग, लेनदेन, JMS) का समर्थन करता है। | एम्बेडेड कंटेनर (डिफ़ॉल्ट रूप से स्टैंडअलोन एक्ज़ीक्यूटेबल JAR)। बाहरी सर्वर (WAS सहित) पर WAR के रूप में डिप्लॉय किया जा सकता है। लाइटवेट/माइक्रोसर्विसेज-उन्मुख। |
| **प्रदर्शन/ओवरहेड**| अधिक ओवरहेड (पूर्ण ऐप सर्वर)। ट्रांसपोर्ट चेन, वेब कंटेनर चैनल परतें जोड़ते हैं। | कम ओवरहेड (एम्बेडेड लाइटवेट कंटेनर)। तेज स्टार्टअप, कम संसाधन उपयोग। |
| **जब फिल्टर चलते हैं**     | WAS वेब कंटेनर इनबाउंड चेन में। सर्वर-लेवल ट्रांसपोर्ट फिल्टर हो सकते हैं (जैसे, TCP चैनल पर IP फिल्टरिंग)। | एम्बेडेड कंटेनर की फिल्टर चेन में। स्प्रिंग बूट अपने स्वयं के फिल्टर (एरर हैंडलिंग, कैरेक्टर एन्कोडिंग, आदि) जोड़ता है। |
| **सामान्य उपयोग के मामले**    | एंटरप्राइज़ मोनोलिथ, पोर्टल, लीगेसी Java EE ऐप्स जिन्हें वैश्विक सुरक्षा/लॉगिंग की आवश्यकता होती है। | आधुनिक माइक्रोसर्विसेज, REST API, स्प्रिंग सिक्योरिटी के साथ तेजी से विकास। |

### व्यावहारिक उदाहरण

**मानक कस्टम फिल्टर (समान कोड दोनों में काम करता है):**
```java
@Component  // स्प्रिंग बूट के लिए; WAS में web.xml में घोषित करें
@Order(1)
public class LoggingFilter implements Filter {
    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
            throws IOException, ServletException {
        System.out.println("Request: " + ((HttpServletRequest) req).getRequestURI());
        chain.doFilter(req, res);  // महत्वपूर्ण: अगले फिल्टर/सर्वलेट को पास करता है
    }
    // init/destroy...
}
```

**स्प्रिंग बूट में (स्वचालित रूप से पंजीकृत):**
बस उपरोक्त क्लास + `@Component`।

**WAS में:**
`web.xml` में जोड़ें:
```xml
<filter>
    <filter-name>LoggingFilter</filter-name>
    <filter-class>com.example.LoggingFilter</filter-class>
</filter>
<filter-mapping>
    <filter-name>LoggingFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
```

### कब क्या चुनें
- **WAS फिल्टर का उपयोग करें** यदि आप एक लीगेसी IBM वातावरण में हैं, पूर्ण Java EE सुविधाओं की आवश्यकता है, या बिना कोड परिवर्तन किए कई ऐप्स में वैश्विक रूप से फिल्टर लागू करना चाहते हैं।
- **स्प्रिंग बूट फिल्टर** (विशेष रूप से स्प्रिंग सिक्योरिटी के साथ) का उपयोग नए/ग्रीनफील्ड प्रोजेक्ट्स, माइक्रोसर्विसेज, तेज पुनरावृत्ति, या जब आप कई सुरक्षा चेन और आसान ऑर्डरिंग चाहते हैं, के लिए करें।

संक्षेप में, **रिक्वेस्ट चेन फिल्टर की अवधारणा समान** (सर्वलेट स्पेक) है, लेकिन **स्प्रिंग बूट इसे अधिकांश आधुनिक उपयोग के मामलों के लिए कहीं अधिक सरल और शक्तिशाली** बनाता है, जबकि WAS अधिक एंटरप्राइज़-हेवी और कॉन्फ़िगरेशन-गहन है।

[आईबीएम WAS सर्वलेट फिल्टरिंग दस्तावेज़ीकरण](https://www.ibm.com/docs/en/was/9.0.5?topic=extensions-servlet-filtering)  
[स्प्रिंग बूट कस्टम फिल्टर](https://www.baeldung.com/spring-boot-add-filter)  
[स्प्रिंग सिक्योरिटी फिल्टर चेन](https://docs.spring.io/spring-security/reference/servlet/architecture.html)