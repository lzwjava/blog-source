---
audio: false
generated: true
lang: hi
layout: post
title: 'पायथन की जीआईएल: थ्रेडिंग सीमा'
translated: true
type: note
---

पायथन में ग्लोबल इंटरप्रेटर लॉक (GIL) एक म्यूटेक्स (लॉक) है जो पायथन ऑब्जेक्ट्स तक पहुंच की सुरक्षा करता है, जो एक ही प्रक्रिया में एक साथ कई नेटिव थ्रेड्स द्वारा पायथन बाइटकोड्स के निष्पादन को रोकता है। यह CPython (मानक पायथन कार्यान्वयन) में इस्तेमाल की जाने वाली एक तंत्र है जो थ्रेड सुरक्षा सुनिश्चित करता है, यहां तक कि मल्टी-कोर सिस्टम पर भी, एक समय में केवल एक थ्रेड को ही पायथन कोड निष्पादित करने की अनुमति देकर।

### GIL के बारे में मुख्य बिंदु:
- **उद्देश्य**: GIL रेस कंडीशन को रोकता है और पायथन ऑब्जेक्ट्स के लिए थ्रेड-सुरक्षित मेमोरी प्रबंधन सुनिश्चित करता है, जिससे CPython के कार्यान्वयन को सरल बनाया जाता है।
- **प्रभाव**: यह मल्टी-थ्रेडेड पायथन प्रोग्राम में वास्तविक समानांतरता को सीमित करता है, क्योंकि एक समय में केवल एक थ्रेड ही पायथन कोड निष्पादित कर सकता है, यहां तक कि मल्टी-कोर CPUs पर भी। यह मल्टी-थ्रेडेड एप्लिकेशन में CPU-बाउंड टास्क के लिए पायथन को कम कुशल बनाता है।
- **वैकल्पिक उपाय**:
  - थ्रेडिंग के बजाय **मल्टीप्रोसेसिंग** का उपयोग करें ताकि GIL को बायपास किया जा सके, क्योंकि प्रत्येक प्रक्रिया का अपना पायथन इंटरप्रेटर और मेमोरी स्पेस होता है।
  - `NumPy` या `Cython` जैसी लाइब्रेरीज का उपयोग करें, जो विशिष्ट ऑपरेशन के लिए GIL को रिलीज़ कर सकती हैं।
  - I/O-बाउंड टास्क (जैसे, नेटवर्क या फाइल ऑपरेशन) के लिए, थ्रेडिंग अभी भी प्रभावी हो सकती है क्योंकि I/O वेट के दौरान GIL रिलीज़ हो जाता है।
- **प्रासंगिकता**: GIL CPython के लिए विशिष्ट है और सभी पायथन कार्यान्वयन (जैसे, Jython या IronPython) में मौजूद नहीं है। CPython में GIL को हटाने या कम करने के प्रयास (जैसे, "No-GIL" पायथन) जारी हैं लेकिन जून 2025 तक अभी तक मानक नहीं हैं।

### उदाहरण प्रभाव:
```python
import threading

def cpu_bound_task():
    count = 0
    for _ in range(10**7):
        count += 1

threads = [threading.Thread(target=cpu_bound_task) for _ in range(4)]
for t in threads:
    t.start()
for t in threads:
    t.join()
```
इस उदाहरण में, GIL थ्रेड्स को क्रमिक रूप से चलने के लिए मजबूर करता है, जो मल्टीपल CPU कोर का लाभ नहीं उठाता, जिससे CPU-बाउंड टास्क के लिए प्रदर्शन सीमित हो जाता है।

अधिक जानकारी के लिए, आप पायथन का आधिकारिक डॉक्यूमेंटेशन या X पर GIL और इसे संबोधित करने के चल रहे प्रयासों पर चर्चा देख सकते हैं। क्या आप चाहेंगे कि मैं इस विषय पर हाल के अपडेट खोजूं?