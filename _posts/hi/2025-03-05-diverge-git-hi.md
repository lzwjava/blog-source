---
audio: false
generated: true
lang: hi
layout: post
title: अलग Git शाखाएँ
translated: true
---

जब आपका स्थानीय `main` शाखा और दूरस्थ `origin/main` शाखा Git में अलग हो जाते हैं—74 और 70 अलग-अलग कमिट्स के साथ—इसका मतलब है कि वे एक सामान्य पूर्वज को साझा करते हैं लेकिन अब अलग-अलग कमिट्स विकसित कर रहे हैं। आपका लक्ष्य है कि आपका स्थानीय `main` शाखा `origin/main` के साथ मिल जाए, अपने स्थानीय शाखा को सामान्य पूर्वज (दोनों का "पिता") पर रीसेट करके और फिर `git pull` का उपयोग करके दूरस्थ परिवर्तन लाने, जो स्थानीय अलग-अलग कमिट्स को दूरस्थों के लिए त्यागने के लिए प्रभावी है। नीचे दिए गए कदम इस लक्ष्य को प्राप्त करने के लिए हैं।

### अलग-अलग होने को ठीक करने के कदम

1. **नवीनतम दूरस्थ परिवर्तन लाने**
   शुरू में, सुनिश्चित करें कि आपके स्थानीय रिपोजिटरी में दूरस्थ से नवीनतम जानकारी है। यह आपके `origin/main` के लिए संदर्भ को अपडेट करता है बिना अभी तक आपके स्थानीय `main` शाखा को बदलने।

   ```bash
   git fetch origin
   ```

2. **सामान्य पूर्वज कमिट ढूंढें**
   `git merge-base` का उपयोग करके स्थानीय `main` और `origin/main` के बीच सामान्य पूर्वज कमिट को पहचानें। यह वह बिंदु है जहाँ शाखाएं अलग हो गईं।

   ```bash
   ancestor=$(git merge-base main origin/main)
   ```

   यह कमांड सामान्य पूर्वज का कमिट हैश को `ancestor` चर में स्टोर करता है।

3. **स्थानीय `main` को सामान्य पूर्वज पर रीसेट करें**
   अपने स्थानीय `main` शाखा को सामान्य पूर्वज कमिट पर रीसेट करें। `--hard` विकल्प सुनिश्चित करता है कि शाखा पॉइंटर और आपके कार्य क्षेत्र दोनों अपडेट हो जाएँ, इस बिंदु के बाद सभी स्थानीय कमिट्स और परिवर्तन को त्यागते हुए।

   ```bash
   git reset --hard $ancestor
   ```

   **सावधानी**: यह कदम आपके कार्य क्षेत्र और स्टेजिंग क्षेत्र में सभी अनकमिटेड परिवर्तन को त्याग देगा, साथ ही स्थानीय `main` के लिए 74 एकल कमिट्स को भी। अगर आपको इनका संरक्षण करना है, तो पहले एक बैकअप शाखा बनाएं (नीचे "वैकल्पिक बैकअप" देखें)।

4. **दूरस्थ परिवर्तन लाएं**
   अब, `origin/main` से परिवर्तन लाएं। क्योंकि आपके स्थानीय `main` अब सामान्य पूर्वज पर है, और `origin/main` 70 कमिट्स से आगे है, यह आपके स्थानीय `main` को `origin/main` के साथ मिलने के लिए फास्ट-फॉरवर्ड करेगा।

   ```bash
   git pull origin main
   ```

   इसके बाद, आपके स्थानीय `main` शाखा `origin/main` के साथ बिल्कुल मिल जाएगा, सभी स्थानीय अलग-अलग कमिट्स को त्यागते हुए।

### पूर्ण कमांड अनुक्रम

यहाँ पूरी कमांड अनुक्रम को अंजाम देने के लिए है:

```bash
git fetch origin
ancestor=$(git merge-base main origin/main)
git reset --hard $ancestor
git pull origin main
```

### क्या होता है?
- **कदम 1 के बाद**: आपके स्थानीय रिपोजिटरी को `origin/main` की नवीनतम स्थिति का पता है।
- **कदम 2 के बाद**: आपने सामान्य पूर्वज कमिट को पहचान लिया है (उदाहरण के लिए, एक हैश जैसे `abc123` के साथ)।
- **कदम 3 के बाद**: आपके स्थानीय `main` को `abc123` पर रीसेट किया गया है, 74 एकल स्थानीय कमिट्स खो गए हैं।
- **कदम 4 के बाद**: `git pull` `main` को `origin/main` पर फास्ट-फॉरवर्ड करता है, दूरस्थ शाखा से 70 कमिट्स लाता है।

नतीजा यह है कि आपके स्थानीय `main` `origin/main` के साथ बिल्कुल मिल जाएगा, दूरस्थ शाखा का उपयोग करने के लिए आपका लक्ष्य पूरा होगा।

### वैकल्पिक बैकअप
अगर आप अपने स्थानीय कमिट्स को त्यागने के बारे में अनिश्चित हैं और उन्हें बाद में उपयोग करने के लिए संरक्षित करना चाहते हैं, तो रीसेट करने से पहले एक बैकअप शाखा बनाएं:

```bash
git branch backup-main
```

इससे पहले `git reset` कमांड चलाएं। आपके 74 स्थानीय कमिट्स `backup-main` पर रहे रहेंगे, और आप उन्हें बाद में जरूरत पड़ने पर फिर से देख सकते हैं।

### महत्वपूर्ण टिप्पणियाँ
- **अनकमिटेड परिवर्तन**: अगर आपके पास अनकमिटेड परिवर्तन हैं (अपने कार्य क्षेत्र या स्टेजिंग क्षेत्र में) जो आप रखना चाहते हैं, तो रीसेट करने से पहले उन्हें स्टैश करें:
  ```bash
  git stash
  ```
  प्रक्रिया पूरी करने के बाद, आप उन्हें `git stash pop` के साथ वापस ला सकते हैं।
- **यह क्यों काम करता है**: सामान्य पूर्वज पर रीसेट करना और पुल करना सुनिश्चित करता है कि `origin/main` पर एक साफ फास्ट-फॉरवर्ड हो, जो अलग-अलग शाखाओं के साथ सीधे पुल करने से हो सकते हैं, जो मर्ज कनफ्लिक्ट्स से बचता है।

इन कदमों का पालन करके, आप अपने स्थानीय `main` को `origin/main` के साथ मिलने के लिए सफलतापूर्वक रीसेट करेंगे।