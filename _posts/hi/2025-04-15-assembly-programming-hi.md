---
audio: false
generated: true
lang: hi
layout: post
title: असेम्बली भाषा प्रोग्रामिंग
translated: true
type: note
---

नीचे **भाग 2: असेंबली भाषा प्रोग्रामिंग** के लिए एक व्यापक ट्यूटोरियल दिया गया है, जो इन विषयों को कवर करता है: *8086 इंस्ट्रक्शन सेट (डेटा ट्रांसफर, अंकगणित, लॉजिक, और कंट्रोल फ्लो इंस्ट्रक्शंस), असेंबली भाषा प्रोग्रामिंग (सीक्वेंशियल, ब्रांच, और लूप स्ट्रक्चर्स), और इंटरप्ट सर्विस रूटीन्स*। यह ट्यूटोरियल माइक्रोकंप्यूटरों (जैसे, 8086/8088 आर्किटेक्चर) की बुनियादी बातों पर आधारित, व्यापक, सुलभ और व्यावहारिक बनाने के लिए डिज़ाइन किया गया है। यह CPU रजिस्टरों और मेमोरी एड्रेसिंग के बुनियादी ज्ञान को मानता है।

---

## भाग 2: असेंबली भाषा प्रोग्रामिंग

असेंबली भाषा एक निम्न-स्तरीय प्रोग्रामिंग भाषा है जो माइक्रोप्रोसेसर के ऑपरेशन्स पर सीधा नियंत्रण प्रदान करती है। इंटेल 8086/8088 के लिए, असेंबली भाषा प्रोग्रामर को ऐसे निर्देश लिखने की अनुमति देती है जो मशीन कोड के निकटता से मैप होते हैं, जिससे रजिस्टरों, मेमोरी और I/O डिवाइस जैसे हार्डवेयर संसाधनों पर सूक्ष्म नियंत्रण मिलता है।

### 1. 8086 इंस्ट्रक्शन सेट

8086 इंस्ट्रक्शन सेट आदेशों का एक संग्रह है जिसे CPU समझता है, जिन्हें उनके कार्य के आधार पर वर्गीकृत किया गया है: **डेटा ट्रांसफर**, **अंकगणित**, **लॉजिक**, और **कंट्रोल फ्लो**। प्रत्येक निर्देश 8086 के एड्रेसिंग मोड (जैसे, रजिस्टर, डायरेक्ट, इनडायरेक्ट) का उपयोग करके रजिस्टरों, मेमोरी, या इमीडिएट वैल्यू पर कार्य करता है।

#### a. डेटा ट्रांसफर इंस्ट्रक्शंस
ये निर्देश रजिस्टरों, मेमोरी और इमीडिएट वैल्यू के बीच डेटा स्थानांतरित करते हैं।

- **MOV (Move)**:
  - सिंटैक्स: `MOV destination, source`
  - फंक्शन: स्रोत से डेटा को गंतव्य में कॉपी करता है।
  - उदाहरण: `MOV AX, BX` (BX को AX में कॉपी करें); `MOV AX, [1234h]` (मेमोरी एड्रेस DS:1234h से डेटा को AX में कॉपी करें)।
  - नोट्स: फ्लैग्स को प्रभावित नहीं करता; स्रोत और गंतव्य का आकार समान (8-बिट या 16-बिट) होना चाहिए।
- **XCHG (Exchange)**:
  - सिंटैक्स: `XCHG destination, source`
  - फंक्शन: स्रोत और गंतव्य की सामग्री को आपस में बदलता है।
  - उदाहरण: `XCHG AX, BX` (AX और BX को स्वैप करें)।
- **PUSH (Push onto Stack)**:
  - सिंटैक्स: `PUSH source`
  - फंक्शन: 16-बिट डेटा को स्टैक पर पुश करता है, SP को 2 से घटाता है।
  - उदाहरण: `PUSH AX` (AX को स्टैक पर सहेजें)।
- **POP (Pop from Stack)**:
  - सिंटैक्स: `POP destination`
  - फंक्शन: स्टैक से 16-बिट डेटा को गंतव्य में पॉप करता है, SP को 2 से बढ़ाता है।
  - उदाहरण: `POP BX` (BX को स्टैक से पुनर्स्थापित करें)।
- **LEA (Load Effective Address)**:
  - सिंटैक्स: `LEA destination, source`
  - फंक्शन: एक मेमोरी ऑपरेंड का एड्रेस एक रजिस्टर में लोड करता है।
  - उदाहरण: `LEA BX, [SI+4]` (DS:SI+4 का एड्रेस BX में लोड करें)।
- **IN/OUT**:
  - सिंटैक्स: `IN destination, port`; `OUT port, source`
  - फंक्शन: I/O पोर्ट से/पर डेटा स्थानांतरित करता है।
  - उदाहरण: `IN AL, 60h` (कीबोर्ड पोर्ट पढ़ें); `OUT 61h, AL` (स्पीकर पोर्ट पर लिखें)।

#### b. अंकगणित इंस्ट्रक्शंस
ये गणितीय ऑपरेशन करते हैं, परिणामों के आधार पर फ्लैग्स (जैसे, ZF, CF, SF, OF) को अपडेट करते हैं।

- **ADD (Add)**:
  - सिंटैक्स: `ADD destination, source`
  - फंक्शन: स्रोत को गंतव्य में जोड़ता है, परिणाम गंतव्य में संग्रहीत करता है।
  - उदाहरण: `ADD AX, BX` (AX = AX + BX)।
- **SUB (Subtract)**:
  - सिंटैक्स: `SUB destination, source`
  - फंक्शन: गंतव्य से स्रोत को घटाता है।
  - उदाहरण: `SUB CX, 10` (CX = CX - 10)।
- **INC (Increment)**:
  - सिंटैक्स: `INC destination`
  - फंक्शन: गंतव्य को 1 से बढ़ाता है।
  - उदाहरण: `INC BX` (BX = BX + 1)।
- **DEC (Decrement)**:
  - सिंटैक्स: `DEC destination`
  - फंक्शन: गंतव्य को 1 से घटाता है।
  - उदाहरण: `DEC CX` (CX = CX - 1)।
- **MUL (Multiply, Unsigned)**:
  - सिंटैक्स: `MUL source`
  - फंक्शन: AL (8-बिट) या AX (16-बिट) को स्रोत से गुणा करता है, परिणाम AX या DX:AX में संग्रहीत करता है।
  - उदाहरण: `MUL BX` (DX:AX = AX * BX)।
- **DIV (Divide, Unsigned)**:
  - सिंटैक्स: `DIV source`
  - फंक्शन: AX (8-बिट) या DX:AX (16-बिट) को स्रोत से विभाजित करता है, भागफल AL/AX में, शेष AH/DX में संग्रहीत करता है।
  - उदाहरण: `DIV BX` (AX = DX:AX / BX, DX = शेष)।
- **ADC (Add with Carry)** और **SBB (Subtract with Borrow)**:
  - फंक्शन: कैरी फ्लैग का उपयोग करके मल्टी-वर्ड अंकगणित को संभालते हैं।
  - उदाहरण: `ADC AX, BX` (AX = AX + BX + CF)।

#### c. लॉजिक इंस्ट्रक्शंस
ये बिटवाइज़ ऑपरेशन करते हैं और बाइनरी डेटा में हेरफेर करते हैं।

- **AND (Bitwise AND)**:
  - सिंटैक्स: `AND destination, source`
  - फंक्शन: बिटवाइज़ AND करता है, परिणाम गंतव्य में संग्रहीत करता है।
  - उदाहरण: `AND AX, 0FFh` (AX के ऊपरी बाइट को साफ़ करें)।
- **OR (Bitwise OR)**:
  - सिंटैक्स: `OR destination, source`
  - फंक्शन: बिटवाइज़ OR करता है।
  - उदाहरण: `OR BX, 1000h` (BX में बिट 12 सेट करें)।
- **XOR (Bitwise XOR)**:
  - सिंटैक्स: `XOR destination, source`
  - फंक्शन: बिटवाइज़ XOR करता है।
  - उदाहरण: `XOR AX, AX` (AX को 0 पर सेट करें)।
- **NOT (Bitwise NOT)**:
  - सिंटैक्स: `NOT destination`
  - फंक्शन: गंतव्य के सभी बिट्स को इनवर्ट करता है।
  - उदाहरण: `NOT BX` (BX = ~BX)।
- **SHL/SHR (Shift Left/Right)**:
  - सिंटैक्स: `SHL destination, count`; `SHR destination, count`
  - फंक्शन: बिट्स को बाएँ/दाएँ शिफ्ट करता है, 0 (SHR) या साइन बिट (SAL/SAR) से भरता है।
  - उदाहरण: `SHL AX, 1` (AX = AX * 2)।
- **ROL/ROR (Rotate Left/Right)**:
  - फंक्शन: बिट्स को घुमाता है, कैरी फ्लैग के माध्यम से रैप अराउंड करता है।
  - उदाहरण: `ROL BX, 1` (BX को बाएँ 1 बिट से घुमाएँ)।

#### d. कंट्रोल फ्लो इंस्ट्रक्शंस
ये प्रोग्राम के एक्सिक्यूशन अनुक्रम को बदलते हैं, जंप्स, लूप्स और सबरूटीन्स को सक्षम करते हैं।

- **JMP (Jump)**:
  - सिंटैक्स: `JMP label`
  - फंक्शन: बिना शर्त एक लेबल पर जंप करता है।
  - उदाहरण: `JMP start` (लेबल `start` पर जाएँ)।
  - वेरिएंट:
    - शॉर्ट जंप (±127 बाइट्स)।
    - नियर जंप (सेगमेंट के भीतर)।
    - फार जंप (अलग सेगमेंट)।
- **कंडीशनल जंप्स**:
  - सिंटैक्स: `Jcc label` (जैसे, JZ, JNZ, JC, JNC)
  - फंक्शन: फ्लैग स्टेट्स के आधार पर जंप करता है।
  - उदाहरण:
    - `JZ loop_end` (जीरो फ्लैग सेट होने पर जंप करें)।
    - `JC error` (कैरी फ्लैग सेट होने पर जंप करें)।
    - सामान्य कंडीशन्स: JZ (जीरो), JNZ (नॉट जीरो), JS (साइन), JO (ओवरफ्लो)।
- **LOOP (Loop)**:
  - सिंटैक्स: `LOOP label`
  - फंक्शन: CX को डिक्रीमेंट करता है, यदि CX ≠ 0 हो तो लेबल पर जंप करता है।
  - उदाहरण: `LOOP process` (CX = 0 होने तक दोहराएँ)।
  - वेरिएंट:
    - `LOOPE/LOOPZ`: लूप यदि CX ≠ 0 और ZF = 1।
    - `LOOPNE/LOOPNZ`: लूप यदि CX ≠ 0 और ZF = 0।
- **CALL (Call Subroutine)**:
  - सिंटैक्स: `CALL label`
  - फंक्शन: रिटर्न एड्रेस को स्टैक पर पुश करता है, सबरूटीन पर जंप करता है।
  - उदाहरण: `CALL compute_sum` (सबरूटीन कॉल करें)।
- **RET (Return)**:
  - सिंटैक्स: `RET`
  - फंक्शन: स्टैक से रिटर्न एड्रेस पॉप करता है, एक्सिक्यूशन फिर से शुरू करता है।
  - उदाहरण: `RET` (सबरूटीन से वापसी)।
- **INT (Interrupt)**:
  - सिंटैक्स: `INT number`
  - फंक्शन: एक सॉफ्टवेयर इंटरप्ट ट्रिगर करता है, एक इंटरप्ट सर्विस रूटीन (ISR) को कॉल करता है।
  - उदाहरण: `INT 21h` (DOS सिस्टम कॉल)।
- **IRET (Interrupt Return)**:
  - फंक्शन: एक ISR से वापसी करता है, फ्लैग्स और रिटर्न एड्रेस को पुनर्स्थापित करता है।

---

### 2. असेंबली भाषा प्रोग्रामिंग

असेंबली भाषा प्रोग्राम मानव-पठनीय निर्देशों के रूप में लिखे जाते हैं जिन्हें मशीन कोड में असेंबल किया जाता है। 8086 एक **सेगमेंटेड मेमोरी मॉडल** का उपयोग करता है, जिसमें कोड, डेटा और स्टैक सेगमेंट स्पष्ट रूप से परिभाषित होते हैं।

#### a. प्रोग्राम स्ट्रक्चर
एक विशिष्ट 8086 असेंबली प्रोग्राम शामिल करता है:
- **डायरेक्टिव्स**: असेंबलर के लिए निर्देश (जैसे, NASM, MASM)।
  - `SEGMENT`: कोड, डेटा, या स्टैक सेगमेंट को परिभाषित करता है।
  - `ORG`: ओरिजिन एड्रेस सेट करता है।
  - `DB/DW`: बाइट/वर्ड डेटा को परिभाषित करता है।
- **इंस्ट्रक्शंस**: CPU ऑपरेशन्स (जैसे, MOV, ADD)।
- **लेबल्स**: जंप्स या डेटा के लिए स्थानों को चिह्नित करते हैं।
- **कमेंट्स**: कोड समझाते हैं (जैसे, `; comment`)।

**उदाहरण प्रोग्राम स्ट्रक्चर (MASM सिंटैक्स)**:
```asm
.model small
.stack 100h
.data
    message db 'Hello, World!$'
.code
main proc
    mov ax, @data    ; DS इनिशियलाइज़ करें
    mov ds, ax
    mov dx, offset message ; मैसेज एड्रेस लोड करें
    mov ah, 09h      ; DOS प्रिंट स्ट्रिंग फंक्शन
    int 21h          ; DOS इंटरप्ट कॉल करें
    mov ah, 4Ch      ; प्रोग्राम से बाहर निकलें
    int 21h
main endp
end main
```

#### b. सीक्वेंशियल स्ट्रक्चर्स
सीक्वेंशियल कोड बिना जंप या लूप के क्रम में निर्देशों को एक्सिक्यूट करता है।

**उदाहरण: दो नंबर जोड़ना**
```asm
mov ax, 5        ; AX = 5
mov bx, 10       ; BX = 10
add ax, bx       ; AX = AX + BX (15)
mov [result], ax ; परिणाम को मेमोरी में स्टोर करें
```
- निर्देश एक के बाद एक एक्सिक्यूट होते हैं।
- सरल गणनाओं या डेटा इनिशियलाइज़ेशन के लिए सामान्य।

#### c. ब्रांच स्ट्रक्चर्स
ब्रांचिंग कंडीशंस के आधार पर प्रोग्राम फ्लो को बदलने के लिए कंडीशनल/अनकंडीशनल जंप्स का उपयोग करती है।

**उदाहरण: तुलना करें और ब्रांच करें**
```asm
mov ax, 10       ; AX = 10
cmp ax, 15       ; AX की 15 से तुलना करें
je equal         ; जंप करें यदि AX == 15
mov bx, 1        ; अन्यथा, BX = 1
jmp done
equal:
    mov bx, 0    ; BX = 0 यदि बराबर
done:
    ; प्रोग्राम जारी रखें
```
- **CMP**: घटाव (AX - 15) के आधार पर फ्लैग्स सेट करता है।
- **JE**: जंप करता है यदि ZF = 1 (बराबर)।
- if-then-else लॉजिक के लिए उपयोगी।

#### d. लूप स्ट्रक्चर्स
लूप तब तक निर्देशों को दोहराते हैं जब तक कोई शर्त पूरी नहीं हो जाती, अक्सर `LOOP` या कंडीशनल जंप्स का उपयोग करते हुए।

**उदाहरण: 1 से 10 तक नंबरों का योग**
```asm
mov cx, 10       ; लूप काउंटर = 10
mov ax, 0        ; योग = 0
sum_loop:
    add ax, cx   ; योग में CX जोड़ें
    loop sum_loop ; CX डिक्रीमेंट करें, लूप करें यदि CX ≠ 0
    ; AX = 55 (1 + 2 + ... + 10)
```
- `LOOP` काउंटर-आधारित पुनरावृत्ति को सरल बनाता है।
- वैकल्पिक: कस्टम कंडीशन्स के लिए `CMP` और `JNZ` का उपयोग करें।

**कंडीशनल लूप के साथ उदाहरण**
```asm
mov ax, 0        ; काउंटर
mov bx, 100      ; लिमिट
count_up:
    inc ax       ; AX++
    cmp ax, bx   ; 100 से तुलना करें
    jle count_up ; जंप करें यदि AX <= 100
```
- गैर-काउंटर-आधारित लूप्स के लिए लचीला।

#### e. सबरूटीन्स
सबरूटीन्स `CALL` और `RET` के माध्यम से पुन: उपयोग की अनुमति देकर कोड को मॉड्यूलर बनाते हैं।

**उदाहरण: किसी संख्या का वर्ग निकालें**
```asm
main:
    mov ax, 4    ; इनपुट
    call square  ; सबरूटीन कॉल करें
    ; AX = 16
    jmp exit
square:
    push bx      ; BX सहेजें
    mov bx, ax   ; AX की कॉपी करें
    mul bx       ; AX = AX * BX
    pop bx       ; BX पुनर्स्थापित करें
    ret          ; वापसी
exit:
    ; प्रोग्राम समाप्त करें
```
- **PUSH/POP**: साइड इफेक्ट्स से बचने के लिए रजिस्टरों को सहेजें/पुनर्स्थापित करें।
- स्टैक रिटर्न एड्रेस को स्वचालित रूप से प्रबंधित करता है।

---

### 3. इंटरप्ट सर्विस रूटीन्स (ISRs)

इंटरप्ट्स CPU को वर्तमान प्रोग्राम को रोककर और एक ISR को एक्सिक्यूट करके बाहरी या आंतरिक घटनाओं (जैसे, कीबोर्ड इनपुट, टाइमर टिक्स) का जवाब देने की अनुमति देते हैं।

#### इंटरप्ट मैकेनिज्म
- **इंटरप्ट वेक्टर टेबल (IVT)**:
  - मेमोरी 0000:0000h–0000:03FFh पर स्थित।
  - 256 इंटरप्ट प्रकारों (0–255) के लिए ISRs के एड्रेस संग्रहीत करता है।
  - प्रत्येक एंट्री: सेगमेंट:ऑफसेट (4 बाइट्स)।
- **प्रकार**:
  - **हार्डवेयर इंटरप्ट्स**: डिवाइस द्वारा ट्रिगर (जैसे, IRQ)।
  - **सॉफ्टवेयर इंटरप्ट्स**: `INT` इंस्ट्रक्शन द्वारा ट्रिगर (जैसे, DOS के लिए INT 21h)।
  - **एक्सेप्शन्स**: CPU एरर्स (जैसे, शून्य से विभाजन)।
- **प्रक्रिया**:
  1. इंटरप्ट होता है।
  2. CPU फ्लैग्स, CS, और IP को स्टैक पर सहेजता है।
  3. IVT के माध्यम से ISR पर जंप करता है।
  4. ISR एक्सिक्यूट होता है, स्टेट को पुनर्स्थापित करने के लिए `IRET` के साथ समाप्त होता है।

#### एक ISR लिखना
ISRs को अवश्य:
- रजिस्टरों को संरक्षित करना चाहिए (PUSH/POP)।
- इंटरप्ट को जल्दी से हैंडल करना चाहिए।
- `IRET` के साथ समाप्त होना चाहिए।

**उदाहरण: कस्टम टाइमर ISR**
```asm
.data
old_vec dw 2 dup(0) ; पुराने इंटरप्ट वेक्टर को स्टोर करें
.code
install_isr:
    cli             ; इंटरप्ट्स अक्षम करें
    mov ax, 0
    mov es, ax      ; ES = 0 (IVT सेगमेंट)
    mov bx, 1Ch*4   ; टाइमर इंटरप्ट (1Ch)
    mov ax, es:[bx] ; पुराना वेक्टर सहेजें
    mov old_vec, ax
    mov ax, es:[bx+2]
    mov old_vec+2, ax
    mov ax, offset my_isr ; नया वेक्टर सेट करें
    mov es:[bx], ax
    mov ax, cs
    mov es:[bx+2], ax
    sti             ; इंटरप्ट्स सक्षम करें
    ret
my_isr:
    push ax
    inc word ptr [counter] ; काउंटर इंक्रीमेंट करें
    pop ax
    iret            ; इंटरप्ट से वापसी
```
- टाइमर इंटरप्ट (1Ch, ~18.2 Hz) को हुक करता है।
- एक काउंटर वेरिएबल को इंक्रीमेंट करता है।
- रजिस्टरों को संरक्षित करता है और `IRET` का उपयोग करता है।

**उदाहरण: DOS इंटरप्ट (INT 21h)**
```asm
mov ah, 09h      ; प्रिंट स्ट्रिंग फंक्शन
mov dx, offset msg ; '$'-टर्मिनेटेड स्ट्रिंग का एड्रेस
int 21h          ; DOS कॉल करें
```
- INT 21h OS सर्विसेज प्रदान करता है (जैसे, I/O, फाइल हैंडलिंग)।
- AH फंक्शन कोड निर्दिष्ट करता है।

#### प्रैक्टिकल नोट्स
- **स्टेट सेविंग**: ISRs को मुख्य प्रोग्राम को दूषित होने से बचाने के लिए सभी रजिस्टरों को संरक्षित करना चाहिए।
- **प्राथमिकता**: हार्डवेयर इंटरप्ट्स दूसरों को प्रीएम्प्ट कर सकते हैं (PIC द्वारा प्रबंधित)।
- **डीबगिंग**: DEBUG.COM या आधुनिक एमुलेटर्स (जैसे, DOSBox, Bochs) का उपयोग करें।

---

### उदाहरण प्रोग्राम: फैक्टोरियल कैलकुलेशन
यह प्रोग्राम एक लूप और सबरूटीन का उपयोग करके एक संख्या (जैसे, 5! = 120) का फैक्टोरियल निकालता है।

```asm
.model small
.stack 100h
.data
    num dw 5        ; इनपुट संख्या
    result dw ?     ; परिणाम स्टोर करें
.code
main proc
    mov ax, @data
    mov ds, ax      ; DS इनिशियलाइज़ करें
    mov ax, num     ; संख्या लोड करें
    call factorial  ; फैक्टोरियल कंप्यूट करें
    mov result, ax  ; परिणाम स्टोर करें
    mov ah, 4Ch     ; बाहर निकलें
    int 21h
main endp
factorial proc
    push bx
    mov bx, ax      ; BX = n
    mov ax, 1       ; AX = परिणाम
fact_loop:
    cmp bx, 1
    jle done        ; यदि BX <= 1, बाहर निकलें
    mul bx          ; AX = AX * BX
    dec bx          ; BX--
    jmp fact_loop
done:
    pop bx
    ret
factorial endp
end main
```
- **लॉजिक**:
  - इनपुट: num = 5।
  - लूप: AX = AX * BX, BX-- जब तक BX = 1।
  - परिणाम: AX = 5 * 4 * 3 * 2 * 1 = 120।
- **फीचर्स**:
  - मॉड्यूलरिटी के लिए सबरूटीन।
  - रजिस्टर संरक्षण के लिए स्टैक।
  - सीक्वेंशियल और लूप स्ट्रक्चर्स।

---

### बेस्ट प्रैक्टिसेज
1. **कोड कमेंट करें**: असेंबली गूढ़ है; हर कदम समझाएँ।
2. **रजिस्टर यूज मिनिमाइज़ करें**: अनावश्यक ओवरराइट्स से बचें।
3. **इंक्रीमेंटली टेस्ट करें**: एक्सिक्यूशन को ट्रेस करने के लिए डीबगर्स का उपयोग करें।
4. **एज केसेज हैंडल करें**: ओवरफ्लो, जीरो, या नेगेटिव इनपुट्स की जाँच करें।
5. **ऑप्टिमाइज़ करें**: निर्देश कम करें (जैसे, MOV AX, 0 के बजाय XOR AX, AX का उपयोग करें)।

---

### सारांश
- **8086 इंस्ट्रक्शन सेट**:
  - **डेटा ट्रांसफर**: डेटा स्थानांतरित करने के लिए MOV, PUSH, POP।
  - **अंकगणित**: गणनाओं के लिए ADD, SUB, MUL।
  - **लॉजिक**: बिट मैनिपुलेशन के लिए AND, OR, XOR।
  - **कंट्रोल फ्लो**: प्रोग्राम फ्लो के लिए JMP, LOOP, CALL।
- **प्रोग्रामिंग स्ट्रक्चर्स**:
  - **सीक्वेंशियल**: सरल कार्यों के लिए रैखिक एक्सिक्यूशन।
  - **ब्रांच**: निर्णयों के लिए कंडीशनल जंप्स।
  - **लूप**: पुनरावृत्ति के लिए LOOP या Jcc।
  - **सबरूटीन्स**: मॉड्यूलर कोड के लिए CALL/RET।
- **इंटरप्ट्स**:
  - ISRs IVT के माध्यम से घटनाओं को हैंडल करते हैं।
  - स्टेट को संरक्षित करें, IRET के साथ समाप्त करें।
  - हार्डवेयर (जैसे, टाइमर) और सॉफ्टवेयर (जैसे, DOS) इंटरप्ट्स के लिए उपयोग किया जाता है।

---

### अभ्यास प्रश्न
1. मेमोरी में एक स्ट्रिंग को उल्टा करने के लिए एक प्रोग्राम लिखें।
2. यह जाँचने के लिए कि कोई संख्या अभाज्य है या नहीं, एक सबरूटीन लागू करें।
3. कीप्रेसेस को गिनने के लिए कीबोर्ड इंटरप्ट (INT 09h) के लिए एक ISR बनाएँ।
4. `JMP` और `CALL` के बीच अंतर समझाएँ।
5. इस कोड को ऑप्टिमाइज़ करें: `MOV AX, 0; MOV BX, AX; ADD BX, 5`।

---

यह ट्यूटोरियल 8086 असेंबली प्रोग्रामिंग के मूल सिद्धांतों को कवर करता है, जिसमें व्यावहारिक कौशल बनाने के लिए उदाहरण और स्पष्टीकरण शामिल हैं। यदि आप विशिष्ट निर्देशों, उन्नत तकनीकों (जैसे, स्ट्रिंग ऑपरेशन्स), या एमुलेशन टूल्स का पता लगाना चाहते हैं, तो मुझे बताएं!