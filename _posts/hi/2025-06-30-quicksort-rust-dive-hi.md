---
audio: false
generated: true
lang: hi
layout: post
title: अनुभवी डेवलपर्स के लिए रस्ट में क्विकसॉर्ट
translated: true
type: note
---

ठीक है, आपके एल्गोरिदम, फुल-स्टैक डेवलपमेंट और यहाँ तक कि मोबाइल इंजीनियरिंग में मजबूत पृष्ठभूमि को देखते हुए, आपको Rust का मेमोरी सुरक्षा और स्पष्ट नियंत्रण का तरीका अवधारणा में काफी परिचित लगेगा, भले ही सिंटैक्स और सख्ती नई हो। आइए Rust में इस Quicksort इम्प्लीमेंटेशन को समझते हैं।

-----

### Rust में Quicksort: अनुभवी डेवलपर्स के लिए एक गहन विवेचना

यह Rust कोड क्लासिक **Quicksort एल्गोरिदम** को लागू करता है। Quicksort का मूल विचार एक एलिमेंट को पिवोट के रूप में चुनना और ऐरे को उसके आसपास इस तरह विभाजित करना है कि पिवोट से छोटे एलिमेंट एक तरफ हों और बड़े एलिमेंट दूसरी तरफ। फिर इस प्रक्रिया को उप-ऐरे पर बार-बार (रिकर्सिवली) लागू किया जाता है।

आइए फंक्शन्स को देखें:

-----

### `fn quick_sort(arr: &mut [i32])`

```rust
fn quick_sort(arr: &mut [i32]) {
    if arr.len() <= 1 {
        return;
    }
    let pivot_index = partition(arr);
    let (left, right) = arr.split_at_mut(pivot_index);
    quick_sort(left);
    quick_sort(&mut right[1..]);
}
```

  * **`arr: &mut [i32]`**: यहाँ Rust का टाइप सिस्टम तुरंत अपनी विशेषताएँ दिखाता है।
      * `&mut` एक **म्यूटेबल रेफरेंस** को दर्शाता है। इसका मतलब है कि `quick_sort` फंक्शन को ऐरे `arr` का उधार लिया गया रेफरेंस मिलता है, और उसे उस ऐरे की सामग्री को *जगह पर ही* बदलने की अनुमति है।
      * `[i32]` `i32` इंटीजर्स की एक **स्लाइस** है। Rust में, `[T]` एक स्लाइस का टाइप होता है, जो एलिमेंट्स के एक सन्निहित क्रम में एक दृश्य होता है। यह डेटा का मालिक नहीं होता; यह सिर्फ किसी ऐरे या `Vec` के एक हिस्से की ओर इशारा करता है। यह दक्षता के लिए महत्वपूर्ण है, क्योंकि यह डेटा को इधर-उधर कॉपी करने से बचाता है। आपकी C/C++/Java पृष्ठभूमि से पॉइंटर्स और ऐरे सेक्शन्स से आप परिचित हैं; इसे Rust का सुरक्षित और स्पष्ट तरीका समझें जो उसी को मैनेज करता है।
  * **बेस केस `if arr.len() <= 1`**: Quicksort के लिए मानक रिकर्सिव बेस केस। अगर स्लाइस में 0 या 1 एलिमेंट है, तो वह पहले से ही सॉर्टेड है, इसलिए बस वापस लौटें।
  * **`let pivot_index = partition(arr);`**: यह `partition` फंक्शन (जिसे हम आगे देखेंगे) को कॉल करता है ताकि स्लाइस को पुनर्व्यवस्थित किया जा सके। यह पिवोट एलिमेंट की अंतिम स्थिति लौटाता है।
  * **`let (left, right) = arr.split_at_mut(pivot_index);`**: यह सुरक्षित म्यूटेबल अलायसिंग के लिए एक प्रमुख Rust विशेषता है।
      * `split_at_mut` म्यूटेबल स्लाइस पर एक मेथड है। यह एक इंडेक्स लेता है और म्यूटेबल स्लाइस को दो *अलग-अलग* म्यूटेबल स्लाइस में विभाजित करता है।
      * `left` होगा `arr[0..pivot_index]` और `right` होगा `arr[pivot_index..len]`।
      * यह Rust के **बोरो चेकर** का मूलभूत सिद्धांत है। आपके पास एक ही समय में *समान डेटा* के दो म्यूटेबल रेफरेंस नहीं हो सकते। `split_at_mut` यह सुनिश्चित करता है कि `left` और `right` मूल ऐरे के पूरी तरह से अलग-अलग हिस्सों को संदर्भित करते हैं, जिससे बोरो चेकर संतुष्ट हो जाता है और मल्टी-थ्रेडेड संदर्भ में डेटा रेस को रोकता है (भले ही यह सिंगल-थ्रेडेड है, सिद्धांत लागू होता है)।
  * **`quick_sort(left);`**: `left` उप-स्लाइस को रिकर्सिवली सॉर्ट करें।
  * **`quick_sort(&mut right[1..]);`**: `right` उप-स्लाइस को रिकर्सिवली सॉर्ट करें।
      * `right[1..]` महत्वपूर्ण है: `right` स्लाइस `pivot_index` से शुरू होती है। चूंकि `arr[pivot_index]` अब सही ढंग से रखा गया पिवोट एलिमेंट है, इसलिए हम दाईं ओर के रिकर्सिव कॉल से इसे बाहर कर देते हैं।
      * `&mut` स्पष्ट रूप से `right` से एक म्यूटेबल स्लाइस को फिर से उधार लेता है।

-----

### `fn partition(arr: &mut [i32]) -> usize`

```rust
fn partition(arr: &mut [i32]) -> usize {
    let len = arr.len();
    let pivot = arr[len - 1];
    let mut i = 0;
    for j in 0..len - 1 {
        if arr[j] <= pivot {
            arr.swap(i, j);
            i += 1;
        }
    }
    arr.swap(i, len - 1);
    i
}
```

यह फंक्शन Quicksort के लिए ऐरे को विभाजित करने के सामान्य तरीके, Lomuto पार्टीशन स्कीम को लागू करता है।

  * **`let len = arr.len();`**: वर्तमान स्लाइस की लंबाई प्राप्त करता है।
  * **`let pivot = arr[len - 1];`**: स्लाइस के **अंतिम एलिमेंट** को पिवोट के रूप में चुना जाता है।
  * **`let mut i = 0;`**: `i` पिवोट से छोटे या बराबर एलिमेंट्स और पिवोट से बड़े एलिमेंट्स के बीच की "सीमा" के लिए एक पॉइंटर के रूप में कार्य करता है। `i` के बाईं ओर के एलिमेंट पिवोट से कम या बराबर होंगे।
  * **`for j in 0..len - 1`**: यह लूप पिवोट (जो `len - 1` पर है) को *छोड़कर* सभी एलिमेंट्स से होकर गुजरता है।
  * **`if arr[j] <= pivot { ... }`**: यदि वर्तमान एलिमेंट `arr[j]` पिवोट से कम या बराबर है:
      * **`arr.swap(i, j);`**: `arr[j]` को `arr[i]` से स्वैप करें। यह छोटे एलिमेंट को "कम या बराबर" वाले सेक्शन में ले जाता है।
      * **`i += 1;`**: "कम या बराबर" वाले सेक्शन को बढ़ाने के लिए `i` को बढ़ाएँ।
  * **`arr.swap(i, len - 1);`**: लूप के बाद, `i` पिवोट के लिए सही स्थिति है। हम पिवोट (जो अभी भी `len - 1` पर है) को उसकी अंतिम सॉर्टेड स्थिति में स्वैप करते हैं। अब, `i` के बाईं ओर के सभी एलिमेंट `arr[i]` (पिवोट) से कम या बराबर हैं, और दाईं ओर के सभी एलिमेंट बड़े हैं।
  * **`i`**: फंक्शन `i` लौटाता है, जो पिवोट एलिमेंट का अंतिम इंडेक्स है।

-----

### `fn main()`

```rust
fn main() {
    let mut arr = [3, 6, 8, 10, 1, 2, 1];
    println!("Before: {:?}", arr);
    quick_sort(&mut arr);
    println!("After: {:?}", arr);
}
```

  * **`let mut arr = [3, 6, 8, 10, 1, 2, 1];`**:
      * `let mut` एक **म्यूटेबल वेरिएबल** घोषित करता है। यह आपको वेरिएबल को पुन: असाइन करने या उसकी सामग्री को संशोधित करने (यदि यह एक म्यूटेबल टाइप है) की अनुमति देता है।
      * `[3, ...]` स्टैक पर एक **फिक्स्ड-साइज ऐरे** बनाता है। इसका आकार कंपाइल टाइम पर ज्ञात होता है।
  * **`println!("Before: {:?}", arr);`**: आउटपुट के लिए `println!` मैक्रो का उपयोग करता है।
      * `{:?}` **डीबग प्रिंट** फॉर्मेट स्पेसिफायर है। यह ऐरे के मानव-पठनीय प्रतिनिधित्व को प्रिंट करने के लिए `Debug` ट्रेट का उपयोग करता है।
  * **`quick_sort(&mut arr);`**: `quick_sort` फंक्शन को कॉल करता है, `arr` ऐरे का एक म्यूटेबल रेफरेंस पास करता है।
  * **`println!("After: {:?}", arr);`**: सॉर्टिंग के बाद ऐरे को फिर से प्रिंट करता है।

-----

### आपके लिए Rust-विशिष्ट मुख्य बातें

  * **ओनरशिप और बोरोइंग**: यह कोड Rust की मुख्य अवधारणाओं का एक प्रमुख उदाहरण है। आप डेटा की प्रतिलिपि बनाने के बजाय **रेफरेंस (`&` और `&mut`)** पास कर रहे हैं। जगह पर ऐरे को संशोधित करने के लिए `&mut` रेफरेंस महत्वपूर्ण हैं, और **बोरो चेकर** (उदाहरण के लिए, `split_at_mut` द्वारा लागू) यह सुनिश्चित करता है कि आपके पास कभी भी समान डेटा के कई म्यूटेबल रेफरेंस न हों, जिससे कंपाइल टाइम पर कंकरेंसी बग्स का एक पूरा वर्ग समाप्त हो जाता है। यह Java या Python जैसी भाषाओं से संभवतः सबसे बड़ा पैराडाइम शिफ्ट है, लेकिन यह गार्बेज कलेक्टर के बिना मेमोरी सुरक्षा प्रदान करता है।
  * **स्लाइस `[T]`**: सन्निहित डेटा के साथ काम करने के लिए ये अविश्वसनीय रूप से शक्तिशाली हैं। ये नई मेमोरी आवंटित किए बिना ऐरे या वेक्टर के हिस्सों में एक सुरक्षित, कुशल दृश्य प्रदान करते हैं।
  * **मैक्रोस (`println!`)**: आप कई स्टैण्डर्ड लाइब्रेरी फंक्शन्स (जैसे `println!`, `vec!`, `format!`) के बाद `!` देखेंगे। यह इंगित करता है कि वे **मैक्रोस** हैं, नियमित फंक्शन नहीं। मैक्रोस कंपाइल टाइम पर कोड का विस्तार करते हैं, जो नियमित फंक्शन्स की तुलना में अधिक लचीलापन और शक्ति (जैसे वेरिएडिक आर्गुमेंट्स या कंपाइल-टाइम कोड जनरेशन) प्रदान करते हैं।

आपकी पृष्ठभूमि को देखते हुए, आप संभवतः Rust द्वारा प्रदान की जाने वाली परफॉर्मेंस विशेषताओं और सुरक्षा गारंटियों की सराहना करेंगे, भले ही "बोरो चेकर डांस" में थोड़ा अभ्यस्त होने में समय लगे। यह मेमोरी मैनेजमेंट के बारे में सोचने का एक अलग तरीका है, लेकिन एक ऐसा तरीका जो अत्यधिक मजबूत और कुशल कोड की ओर ले जाता है।