---
audio: false
generated: true
image: false
lang: hi
layout: post
model: x-ai/grok-code-fast-1
title: बहु-मॉड्यूल मेवेन प्रोजेक्ट्स में निर्दोष
translated: true
type: note
---

### मल्टी-मॉड्यूल Maven प्रोजेक्ट्स में Spotless

Spotless एक कोड फॉर्मेटिंग प्लगइन है जो Maven और Gradle दोनों के लिए उपलब्ध है। आपके द्वारा Maven के `-pl` (प्रोजेक्ट लिस्ट) फ्लैग का उल्लेख करने के आधार पर, मैं मान रहा हूँ कि आप एक मल्टी-मॉड्यूल Java प्रोजेक्ट में **Spotless Maven प्लगइन** का उपयोग कर रहे हैं। यह आपको फॉर्मेटिंग जांच (जैसे, `spotless:check` के माध्यम से) या सुधार लागू करने (जैसे, `spotless:apply` के माध्यम से) को विशिष्ट मॉड्यूल्स पर चुनिंदा रूप से चलाने की अनुमति देता है, जो बड़े प्रोजेक्ट्स के लिए कुशल है जहाँ आपको केवल कुछ विशेष मॉड्यूल्स को फॉर्मेट करने की आवश्यकता हो सकती है (जैसे, किसी विशिष्ट सबमॉड्यूल पर विकास के दौरान)।

#### पूर्वापेक्षाएँ
- आपका प्रोजेक्ट Maven का उपयोग करता है जिसमें मल्टी-मॉड्यूल संरचना है (एक पैरेंट `pom.xml` में `<modules>...</modules>` के साथ परिभाषित)।
- Spotless Maven प्लगइन आपके प्रोजेक्ट में कॉन्फ़िगर है (आमतौर पर पैरेंट POM या व्यक्तिगत मॉड्यूल POMs में)। यदि नहीं है, तो इसे अपने POM में जोड़ें:
  ```xml
  <build>
    <plugins>
      <plugin>
        <groupId>com.diffplug.spotless</groupId>
        <artifactId>spotless-maven-plugin</artifactId>
        <version>2.43.0</version>  <!-- नवीनतम वर्जन का उपयोग करें -->
        <configuration>
          <!-- आपके फॉर्मेटिंग नियम यहाँ, उदा. Java, Groovy के लिए -->
        </configuration>
      </plugin>
    </plugins>
  </build>
  ```
  - सामान्य नियमों में Google Java Format, Eclipse JDT for Java, या इम्पोर्ट्स, स्पेसिंग आदि के लिए कस्टमाइज़ेशन शामिल हैं।
  - Spotless कई फ़ाइल प्रकारों (Java, Kotlin, XML, आदि) को सपोर्ट करता है और CI टूल्स के साथ प्री-कमिट हुक्स ( `spotless:check` गोल के माध्यम से, जो अनफॉर्मेटेड कोड पर बिल्ड्स को फेल कर देता है) के लिए अच्छी तरह से एकीकृत होता है।

#### फॉर्मेटिंग को नियंत्रित करने के लिए `-pl` का उपयोग करना
Maven का `-pl` (प्रोजेक्ट लिस्ट) फ्लैग आपको बिल्ड/प्लगइन एक्ज़िक्यूशन में शामिल करने के लिए मॉड्यूल्स की एक कॉमा-सेपरेटेड लिस्ट निर्दिष्ट करने देता है। डिफ़ॉल्ट रूप से, Maven सभी मॉड्यूल्स पर चलता है, लेकिन `-pl` इसे प्रतिबंधित कर देता है, जिससे समय बचता है और अप्रभावित मॉड्यूल्स पर अनावश्यक काम से बचा जा सकता है।

- **बेसिक कमांड स्ट्रक्चर**:
  - फॉर्मेटिंग जांचने के लिए (बदलाव लागू किए बिना): `mvn spotless:check -pl module1,module2`
  - फॉर्मेटिंग सुधार लागू करने के लिए: `mvn spotless:apply -pl module1,module2`
  - `module1,module2` को वास्तविक मॉड्यूल नामों से बदलें (जैसे, रूट से रिलेटिव पाथ, जैसे `core,api`)।

- **उदाहरण**:
  1. **केवल `core` मॉड्यूल पर फॉर्मेटिंग जांचें**:
     ```
     mvn spotless:check -pl core
     ```
     - यह केवल `core` के सोर्स फ़ाइलों को स्कैन और वैलिडेट करता है। यदि कोई फॉर्मेटिंग समस्या मौजूद है, तो बिल्ड विवरण के साथ फेल हो जाती है (जैसे, "कृपया फिक्स करने के लिए `spotless:apply` चलाएं")।

  2. **एकाधिक मॉड्यूल्स (`api` और `utils`) पर फॉर्मेटिंग लागू करें**:
     ```
     mvn spotless:apply -pl api,utils
     ```
     - यह आपके Spotless नियमों से मेल खाने के लिए फ़ाइलों को इन-प्लेस मॉडिफ़ाई करता है। वर्जन कंट्रोल में सरप्राइज से बचने के लिए हमेशा बाद में चेंजेज को कमिट करें।

  3. **फुल प्रोजेक्ट रन के दौरान विशिष्ट मॉड्यूल्स को बाहर करें**: कुछ मॉड्यूल्स *छोड़कर* बाकी सब कुछ चलाने के लिए `-pl !moduleToSkip` का उपयोग करें (Maven 3.2.1+ `!` के साथ नेगेशन को सपोर्ट करता है)।
     - उदाहरण: `mvn spotless:check -pl !legacy` (`legacy` को छोड़कर सभी मॉड्यूल्स पर चलता है)।

- **दक्षता के लिए टिप्स**:
  - **पैरेलल एक्ज़िक्यूशन**: मल्टी-थ्रेडेड बिल्ड्स के लिए `-T 4` जोड़ें (जैसे, `mvn spotless:check -pl core,api -T 4`)।
  - **ड्राई रन**: बिना बदलाव के समस्याओं का प्रीव्यू देखने के लिए पहले `spotless:check` का उपयोग करें—यह इडेम्पोटेंट और सेफ है।
  - **IDE/वर्जन कंट्रोल के साथ एकीकरण**: अपने IDE (जैसे, IntelliJ Spotless प्लगइन के माध्यम से) में सेव/कमिट पर चलाने के लिए Spotless को कॉन्फ़िगर करें या ऑटोमेटेड चेक्स के लिए इसे प्री-कमिट हुक के रूप में उपयोग करें (pre-commit या Git हुक्स जैसे टूल्स के माध्यम से)।
  - **रिएक्टर रेजोल्यूशन को हैंडल करना**: यदि मॉड्यूल डिपेंडेंसीज कॉम्प्लेक्स हैं, तो `-pl` का उपयोग करते समय Maven उन्हें ऑटोमैटिकली रेजोल्व कर देता है, यह सुनिश्चित करते हुए कि यदि आवश्यक हो तो डिपेंडेंट मॉड्यूल्स को पहले प्रोसेस किया जाता है।
  - **सामान्य समस्याएँ**:
    - यदि `-pl` काम नहीं कर रहा है, तो सुनिश्चित करें कि मॉड्यूल्स `<modules>` में परिभाषित हैं और यदि कोई अस्पष्टता है तो फुली क्वालिफाइड पाथ्स का उपयोग करें (जैसे, मल्टी-रेपो सेटअप के लिए `-pl :core`)।
    - Gradle यूजर्स के लिए (यदि आपका मतलब Spotless Gradle प्लगइन से था), समकक्ष प्रोजेक्ट पाथ्स के लिए `-p` है, लेकिन आपके क्वेरी में `-pl` निर्दिष्ट है, इसलिए Maven माना जा रहा है। यदि यह Gradle है, तो `gradle task -p submodule` जैसे प्लगइन्स पर स्विच करें।

पूर्ण डॉक्युमेंटेशन के लिए, [Spotless Maven Plugin डॉक्स](https://github.com/diffplug/spotless/tree/v2.43.0/plugin-maven) देखें। यदि आपका सेटअप अलग है (जैसे, Gradle), तो टेलर्ड सलाह के लिए अधिक विवरण प्रदान करें।