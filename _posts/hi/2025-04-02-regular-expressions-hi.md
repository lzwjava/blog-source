---
audio: false
generated: true
lang: hi
layout: post
title: रेगुलर एक्सप्रेशन्स
translated: true
type: note
---

रेगुलर एक्सप्रेशन, जिन्हें अक्सर "regex" या "regexp" कहा जाता है, टेक्स्ट में पैटर्न मिलान के लिए एक शक्तिशाली और बहुमुखी उपकरण हैं। वे परिभाषित पैटर्न के आधार पर स्ट्रिंग्स को खोजने, उनमें हेरफेर करने और उन्हें वैलिडेट करने का एक संक्षिप्त और लचीला तरीका प्रदान करते हैं। हालांकि सिंटैक्स पहली नज़र में डराने वाला लग सकता है, लेकिन regex में महारत हासिल करने से विभिन्न प्रोग्रामिंग भाषाओं, टेक्स्ट एडिटर्स और कमांड-लाइन टूल्स में आपकी टेक्स्ट प्रोसेसिंग क्षमताओं में काफी वृद्धि हो सकती है।

यह गाइड आपको रेगुलर एक्सप्रेशन की बुनियादी बातों से लेकर अधिक उन्नत अवधारणाओं तक ले जाएगी।

**I. मूल सिद्धांत: Regex के बिल्डिंग ब्लॉक्स**

इसके मूल में, एक regex वर्णों का एक क्रम है जो एक खोज पैटर्न को परिभाषित करता है। ये वर्ण शाब्दिक (अपने आप से मेल खाने वाले) या विशेष (विशिष्ट अर्थ रखने वाले) हो सकते हैं।

**A. शाब्दिक वर्ण (Literal Characters):**

एक regex में अधिकांश वर्ण अपने आप से शाब्दिक रूप से मेल खाते हैं। उदाहरण के लिए:

* `abc` एक स्ट्रिंग में सटीक क्रम "abc" से मेल खाएगा।
* `123` सटीक क्रम "123" से मेल खाएगा।
* `hello` सटीक क्रम "hello" से मेल खाएगा।

**B. मेटाकैरेक्टर्स: विशेष शक्तियाँ**

मेटाकैरेक्टर्स वह मूलभूत इकाइयाँ हैं जो regex को उसकी शक्ति प्रदान करते हैं। उनके विशेष अर्थ होते हैं और वे अपने आप से शाब्दिक रूप से मेल नहीं खाते। यहाँ सबसे आम ones दिए गए हैं:

1.  **`.` (डॉट):** एक न्यूलाइन कैरेक्टर (`\n` डिफ़ॉल्ट रूप से) *को छोड़कर* किसी भी एकल वर्ण से मेल खाता है।
    * `a.c` "abc", "adc", "a1c", "a c" से मेल खाएगा, लेकिन "ac" या "abbc" से नहीं।

2.  **`^` (कैरट):**
    * **एक कैरेक्टर सेट के अंदर (नीचे देखें):** सेट को नकारता है, सेट में *नहीं* आने वाले किसी भी वर्ण से मेल खाता है।
    * **कैरेक्टर सेट के बाहर:** एक स्ट्रिंग की शुरुआत से मेल खाता है (या मल्टीलाइन मोड में एक लाइन की शुरुआत)।
        * `^hello` "hello world" से मेल खाएगा लेकिन "say hello" से नहीं।

3.  **`$` (डॉलर साइन):** एक स्ट्रिंग के अंत से मेल खाता है (या मल्टीलाइन मोड में एक लाइन का अंत)।
    * `world$` "hello world" से मेल खाएगा लेकिन "world hello" से नहीं।

4.  **`*` (एस्टेरिस्क):** पिछले वर्ण या समूह को शून्य या अधिक बार मेल करता है।
    * `ab*c` "ac", "abc", "abbc", "abbbc", इत्यादि से मेल खाएगा।

5.  **`+` (प्लस साइन):** पिछले वर्ण या समूह को एक या अधिक बार मेल करता है।
    * `ab+c` "abc", "abbc", "abbbc" से मेल खाएगा, लेकिन "ac" से नहीं।

6.  **`?` (प्रश्न चिह्न):**
    * पिछले वर्ण या समूह को शून्य या एक बार मेल करता है (इसे वैकल्पिक बनाता है)।
        * `ab?c` "ac" और "abc" से मेल खाएगा, लेकिन "abbc" से नहीं।
    * एक मैच को नॉन-ग्रीडी (non-greedy) बनाने के लिए एक क्वांटिफायर मॉडिफायर के रूप में उपयोग किया जाता है (क्वांटिफायर्स सेक्शन देखें)।

7.  **`{}` (कर्ली ब्रेसिज़):** पिछले वर्ण या समूह की घटनाओं की सटीक संख्या या रेंज निर्दिष्ट करता है।
    * `a{3}` ठीक तीन "a" से मेल खाता है (जैसे, "aaa")।
    * `a{2,4}` दो और चार "a" के बीच से मेल खाता है (जैसे, "aa", "aaa", "aaaa")।
    * `a{2,}` दो या अधिक "a" से मेल खाता है (जैसे, "aa", "aaa", "aaaa", ...)।

8.  **`[]` (वर्गाकार कोष्ठक):** एक कैरेक्टर सेट को परिभाषित करता है, कोष्ठक के अंदर किसी भी एकल वर्ण से मेल खाता है।
    * `[abc]` या तो "a", "b", या "c" से मेल खाएगा।
    * `[a-z]` "a" से "z" तक के किसी भी लोअरकेस अक्षर से मेल खाएगा (रेंज)।
    * `[0-9]` "0" से "9" तक के किसी भी अंक से मेल खाएगा।
    * `[A-Za-z0-9]` किसी भी अल्फ़ान्यूमेरिक वर्ण से मेल खाएगा।
    * `[^abc]` (शुरुआत में `^` के साथ) "a", "b", या "c" *को छोड़कर* किसी भी वर्ण से मेल खाएगा।

9.  **`\` (बैकस्लैश):** अगले वर्ण को एस्केप करता है, एक मेटाकैरेक्टर को शाब्दिक वर्ण के रूप में मानता है या एक विशेष वर्ण अनुक्रम पेश करता है।
    * `\.` एक शाब्दिक डॉट "." से मेल खाएगा।
    * `\*` एक शाब्दिक एस्टेरिस्क "*" से मेल खाएगा।
    * `\d` किसी भी अंक से मेल खाता है (`[0-9]` के बराबर)।
    * `\D` किसी भी गैर-अंक वर्ण से मेल खाता है (`[^0-9]` के बराबर)।
    * `\s` किसी भी व्हाइटस्पेस वर्ण (स्पेस, टैब, न्यूलाइन, आदि) से मेल खाता है।
    * `\S` किसी भी गैर-व्हाइटस्पेस वर्ण से मेल खाता है।
    * `\w` किसी भी वर्ड कैरेक्टर (अल्फ़ान्यूमेरिक और अंडरस्कोर, `[a-zA-Z0-9_]` के बराबर) से मेल खाता है।
    * `\W` किसी भी गैर-वर्ड कैरेक्टर (`[^a-zA-Z0-9_]` के बराबर) से मेल खाता है।
    * `\b` एक वर्ड बाउंडरी (एक वर्ड कैरेक्टर और एक गैर-वर्ड कैरेक्टर के बीच की स्थिति) से मेल खाता है।
    * `\B` एक गैर-वर्ड बाउंडरी से मेल खाता है।
    * `\n` एक न्यूलाइन कैरेक्टर से मेल खाता है।
    * `\r` एक कैरिज रिटर्न कैरेक्टर से मेल खाता है।
    * `\t` एक टैब कैरेक्टर से मेल खाता है।

10. **`|` (पाइप प्रतीक):** एक "OR" ऑपरेटर के रूप में कार्य करता है, या तो पाइप से पहले वाले एक्सप्रेशन या बाद वाले एक्सप्रेशन से मेल खाता है।
    * `cat|dog` या तो "cat" या "dog" से मेल खाएगा।

11. **`()` (कोष्ठक):**
    * **ग्रुपिंग:** regex के भागों को एक साथ समूहित करता है, आपको पूरे समूह पर क्वांटिफायर्स या OR ऑपरेटर लागू करने की अनुमति देता है।
        * `(ab)+c` "abc", "ababc", "abababc", इत्यादि से मेल खाएगा।
        * `(cat|dog) food` "cat food" या "dog food" से मेल खाएगा।
    * **कैप्चरिंग ग्रुप:** कोष्ठक के अंदर के एक्सप्रेशन से मेल खाए गए टेक्स्ट को कैप्चर करता है। इन कैप्चर किए गए समूहों को बाद में संदर्भित किया जा सकता है (जैसे, प्रतिस्थापन या निष्कर्षण के लिए)।

**II. क्वांटिफायर्स: पुनरावृत्ति को नियंत्रित करना**

क्वांटिफायर्स निर्दिष्ट करते हैं कि एक पूर्ववर्ती तत्व (वर्ण, समूह, या कैरेक्टर सेट) कितनी बार घटित हो सकता है।

* `*`: शून्य या अधिक बार
* `+`: एक या अधिक बार
* `?`: शून्य या एक बार
* `{n}`: ठीक `n` बार
* `{n,}`: `n` या अधिक बार
* `{n,m}`: `n` और `m` बार के बीच (सम्मिलित)

**ग्रीडी बनाम नॉन-ग्रीडी मिलान (Greedy vs. Non-Greedy Matching):**

डिफ़ॉल्ट रूप से, क्वांटिफायर्स **ग्रीडी** होते हैं, जिसका अर्थ है कि वे स्ट्रिंग के अधिक से अधिक हिस्से से मेल खाने का प्रयास करते हैं। आप किसी क्वांटिफायर के बाद `?` जोड़कर उसे **नॉन-ग्रीडी** (या लेज़ी) बना सकते हैं। नॉन-ग्रीडी क्वांटिफायर सबसे छोटी संभव स्ट्रिंग से मेल खाने का प्रयास करते हैं।

* `a.*b` (ग्रीडी) "axxbxb" पर "axxbxb" से मेल खाएगा।
* `a.*?b` (नॉन-ग्रीडी) "axxbxb" पर पहले "axb" और फिर "xb" से मेल खाएगा।

**III. एंकर्स: स्थिति निर्दिष्ट करना**

एंकर्स स्वयं किसी वर्ण से मेल नहीं खाते हैं, बल्कि स्ट्रिंग के भीतर एक स्थिति की पुष्टि करते हैं।

* `^`: स्ट्रिंग (या लाइन) की शुरुआत से मेल खाता है।
* `$`: स्ट्रिंग (या लाइन) के अंत से मेल खाता है।
* `\b`: एक वर्ड बाउंडरी से मेल खाता है।
* `\B`: एक गैर-वर्ड बाउंडरी से मेल खाता है।

**IV. कैरेक्टर क्लासेस: पूर्वनिर्धारित सेट**

कैरेक्टर क्लासेस आमतौर पर उपयोग किए जाने वाले वर्णों के सेट के लिए शॉर्टहैंड प्रदान करती हैं।

* `\d`: किसी भी अंक (0-9) से मेल खाता है।
* `\D`: किसी भी गैर-अंक वर्ण से मेल खाता है।
* `\s`: किसी भी व्हाइटस्पेस वर्ण (स्पेस, टैब, न्यूलाइन, कैरिज रिटर्न, फॉर्म फीड) से मेल खाता है।
* `\S`: किसी भी गैर-व्हाइटस्पेस वर्ण से मेल खाता है।
* `\w`: किसी भी वर्ड कैरेक्टर (अल्फ़ान्यूमेरिक और अंडरस्कोर: a-zA-Z0-9_) से मेल खाता है।
* `\W`: किसी भी गैर-वर्ड कैरेक्टर से मेल खाता है।

**V. ग्रुपिंग और कैप्चरिंग**

कोष्ठक `()` दो मुख्य उद्देश्यों को पूरा करते हैं:

* **ग्रुपिंग:** आपको वर्णों के एक क्रम पर क्वांटिफायर्स या OR ऑपरेटर लागू करने की अनुमति देता है।
* **कैप्चरिंग:** एक कैप्चरिंग ग्रुप बनाता है, जो कोष्ठक के अंदर के एक्सप्रेशन से मेल खाए गए स्ट्रिंग के हिस्से को संग्रहीत करता है। इन कैप्चर किए गए समूहों को एक्सेस किया जा सकता है और बैकरेफरेंस या प्रतिस्थापन के लिए उपयोग किया जा सकता है।

**बैकरेफरेंस (Backreferences):**

आप एक ही regex के भीतर पहले कैप्चर किए गए समूहों को `\1`, `\2`, `\3`, इत्यादि का उपयोग करके वापस संदर्भित कर सकते हैं, जहां संख्या कैप्चरिंग ग्रुप के खुलने वाले कोष्ठक के क्रम से मेल खाती है।

* `(.)\1` किसी भी वर्ण के बाद उसी वर्ण से मेल खाएगा (जैसे, "aa", "bb", "11")।
* `(\w+) \1` एक शब्द के बाद एक स्पेस और फिर उसी शब्द से मेल खाएगा (जैसे, "hello hello")।

**नॉन-कैप्चरिंग ग्रुप (Non-Capturing Groups):**

यदि आपको कैप्चरिंग ग्रुप बनाए बिना regex के भागों को समूहित करने की आवश्यकता है, तो आप `(?:...)` का उपयोग कर सकते हैं। यह स्पष्टता या प्रदर्शन कारणों से उपयोगी है।

* `(?:ab)+c` "abc", "ababc", आदि से मेल खाएगा, लेकिन "ab" को कैप्चर नहीं करेगा।

**VI. लुकअराउंड्स: उपभोग के बिना अभिकथन**

लुकअराउंड ज़ीरो-विड्थ अभिकथन हैं जो स्ट्रिंग में वर्तमान स्थिति से पहले या बाद में एक पैटर्न की जाँच करते हैं, बिना मेल खाए गए लुकअराउंड भाग को समग्र मैच में शामिल किए।

* **पॉजिटिव लुकअहेड `(?=...)`:** अभिकथन करता है कि कोष्ठक के अंदर का पैटर्न वर्तमान स्थिति के बाद आना चाहिए।
    * `\w+(?=:)` कोलन के बाद आने वाले किसी भी शब्द से मेल खाएगा, लेकिन कोलन स्वयं मैच का हिस्सा नहीं होगा (जैसे, "name:" में, यह "name" से मेल खाएगा)।

* **नेगेटिव लुकअहेड `(?!...)`:** अभिकथन करता है कि कोष्ठक के अंदर का पैटर्न वर्तमान स्थिति के बाद *नहीं* आना चाहिए।
    * `\w+(?!:)` कोलन के बाद न आने वाले किसी भी शब्द से मेल खाएगा (जैसे, "name value" में, यह "name" और "value" से मेल खाएगा)।

* **पॉजिटिव लुकबिहाइंड `(?<=...)`:** अभिकथन करता है कि कोष्ठक के अंदर का पैटर्न वर्तमान स्थिति से पहले आना चाहिए। लुकबिहाइंड के अंदर के पैटर्न की एक फिक्स्ड विड्थ (निश्चित लंबाई) होनी चाहिए (कोई वेरिएबल क्वांटिफायर्स जैसे `*` या `+` नहीं)।
    * `(?<=\$)\d+` एक डॉलर चिह्न से पहले आने वाले एक या अधिक अंकों से मेल खाएगा, लेकिन डॉलर चिह्न स्वयं मैच का हिस्सा नहीं होगा (जैसे, "$100" में, यह "100" से मेल खाएगा)।

* **नेगेटिव लुकबिहाइंड `(?<!...)`:** अभिकथन करता है कि कोष्ठक के अंदर का पैटर्न वर्तमान स्थिति से पहले *नहीं* आना चाहिए। लुकबिहाइंड के अंदर के पैटर्न की एक फिक्स्ड विड्थ होनी चाहिए।
    * `(?<!\$)\d+` डॉलर चिह्न से पहले न आने वाले एक या अधिक अंकों से मेल खाएगा (जैसे, "100$" में, यह "100" से मेल खाएगा)।

**VII. फ्लैग्स (मॉडिफायर्स): Regex व्यवहार को नियंत्रित करना**

फ्लैग्स (या मॉडिफायर्स) का उपयोग रेगुलर एक्सप्रेशन इंजन के व्यवहार को बदलने के लिए किया जाता है। इन्हें आमतौर पर कार्यान्वयन के आधार पर regex पैटर्न की शुरुआत या अंत में निर्दिष्ट किया जाता है। सामान्य फ्लैग्स में शामिल हैं:

* **`i` (केस-इनसेंसिटिव):** मिलान को केस-इनसेंसिटिव बनाता है। `[a-z]` लोअरकेस और अपरकेस दोनों अक्षरों से मेल खाएगा।
* **`g` (ग्लोबल):** स्ट्रिंग में सिर्फ पहला नहीं, बल्कि सभी मैच ढूंढता है।
* **`m` (मल्टीलाइन):** `^` और `$` को पूरी स्ट्रिंग की शुरुआत और अंत के बजाय प्रत्येक लाइन (`\n` या `\r` द्वारा सीमांकित) की शुरुआत और अंत से मेल कराता है।
* **`s` (डॉटऑल/सिंगल लाइन):** `.` मेटाकैरेक्टर को किसी भी वर्ण, जिसमें न्यूलाइन कैरेक्टर भी शामिल हैं, से मेल कराता है।
* **`u` (यूनिकोड):** कैरेक्टर क्लासेस और अन्य सुविधाओं के लिए पूर्ण यूनिकोड सपोर्ट सक्षम करता है।
* **`x` (एक्सटेंडेड/वर्बोज़):** पैटर्न के भीतर व्हाइटस्पेस और कमेंट्स को नजरअंदाज करके अधिक पठनीय regex लिखने की अनुमति देता है (जटिल regex के लिए उपयोगी)।

**VIII. Regex के व्यावहारिक अनुप्रयोग**

Regex का व्यापक रूप से विभिन्न क्षेत्रों में उपयोग किया जाता है:

* **टेक्स्ट एडिटर्स (जैसे, Notepad++, Sublime Text, VS Code):** पैटर्न के आधार पर टेक्स्ट ढूंढना और बदलना।
* **प्रोग्रामिंग भाषाएँ (जैसे, Python, JavaScript, Java, C#):**
    * उपयोगकर्ता इनपुट वैलिडेट करना (जैसे, ईमेल एड्रेस, फोन नंबर, URL)।
    * टेक्स्ट से विशिष्ट जानकारी निकालना (जैसे, तिथियाँ, नंबर, टैग)।
    * पैटर्न के आधार पर स्ट्रिंग के कुछ हिस्सों को बदलना।
    * लॉग फ़ाइलों या अन्य संरचित टेक्स्ट डेटा को पार्स करना।
* **कमांड-लाइन टूल्स (जैसे, `grep`, `sed`, `awk`):** टेक्स्ट फ़ाइलों को खोजना और उनमें हेरफेर करना।
* **वेब डेवलपमेंट:** फॉर्म वैलिडेशन, URL रूटिंग, कंटेंट प्रोसेसिंग।
* **डेटा साइंस:** डेटा क्लीनिंग, डेटा एक्सट्रैक्शन, पैटर्न रिकग्निशन।
* **सुरक्षा:** घुसपैठ का पता लगाना, लॉग विश्लेषण।

**IX. विभिन्न प्रोग्रामिंग भाषाओं में Regex**

अधिकांश आधुनिक प्रोग्रामिंग भाषाओं में रेगुलर एक्सप्रेशन के लिए अंतर्निहित सपोर्ट होता है, हालांकि विशिष्ट सिंटैक्स और सुविधाएँ थोड़ी भिन्न हो सकती हैं। आप आमतौर पर मानक लाइब्रेरी या मॉड्यूल में regex कार्यक्षमता पाएंगे।

* **Python:** `re` मॉड्यूल।
* **JavaScript:** अंतर्निहित `RegExp` ऑब्जेक्ट और स्ट्रिंग मेथड जैसे `match()`, `replace()`, `search()`, `split()`।
* **Java:** `java.util.regex` पैकेज।
* **C# (.NET):** `System.Text.RegularExpressions` नेमस्पेस।
* **PHP:** फ़ंक्शन जैसे `preg_match()`, `preg_replace()`, `preg_match_all()`।

**X. प्रभावी Regex लिखने के लिए सुझाव**

* **सरल शुरुआत करें:** एक बुनियादी पैटर्न से शुरुआत करें और धीरे-धीरे जटिलता जोड़ें।
* **बार-बार परीक्षण करें:** सैंपल डेटा के खिलाफ अपने पैटर्न का परीक्षण करने के लिए ऑनलाइन regex टेस्टर या अपनी प्रोग्रामिंग भाषा के regex टूल्स का उपयोग करें।
* **विशिष्ट बनें:** अत्यधिक व्यापक पैटर्न से बचें जो अनचाहे टेक्स्ट से मेल खा सकते हैं।
* **कैरेक्टर क्लासेस और क्वांटिफायर्स का बुद्धिमानी से उपयोग करें:** वे शक्तिशाली हैं लेकिन गलत तरीके से उपयोग किए जाने पर अप्रत्याशित व्यवहार भी पैदा कर सकते हैं।
* **ग्रीडी बनाम नॉन-ग्रीडी मिलान को समझें:** अपनी आवश्यकताओं के लिए उपयुक्त व्यवहार चुनें।
* **ग्रुपिंग और कैप्चरिंग का विवेकपूर्ण उपयोग करें:** केवल वही कैप्चर करें जिसकी आपको आवश्यकता है। जब कैप्चरिंग आवश्यक न हो तो नॉन-कैप्चरिंग ग्रुप का उपयोग करें।
* **अपने Regex को डॉक्यूमेंट करें:** जटिल पैटर्न के लिए, उनके उद्देश्य की व्याख्या करने के लिए कमेंट्स जोड़ें (विशेष रूप से `x` फ्लैग का उपयोग करते समय)।
* **एज केस पर विचार करें:** इनपुट टेक्स्ट के विभिन्न रूपों के बारे में सोचें और सुनिश्चित करें कि आपका regex उन्हें सही ढंग से हैंडल करता है।
* **जटिल समस्याओं को तोड़ें:** यदि आपके पास बहुत जटिल मिलान कार्य है, तो इसे कई सरल regex पैटर्न में तोड़ने पर विचार करें।

**XI. सीखने के संसाधन**

* **ऑनलाइन Regex टेस्टर:** regex101.com, regexr.com, regextester.com
* **भाषा-विशिष्ट डॉक्यूमेंटेशन:** अपनी चुनी हुई प्रोग्रामिंग भाषा के regex डॉक्यूमेंटेशन देखें।
* **ऑनलाइन ट्यूटोरियल और कोर्स:** प्लेटफॉर्म जैसे Coursera, Udemy, और YouTube व्यापक regex कोर्स प्रदान करते हैं।
* **किताबें:** "Mastering Regular Expressions" जेफ्री फ्रीडल द्वारा एक अत्यधिक अनुशंसित संसाधन है।

**निष्कर्ष**

रेगुलर एक्सप्रेशन टेक्स्ट डेटा के साथ काम करने वाले किसी भी व्यक्ति के लिए एक अनिवार्य उपकरण हैं। हालांकि प्रारंभिक सीखने की अवस्था खड़ी लग सकती है, लेकिन जटिल पैटर्न के आधार पर टेक्स्ट को कुशलतापूर्वक खोजने, उसमें हेरफेर करने और उसे वैलिडेट करने की क्षमता एक मूल्यवान कौशल है। regex की मौलिक अवधारणाओं, मेटाकैरेक्टर्स, क्वांटिफायर्स और अन्य सुविधाओं को समझकर, आप विभिन्न प्रकार के अनुप्रयोगों में अपनी उत्पादकता और समस्या-समाधान क्षमताओं में काफी वृद्धि कर सकते हैं। regex में महारत हासिल करने के लिए अभ्यास महत्वपूर्ण है, इसलिए विभिन्न टेक्स्ट प्रोसेसिंग कार्यों के लिए विभिन्न पैटर्न के साथ प्रयोग और अन्वेषण करने में संकोच न करें।