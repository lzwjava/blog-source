---
audio: false
generated: true
image: false
lang: hi
layout: post
model: openai/gpt-5
title: ३x३ मैट्रिक्स का व्युत्क्रम
translated: true
type: note
---

ज़रूर — आइए इसे स्पष्ट और सहज तरीके से समझते हैं, बिना किसी टेबल फॉर्मेटिंग के ताकि इसे लाइन दर लाइन आसानी से पढ़ा जा सके।

---

### 1. लक्ष्य क्या है  
हम एक 3×3 मैट्रिक्स का व्युत्क्रम (inverse) ढूंढना चाहते हैं, जिसे आमतौर पर A⁻¹ लिखा जाता है।  
व्युत्क्रम वह मैट्रिक्स है जो A के प्रभाव को "पलट" देता है, यानी  
A × A⁻¹ = I,  
जहाँ I इकाई मैट्रिक्स (identity matrix) है।

---

### 2. मुख्य सूत्र  
किसी भी व्युत्क्रमणीय वर्ग मैट्रिक्स के लिए सामान्य सूत्र है  

A⁻¹ = (1 / det(A)) × adj(A).

इसलिए हमें दो चीजों की आवश्यकता है:  
- सारणिक (determinant) det(A), और  
- सहखंडज मैट्रिक्स (adjugate matrix) adj(A), जो कि कोफैक्टर मैट्रिक्स का ट्रांसपोज़ (transpose) होता है।

---

### 3. 3×3 मैट्रिक्स का सारणिक  
यदि  
A =  
[a  b  c]  
[d  e  f]  
[g  h  i],  

तो  

det(A) = a(ei − fh) − b(di − fg) + c(dh − eg).

यह मान बताता है कि क्या मैट्रिक्स व्युत्क्रमणीय है:  
- यदि det(A) = 0 → कोई व्युत्क्रम नहीं (मैट्रिक्स विशेष या singular है),  
- यदि det(A) ≠ 0 → व्युत्क्रम मौजूद है।

---

### 4. कोफैक्टर  
adj(A) बनाने के लिए, हम पहले प्रत्येक अवयव का कोफैक्टर ढूंढते हैं।  
अवयव aᵢⱼ का कोफैक्टर है  
Cᵢⱼ = (−1)^(i+j) × Mᵢⱼ,  
जहाँ Mᵢⱼ उस 2×2 उप-मैट्रिक्स (submatrix) का सारणिक है जो पंक्ति i और स्तंभ j को हटाने के बाद बचता है।

इस प्रक्रिया को सभी नौ स्थितियों के लिए करने पर "कोफैक्टर मैट्रिक्स" प्राप्त होता है।  
ऊपर दिए गए सामान्य मामले के लिए:  

C₁₁ = ei − fh  
C₁₂ = −(di − fg)  
C₁₃ = dh − eg  

C₂₁ = −(bi − ch)  
C₂₂ = ai − cg  
C₂₃ = −(ah − bg)  

C₃₁ = bf − ce  
C₃₂ = −(af − cd)  
C₃₃ = ae − bd  

---

### 5. कोफैक्टर मैट्रिक्स का ट्रांसपोज़ करना  
अब उस कोफैक्टर मैट्रिक्स को लें और उसका ट्रांसपोज़ करें — यानी पंक्तियों और स्तंभों को आपस में बदल दें।  
यह नया मैट्रिक्स A का **सहखंडज (adjugate)** कहलाता है, जिसे adj(A) लिखा जाता है।  
यदि आप इसे दृष्टिगत रूप से देखें, तो यह "ट्रांसपोज़" मैट्रिक्स को घुमाने जैसा है: जो पहली पंक्ति में था वह पहले स्तंभ में आ जाता है, और इसी तरह आगे।

---

### 6. 1/det(A) से गुणा करना  
अंत में, adjugate मैट्रिक्स के प्रत्येक पद को det(A) से विभाजित करके स्केल करें।  
इससे आपको A⁻¹ प्राप्त होता है।

प्रतीकात्मक रूप से:  
A⁻¹ = (1/det(A)) × adj(A).

---

### 7. यह क्यों काम करता है  
यह सूत्र सारणिकों और कोफैक्टर्स के एक मौलिक गुण से आता है:  

A × adj(A) = det(A) × I.

यदि आप दोनों पक्षों को det(A) से विभाजित करते हैं, तो आपको बिल्कुल यह मिलता है  
A × [(1/det(A)) × adj(A)] = I.

इसलिए दायाँ पक्ष वाला गुणनखंड ही व्युत्क्रम होना चाहिए।

यह पहचान क्यों सही रहती है, इसका कारण यह है कि जब आप A को उसके कोफैक्टर मैट्रिक्स से गुणा करते हैं, तो प्रत्येक विकर्ण पद (diagonal term) स्वयं सारणिक बन जाता है (क्योंकि यह उस पंक्ति के साथ विस्तार होता है), और प्रत्येक गैर-विकर्ण पद (off-diagonal term) वैकल्पिक कोफैक्टर चिह्नों के कारण शून्य हो जाता है — यह बीजगणितीय रद्दीकरण (algebraic cancellation) का काम है।

---

### 8. उदाहरण  
मान लीजिए  
A =  
[1  2  3]  
[0  1  4]  
[5  6  0].

det(A) की गणना करें:  
= 1(1×0 − 4×6) − 2(0×0 − 4×5) + 3(0×6 − 1×5)  
= (−24) − (−40) + (−15)  
= −24 + 40 − 15 = 1.

इसलिए det(A) = 1.

फिर सभी कोफैक्टर्स को ढूंढें (थोड़ा थकाऊ, लेकिन सीधा), उनका ट्रांसपोज़ करके adj(A) प्राप्त करें, और चूंकि det(A) = 1 है, इसलिए adjugate ही पहले से ही व्युत्क्रम है।

---

### 9. सारांश और अंतर्ज्ञान  
- सारणिक → एक माप है कि मैट्रिक्स "स्पेस को कैसे स्केल करता है"।  
- कोफैक्टर → उस स्केलिंग में प्रत्येक अवयव के योगदान को दर्शाता है।  
- ट्रांसपोज़ करना → उन योगदानों को इस तरह संरेखित करता है कि गुणा करने पर पहचान मैट्रिक्स (identity matrix) पुनर्निर्मित हो जाए।  
- सारणिक से विभाजित करना → स्केलिंग को सामान्य करता है।

---

क्या आप चाहेंगे कि मैं उस उदाहरण ([1 2 3; 0 1 4; 5 6 0]) के लिए विस्तृत कोफैक्टर गणनाएँ दिखाऊं ताकि आप हर माइनर (minor) और चिह्न को देख सकें?