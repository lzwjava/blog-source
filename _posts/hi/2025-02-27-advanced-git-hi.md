---
audio: false
generated: true
lang: hi
layout: post
title: उन्नत गिट कमांड्स
translated: true
type: note
---

Git डेवलपर्स के लिए एक स्विस आर्मी चाकू की तरह है—बहुमुखी, शक्तिशाली, और कभी-कभी भ्रमित करने वाला अगर आपको नहीं पता कि कौन सा टूल निकालना है। आज, हम Git की कुछ बेहतरीन विशेषताओं और वर्कफ़्लोज़ पर गहराई से नज़र डालेंगे: चेंजेज़ को चेरी-पिक करना, स्टाइल के साथ मर्ज करना, क्लीनर हिस्ट्री के लिए रीबेसिंग, उन बड़ी फ़ाइलों को डिलीट करना जिन्हें आपने गलती से कमिट कर दिया, और कमिट को अनडू करना जब आपको एहसास हो कि आपने गलती कर दी है। आइए इसे समझते हैं।

#### चेरी-पिकिंग: सिर्फ वही लेना जो चाहिए
कल्पना कीजिए कि आपके पास एक फीचर ब्रांच है जिसमें एक दर्जन कमिट हैं, लेकिन उसमें एक शानदार कमिट है जिसे आप निकालकर अपनी मुख्य ब्रांच पर लगाना चाहते हैं—बाकी सब कुछ लिए बिना। यहीं पर `git cherry-pick` काम आता है।

यह बहुत सीधा है: कमिट हैश ढूंढें (आप इसे `git log` से ले सकते हैं), उस ब्रांच पर स्विच करें जहाँ आप इसे चाहते हैं, और रन करें:
```
git cherry-pick <commit-hash>
```
बूम, वह कमिट अब आपकी करंट ब्रांच का हिस्सा है। अगर कोई कॉन्फ्लिक्ट है, तो Git रुक जाएगा और आपको उसे रिज़ॉल्व करने देगा, बिल्कुल मर्ज की तरह। एक बार जब आप संतुष्ट हो जाएं, तो चेंजेज़ को कमिट कर दें, और आपका काम हो गया।

मैं इसका इस्तेमाल तब करता हूं जब कोई बग फिक्स किसी मैसी फीचर ब्रांच में घुस जाता है, और मुझे उसे `main` पर ASAP चाहिए होता है। बस सावधान रहें—चेरी-पिकिंग कमिट की डुप्लिकेट कॉपी बनाती है, इसलिए उसे एक नया हैश मिलता है। अगर आप बाद में ओरिजिनल ब्रांच को बिना कुछ साफ किए मर्ज करते हैं, तो उसके सही काम करने की उम्मीद न करें।

#### मर्ज ऑप्शन: सिर्फ "मर्ज" से कहीं अधिक
मर्ज करना Git का मुख्य काम है, लेकिन क्या आप जानते हैं कि इसके अलग-अलग विकल्प हैं? डिफॉल्ट `git merge` अगर संभव हो तो एक "फास्ट-फॉरवर्ड" करता है (हिस्ट्री को सीधा करता है) या अगर ब्रांचेज़ अलग हो गई हों तो एक मर्ज कमिट बनाता है। लेकिन आपके पास विकल्प हैं:

- **`--no-ff` (नो फास्ट-फॉरवर्ड)**: अगर फास्ट-फॉरवर्ड संभव भी हो तो भी एक मर्ज कमिट को फोर्स करता है। मैं इसे इसलिए पसंद करता हूं क्योंकि इससे `main` पर फीचर ब्रांच के मर्ज होने का एक स्पष्ट रिकॉर्ड रहता है। इसे इस तरह रन करें:
  ```
  git merge --no-ff feature-branch
  ```
- **`--squash`**: ब्रांच के सारे चेंजेज़ को आपकी करंट ब्रांच पर एक ही कमिट में ले आता है। कोई मर्ज कमिट नहीं, बस एक साफ-सुथरा पैकेज। किसी मैसी ब्रांच को प्रेजेंटेबल बनाने के लिए परफेक्ट:
  ```
  git merge --squash feature-branch
  ```
  इसके बाद, डील को फाइनल करने के लिए आपको मैन्युअली कमिट करना होगा।

हर एक की अपनी जगह है। मैं लॉन्ग-लिव्ड ब्रांचेज़ के लिए `--no-ff` और "WIP" कमिट्स से भरी ब्रांचेज़ के लिए `--squash` का इस्तेमाल करता हूं जिन्हें मैं भूल जाना चाहता हूं।

#### रीबेसिंग: एक प्रो की तरह हिस्ट्री को रीराइट करना
अगर मर्ज आपको बहुत अव्यवस्थित लगते हैं, तो `git rebase` आपके लिए हो सकता है। यह आपकी कमिट्स को लेता है और उन्हें किसी दूसरी ब्रांच पर दोबारा चलाता (रिप्ले) है, जिससे आपको एक लीनियर हिस्ट्री मिलती है जो ऐसी लगती है कि आपने शुरू से ही सब कुछ परफेक्ट प्लान किया था।

अपनी फीचर ब्रांच पर स्विच करें और रन करें:
```
git rebase main
```
Git आपकी कमिट्स को हटा देगा, ब्रांच को `main` के अनुरूप अपडेट करेगा, और आपके चेंजेज़ को वापस सबसे ऊपर लगा देगा। अगर कोई कॉन्फ्लिक्ट आता है, तो उन्हें रिज़ॉल्व करें, फिर `git rebase --continue` करें जब तक कि यह पूरा न हो जाए।

फायदा? एक साफ-सुथरी टाइमलाइन। नुकसान? अगर आपने उस ब्रांच को पहले ही पुश कर दिया है और दूसरे लोग उस पर काम कर रहे हैं, तो रीबेसिंग हिस्ट्री को रीराइट कर देती है—जिससे आपके टीममेट्स के गुस्से भरे ईमेल आ सकते हैं। मैं रीबेसिंग का इस्तेमाल सिर्फ लोकल ब्रांचेज़ या सोलो प्रोजेक्ट्स के लिए करता हूं। शेयर्ड चीजों के लिए, मर्ज करना ज्यादा सुरक्षित है।

#### हिस्ट्री से बड़ी फाइलें डिलीट करना: ऊप्स, वह 2GB की वीडियो फाइल
हम सभी के साथ ऐसा हो चुका है: आप गलती से एक बहुत बड़ी फाइल कमिट कर देते हैं, उसे पुश कर देते हैं, और अब आपकी रेपो फूल गई है। Git आसानी से नहीं भूलता, लेकिन आप कुछ मेहनत करके उस फाइल को हिस्ट्री से हटा सकते हैं।

यहां मुख्य टूल `git filter-branch` या नया `git filter-repo` है (मैं बाद वाले की सलाह देता हूं—यह तेज और कम एरर-प्रोन है)। मान लीजिए आपने `bigfile.zip` कमिट कर दी है और उसे हटाना चाहते हैं:
1. `git-filter-repo` इंस्टॉल करें (सेटअप के लिए इसके डॉक्स चेक करें)।
2. रन करें:
   ```
   git filter-repo --path bigfile.zip --invert-paths
   ```
   यह हर कमिट से `bigfile.zip` को हटा देता है।
3. रीराइट की गई हिस्ट्री को फोर्स-पुश करें:
   ```
   git push --force
   ```

सावधानी: यह हिस्ट्री को रीराइट करता है, इसलिए अपनी टीम के साथ कोऑर्डिनेट करें। और अगर यह कहीं पुल रिक्वेस्ट में है, तो आपको रेफ्स को भी क्लीन अप करना पड़ सकता है। एक बार यह हट जाने के बाद, गार्बेज कलेक्शन (`git gc`) के बाद आपकी रेपो सिकुड़ जाएगी।

#### अनकमिटिंग: समय को पीछे ले जाना
कमिट किया और तुरंत पछतावा हुआ? Git आपकी मदद करेगा। इसे अनडू करने के कुछ तरीके हैं, यह इस बात पर निर्भर करता है कि आप कितना आगे बढ़ चुके हैं:

- **अगर आपने अभी तक पुश नहीं किया है**: `git reset` का उपयोग करें। आखिरी कमिट को अनडू करने के लिए लेकिन चेंजेज़ को वर्किंग डायरेक्टरी में रखने के लिए:
  ```
  git reset HEAD^ --soft
  ```
  क्या चेंजेज़ को पूरी तरह हटाना चाहते हैं?
  ```
  git reset HEAD^ --hard
  ```
- **अगर आप पहले ही पुश कर चुके हैं**: आपको हिस्ट्री को रीराइट करना होगा। लोकली `git reset HEAD^` से रीसेट करें, फिर फोर्स-पुश करें:
  ```
  git push --force
  ```
  फिर से, यह शेयर्ड हिस्ट्री के साथ छेड़छाड़ करता है, इसलिए सावधानी से आगे बढ़ें।

मैंने `git reset --soft` से खुद को कई बार बचाया है—यह तब परफेक्ट है जब आप जल्दबाजी में कमिट कर देते हैं और कुछ ट्वीक करने की जरूरत होती है।

#### समापन

Git की लचीलापन ही इसे इतना शक्तिशाली बनाती है, लेकिन अगर आप अपने विकल्पों को नहीं जानते हैं तो उलझना आसान है। सर्जिकल प्रिसिजन के लिए चेरी-पिक करें, अपने वर्कफ़्लो के अनुरूप मर्ज को ट्वीक करें, पॉलिश्ड हिस्ट्री के लिए रीबेस करें, और गलती मिटाने की जरूरत पड़ने पर घबराएं नहीं—चाहे वह कोई बहुत बड़ी फाइल हो या कोई जल्दबाजी की हुई कमिट। अगर आप नर्वस हैं तो इन्हें किसी टेस्ट रेपो पर प्रैक्टिस करें, और जल्द ही ये आपकी आदत बन जाएंगी।

आपकी पसंदीदा Git ट्रिक क्या है? मुझे बताएं—मैं हमेशा कुछ नया सीखने के लिए तैयार रहता हूं!