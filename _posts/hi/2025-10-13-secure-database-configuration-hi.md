---
audio: false
generated: true
image: false
lang: hi
layout: post
model: x-ai/grok-4-fast
title: सुरक्षित डेटाबेस कॉन्फ़िगरेशन रणनीतियाँ
translated: true
type: note
---

### पायथन प्रोजेक्ट्स में संवेदनशील डेटाबेस कॉन्फ़िगरेशन को हैंडल करना

कॉन्फ़िगरेशन फ़ाइलों में डेटाबेस पासवर्ड और पोर्ट जैसी संवेदनशील जानकारी को प्रबंधित करना पायथन प्रोजेक्ट्स में एक आम चुनौती है। लक्ष्य वर्जन कंट्रोल (जैसे Git) में सीक्रेट्स को कमिट करने से बचना है, साथ ही डेप्लॉयमेंट को सीधा-सादा रखना है। नीचे, मैं आपके द्वारा बताए गए दोनों तरीकों की तुलना करूंगा: (1) वास्तविक फ़ाइल के लिए `.gitignore` के साथ एक टेम्प्लेट `config_example.ini` का उपयोग करना, और UAT जैसे सर्वर पर मैन्युअल सेटअप; और (2) `config.ini` में एन्क्रिप्टेड वैल्यूज़ को स्टोर करने और रनटाइम पर उन्हें डिक्रिप्ट करने के लिए GPG एन्क्रिप्शन का उपयोग करना। दोनों ही सही तरीके से लागू किए जाने पर सुरक्षित हैं, लेकिन वे सरलता के बदले ऑटोमेशन का ट्रेड-ऑफ करते हैं।

#### तरीका 1: टेम्प्लेट कॉन्फ़िग + `.gitignore` + मैन्युअल सर्वर सेटअप
यह एक सीधा-सादा, कम-तकनीक वाला तरीका है। आप डेवलपर्स और CI/CD पाइपलाइनों के लिए एक सैंपल कॉन्फ़िग फ़ाइल बनाते हैं, वास्तविक फ़ाइल को Git में इग्नोर करते हैं, और प्रोडक्शन-जैसे वातावरण (जैसे UAT सर्वर) पर वास्तविक कॉन्फ़िग को मैन्युअली हैंडल करते हैं।

**लागू करने के चरण:**
1. प्लेसहोल्डर्स के साथ `config_example.ini` बनाएं:
   ```
   [database]
   host = localhost
   port = 5432  # उदाहरण पोर्ट; वास्तविक पोर्ट से बदलें
   user = dbuser
   password = example_password  # वास्तविक पासवर्ड से बदलें
   database = mydb
   ```

2. वास्तविक `config.ini` को `.gitignore` में जोड़ें:
   ```
   config.ini
   ```

3. अपने पायथन कोड में, `config.ini` से लोड करें (डेव के लिए गायब होने पर उदाहरण फ़ाइल का उपयोग करें):
   ```python
   import configparser
   import os

   config = configparser.ConfigParser()
   config_file = 'config.ini' if os.path.exists('config.ini') else 'config_example.ini'
   config.read(config_file)

   db_host = config['database']['host']
   db_port = config['database']['port']
   db_user = config['database']['user']
   db_password = config['database']['password']
   db_name = config['database']['database']
   ```

4. UAT सर्वर के लिए: वास्तविक वैल्यूज़ के साथ `config.ini` को मैन्युअली कॉपी करें (जैसे, SCP या Ansible के माध्यम से)। डेवलपर्स `config_example.ini` को `config.ini` में कॉपी करके स्थानीय रूप से भर सकते हैं।

**फायदे:**
- सरल—कोई अतिरिक्त लाइब्रेरी या कुंजी प्रबंधन नहीं।
- कोई रनटाइम ओवरहेड (डिक्रिप्शन) नहीं।
- छोटी टीमों के लिए आसान; मैन्युअल डेप्लॉयमेंट के साथ अच्छी तरह काम करता है।

**नुकसान:**
- प्रत्येक सर्वर पर मैन्युअल सेटअप से त्रुटि का जोखिम बढ़ता है (जैसे, पासवर्ड अपडेट करना भूल जाना)।
- ऑटोमेटेड CI/CD के लिए आदर्श नहीं; सिक्योर सीक्रेट इंजेक्शन की आवश्यकता होती है (जैसे, पाइपलाइनों में एनवायरनमेंट वेरिएबल्स के माध्यम से)।
- अगर कोई गलती से `config.ini` को कमिट कर दे, तो सीक्रेट्स एक्सपोज हो जाते हैं।

यह तरीका शुरुआती चरण के प्रोजेक्ट्स या जब एन्क्रिप्शन ज़रूरत से ज़्यादा लगे, उसके लिए बढ़िया है।

#### तरीका 2: कॉन्फ़िग वैल्यूज़ के लिए GPG एन्क्रिप्शन
यहां, आप संवेदनशील फ़ील्ड्स (जैसे, पासवर्ड) को GPG का उपयोग करके एन्क्रिप्ट करते हैं, एन्क्रिप्टेड ब्लॉब को `config.ini` में स्टोर करते हैं, और अपने कोड में रनटाइम पर इसे डिक्रिप्ट करते हैं। एन्क्रिप्टेड फ़ाइल को Git में सुरक्षित रूप से कमिट किया जा सकता है, जब तक आपकी प्राइवेट की शेयर नहीं की जाती।

**लागू करने के चरण:**
1. अपने सिस्टम पर GPG इंस्टॉल करें (यह Linux/Mac पर स्टैंडर्ड है; Windows पर Gpg4win का उपयोग करें)। अगर ज़रूरत हो तो एक की पेयर जनरेट करें:
   ```
   gpg --gen-key  # अपनी कुंजी के लिए प्रॉम्प्ट का पालन करें
   ```

2. संवेदनशील वैल्यू (जैसे, पासवर्ड) को एक फ़ाइल में एन्क्रिप्ट करें:
   ```
   echo "real_password_here" | gpg --encrypt --recipient your-email@example.com -o encrypted_password.gpg
   ```
   - यह `encrypted_password.gpg` बनाता है। आप इसे INI में आसान स्टोरेज के लिए base64-encode कर सकते हैं:
     ```bash
     base64 encrypted_password.gpg > encrypted_password.b64
     ```

3. एन्क्रिप्टेड (और base64-encoded) वैल्यू को शामिल करने के लिए `config.ini` अपडेट करें। इसे कमिट करें—यह सुरक्षित है:
   ```
   [database]
   host = localhost
   port = 5432
   user = dbuser
   password_encrypted = <base64-encoded-encrypted-blob-here>  # encrypted_password.b64 से
   database = mydb
   ```

4. अपने पायथन कोड में, `gnupg` लाइब्रेरी का उपयोग करके डिक्रिप्ट करें (डेव के लिए `pip install python-gnupg` के माध्यम से इंस्टॉल करें, लेकिन मान लें कि यह उपलब्ध है):
   ```python
   import configparser
   import gnupg
   import base64
   import tempfile
   import os

   config = configparser.ConfigParser()
   config.read('config.ini')  # इसे सुरक्षित रूप से कमिट कर सकते हैं

   # पासवर्ड डिक्रिप्ट करें
   gpg = gnupg.GPG()  # मानता है कि GPG इंस्टॉल है और कुंजी उपलब्ध है
   encrypted_b64 = config['database']['password_encrypted']
   encrypted_data = base64.b64decode(encrypted_b64)

   with tempfile.NamedTemporaryFile(delete=False) as tmp:
       tmp.write(encrypted_data)
       tmp.flush()
       decrypted = gpg.decrypt_file(None, passphrase=None, extra_args=['--batch', '--yes'], output=tmp.name)
       if decrypted.ok:
           db_password = decrypted.data.decode('utf-8').strip()
       else:
           raise ValueError("डिक्रिप्शन विफल")

   os.unlink(tmp.name)  # सफाई

   db_host = config['database']['host']
   db_port = config['database']['port']
   db_user = config['database']['user']
   db_name = config['database']['database']

   # अब db_password का उपयोग करें...
   ```

5. UAT सर्वर के लिए: `config.ini` को यथावत डेप्लॉय करें (Git या कॉपी के माध्यम से)। सुनिश्चित करें कि GPG प्राइवेट की सर्वर पर सुरक्षित रूप से रखी गई है (जैसे, Ansible वॉल्ट या मैन्युअल सिक्योर कॉपी के माध्यम से)। कोड स्टार्टअप पर डिक्रिप्ट करेगा।

**फायदे:**
- एन्क्रिप्टेड कॉन्फ़िग को वर्जन कंट्रोल किया जा सकता है—सीक्रेट्स के लिए `.gitignore` की आवश्यकता नहीं।
- डेप्लॉयमेंट को ऑटोमेट करता है; CI/CD के साथ काम करता है (बस कुंजी को सुरक्षित रूप से सिंक करना होता है)।
- ऑडिटेबल: एन्क्रिप्टेड वैल्यूज़ में परिवर्तन ट्रैक किए जाते हैं।

**नुकसान:**
- GPG सेटअप और की मैनेजमेंट की आवश्यकता होती है (जैसे, कुंजियों को समय-समय पर रोटेट करें; प्राइवेट कीज़ को कभी कमिट न करें)।
- GPG और `python-gnupg` पर रनटाइम डिपेंडेंसी; अगर कुंजी गायब है तो डिक्रिप्शन विफल हो जाता है।
- शुरुआती लोगों के लिए थोड़ा अधिक जटिल; डिक्रिप्ट पर संभावित परफॉर्मेंस हिट (पासवर्ड के लिए नगण्य)।

इसका उपयोग ऑटोमेटेड डेप्लॉयमेंट वाली टीमों या वातावरणों में कॉन्फ़िग शेयर करने के लिए करें।

#### तुलना तालिका

| पहलू              | टेम्प्लेट + .gitignore + मैन्युअल | GPG एन्क्रिप्शन + रनटाइम डिक्रिप्ट |
|---------------------|--------------------------------|----------------------------------|
| **सुरक्षा**       | उच्च अगर मैन्युअल कदम सावधानी से उठाए जाएं; मानवीय त्रुटि का जोखिम। | उच्च; सीक्रेट्स कभी प्लेन टेक्स्ट में नहीं। |
| **सेटअप में आसानी**  | बहुत आसान (किसी टूल की आवश्यकता नहीं)।  | मध्यम (GPG + लाइब्रेरी)।       |
| **वर्जन कंट्रोल**| टेम्प्लेट कमिट किया गया; वास्तविक फ़ाइल इग्नोर की गई। | पूरी कॉन्फ़िग कमिट की गई (एन्क्रिप्टेड)। |
| **डेप्लॉयमेंट**     | प्रति सर्वर मैन्युअल (जैसे, SCP)।| ऑटोमेटेड (कुंजी सिंक की आवश्यकता)।    |
| **ओवरहेड**       | कोई नहीं।                         | मामूली (लोड पर डिक्रिप्ट)।        |
| **सर्वोत्तम किसके लिए**       | छोटे/मैन्युअल प्रोजेक्ट्स।        | ऑटोमेटेड/CI/CD पाइपलाइनें।      |

#### सिफारिशें
- **तरीका 1** से शुरुआत करें अगर आपका प्रोजेक्ट सरल है या टीम छोटी है—यह परखा हुआ तरीका है।
- स्केलिंग के लिए **तरीका 2** (या env vars/सीक्रेट्स मैनेजर जैसे AWS SSM/HashiCorp Vault की ओर विकसित) पर स्विच करें।
- हमेशा ओवरराइड्स के लिए env vars के साथ संयोजन करें (जैसे, `os.getenv('DB_PASSWORD', db_password)`)।
- UAT से पहले एक स्टेजिंग वातावरण में डिक्रिप्शन का परीक्षण करें।

अगर आप और विवरण साझा करते हैं (जैसे, आपका डेप्लॉयमेंट टूल या पूरी कॉन्फ़िग), तो मैं कोड को परिष्कृत कर सकता हूं!