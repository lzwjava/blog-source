---
audio: false
generated: true
lang: hi
layout: post
title: शेल चेनिंग के साथ रस्ट वन-लाइनर
translated: true
type: note
---

आप अनुभवी डेवलपर्स की एक सामान्य इच्छा को उजागर कर रहे हैं, जो Python, Ruby, या JavaScript जैसी भाषाओं से आते हैं, जहां अक्सर सीधे एक स्क्रिप्ट चलाने के लिए एक ही कमांड होती है। Rust, जो एक कंपाइल्ड भाषा है, की डिफ़ॉल्ट रूप से थोड़ा अलग वर्कफ़्लो है।

हालाँकि, आप निश्चित रूप से, विशेष रूप से सरल स्क्रिप्ट्स या एक्सरसाइज के लिए, अपने शेल में कमांड्स को जोड़कर एक "वन-लाइनर" का अहसास प्राप्त कर सकते हैं।

### सीधा "वन-लाइनर" (शेल चेनिंग)

आपके पास पहले से ही घटक मौजूद हैं: कंपाइलेशन के लिए `rustc` और एक्सेक्यूशन के लिए `./`। आप उन्हें शेल ऑपरेटर्स का उपयोग करके जोड़ सकते हैं:

```bash
rustc scripts/rust/example.rs -o test/example && ./test/example
```

**व्याख्या:**

  * `rustc scripts/rust/example.rs -o test/example`: यह आपकी Rust फ़ाइल को कंपाइल करता है और एक्ज़ीक्यूटेबल को `test/example` पर रखता है।
  * `&&`: यह bash (और अधिकांश यूनिक्स-जैसे शेल्स) में एक **कंडीशनल कमांड सेपरेटर** है। `&&` के *बाद* वाला कमांड तभी एक्ज़ीक्यूट होगा यदि `&&` के *पहले* वाला कमांड सफलतापूर्वक पूरा हो जाता है (यानी, 0 का एक्ज़िट कोड लौटाता है)।
      * यदि `rustc` बिना एरर्स के कंपाइल हो जाता है, तो यह 0 लौटाएगा, और फिर `./test/example` रन करेगा।
      * यदि `rustc` को कंपाइलेशन एरर आती है, तो यह एक नॉन-ज़ीरो एक्ज़िट कोड लौटाएगा, और `./test/example` *नहीं* चलेगा। यह अच्छा व्यवहार है\!

### एक अधिक "स्क्रिप्ट-जैसे" अनुभव के लिए (Cargo)

जबकि उपरोक्त `&&` वाला तरीका क्विक टेस्ट के लिए अच्छा काम करता है, तुच्छ सिंगल-फ़ाइल स्क्रिप्ट्स से परे किसी भी चीज़ के लिए, Rust का `cargo` टूल अनुशंसित तरीका है, और यह एक प्रोजेक्ट के भीतर कोड चलाने के लिए *Python-जैसा* वन-लाइनर प्रदान *करता है*:

1.  **एक Cargo प्रोजेक्ट इनिशियलाइज़ करें (यदि आपने पहले से नहीं किया है):**
    यदि आपकी `scripts/rust/example.rs` सिर्फ एक स्टैंडअलोन फ़ाइल है, तो आप आम तौर पर इसके पैरेंट डायरेक्टरी (या एक नई समर्पित डायरेक्टरी) में एक Cargo प्रोजेक्ट बनाकर शुरुआत करेंगे।

    ```bash
    # उस डायरेक्टरी पर जाएँ जहाँ आप अपना प्रोजेक्ट चाहते हैं (जैसे, scripts/rust)
    cd scripts/rust

    # एक नया Cargo बाइनरी प्रोजेक्ट इनिशियलाइज़ करें
    cargo init --bin .
    ```

    यह `Cargo.toml` बनाएगा और आपकी `example.rs` को (यदि यह `main.rs` थी) ले जाएगा या `Cargo.toml` को एडजस्ट करेगा ताकि वह `src/` के अंदर `main.rs` बनने के बाद इसे पॉइंट करे।

2.  **Cargo के साथ रन करें:**
    एक बार जब आपके पास एक Cargo प्रोजेक्ट सेटअप हो जाता है, तो आप एक ही कमांड से कंपाइल और रन कर सकते हैं:

    ```bash
    # अपने प्रोजेक्ट रूट से (जैसे, scripts/rust यदि आपने वहाँ cargo init चलाया था)
    cargo run
    ```

    `cargo run` यह करेगा:

      * आपके कोड को कंपाइल करेगा (यदि इसे पहले कंपाइल नहीं किया गया है या बदलाव किए गए हैं)।
      * फिर, परिणामी बाइनरी को एक्ज़ीक्यूट करेगा।
      * डिफ़ॉल्ट रूप से, बाइनरी आपके प्रोजेक्ट के अंदर `target/debug/` में रखी जाती है, लेकिन आपको इसके विशिष्ट पथ की चिंता करने की ज़रूरत नहीं है।

**Cargo को प्राथमिकता क्यों दी जाती है:**

  * **डिपेंडेंसी मैनेजमेंट:** यदि आपके कोड को कभी एक्सटर्नल लाइब्रेरीज़ (crates) की आवश्यकता होती है, तो Cargo उन्हें फ़ेच करने, कंपाइल करने और लिंक करने का काम स्वचालित रूप से संभाल लेता है। आप उन्हें `Cargo.toml` में निर्दिष्ट करते हैं।
  * **स्टैंडर्ड प्रोजेक्ट स्ट्रक्चर:** यह एक सुसंगत लेआउट (`src/main.rs`, `Cargo.toml`) को प्रोत्साहित करता है, जो आपके कोड को दूसरों (और भविष्य के आप) के लिए समझने में आसान बनाता है।
  * **टेस्टिंग:** `cargo test` आपके यूनिट और इंटीग्रेशन टेस्ट चलाता है।
  * **रिलीज़ बिल्ड्स:** `cargo run --release` (या `cargo build --release`) प्रोडक्शन के लिए ऑप्टिमाइज़ेशन के साथ कंपाइल करता है।
  * **कोई मैन्युअल क्लीनअप नहीं:** आपको मैन्युअल रूप से कंपाइल की गई बाइनरीज़ को डिलीट नहीं करना पड़ता। `cargo clean` इसका ध्यान रखता है।

### Python के `python script.py` जैसा एक सच्चा "स्क्रिप्टिंग" दृष्टिकोण क्या है?

Rust को एक इंटरप्रेटेड स्क्रिप्टिंग भाषा के रूप में डिज़ाइन नहीं किया गया है। यह एक कंपाइल्ड सिस्टम्स लैंग्वेज है। इसलिए, आपको एक सीधा `rust script.rs` कमांड नहीं मिलेगा जो एक स्पष्ट कंपाइलेशन स्टेप के बिना कंपाइल और रन करता हो।

हालाँकि, क्विक, सिंगल-फ़ाइल Rust "स्क्रिप्ट्स" (हालाँकि वे अभी भीं कंपाइल हो रही हैं) के लिए इस अंतर को पाटने का प्रयास करने वाले कम्युनिटी टूल्स मौजूद हैं:

  * **`cargo-script`**: एक Cargo सबकमांड जो आपको सिंगल `.rs` फ़ाइलें चलाने की अनुमति देता है, और कमेंट्स के माध्यम से निर्दिष्ट डिपेंडेंसी को हैंडल करता है। आप आम तौर पर इसे `cargo install cargo-script` के साथ इंस्टॉल करते हैं। फिर आप संभावित रूप से `cargo script scripts/rust/example.rs` चला सकते हैं।
  * **`rust-script`**: Rust फ़ाइलों को सीधे स्क्रिप्ट्स की तरह चलाने के लिए एक और लोकप्रिय टूल। इसे `cargo install rust-script` के माध्यम से इंस्टॉल करें। फिर, आप अक्सर अपनी `.rs` फ़ाइल को एक्ज़ीक्यूटेबल बना सकते हैं (`chmod +x example.rs`) और इसे रन कर सकते हैं: `./example.rs`। यह बैकग्राउंड में कंपाइलेशन और एक्ज़ीक्यूशन को हैंडल करता है।

`example.rs` को जल्दी से टेस्ट करने के आपके उपयोग के मामले के लिए, `rustc ... && ./...` वन-लाइनर पूरी तरह से ठीक है और सीधे तौर पर दो कमांड्स को जोड़ने के आपके प्रश्न का उत्तर देता है। किसी भी नॉन-ट्रिवियल डेवलपमेंट के लिए, Cargo को अपनाना एक अधिक उत्पादक और इडियोमैटिक Rust अनुभव होगा।