---
audio: false
generated: true
image: false
lang: hi
layout: post
title: गिट डिफ-ट्री गाइड
translated: true
type: note
---

यहाँ `git diff-tree` की एक व्यावहारिक, एंड-टू-एंड गाइड है — यह क्या है, इसका उपयोग कब करें, और वे विकल्प जिनका आप वास्तविक काम में उपयोग करेंगे। मैं बड़ी टेबल्स से बचूंगा और कॉपी-पेस्ट करने योग्य उदाहरणों के साथ केंद्रित स्पष्टीकरण दूंगा।

# `git diff-tree` वास्तव में क्या करता है

* यह **ट्री ऑब्जेक्ट्स** की तुलना करता है। रोज़मर्रा के उपयोग में, इसका आमतौर पर मतलब होता है: "मुझे दिखाओ कि एक **कमिट** में इसके पैरेंट(s) की तुलना में क्या बदला।"
* यह एक **प्लंबिंग** (स्क्रिप्ट-फ्रेंडली) कमांड है, `git show`/`git log` के विपरीत जो पोर्सिलेन (मानव-उन्मुख) हैं।
* यह कभी भी आपके वर्किंग डायरेक्टरी को नहीं देखता; यह केवल रेपो में संग्रहीत ट्रीज़ (कमिट्स, टैग्स जो कमिट्स की ओर इशारा करते हैं, या रॉ ट्री आईडी) की तुलना करता है।

# आपके द्वारा उपयोग किए जाने वाले बेसिक फॉर्म

1.  एक कमिट की इसके पैरेंट के विरुद्ध तुलना करें

```bash
git diff-tree -p <commit>
```

यदि `<commit>` का एक पैरेंट है, तो आपको एक सामान्य पैच दिखेगा। यदि यह एक मर्ज कमिट है, तो आपको तब तक कुछ नहीं दिखेगा जब तक आप मर्ज के लिए नहीं कहते (नीचे देखें)।

2.  दो ट्री/कमिट्स की स्पष्ट रूप से तुलना करें

```bash
git diff-tree -p <old-tree-or-commit> <new-tree-or-commit>
```

बहुत अच्छा है जब आप किसी भी दो बिंदुओं की तुलना करना चाहते हैं, न कि केवल "कमिट बनाम पैरेंट"।

3.  केवल फ़ाइल नाम दिखाएं (कोई पैच नहीं)

```bash
git diff-tree --name-only -r <commit>
```

सबडायरेक्टरीज़ में रिकर्स करने के लिए `-r` जोड़ें ताकि आपको एक फ्लैट सूची मिले।

4.  परिवर्तन प्रकार के साथ नाम दिखाएं

```bash
git diff-tree --name-status -r <commit>
# आउटपुट लाइन्स इस प्रकार होगी:
# A path/to/newfile
# M path/to/modified
# D path/to/deleted
```

5.  एक पैच दिखाएं (पूरा डिफ)

```bash
git diff-tree -p <commit>            # यूनिफाइड डिफ जैसे `git show`
git diff-tree -U1 -p <commit>        # कम कॉन्टेक्स्ट (1 लाइन)
```

# जानने योग्य विकल्प (क्यों/कब के साथ)

* `-r` — सबट्रीज़ में रिकर्स करें ताकि आपको सभी नेस्टेड पाथ दिखें। इसके बिना, एक डायरेक्टरी जो बदली है, एक सिंगल लाइन के रूप में दिख सकती है।
* `--no-commit-id` — स्क्रिप्टिंग के दौरान प्रति-कमिट आउटपुट में "commit <sha>" हेडर को दबाएं।
* `--root` — जब किसी कमिट का **कोई पैरेंट नहीं** हो (इनिशियल कमिट), तब भी इसके परिवर्तन खाली ट्री की तुलना में दिखाएं।
* `-m` — मर्ज कमिट्स के लिए, **प्रत्येक पैरेंट के विरुद्ध** डिफ़्स दिखाएं (मल्टीपल डिफ़्स प्रोड्यूस करता है)।
* `-c` / `--cc` — कंबाइंड मर्ज डिफ। `--cc` एक परिष्कृत व्यू है (जो `git show` मर्ज के लिए उपयोग करता है)।
* `--name-only` / `--name-status` / `--stat` / `--numstat` — विभिन्न सारांश शैलियाँ। `--numstat` स्क्रिप्ट-फ्रेंडली है (जोड़ी/हटाई गई लाइन काउंट्स)।
* `--diff-filter=<set>` — परिवर्तन प्रकारों द्वारा फ़िल्टर करें, उदा. `--diff-filter=AM` (केवल एडेड या मॉडिफाइड); सामान्य अक्षर: `A`dd, `M`odified, `D`eleted, `R`enamed, `C`opied, `T`ype changed।
* `-M` / `-C` — रीनाम्स और कॉपीज़ का पता लगाएं। एक वैकल्पिक सिमिलैरिटी थ्रेशोल्ड जोड़ें, उदा. `-M90%`।
* `--relative[=<path>]` — आउटपुट को एक सबडायरेक्टरी तक सीमित करें; बिना आर्गुमेंट के, यह करंट वर्किंग डिर का उपयोग करता है।
* `-z` — **NUL-टर्मिनेटेड** पाथ्स असंदिग्ध मशीन पार्सिंग के लिए (फाइलनाम में न्यूलाइन या टैब को हैंडल करता है)।
* `--stdin` — स्टैंडर्ड इनपुट से कमिट्स (या जोड़े) की एक सूची पढ़ें। यह फास्ट बैच ऑपरेशन्स के लिए सीक्रेट सॉस है।

# कैनोनिकल स्क्रिप्टिंग पैटर्न

### 1) एकल कमिट के लिए बदली गई फ़ाइलों की सूची बनाएं

```bash
git diff-tree --no-commit-id --name-status -r <commit>
```

### 2) कई कमिट्स पर बैच करें (फास्ट!)

```bash
git rev-list main --since="2025-08-01" |
  git diff-tree --stdin -r --no-commit-id --name-status
```

`--stdin` प्रति कमिट `git` स्पॉन करने से बचाता है और बड़ी रेंज के लिए बहुत तेज़ है।

### 3) एक डायरेक्टरी में केवल एडिशन और मॉडिफिकेशन

```bash
git diff-tree -r --no-commit-id --name-status \
  --diff-filter=AM <commit> -- src/backend/
```

### 4) प्रति फ़ाइल जोड़ी/हटाई गई लाइनों की गिनती करें (स्क्रिप्ट-फ्रेंडली)

```bash
git diff-tree -r --no-commit-id --numstat <commit>
# आउटपुट: "<added>\t<deleted>\t<path>"
```

### 5) एक कमिट में रीनाम का पता लगाएं और दिखाएं

```bash
git diff-tree -r --no-commit-id -M --name-status <commit>
# लाइन्स इस प्रकार: "R100 old/name.txt\tnew/name.txt"
```

### 6) एक मर्ज कमिट के लिए पैच

```bash
git diff-tree -m -p <merge-commit>     # प्रति-पैरेंट पैच
git diff-tree --cc <merge-commit>      # कंबाइंड व्यू (सिंगल पैच)
```

### 7) इनिशियल कमिट (कोई पैरेंट नहीं)

```bash
git diff-tree --root -p <initial-commit>
```

# रॉ रिकॉर्ड फॉर्मेट को समझना (यदि आप मैन्युअल रूप से पार्स कर रहे हैं)

न्यूनतम, स्थिर रिकॉर्ड प्राप्त करने के लिए `--raw` का उपयोग करें (कुछ मोड द्वारा अंतर्निहित रूप से उपयोग किया जाता है):

```
:100644 100644 <oldsha> <newsha> M<TAB>path
```

* नंबर फ़ाइल मोड हैं: `100644` रेगुलर फाइल, `100755` एक्जीक्यूटेबल, `120000` सिमलिंक, `160000` gitlink (सबमॉड्यूल)।
* स्टेटस एक सिंगल लेटर है (`A`, `M`, `D`, आदि), संभवतः एक स्कोर के साथ (उदा., `R100`)।
* रीनाम/कॉपी के लिए आप दो पाथ देखेंगे। `-z` के साथ, फ़ील्ड NUL-सेपरेटेड होते हैं; `-z` के बिना, वे टैब-सेपरेटेड होते हैं।

**टिप:** यदि आप विश्वसनीय टूलिंग बना रहे हैं, तो हमेशा `-z` पास करें और NUL पर स्प्लिट करें। न्यूलाइन वाले फाइलनाम मौजूद हैं।

# संबंधित कमांड्स से `git diff-tree` की तुलना करना (ताकि आप सही चुनें)

* `git diff`: **इंडेक्स/वर्किंग ट्री** बनाम HEAD या किसी भी दो कमिट/ट्री की तुलना करता है; इंटरएक्टिव डेवलपमेंट।
* `git show <commit>`: "पैरेंट बनाम डिफ + मेटाडेटा" के लिए एक प्रीटी रैपर। मनुष्यों के लिए बढ़िया।
* `git log -p`: हिस्ट्री प्लस पैच। रेंज के लिए, यह मैन्युअल रूप से `diff-tree` लूप करने से अक्सर अधिक सुविधाजनक होता है।
* `git diff-tree`: **सटीक, स्क्रिप्टेबल प्रति-कमिट डिफ़्स** के लिए प्लंबिंग, `--stdin` के साथ बैच करने योग्य।

# वास्तविक दुनिया के उदाहरण

### "इस PR मर्ज कमिट में क्या बदला?"

```bash
git diff-tree --cc <merge-commit> | less
```

यदि आपको पैरेंट-वाइज डिटेल चाहिए:

```bash
git diff-tree -m -p <merge-commit> | less
```

### "एक CI स्टेप को लेटेस्ट कमिट द्वारा संशोधित फ़ाइलों की एक साफ सूची फीड करें"

```bash
git diff-tree --no-commit-id --name-only -r HEAD > changed.txt
```

### "पिछले 20 कमिट्स में केवल जोड़ी या संशोधित Java फ़ाइलें"

```bash
git rev-list -n 20 HEAD |
  git diff-tree --stdin -r --no-commit-id --name-only --diff-filter=AM |
  grep -E '\.java$'
```

### "एक रिलीज़ टैग के लिए चर्न (जोड़ी/हटाई गई लाइनें) का सारांश दें"

```bash
git diff-tree -r --no-commit-id --numstat v1.2.0..v1.3.0
```

### "अजीब फाइलनामों को सुरक्षित रूप से हैंडल करें"

```bash
git diff-tree -z -r --no-commit-id --name-status <commit> |
  awk -v RS='\0' 'NR%2{status=$0; next}{printf "%s %s\n", status, $0}'
```

# परफॉर्मेंस नोट्स

* बड़ी रेंज के लिए `git rev-list` के साथ `--stdin` को प्राथमिकता दें; यह प्रोसेस चर्न से बचाता है।
* जब आपको लाइन परिवर्तनों की आवश्यकता नहीं होती है तो पैच्स (`--name-only`/`--name-status`) को छोड़ दें।
* यदि आप सटीकता पर गति को प्राथमिकता देते हैं तो रीनाम डिटेक्शन (`-M`, `-C`) से बचें।

# गोत्चास और एज केस

* **मर्ज के लिए डिफ़ॉल्ट रूप से कोई आउटपुट नहीं।** आपको `-m` (प्रति-पैरेंट) या `--cc`/`-c` (कंबाइंड) पास करना होगा।
* **इनिशियल कमिट "खाली ट्री बनाम ट्री" है।** डिफ फोर्स करने के लिए `--root` का उपयोग करें।
* **सबमॉड्यूल** मोड `160000` और एक SHA (gitlink) दिखाते हैं। जब तक आप सबमॉड्यूल रेपो के अंदर डिफ नहीं करते, तब तक आपको आंतरिक डिफ़्स नहीं दिखेंगे।
* **पाथस्पेक्स `--` के बाद आते हैं।** यदि आप पाथ से फ़िल्टर कर रहे हैं, तो अस्पष्टता से बचने के लिए उन्हें `--` के बाद रखें।
* **व्हाइटस्पेस/न्यूलाइन वाले फाइलनाम।** यदि आप पार्सिंग कर रहे हैं तो हमेशा `-z` जोड़ें।

# क्विक "चीट स्निपेट्स" जिनका आप वास्तव में पुन: उपयोग करेंगे

```bash
# बदली गई फाइलें (फ्लैट सूची)
git diff-tree --no-commit-id --name-only -r <commit>
```