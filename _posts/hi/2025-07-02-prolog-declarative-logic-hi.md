---
audio: false
generated: true
lang: hi
layout: post
title: तर्क-आधारित घोषणात्मक प्रोग्रामिंग
translated: true
type: note
---

प्रोलोग, जो "प्रोग्रामिंग इन लॉजिक" का संक्षिप्त रूप है, एक **डिक्लेरेटिव प्रोग्रामिंग लैंग्वेज** है जो पायथन, जावा, या C++ जैसी इम्पेरेटिव भाषाओं के विपरीत है। कंप्यूटर को समस्या को चरण दर चरण *कैसे* हल करना है, यह बताने के बजाय, आप यह बताते हैं कि समस्या *क्या* है, और प्रोलोग समाधान खोजने के लिए अपने अंतर्निहित इनफेरेंस इंजन का उपयोग करता है।

यह **लॉजिक, सिंबोलिक रीजनिंग, और नॉलेज रिप्रेजेंटेशन** से जुड़ी समस्याओं के लिए विशेष रूप से उपयुक्त है, जिससे यह आर्टिफिशियल इंटेलिजेंस (AI), नेचुरल लैंग्वेज प्रोसेसिंग, और एक्सपर्ट सिस्टम्स के क्षेत्र में एक आधारशिला बन गया है।

### प्रोलोग की मुख्य अवधारणाएँ:

1.  **फैक्ट्स (तथ्य):**
    फैक्ट्स वे मौलिक सत्य हैं जो आप प्रोलोग को प्रदान करते हैं। वे बिना शर्त दावों का प्रतिनिधित्व करते हैं।

      * **सिंटैक्स:** `predicate(argument1, argument2, ...).`
      * **उदाहरण:**
          * `man(john).` (जॉन एक पुरुष है)
          * `woman(mary).` (मैरी एक महिला है)
          * `parent(john, mary).` (जॉन, मैरी का माता-पिता है)
          * `capital_of(france, paris).` (पेरिस, फ्रांस की राजधानी है)

2.  **रूल्स (नियम):**
    नियम फैक्ट्स के बीच संबंधों को परिभाषित करते हैं। वे बताते हैं कि एक निश्चित तथ्य तब सत्य होता है जब एक या अधिक अन्य तथ्य (या शर्तें) सत्य होती हैं।

      * **सिंटैक्स:** `head :- body.` (इसे "हेड सत्य है अगर बॉडी सत्य है" के रूप में पढ़ें)
          * `head` एक सिंगल प्रेडिकेट होता है।
          * `body` एक या अधिक प्रेडिकेट्स का संयोजन होता है, जो कॉमा (`,`) से अलग किए जाते हैं, जिसका अर्थ "AND" होता है।
      * **उदाहरण:**
          * `happy(X) :- likes(X, pizza).` (X खुश है अगर X को पिज़्ज़ा पसंद है)
          * `father(X, Y) :- parent(X, Y), male(X).` (X, Y का पिता है अगर X, Y का माता-पिता है AND X पुरुष है)
          * `grandparent(G, C) :- parent(G, P), parent(P, C).` (G, C का दादा-दादी/नाना-नानी है अगर G, P का माता-पिता है AND P, C का माता-पिता है)

3.  **क्वेरीज़ (प्रश्न):**
    एक बार जब आप अपने फैक्ट्स और रूल्स (आपका "नॉलेज बेस") को परिभाषित कर देते हैं, तो आप जानकारी पुनः प्राप्त करने या संबंधों को सत्यापित करने के लिए, प्रोलोग से प्रश्न पूछ सकते हैं, जिन्हें क्वेरीज़ कहा जाता है।

      * **सिंटैक्स:** `?- query.`
      * प्रोलोग स्थापित फैक्ट्स और रूल्स के आधार पर, क्वेरी को सत्य बनाने वाले वेरिएबल्स को ढूंढकर क्वेरी को संतुष्ट करने का प्रयास करता है। यदि एकाधिक समाधान मौजूद हैं, तो आप अक्सर सेमीकोलन (`;`) टाइप करके प्रोलोग को और अधिक खोजने के लिए प्रेरित कर सकते हैं।
      * **उदाहरण:**
          * `?- man(john).` (क्या जॉन एक पुरुष है?)
          * `?- parent(john, X).` (जॉन किसका माता-पिता है? - `X` एक वेरिएबल है)
          * `?- grandparent(elizabeth, william).` (क्या एलिजाबेथ, विलियम की दादी/नानी है?)

4.  **वेरिएबल्स (चर):**
    प्रोलोग में वेरिएबल्स का उपयोग अज्ञात मूल्यों का प्रतिनिधित्व करने के लिए किया जाता है। वे हमेशा अपरकेस अक्षर या अंडरस्कोर (`_`) से शुरू होते हैं। इम्पेरेटिव भाषाओं के वेरिएबल्स के विपरीत, वे मेमोरी लोकेशन नहीं हैं जिन्हें पुनः असाइन किया जा सकता है; बल्कि, वे प्लेसहोल्डर हैं जिन्हें प्रोलोग एक क्वेरी को संतुष्ट करने के लिए मूल्यों के साथ यूनिफाई (एकीकृत) करने का प्रयास करता है।

5.  **यूनिफिकेशन (एकीकरण):**
    यह प्रोलोग का मूल तंत्र है। यूनिफिकेशन एक पैटर्न-मिलान प्रक्रिया है जो वेरिएबल्स को मान निर्दिष्ट करके दो टर्म्स को समान बनाने का प्रयास करती है। यदि कोई मिलान पाया जाता है, तो वेरिएबल्स उन मूल्यों से "बाउंड" हो जाते हैं। यदि कोई मिलान संभव नहीं है, तो यूनिफिकेशन विफल हो जाता है।

6.  **बैकट्रैकिंग (पश्चगमन):**
    जब प्रोलोग एक क्वेरी को संतुष्ट करने का प्रयास करता है, तो यह गहराई-प्रथम (depth-first) तरीके से फैक्ट्स और रूल्स के माध्यम से काम करता है। यदि कोई पथ एक डेड एंड (एक लक्ष्य संतुष्ट नहीं हो सकता) की ओर जाता है, तो प्रोलोग एक पिछले चॉइस पॉइंट पर "बैकट्रैक" करता है और एक वैकल्पिक पथ आज़माता है। यह व्यवस्थित खोज इसे एक क्वेरी के सभी संभावित समाधान खोजने की अनुमति देती है।

### प्रोलोग कैसे काम करता है (सरलीकृत):

1.  आप एक प्रोलोग प्रोग्राम (फैक्ट्स और रूल्स का एक संग्रह) इंटरप्रेटर में लोड करते हैं।
2.  आप एक क्वेरी पूछते हैं।
3.  प्रोलोग अपने फैक्ट्स और अपने रूल्स के हेड के खिलाफ मिलान करके क्वेरी को सिद्ध करने का प्रयास करता है।
4.  यदि किसी नियम का हेड मेल खाता है, तो प्रोलोग नियम की बॉडी में शर्तों को सिद्ध करने का प्रयास करता है (ये सब-गोल बन जाते हैं)।
5.  यह प्रक्रिया तब तक पुनरावर्ती रूप से जारी रहती है जब तक कि सभी सब-गोल फैक्ट्स द्वारा या सफलतापूर्वक सिद्ध नियमों द्वारा संतुष्ट नहीं हो जाते।
6.  यदि कोई समाधान मिल जाता है, तो प्रोलोग वेरिएबल बाइंडिंग्स प्रस्तुत करता है। यदि एकाधिक समाधान मौजूद हैं, तो वह उन्हें खोजने के लिए बैकट्रैक कर सकता है।

### प्रोलोग के लाभ:

  * **डिक्लेरेटिव प्रकृति:** *क्या* हल करना है, इस पर ध्यान दें, *कैसे* पर नहीं। इससे कुछ समस्याओं के लिए अधिक संक्षिप्त और पठनीय कोड बन सकता है।
  * **अंतर्निहित लॉजिक और इनफेरेंस:** लॉजिकल रीजनिंग और खोज के लिए शक्तिशाली तंत्र।
  * **सिंबोलिक AI के लिए उत्कृष्ट:** एक्सपर्ट सिस्टम्स, नेचुरल लैंग्वेज प्रोसेसिंग, नॉलेज रिप्रेजेंटेशन, और थ्योरम प्रूविंग के लिए आदर्श।
  * **पैटर्न मिलान और यूनिफिकेशन:** जटिल डेटा मैनिपुलेशन को सरल बनाता है।
  * **बैकट्रैकिंग:** समाधानों की खोज को स्वचालित करता है, जिसे अन्य भाषाओं में मैन्युअल रूप से प्रोग्राम किया जाता है।

### प्रोलोग की हानियाँ:

  * **सीखने की अवस्था:** डिक्लेरेटिव पैराडाइम उन लोगों के लिए चुनौतीपूर्ण हो सकता है जो इम्पेरेटिव प्रोग्रामिंग के आदी हैं।
  * **परफॉर्मेंस:** इम्पेरेटिव भाषाओं की तुलना में संख्यात्मक गणनाओं या I/O-गहन कार्यों के लिए कम कुशल हो सकता है।
  * **सीमित I/O और ग्राफिक्स:** जटिल यूजर इंटरफेस या ग्राफिकल एप्लिकेशन्स के लिए डिज़ाइन नहीं किया गया है।
  * **डिबगिंग:** बैकट्रैकिंग के कारण प्रोलोग में एक्सिक्यूशन फ्लो को ट्रेस करना कभी-कभी पेचीदा हो सकता है।

-----

### प्रोलोग कोड उदाहरण:

इन उदाहरणों को चलाने के लिए, आपको एक प्रोलोग इंटरप्रेटर (जैसे SWI-Prolog, जो मुफ्त और व्यापक रूप से उपयोग किया जाता है) की आवश्यकता होगी। आप आमतौर पर अपना कोड एक `.pl` एक्सटेंशन (जैसे, `family.pl`) वाली फ़ाइल में सेव करते हैं और फिर उसे इंटरप्रेटर में लोड करते हैं।

**उदाहरण 1: पारिवारिक संबंध**

आइए कुछ बुनियादी पारिवारिक संबंधों को परिभाषित करें।

**`family.pl`:**

```prolog
% Facts: Define basic relationships
male(john).
male(jim).
male(george).
female(mary).
female(lisa).
female(susan).

parent(john, lisa).   % John is a parent of Lisa
parent(john, jim).    % John is a parent of Jim
parent(mary, lisa).   % Mary is a parent of Lisa
parent(mary, jim).    % Mary is a parent of Jim
parent(lisa, george). % Lisa is a parent of George
parent(jim, susan).   % Jim is a parent of Susan

% Rules: Define derived relationships
father(X, Y) :- parent(X, Y), male(X).         % X is the father of Y if X is a parent of Y AND X is male.
mother(X, Y) :- parent(X, Y), female(X).        % X is the mother of Y if X is a parent of Y AND X is female.
child(X, Y) :- parent(Y, X).                    % X is a child of Y if Y is a parent of X.
grandparent(G, C) :- parent(G, P), parent(P, C). % G is a grandparent of C if G is a parent of P AND P is a parent of C.
sibling(X, Y) :- parent(P, X), parent(P, Y), X \= Y. % X and Y are siblings if they share a parent P, and X is not the same as Y.
```

**प्रोलोग इंटरप्रेटर (जैसे, SWI-Prolog) में चलाना:**

```prolog
?- consult('family.pl').
% family.pl compiled 0.00 sec, 7 clauses
true.

% Queries:

?- male(john).
true.

?- female(jim).
false.

?- parent(john, lisa).
true.

?- parent(X, jim). % Who is a parent of Jim?
X = john ;           % Type ';' for more solutions
X = mary.
false.

?- father(john, lisa).
true.

?- mother(mary, jim).
true.

?- grandparent(john, george).
true.

?- grandparent(X, susan). % Who is a grandparent of Susan?
X = john ;
X = mary.
false.

?- sibling(lisa, jim).
true.

?- sibling(lisa, george).
false. % Because they don't share *all* parents
```

**उदाहरण 2: सरल नॉलेज बेस (जानवर)**

**`animals.pl`:**

```prolog
% Facts about animals and their properties
animal(dog).
animal(cat).
animal(bird).
animal(fish).

has_fur(dog).
has_fur(cat).
flies(bird).
swims(fish).

eats(dog, bones).
eats(cat, fish).
eats(bird, seeds).
eats(fish, plankton).

% Rules
is_mammal(X) :- animal(X), has_fur(X). % A mammal is an animal that has fur.
can_fly(X) :- animal(X), flies(X).     % Something can fly if it's an animal and flies.
```

**प्रोलोग इंटरप्रेटर में चलाना:**

```prolog
?- consult('animals.pl').
% animals.pl compiled 0.00 sec, 10 clauses
true.

% Queries:

?- animal(cat).
true.

?- has_fur(dog).
true.

?- eats(cat, X). % What does a cat eat?
X = fish.

?- is_mammal(dog).
true.

?- is_mammal(bird).
false.

?- can_fly(X). % What animals can fly?
X = bird.
false.
```

ये उदाहरण प्रोलोग की डिक्लेरेटिव प्रकृति को दर्शाते हैं, जहां आप संबंधों और गुणों को परिभाषित करते हैं, और सिस्टम आपके प्रश्नों के उत्तर अनुमानित करता है।