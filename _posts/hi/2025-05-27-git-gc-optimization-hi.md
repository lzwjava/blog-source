---
audio: false
generated: true
image: false
lang: hi
layout: post
model: x-ai/grok-code-fast-1
title: गिट गार्बेज कलेक्शन ऑप्टिमाइज़ेशन समझाया
translated: true
type: note
---

### Git GC क्या करता है
Git GC (गार्बेज कलेक्शन) एक रखरखाव कमांड है जो आपके Git रिपॉजिटरी को अनावश्यक फाइलों को साफ़ करके और डेटा को कंप्रेस करके स्पेस बचाने और परफॉर्मेंस सुधारने के लिए ऑप्टिमाइज़ करता है। यह `.git` डायरेक्टरी पर काम करता है, जो किसी रिपो के लिए सारा इतिहास, ऑब्जेक्ट्स और मेटाडेटा स्टोर करती है।

इसके प्रमुख कार्य:
- **अनरीचेबल ऑब्जेक्ट्स को प्रून करना**: ऐसे कमिट्स, ट्रीज़ और ब्लॉब्स को हटाता है जिनका अब कोई रेफरेंस नहीं है (जैसे, रीबेसिंग या ब्रांचेज़ डिलीट करने के बाद)। ये `.git/objects` में "लूज़ ऑब्जेक्ट्स" बन जाते हैं, और GC इन्हें साफ़ कर देता है।
- **ऑब्जेक्ट्स को रीपैक करना**: लूज़ ऑब्जेक्ट्स (जो अलग-अलग स्टोर रहते हैं) को पैक फाइल्स (`.git/objects/pack`) में कंप्रेस करता है, जो ज़्यादा एफिशिएंट होती हैं। यह डेल्टा कंप्रेशन का उपयोग करके समान फाइल्स के बीच के अंतरों को स्टोर करता है, जिससे डिस्क यूज कम होता है।
- **रेफरेंसेज़ अपडेट करना**: रिपॉजिटरी की इंटरनल स्टेट को रिफ्रेश करता है, जैसे तेज़ लुकअप्स के लिए पैक इंडेक्स को दोबारा लिखना।
- **संबंधित टूल्स चलाना**: यह प्रक्रिया के हिस्से के रूप में अक्सर `git prune`, `git repack`, और `git rerere` (रिज़ॉल्यूशन रीयूज़ के लिए) जैसे कमांड्स को इनवोक करता है।

साक्ष्य: Git के ऑफिशियल डॉक्युमेंटेशन (जैसे, `git gc --help`) के अनुसार, GC को रिपॉजिटरीज़ का "हाउसकीपिंग" करने के लिए डिज़ाइन किया गया है। उदाहरण के लिए, 10,000 लूज़ ऑब्जेक्ट्स वाला एक रिपो पैक होने के बाद सैकड़ों MB से घटकर एक छोटे से हिस्से में आ सकता है, क्योंकि डेल्टा कंप्रेशन समानताओं (जैसे, कोड हिस्ट्री में फाइल वर्ज़न्स के बीच) का लाभ उठाता है।

### यह आंतरिक रूप से कैसे काम करता है
1.  **ट्रिगर्स**: GC मैन्युअल रूप से `git gc` के ज़रिए या ऑटोमैटिक रूप से चलता है जब Git कुछ खास कंडीशन्स को डिटेक्ट करता है (नीचे देखें)। यह हर कमांड पर स्लोडाउन से बचने के लिए नहीं चलता है।
2.  **प्रक्रिया**:
    - लूज़ ऑबजेक्ट्स और पैक फाइल्स को काउंट करता है।
    - यदि थ्रेशोल्ड्स पार हो जाते हैं (जैसे, डिफ़ॉल्ट रूप से >6,700 लूज़ ऑब्जेक्ट्स, `gc.auto` के ज़रिए कॉन्फ़िगर करने योग्य), तो यह एग्रेसिवली रीपैक करता है।
    - यह डेटा लॉस से बचने के लिए टेम्पररी फाइल्स (जैसे, `.git/objects/tmp_*`) बनाता है, फिर उन्हें एटोमिकली स्वैप कर देता है।
    - `git gc --auto` जैसे हल्के मोड सिर्फ प्रून करते हैं, फुल रीपैकिंग के बिना।
3.  **कंप्रेशन डिटेल्स**: कंप्रेशन के लिए zlib का उपयोग करता है। रीपैकिंग पैक फाइल्स बनाती है जहां ऑब्जेक्ट्स बेस ऑब्जेक्ट्स से डेल्टास (अंतर) के रूप में स्टोर होते हैं, जो इवॉल्विंग कोड वाली रिपॉजिटरीज़ के लिए इसे एफिशिएंट बनाता है—उदाहरण के लिए, एक बड़े कोडबेस में एक फाइल में एक लाइन जोड़ने से पूरी फाइल को डुप्लिकेट करने के बजाय एक छोटा सा डेल्टा बनता है।

यह Git के सोर्स कोड (GitHub पर उपलब्ध) द्वारा समर्थित है, जो GC को रिलायबिलिटी के लिए प्रूनिंग और पैकिंग यूटिलिटीज़ की एक सीरीज़ के शेल कॉल्स के रूप में इम्प्लीमेंट करता है।

### यह अचानक क्यों चल जाता है
GC अक्सर "अचानक" ट्रिगर होता है क्योंकि यह परफॉर्मेंस को बैलेंस करने के लिए ऑटोमैटिक है, रियल-टाइम नहीं। आम वजहें:
- **थ्रेशोल्ड्स पार होना**: लूज़ ऑब्जेक्ट्स के जमा होने के बाद (जैसे, बिना पैकिंग के बार-बार कमिट्स या फ़ेचेज़ से)। Git ऑपरेशन्स जैसे `git commit`, `git merge`, या `push` के बाद इसे चेक करता है। यदि लूज़ ऑब्जेक्ट्स `gc.auto` लिमिट (डिफ़ॉल्ट: लगभग 6,700) से अधिक हो जाते हैं, तो यह चल जाता है। इसीलिए यह एक्टिविटी के एक झोंके के बाद हो सकता है, जो "अचानक" लगता है।
- **प्रून शेड्यूल**: यदि `gc.prune` सेट है, तो यह पीरियडिकली स्टेल रेफ्स को प्रून करता है, लेकिन मुख्य ऑटो-जीसी ऑब्जेक्ट काउंट्स पर आधारित है।
- **बड़े ऑपरेशन्स**: हैवी रीबेसिंग या क्लोनिंग बहुत सारे लूज़ ऑब्जेक्ट्स जल्दी जनरेट कर सकती है, जिससे यह ट्रिगर हो जाता है।
- **पोस्ट-कमांड हुक्स**: कुछ वर्कफ़्लो या टूल्स (जैसे, Git हुक्स या IDE) बड़े बदलावों के बाद `git gc` इनवोक कर सकते हैं।

इसे कंट्रोल करने के लिए: सेटिंग्स एडजस्ट करें जैसे `git config --global gc.auto 0` ऑटो-जीसी को डिसेबल करने के लिए अगर आप मैन्युअल रन पसंद करते हैं, या इंटरप्शन्स कम करने के लिए थ्रेशोल्ड बढ़ा दें। इसे चलाने से रिपोज़ के फूलने से बचाव होता है—उदाहरण के लिए, Linux kernel रिपो अपने विशाल स्केल के बावजूद हिस्ट्री को मैनेजेबल रखने के लिए GC का उपयोग करता है। यदि समस्या बनी रहती है, तो लूज़ ऑब्जेक्ट स्टैट्स के लिए `git count-objects -v` चेक करें।