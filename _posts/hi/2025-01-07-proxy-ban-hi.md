---
audio: true
lang: hi
layout: post
title: प्रॉक्सी सर्वर प्रतिबंध का विश्लेषण
---

## क्या प्रॉक्सी सर्वर में एपीआई GFW प्रतिबंधों से बच सकती हैं?

मैं अपने Shadowsocks इंस्टेंस पर निम्नलिखित कोड के साथ एक सरल सर्वर चलाता हूँ:

```python
from flask import Flask, jsonify
from flask_cors import CORS
import subprocess
```

```python
app = Flask(__name__)
CORS(app)  # सभी रूट्स के लिए CORS सक्षम करें
```

```python
@app.route('/bandwidth', methods=['GET'])
def get_bandwidth():
    # eth0 के लिए 5-मिनट के अंतराल पर ट्रैफ़िक सांख्यिकी प्राप्त करने के लिए vnstat कमांड चलाएं
    result = subprocess.run(['vnstat', '-i', 'eth0', '-5', '--json'], capture_output=True, text=True)
    data = result.stdout
```

    # कैप्चर किए गए डेटा को JSON प्रतिक्रिया के रूप में वापस करें
    return jsonify(data)

```python
if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
```

और मैं nginx का उपयोग करके पोर्ट 443 को सर्व करता हूं, जैसा कि नीचे दिखाया गया है:

```bash
server {
    listen 443 ssl;
    server_name www.some-domain.xyz;
```

    ssl_certificate /etc/letsencrypt/live/www.some-domain.xyz/fullchain.pem; # managed by 
    # ...
    location / {

```nginx
        proxy_pass http://127.0.0.1:5000/;
        # ...
    }
}
```

यह सर्वर प्रोग्राम नेटवर्क डेटा प्रदान करता है, और मैं इस सर्वर को अपने प्रॉक्सी सर्वर के रूप में उपयोग करता हूं, जिससे मैं नेटवर्क डेटा का उपयोग करके अपने ब्लॉग पर अपनी ऑनलाइन स्थिति प्रदर्शित कर सकता हूं।

यह दिलचस्प बात है कि सर्वर को ग्रेट फ़ायरवॉल (GFW) या किसी अन्य नेटवर्क नियंत्रण प्रणाली द्वारा कई दिनों से प्रतिबंधित नहीं किया गया है। आमतौर पर, मेरे द्वारा सेट किया गया प्रॉक्सी सर्वर एक या दो दिनों के भीतर प्रतिबंधित हो जाता है। सर्वर 51939 जैसे पोर्ट पर Shadowsocks प्रोग्राम चलाता है, इसलिए यह Shadowsocks ट्रैफ़िक के साथ नियमित API ट्रैफ़िक को मिलाकर चलता है। यह मिश्रण GFW को यह विश्वास दिलाता है कि सर्वर एक समर्पित प्रॉक्सी नहीं है, बल्कि एक सामान्य सर्वर है, जिससे IP को प्रतिबंधित करने से रोका जाता है।

यह अवलोकन दिलचस्प है। ऐसा लगता है कि GFW प्रॉक्सी ट्रैफ़िक और सामान्य ट्रैफ़िक के बीच अंतर करने के लिए विशिष्ट तर्क का उपयोग करता है। जबकि ट्विटर और यूट्यूब जैसी कई वेबसाइटें चीन में ब्लॉक हैं, कई विदेशी वेबसाइटें—जैसे कि अंतरराष्ट्रीय विश्वविद्यालयों और कंपनियों की वेबसाइटें—अभी भी सुलभ हैं।

इससे पता चलता है कि GFW संभवतः ऐसे नियमों पर काम करता है जो सामान्य HTTP/HTTPS ट्रैफ़िक और प्रॉक्सी-संबंधित ट्रैफ़िक के बीच अंतर करते हैं। ऐसे सर्वर जो दोनों प्रकार के ट्रैफ़िक को हैंडल करते हैं, वे प्रतिबंध से बच जाते हैं, जबकि जो सर्वर केवल प्रॉक्सी ट्रैफ़िक को हैंडल करते हैं, उनके ब्लॉक होने की संभावना अधिक होती है।

एक सवाल यह है कि GFW प्रतिबंध लगाने के लिए डेटा संचित करने के लिए किस समय सीमा का उपयोग करता है—चाहे वह एक दिन हो या एक घंटा। इस समय सीमा के दौरान, यह पता लगाता है कि क्या ट्रैफ़िक विशेष रूप से एक प्रॉक्सी से है। यदि ऐसा है, तो सर्वर का IP प्रतिबंधित हो जाता है।

मैं अक्सर अपने ब्लॉग पर जाकर यह जांचता हूं कि मैंने क्या लिखा है, लेकिन आने वाले हफ्तों में मेरा ध्यान ब्लॉग पोस्ट लिखने के बजाय अन्य कार्यों पर केंद्रित होगा। इससे पोर्ट 443 के माध्यम से `bandwidth` API तक मेरी पहुंच कम हो जाएगी। अगर मुझे लगता है कि मुझे फिर से बैन कर दिया गया है, तो मुझे इस API को नियमित रूप से एक्सेस करने के लिए एक प्रोग्राम लिखना चाहिए ताकि GFW को धोखा दिया जा सके।

यहां आपके पाठ का परिष्कृत संस्करण दिया गया है, जिसमें संरचना और स्पष्टता में सुधार किया गया है:

## महान फ़ायरवॉल (GFW) कैसे काम करता है।

### चरण 1: अनुरोधों को लॉग करना

```python
import time
```

# अनुरोध डेटा को स्टोर करने के लिए डेटाबेस
request_log = []

# अनुरोधों को लॉग करने के लिए फ़ंक्शन
def log_request(source_ip, target_ip, target_port, body):
    request_log.append({
        'source_ip': source_ip,
        'target_ip': target_ip,
        'target_port': target_port,
        'body': body,
        'timestamp': time.time()
    })
```

`log_request` फ़ंक्शन आने वाले अनुरोधों को स्रोत IP, लक्ष्य IP, लक्ष्य पोर्ट, अनुरोध बॉडी, और टाइमस्टैम्प जैसी आवश्यक जानकारी के साथ रिकॉर्ड करता है।

### चरण 2: IPs की जांच और प्रतिबंध लगाना

```python
# अनुरोधों की जांच करने और IPs को ब्लॉक करने के लिए फ़ंक्शन
def check_and_ban_ips():
    banned_ips = set()
```

    # सभी लॉग किए गए अनुरोधों पर पुनरावृत्ति करें
    for request in request_log:
        if is_illegal(request):
            banned_ips.add(request['target_ip'])
        else:
            banned_ips.discard(request['target_ip'])

    # सभी पहचाने गए IPs पर प्रतिबंध लगाएं
    ban_ips(banned_ips)
```

`check_and_ban_ips` फ़ंक्शन सभी लॉग किए गए अनुरोधों के माध्यम से पुनरावृत्ति करता है, और उन आईपी पतों की पहचान करता है और उन्हें प्रतिबंधित करता है जो अवैध गतिविधि से जुड़े होते हैं।

### चरण 3: यह परिभाषित करना कि क्या अनुरोध अवैध बनाता है

```python
# एक अनुरोध को अवैध जांचने के लिए सिम्युलेट करने वाला फ़ंक्शन
def is_illegal(request):
    # वास्तविक अवैध अनुरोध जांच लॉजिक के लिए प्लेसहोल्डर
    # उदाहरण के लिए, अनुरोध बॉडी या लक्ष्य की जांच करना
    return "illegal" in request['body']
```

यहां, `is_illegal` यह जांचता है कि क्या अनुरोध के बॉडी में "illegal" शब्द शामिल है। इसे और अधिक परिष्कृत तर्क में विस्तारित किया जा सकता है, यह इस बात पर निर्भर करता है कि अवैध गतिविधि क्या मानी जाती है।

### चरण 4: पहचाने गए IP पतों को प्रतिबंधित करना

```python
# IP सूची को ब्लॉक करने के लिए फ़ंक्शन
def ban_ips(ip_set):
    for ip in ip_set:
        print(f"IP ब्लॉक किया जा रहा है: {ip}")
```

एक बार अवैध IP पते पहचाने जाने के बाद, `ban_ips` फ़ंक्शन उन्हें उनके IP पते प्रिंट करके बैन कर देता है (या, एक वास्तविक सिस्टम में, उन्हें ब्लॉक कर सकता है)।

### चरण 5: 80% अवैध अनुरोधों के आधार पर IPs की जांच और प्रतिबंध लगाने के लिए वैकल्पिक विधि

```python
# 80% अवैध अनुरोधों के आधार पर अनुरोधों की जांच करने और IPs को ब्लॉक करने के लिए फ़ंक्शन
def check_and_ban_ips():
    banned_ips = set()
    illegal_count = 0
    total_requests = 0
```

    # सभी लॉग किए गए अनुरोधों पर पुनरावृत्ति करें
    for request in request_log:
        total_requests += 1
        if is_illegal(request):
            illegal_count += 1

    # यदि 80% या अधिक अनुरोध अवैध हैं, तो उन IPs को ब्लॉक करें
    if total_requests > 0 and (illegal_count / total_requests) >= 0.8:
        for request in request_log:
            if is_illegal(request):
                banned_ips.add(request['target_ip'])

    # सभी पहचाने गए IPs पर प्रतिबंध लगाएं
    ban_ips(banned_ips)
```

यह वैकल्पिक विधि यह मूल्यांकन करती है कि क्या किसी IP को प्रतिबंधित किया जाना चाहिए, अवैध अनुरोधों के प्रतिशत के आधार पर। यदि किसी IP से 80% या अधिक अनुरोध अवैध हैं, तो उसे प्रतिबंधित कर दिया जाता है।

### चरण 6: बढ़ाया गया अवैध अनुरोध जांच (उदाहरण के लिए, Shadowsocks और Trojan प्रोटोकॉल का पता लगाना)

```python
def is_illegal(request):
    # जांचें कि क्या अनुरोध Shadowsocks प्रोटोकॉल का उपयोग करता है (बॉडी में बाइनरी-जैसा डेटा होता है)
    if request['target_port'] == 443:
        if is_trojan(request):
            return True
    elif is_shadowsocks(request):
        return True
    return False
```

`is_illegal` फ़ंक्शन अब Shadowsocks और Trojan जैसे विशिष्ट प्रोटोकॉल की भी जाँच करता है:
- **Shadowsocks**: हम अनुरोध के बॉडी में एन्क्रिप्टेड या बाइनरी जैसे डेटा की जाँच कर सकते हैं।
- **Trojan**: यदि अनुरोध पोर्ट 443 (HTTPS) पर आता है और विशिष्ट पैटर्न से मेल खाता है (जैसे, Trojan ट्रैफ़िक की विशेषताएँ), तो इसे अवैध के रूप में चिह्नित किया जाता है।

### चरण 7: कानूनी अनुरोध उदाहरण

उदाहरण के लिए, `GET https://some-domain.xyz/bandwidth` जैसे अनुरोध निश्चित रूप से वैध हैं और बैनिंग मैकेनिज्म को ट्रिगर नहीं करेंगे।

### चरण 8: प्रॉक्सी सर्वर ट्रैफ़िक की विशेषताएँ

प्रॉक्सी सर्वरों की ट्रैफ़िक विशेषताएँ नियमित वेब या API सर्वरों की तुलना में बहुत अलग होती हैं। GFW को सामान्य वेब सर्वर ट्रैफ़िक और प्रॉक्सी सर्वर ट्रैफ़िक के बीच अंतर करने की आवश्यकता होती है, जो पूरी तरह से अलग दिख सकते हैं।

### चरण 9: स्मार्ट डिटेक्शन के लिए मशीन लर्निंग और AI मॉडल

इंटरनेट के माध्यम से जो विभिन्न प्रकार के अनुरोध और प्रतिक्रियाएं प्रसारित होती हैं, उन्हें देखते हुए GFW (Great Firewall) AI और मशीन लर्निंग मॉडल का उपयोग करके ट्रैफ़िक पैटर्न का विश्लेषण कर सकता है और अवैध व्यवहार को बुद्धिमत्तापूर्वक पहचान सकता है। विभिन्न प्रकार के ट्रैफ़िक पर सिस्टम को प्रशिक्षित करके और उन्नत तकनीकों का उपयोग करके, यह देखे गए पैटर्न के आधार पर ट्रैफ़िक को अधिक प्रभावी ढंग से प्रतिबंधित या फ़िल्टर कर सकता है।

