---
audio: false
generated: false
lang: hi
layout: post
title: प्रॉक्सी सर्वर प्रतिबंध का विश्लेषण
translated: true
---

## क्या प्रॉक्सी सर्वर में API ग्रेट फ़ायरवॉल (GFW) बैन से बच सकते हैं?

मैंने अपने Shadowsocks इंस्टेंस पर एक सरल सर्वर चलाया है, जिसका कोड निम्नलिखित है:

```python
from flask import Flask, jsonify
from flask_cors import CORS
import subprocess

app = Flask(__name__)
CORS(app)  # सभी रूट्स के लिए CORS सक्षम करें

@app.route('/bandwidth', methods=['GET'])
def get_bandwidth():
    # eth0 के लिए 5-मिनट अंतराल ट्रैफ़िक सांख्यिकी प्राप्त करने के लिए vnstat कमांड चलाएं
    result = subprocess.run(['vnstat', '-i', 'eth0', '-5', '--json'], capture_output=True, text=True)
    data = result.stdout

    # कैप्चर किए गए डेटा को JSON प्रतिक्रिया के रूप में वापस करें
    return jsonify(data)

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
```

और मैं nginx का उपयोग करके पोर्ट 443 को सर्व करता हूं, जैसा कि नीचे दिखाया गया है:

```bash
server {
    listen 443 ssl;
    server_name www.some-domain.xyz;

    ssl_certificate /etc/letsencrypt/live/www.some-domain.xyz/fullchain.pem; # managed by 
    # ...
    location / {

        proxy_pass http://127.0.0.1:5000/;
        # ...
    }
}
```

यह सर्वर प्रोग्राम नेटवर्क डेटा प्रदान करता है, और मैं इस सर्वर को अपने प्रॉक्सी सर्वर के रूप में उपयोग करता हूं, जिससे मैं नेटवर्क डेटा का उपयोग करके अपने ब्लॉग पर अपनी ऑनलाइन स्थिति प्रदर्शित कर सकता हूं।

दिलचस्प बात यह है कि यह सर्वर कई दिनों से ग्रेट फ़ायरवॉल (GFW) या किसी अन्य नेटवर्क नियंत्रण प्रणाली द्वारा बैन नहीं किया गया है। आमतौर पर, मेरे द्वारा सेट किया गया प्रॉक्सी सर्वर एक या दो दिनों के भीतर बैन हो जाता है। सर्वर 51939 जैसे पोर्ट पर Shadowsocks प्रोग्राम चलाता है, इसलिए यह Shadowsocks ट्रैफ़िक के साथ नियमित API ट्रैफ़िक को मिलाकर चलता है। यह मिश्रण GFW को यह विश्वास दिलाता है कि सर्वर एक समर्पित प्रॉक्सी नहीं है, बल्कि एक सामान्य सर्वर है, जिससे यह IP को बैन नहीं करता है।

यह अवलोकन दिलचस्प है। ऐसा लगता है कि GFW प्रॉक्सी ट्रैफ़िक और नियमित ट्रैफ़िक के बीच अंतर करने के लिए विशिष्ट तर्क का उपयोग करता है। जबकि चीन में Twitter और YouTube जैसी कई वेबसाइट्स ब्लॉक हैं, कई विदेशी वेबसाइट्स—जैसे कि अंतरराष्ट्रीय विश्वविद्यालयों और कंपनियों की वेबसाइट्स—अभी भी सुलभ हैं।

इससे पता चलता है कि GFW संभवतः नियमित HTTP/HTTPS ट्रैफ़िक और प्रॉक्सी-संबंधित ट्रैफ़िक के बीच अंतर करने के नियमों पर काम करता है। जो सर्वर दोनों प्रकार के ट्रैफ़िक को संभालते हैं, वे बैन से बच जाते हैं, जबकि केवल प्रॉक्सी ट्रैफ़िक संभालने वाले सर्वर अधिक संभावना से ब्लॉक हो जाते हैं।

एक सवाल यह है कि GFW बैन के लिए डेटा एकत्र करने के लिए किस समय सीमा का उपयोग करता है—चाहे वह एक दिन हो या एक घंटा। इस समय सीमा के दौरान, यह पता लगाता है कि क्या ट्रैफ़िक विशेष रूप से प्रॉक्सी से है। यदि हां, तो सर्वर का IP बैन हो जाता है।

मैं अक्सर अपने ब्लॉग पर जाकर यह समीक्षा करता हूं कि मैंने क्या लिखा है, लेकिन आने वाले हफ्तों में मेरा ध्यान ब्लॉग पोस्ट लिखने के बजाय अन्य कार्यों पर होगा। इससे पोर्ट 443 के माध्यम से `bandwidth` API तक मेरी पहुंच कम हो जाएगी। यदि मुझे लगता है कि मैं फिर से बैन हो गया हूं, तो मुझे GFW को धोखा देने के लिए इस API को नियमित रूप से एक्सेस करने के लिए एक प्रोग्राम लिखना चाहिए।

यहां आपके टेक्स्ट का संशोधित संस्करण है जिसमें संरचना और स्पष्टता में सुधार किया गया है:

## ग्रेट फ़ायरवॉल (GFW) कैसे काम करता है।

### चरण 1: अनुरोधों को लॉग करना

```python
import time

# अनुरोध डेटा संग्रहीत करने के लिए डेटाबेस
request_log = []

# अनुरोधों को लॉग करने के लिए फ़ंक्शन
def log_request(source_ip, target_ip, target_port, body):
    request_log.append({
        'source_ip': source_ip,
        'target_ip': target_ip,
        'target_port': target_port,
        'body': body,
        'timestamp': time.time()
    })
```

`log_request` फ़ंक्शन स्रोत IP, लक्ष्य IP, लक्ष्य पोर्ट, अनुरोध बॉडी और टाइमस्टैम्प जैसी आवश्यक जानकारी के साथ आने वाले अनुरोधों को रिकॉर्ड करता है।

### चरण 2: IPs की जांच और बैन करना

```python
# अनुरोधों की जांच करने और IPs को बैन करने के लिए फ़ंक्शन
def check_and_ban_ips():
    banned_ips = set()

    # सभी लॉग किए गए अनुरोधों पर पुनरावृत्ति करें
    for request in request_log:
        if is_illegal(request):
            banned_ips.add(request['target_ip'])
        else:
            banned_ips.discard(request['target_ip'])

    # सभी पहचाने गए IPs पर बैन लागू करें
    ban_ips(banned_ips)
```

`check_and_ban_ips` फ़ंक्शन सभी लॉग किए गए अनुरोधों पर पुनरावृत्ति करता है, और अवैध गतिविधि से जुड़े IPs की पहचान करता है और उन्हें बैन करता है।

### चरण 3: अनुरोध को अवैध बनाने वाले कारकों को परिभाषित करना

```python
# अनुरोध को अवैध मानने की जांच करने के लिए फ़ंक्शन
def is_illegal(request):
    # वास्तविक अवैध अनुरोध जांच तर्क के लिए प्लेसहोल्डर
    # उदाहरण के लिए, अनुरोध बॉडी या लक्ष्य की जांच करना
    return "illegal" in request['body']
```

यहां, `is_illegal` जांचता है कि क्या अनुरोध बॉडी में "illegal" शब्द है। इसे अवैध गतिविधि के आधार पर अधिक परिष्कृत तर्क में विस्तारित किया जा सकता है।

### चरण 4: पहचाने गए IPs को बैन करना

```python
# IPs की सूची को बैन करने के लिए फ़ंक्शन
def ban_ips(ip_set):
    for ip in ip_set:
        print(f"IP बैन कर रहा है: {ip}")
```

एक बार अवैध IPs की पहचान हो जाने पर, `ban_ips` फ़ंक्शन उन्हें बैन करता है (या, वास्तविक सिस्टम में, उन्हें ब्लॉक कर सकता है)।

### चरण 5: 80% अवैध अनुरोधों के आधार पर IPs की जांच और बैन करने के लिए वैकल्पिक विधि

```python
# 80% अवैध अनुरोधों के आधार पर अनुरोधों की जांच करने और IPs को बैन करने के लिए फ़ंक्शन
def check_and_ban_ips():
    banned_ips = set()
    illegal_count = 0
    total_requests = 0

    # सभी लॉग किए गए अनुरोधों पर पुनरावृत्ति करें
    for request in request_log:
        total_requests += 1
        if is_illegal(request):
            illegal_count += 1

    # यदि 80% या अधिक अनुरोध अवैध हैं, तो उन IPs को बैन करें
    if total_requests > 0 and (illegal_count / total_requests) >= 0.8:
        for request in request_log:
            if is_illegal(request):
                banned_ips.add(request['target_ip'])

    # सभी पहचाने गए IPs पर बैन लागू करें
    ban_ips(banned_ips)
```

यह वैकल्पिक विधि IPs को बैन करने के लिए अवैध अनुरोधों के प्रतिशत का मूल्यांकन करती है। यदि किसी IP से 80% या अधिक अनुरोध अवैध हैं, तो उसे बैन कर दिया जाता है।

### चरण 6: अवैध अनुरोध जांच को बढ़ाना (उदाहरण के लिए, Shadowsocks और Trojan प्रोटोकॉल का पता लगाना)

```python
def is_illegal(request):
    # जांचें कि क्या अनुरोध Shadowsocks प्रोटोकॉल का उपयोग करता है (बॉडी में बाइनरी-जैसा डेटा होता है)
    if request['target_port'] == 443:
        if is_trojan(request):
            return True
    elif is_shadowsocks(request):
        return True
    return False
```

`is_illegal` फ़ंक्शन अब Shadowsocks और Trojan जैसे विशिष्ट प्रोटोकॉल की भी जांच करता है:
- **Shadowsocks**: हम अनुरोध बॉडी में एन्क्रिप्टेड या बाइनरी-जैसा डेटा की जांच कर सकते हैं।
- **Trojan**: यदि अनुरोध पोर्ट 443 (HTTPS) पर आता है और विशिष्ट पैटर्न से मेल खाता है (उदाहरण के लिए, Trojan ट्रैफ़िक की विशेषताएं), तो इसे अवैध माना जाता है।

### चरण 7: वैध अनुरोध उदाहरण

उदाहरण के लिए, `GET https://some-domain.xyz/bandwidth` जैसे अनुरोध निश्चित रूप से वैध हैं और बैन तंत्र को ट्रिगर नहीं करेंगे।

### चरण 8: प्रॉक्सी सर्वर ट्रैफ़िक की विशेषताएं

प्रॉक्सी सर्वर में नियमित वेब या API सर्वर की तुलना में बहुत अलग ट्रैफ़िक विशेषताएं होती हैं। GFW को नियमित वेब सर्वर ट्रैफ़िक और प्रॉक्सी सर्वर ट्रैफ़िक के बीच अंतर करने की आवश्यकता होती है, जो पूरी तरह से अलग दिख सकते हैं।

### चरण 9: स्मार्ट पहचान के लिए मशीन लर्निंग और AI मॉडल

इंटरनेट के माध्यम से गुजरने वाले अनुरोधों और प्रतिक्रियाओं की विस्तृत श्रृंखला को देखते हुए, GFW ट्रैफ़िक पैटर्न का विश्लेषण करने और अवैध व्यवहार का स्मार्ट तरीके से पता लगाने के लिए AI और मशीन लर्निंग मॉडल का उपयोग कर सकता है। विभिन्न प्रकार के ट्रैफ़िक पर सिस्टम को प्रशिक्षित करके और उन्नत तकनीकों का उपयोग करके, यह देखे गए पैटर्न के आधार पर ट्रैफ़िक को अधिक प्रभावी ढंग से बैन या फ़िल्टर कर सकता है।

## अपडेट

मेरे प्रयासों के बावजूद, मेरा प्रॉक्सी सर्वर लगातार बैन हो रहा है। इसे कम करने के लिए, मैंने Digital Ocean के उलटे IP फ़ीचर का उपयोग करके एक वर्कअराउंड लागू किया है, जो मुझे जब भी बैन होता है तो तुरंत एक नया IP पता असाइन करने की अनुमति देता है।