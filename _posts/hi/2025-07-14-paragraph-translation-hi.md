---
audio: false
generated: false
image: false
lang: hi
layout: post
title: ट्रांसलेशन लागत को अनुकूलित करना पैराग्राफ-आधारित मार्कडाउन के साथ
translated: true
type: post
---

मेरा Jekyll ब्लॉग Markdown का उपयोग करके पैराग्राफ लिखने के लिए करता है। अंग्रेजी में लिखने के बाद, मैं AI टूल्स जैसे DeepSeek या Mistral का उपयोग करके आठ अन्य भाषाओं में अनुवाद करता हूँ। हालांकि वे पहले से ही सस्ते हैं, फिर भी सुधार के लिए स्थान है।

कभी-कभी, मैं बस एक शब्द या एक पैराग्राफ को संपादित करता हूँ, और फिर पूरे पोस्ट का पाठ आठ अन्य भाषाओं में अनुवाद हो जाता है। इस मामले में, टोकन का उपयोग अधिक होता है। अगर मैं केवल संपादित पैराग्राफ को फिर से अनुवाद करता हूँ, तो टोकन का उपयोग कम होगा, विशेषकर लंबे पोस्ट के लिए।

हालांकि, मैं अभी भी Markdown का उपयोग करके अपने विचारों को रिकॉर्ड करना चाहता हूँ। एक डेटाबेस का उपयोग करके पोस्ट्स को बनाए रखना और अपडेट करना आसान नहीं है। YAML या JSON का उपयोग करना भी अधिक जटिल हो सकता है।

मुद्दा यह है कि संपादन से पहले और बाद के टेक्स्ट के बीच अंतर को पहचानना है। अगर हम पैराग्राफ-आधारित दृष्टिकोण का उपयोग करते हैं, तो इसका मतलब है कि न्यूलाइन कैरेक्टर "\n" का उपयोग करके टेक्स्ट को विभाजित करना।

मुझे यह जानना है कि संपादन के बाद कौन से पैराग्राफ बदल गए हैं और कौन नहीं। हमें संपादन से पहले और बाद के टेक्स्ट के बीच पैराग्राफों के एक-से-एक मैपिंग स्थापित करने की आवश्यकता है।

हम पैराग्राफ-आधारित दृष्टिकोण का उपयोग करते हैं क्योंकि हम AI मॉडल द्वारा किए गए अनुवादों को अपडेट करना चाहते हैं। अगर हम वाक्यों का उपयोग करते हैं, तो यह उतना सटीक नहीं हो सकता।

Markdown के लिए, यह Markdown तत्वों के आधार पर अनुवादों को सिंक्रनाइज़ करने के लिए Markdown पार्सिंग का उपयोग करना अधिक महत्वपूर्ण हो सकता है।

लेकिन अगर कोड ब्लॉक्स या विशेष Markdown सिंटैक्स नहीं हैं, तो हम पैराग्राफ-आधारित दृष्टिकोण का उपयोग कर सकते हैं।

एक सरल पैराग्राफ-आधारित दृष्टिकोण के लिए, हमारे पास दो पैराग्राफों के एरे हैं और हमें पता चलना चाहिए कि वे कैसे मिलते हैं।

इन दो एरे में किसी भी पैराग्राफ की तुलना करते समय, दो संभावित परिणाम होते हैं: वे या तो समान हैं या अलग हैं। अगर वे अलग हैं, तो कई मामले हैं: दोनों नए जोड़े गए हैं, बाएं वाला नया जोड़ा गया है, या दाएं वाला नया जोड़ा गया है।

मैं बस लागत बचाना चाहता हूँ, इसलिए मेरा उद्देश्य टोकन का उपयोग कम करना है। मुझे और कुछ नहीं चाहिए। मुझे बस हर पैराग्राफ का अनुवाद करना है, परिणाम को कैश करना है, और अगली बार, हर पैराग्राफ के लिए, मैं पहले अनुवाद परिणाम की तलाश करूंगा। अगर वह मौजूद नहीं है, तो मुझे इसे फिर से अनुवाद करना होगा।

Markdown के लिए, यह थोड़ा अधिक जटिल है। मैं कोड ब्लॉक्स का अनुवाद नहीं करना चाहता। इसलिए, हम एक Markdown पार्सिंग लाइब्रेरी का उपयोग कर सकते हैं ताकि कोड ब्लॉक्स और सामान्य टेक्स्ट को अलग-अलग तरीके से संभाला जा सके।

कुछ हफ्तों में, मैं इसे Python और Grok के साथ लागू करने जा रहा हूँ क्योंकि यह एक वास्तविक समस्या है। मुझे इसे हल करना होगा।

एक डिजाइन कैश फाइलों के बारे में है। मैं कैश को एक कैश डायरेक्टरी में स्टोर करता हूँ जिसमें फाइलें जैसे `lang.json` होती हैं, जैसे `zh.json` आदि।