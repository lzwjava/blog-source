---
audio: false
generated: true
image: false
lang: hi
layout: post
model: x-ai/grok-code-fast-1
title: सीएफएफआई पायथन सी इंटरफेस गाइड
translated: true
type: note
---

### CFFI क्या है?
CFFI (C फॉरेन फंक्शन इंटरफेस) C फंक्शन्स को Python कोड से कॉल करने के लिए एक Python लाइब्रेरी है। यह CPython और PyPy दोनों के साथ संगत है, और ctypes जैसी लाइब्रेरीज़ के लिए एक सुरक्षित और अधिक पोर्टेबल विकल्प प्रदान करती है। यह दो मुख्य मोड का समर्थन करती है: ABI (मौजूदा शेयर्ड लाइब्रेरीज़ को कॉल करना) और API (C कोड को इनलाइन कंपाइल करना)।

### इंस्टालेशन
CFFI को pip का उपयोग करके इंस्टॉल करें:
```bash
pip install cffi
```
CFFI को मॉड्यूल बनाने के लिए एक C कंपाइलर (जैसे, Linux पर GCC, Windows पर Visual Studio) की आवश्यकता होती है।

### बेसिक उपयोग उदाहरण
यहाँ एक सरल उपयोग केस का चरण-दर-चरण मार्गदर्शक दिया गया है: एक C फंक्शन को कॉल करना जो दो पूर्णांकों को जोड़ता है, API मोड का उपयोग करके (नए कोड के लिए अनुशंसित)।

1. **FFI को इम्पोर्ट और सेट अप करें**:
   ```python
   from cffi import FFI
   ffibuilder = FFI()
   ```

2. **C डिक्लेरेशन डिफाइन करें**:
   एक स्ट्रिंग में C फंक्शन सिग्नेचर निर्दिष्ट करें:
   ```python
   ffibuilder.cdef("""
       int add(int a, int b);
   """)
   ```

3. **C सोर्स कोड प्रदान करें**:
   C इम्प्लीमेंटेशन शामिल करें:
   ```python
   ffibuilder.set_source("_example",
       """
       int add(int a, int b) {
           return a + b;
       }
       """)
   ```

4. **मॉड्यूल को कंपाइल करें**:
   C एक्सटेंशन बनाने के लिए इस स्क्रिप्ट को एक बार रन करें:
   ```python
   if __name__ == "__main__":
       ffibuilder.compile(verbose=True)
   ```
   यह एक कंपाइल्ड मॉड्यूल उत्पन्न करता है (जैसे, `_example.cpython-39-x86_64-linux-gnu.so`)।

5. **कंपाइल्ड मॉड्यूल का उपयोग करें**:
   अपने Python कोड में, फंक्शन को इम्पोर्ट और कॉल करें:
   ```python
   from _example import lib
   result = lib.add(5, 3)
   print(result)  # आउटपुट: 8
   ```

### मुख्य अवधारणाएँ
- **FFI ऑब्जेक्ट**: मुख्य इंटरफेस, `FFI()` के साथ बनाया गया। डिक्लेरेशन के लिए `cdef()` और कोड के लिए `set_source()` का उपयोग करें।
- **डिक्लेरेशन**: Python को C टाइप्स, स्ट्रक्चर्स, फंक्शन्स आदि के बारे में बताता है। स्ट्रिंग्स को C सिंटैक्स से बिल्कुल मेल खाना चाहिए।
- **टाइप कनवर्जन**: CFFI बेसिक टाइप्स (int, float, पॉइंटर्स) को स्वचालित रूप से हैंडल करती है। जटिलता के लिए ऐरे, स्ट्रक्चर्स, या कॉलबैक्स का उपयोग करें।
- **एरर हैंडलिंग**: अमान्य C डेफिनिशन के लिए `CDefError` जैसे एक्सेप्शन होते हैं। C रनटाइम एरर्स (जैसे, `errno` के माध्यम से) को `ffi.errno` से चेक किया जा सकता है।
- **मेमोरी मैनेजमेंट**: C स्ट्रक्चर्स/ऐरे के लिए `ffi.new()` का उपयोग करें, और लीक से बचने के लिए उचित डीलोकेशन सुनिश्चित करें।

### मोड: ABI बनाम API
- **ABI मोड** (मौजूदा लाइब्रेरीज़ के लिए): एक शेयर्ड लाइब्रेरी लोड करें (जैसे, `ffi.dlopen("mylib.so")`) और फंक्शन्स को सीधे कॉल करें। उदाहरण:
  ```python
  from cffi import FFI
  ffi = FFI()
  ffi.cdef("int add(int a, int b);")
  lib = ffi.dlopen("/path/to/libmylib.so")
  result = lib.add(5, 3)
  ```
  यह पहले से बनी लाइब्रेरीज़ के लिए तेज़ है लेकिन कम पोर्टेबल है—आपको सटीक बाइनरी की आवश्यकता होती है।

- **API मोड** (अनुशंसित): C कोड को इनलाइन कंपाइल करें, जैसा कि ऊपर के उदाहरण में है। यह अधिक सुरक्षित है, बेहतर ऑप्टिमाइज़ करता है, और सभी प्लेटफॉर्म्स पर काम करता है।

### एडवांस्ड फीचर्स
- **स्ट्रक्चर्स और यूनियन्स**: जटिल टाइप्स डिफाइन करें, जैसे, `cdef("struct Point { int x, y; }")`।
- **ऐरे और पॉइंटर्स**: ऐरे के लिए `ffi.new("int[10]")` या कास्ट के लिए `ffi.cast("int*", ptr)` का उपयोग करें।
- **कॉलबैक्स**: `ffi.callback()` का उपयोग करके Python फंक्शन्स को C में पास करें।
- **पैकेजेस के साथ इंटीग्रेशन**: कई लाइब्रेरीज़ (जैसे, cryptography, NumPy) परफॉर्मेंस के लिए CFFI का उपयोग करती हैं।
- **परफॉर्मेंस टिप्स**: कंपाइलेशन में समय लगता है; वितरण के लिए इनप्लेस बिल्ड्स या cffi पैकेजेस का उपयोग करें। लूप्स में भारी Python-C ट्रांजिशन से बचें।

पूर्ण डॉक्यूमेंटेशन के लिए, [ऑफिशियल CFFI डॉक्स](https://cffi.readthedocs.io/) देखें। यह मूल बातें कवर करता है—अपनी आवश्यकताओं के अनुकूल बनाने के लिए उदाहरणों के साथ प्रयोग करें। यदि आपके पास कोई विशिष्ट उपयोग केस है, तो तैयार सलाह के लिए अधिक विवरण प्रदान करें।