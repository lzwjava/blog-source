---
audio: false
generated: true
lang: hi
layout: post
title: 'Java Naming and Directory Interface (JNDI) का अनुवाद:


  Java Naming and Directory Interface (JNDI)'
translated: true
---

### मुख्य बिंदु
- यह प्रतीत होता है कि `javax.naming` Java Naming and Directory Interface (JNDI) का उपयोग करके डेटाबेस जैसे सेवाओं में नामित वस्तुओं को खोजने और प्रबंधित करने के लिए किया जाता है।
- अनुसंधान से पता चलता है कि आपको शुरू करने के लिए एक प्रारंभिक सन्दर्भ की आवश्यकता होती है, जो आमतौर पर एक Java EE अनुप्रयोग सर्वर द्वारा उत्पादन के लिए सेट अप किया जाता है, या परीक्षण के लिए मैन्युअल रूप से।
- सबूत `InitialContext` का उपयोग करने की ओर इशारा करते हैं, जैसे कि "java:comp/env/jdbc/datasource" जैसे नामों से एक DataSource खोजने के लिए।

### `javax.naming` से शुरू करना
`javax.naming` JNDI का हिस्सा है, जो Java अनुप्रयोगों को नाम और डायरेक्टरी सेवाओं के साथ बातचीत करने में मदद करता है, जैसे कि डेटाबेस कनेक्शन खोजने में। एक Java EE पर्यावरण में, अनुप्रयोग सर्वर आमतौर पर इसे सेट अप करता है, जिससे नामों द्वारा संसाधनों को खोजना आसान हो जाता है।

### उदाहरण उपयोग
एक Java EE अनुप्रयोग में एक DataSource खोजने का एक सरल तरीका है:
```java
InitialContext ctx = new InitialContext();
DataSource ds = (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
```
यह मानता है कि DataSource आपके सर्वर पर पहले से ही कॉन्फ़िगर किया गया है। एक सर्वर के बिना परीक्षण के लिए, आपको Simple-JNDI जैसे अतिरिक्त लाइब्रेरी की आवश्यकता हो सकती है।

### अप्रत्याशित विवरण
आप शायद यह नहीं अपेक्षित करेंगे कि स्वतंत्र अनुप्रयोगों के लिए, JNDI सेट अप करने में एक कस्टम सन्दर्भ को कॉन्फ़िगर करने की आवश्यकता हो सकती है, जो Simple-JNDI जैसे औजारों के बिना जटिल हो सकती है।

---

### सर्वेक्षण नोट: `javax.naming` का उपयोग करने का व्यापक मार्गदर्शन

यह नोट `javax.naming` का उपयोग करने का एक विस्तृत अन्वेषण प्रदान करता है, जो Java Naming and Directory Interface (JNDI) का हिस्सा है, जो Java अनुप्रयोगों में नाम और डायरेक्टरी सेवाओं के साथ बातचीत को सुविधाजनक बनाता है। JNDI को विशेष सेवा कार्यान्वयन से स्वतंत्र बनाया गया है, जिससे डेटाबेस, LDAP और फ़ाइल सिस्टम जैसे विभिन्न सेवाओं तक एकीकृत तरीके से पहुंचा जा सकता है। इस खंड में सीधे उत्तर पर विस्तार किया गया है, जो विकसकों के लिए एक गहन समझ प्रदान करता है, जिसमें सेटअप, उदाहरण और विभिन्न पर्यावरणों के लिए विचार शामिल हैं।

#### `javax.naming` और JNDI समझना
`javax.naming` JNDI का कोर पैकेज है, जो Java के मानक लाइब्रेरी का हिस्सा है, जो नाम और डायरेक्टरी कार्यक्षमता प्रदान करता है। यह `Context` इंटरफ़ेस को परिभाषित करता है, जो JNDI ऑपरेशनों के केंद्र में है, जिसमें वस्तुओं को खोजने, बाइंड करने, अनबाइंड करने और रीनेम करने, साथ ही सबकॉनटेक्स्ट बनाना और नष्ट करना शामिल है। `lookup()` विधि को आमतौर पर नामों द्वारा वस्तुओं को प्राप्त करने के लिए उपयोग किया जाता है, जिससे एंटरप्राइज़ अनुप्रयोगों में संसाधनों तक पहुंचने में आवश्यक बन जाता है।

JNDI विशेष रूप से Java EE पर्यावरणों में उपयोगी है, जहां यह अनुप्रयोगों को विशेष सेवा विवरणों से अलग होने की अनुमति देता है, जिससे पोर्टेबिलिटी और लचीलापन बढ़ जाता है। उदाहरण के लिए, इसे डेटाबेस कनेक्शन (DataSources), JMS प्रोवाइडर और JavaMail सेवाओं जैसे संसाधनों तक पहुंचने के लिए अक्सर उपयोग किया जाता है, जो अनुप्रयोग सर्वर द्वारा प्रबंधित होते हैं।

#### JNDI सेटअप और उपयोग
`javax.naming` का उपयोग करने के लिए, आप एक प्रारंभिक सन्दर्भ बनाते हैं, जो नाम ऑपरेशनों के लिए प्रवेश द्वार के रूप में कार्य करता है। यह आमतौर पर `InitialContext` क्लास का उपयोग करके किया जाता है। सेटअप पर्यावरण पर निर्भर करता है:

- **Java EE अनुप्रयोगों में:** अनुप्रयोग सर्वर (जैसे टोमकैट, जबॉस, वेबस्पीयर) प्रारंभिक सन्दर्भ को कॉन्फ़िगर करता है। आप मानक JNDI नामों का उपयोग करके संसाधनों को खोज सकते हैं, जो अक्सर "java:comp/env/" से शुरू होते हैं। उदाहरण के लिए, एक DataSource को "java:comp/env/jdbc/datasource" पर पहुंचा जा सकता है।
- **स्वतंत्र अनुप्रयोगों में:** बिना अनुप्रयोग सर्वर के, आपको प्रारंभिक सन्दर्भ को मैन्युअल रूप से कॉन्फ़िगर करना होगा, जिसमें नाम सेवा प्रोवाइडर और URL जैसे गुणों को स्पष्ट करना शामिल है। यह जटिल हो सकता है, जिसमें परीक्षण के लिए अतिरिक्त लाइब्रेरी की आवश्यकता हो सकती है, जैसे Simple-JNDI, जो एक मेमोरी-आधारित कार्यान्वयन प्रदान करता है।

यहाँ एक तालिका है जो `javax.naming` में मुख्य क्लासों और उनके भूमिकाओं का सारांश प्रदान करती है:

| क्लास/इंटरफ़ेस        | भूमिका                                                                 |
|-------------------------|----------------------------------------------------------------------|
| `Context`              | नाम ऑपरेशनों जैसे खोज, बाइंड और अनबाइंड के लिए कोर इंटरफ़ेस।   |
| `InitialContext`       | JNDI ऑपरेशनों को शुरू करने के लिए प्रारंभिक सन्दर्भ बनाता है।             |
| `Name`                 | एक सामान्य नाम, एक क्रमबद्ध घटकों का अनुक्रम।         |
| `NamingException`      | नाम ऑपरेशनों के दौरान फेंके गए अपवादों का आधार क्लास।            |

#### व्यावहारिक उदाहरण
Java EE और स्वतंत्र परिस्थितियों के लिए उदाहरणों का अन्वेषण करें:

##### उदाहरण 1: Java EE में एक DataSource खोजना
एक Java EE अनुप्रयोग में, आप एक कॉन्फ़िगर किए गए DataSource को निम्नलिखित तरीके से खोज सकते हैं:

```java
import javax.naming.InitialContext;
import javax.sql.DataSource;
import java.sql.*;

public class JNDIExample {
    public static void main(String[] args) throws Exception {
        InitialContext ctx = new InitialContext();
        DataSource ds = (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
        Connection conn = ds.getConnection();
        // कनेक्शन का उपयोग करें...
        conn.close();
        ctx.close();
    }
}
```

यह उदाहरण मानता है कि DataSource अनुप्रयोग सर्वर में कॉन्फ़िगर किया गया है, आमतौर पर टोमकैट के लिए `context.xml` जैसे फ़ाइलों में। JNDI नाम "java:comp/env/jdbc/datasource" एक मानक परंपरा है, लेकिन यह सर्वर कॉन्फ़िगरेशन पर निर्भर करता है।

##### उदाहरण 2: एक कस्टम वस्तु बाइंड और खोजना
परीक्षण या स्वतंत्र उपयोग के लिए, आप एक सरल मेमोरी-आधारित सन्दर्भ बनाना चाह सकते हैं। जबकि मानक API में एक मेमोरी-आधारित सन्दर्भ फैक्टरी शामिल नहीं है, लाइब्रेरी जैसे Simple-JNDI मदद कर सकते हैं। यहाँ एक संकल्पनात्मक उदाहरण है, जो ऐसे सेटअप को मानता है:

```java
import javax.naming.*;

public class JNDIExample {
    public static void main(String[] args) throws NamingException {
        Context ctx = new InitialContext();
        ctx.rebind("myObject", "Hello, World!");
        String value = (String) ctx.lookup("myObject");
        System.out.println(value);
        ctx.close();
    }
}
```

ध्यान दें: इस स्वतंत्र उदाहरण में प्रारंभिक सन्दर्भ को सही गुणों के साथ कॉन्फ़िगर करने की आवश्यकता होती है, जो `java.naming.factory.initial` को एक कस्टम सन्दर्भ फैक्टरी, जैसे Simple-JNDI द्वारा प्रदान किए गए, सेट करने की आवश्यकता हो सकती है।

#### विभिन्न पर्यावरणों के लिए विचार
- **उत्पादन (Java EE):** उत्पादन में, अनुप्रयोग सर्वर JNDI सेटअप का प्रबंधन करता है, जिससे संसाधनों को खोजना आसान हो जाता है। यह आमतौर पर डेटाबेस कनेक्शन पूल के लिए JNDI का उपयोग किया जाता है, जहां सर्वर कनेक्शन प्रबंधित करता है, जिससे पैमाने और सुरक्षा में सुधार होता है। उदाहरण के लिए, डेटाबेस प्रमाणपत्रों को बदलने के लिए केवल सर्वर कॉन्फ़िगरेशन को अपडेट करना होगा, नहीं अनुप्रयोग कोड।
- **परीक्षण (स्वतंत्र):** यूनिट और इंटिग्रेशन टेस्ट के लिए, बिना अनुप्रयोग सर्वर के चलाना अक्सर आवश्यक होता है। लाइब्रेरी जैसे Simple-JNDI ([Simple-JNDI GitHub](https://github.com/h-thurow/Simple-JNDI)) आपको JNDI पर्यावरणों को सिमुलेट करने की अनुमति देते हैं, संसाधनों को प्रोग्रामेटिक रूप से बाइंड करते हुए। यह JNDI खोजों पर निर्भर अनुप्रयोग कोड को काम करने के लिए सुनिश्चित करने के लिए आवश्यक है, जिससे यह बिना सर्वर पर डिप्लॉय करने के काम करे।

#### सुरक्षा और सर्वश्रेष्ठ अभ्यास
JNDI इंजेक्शन के साथ सावधान रहें, विशेष रूप से पुराने Java संस्करणों में, क्योंकि वे रिमोट कोड एक्सिक्यूशन जैसे सुरक्षा कमजोरियों को जन्म दे सकते हैं। Oracle ने कई ऐसे मुद्दों को हल किया है, जैसे कि Java 8u191 में LDAP वेक्टर खामियों को बंद करने के लिए अपडेट। हमेशा इनपुट को वैलिडेट करें और सुरक्षा के लिए नवीनतम Java संस्करण का उपयोग करें।

#### अप्रत्याशित विवरण: स्वतंत्र सेटअप में जटिलता
आप शायद स्वतंत्र सेटअप में JNDI को सेटअप करने में शामिल जटिलता का अनुमान नहीं लगाएंगे। जबकि Java EE इसे सर्वर-प्रबंधित सन्दर्भों के साथ सरल बनाता है, स्वतंत्र सेटअप में सन्दर्भ फैक्टरी और गुणों को कॉन्फ़िगर करने की आवश्यकता होती है, अक्सर तीसरे पक्ष के लाइब्रेरी की आवश्यकता होती है। यह JNDI के नए विकसकों के लिए एक बाधा हो सकती है, लेकिन औजार जैसे Simple-JNDI इसे कम करने में मदद करते हैं, जो मेमोरी-आधारित कार्यान्वयन प्रदान करते हैं।

#### आगे पढ़ने और संसाधन
गहन समझ के लिए, निम्नलिखित पर विचार करें:
- [Oracle Java Tutorials: JNDI Overview](https://docs.oracle.com/en/ java/ tutorial/jndi/ overview/index.html) आधिकारिक दस्तावेज़ के लिए।
- [Baeldung: Java Naming and Directory Interface Overview](https://www.baeldung.com/jndi) व्यावहारिक उदाहरणों और आधुनिक उपयोग के लिए।
- [Simple-JNDI GitHub](https://github.com/h-thurow/Simple-JNDI) बिना सर्वरों के JNDI परीक्षण के लिए।

ये संसाधन कोड उदाहरण, ट्यूटोरियल और सर्वश्रेष्ठ अभ्यास प्रदान करते हैं, जिससे आप विभिन्न परिस्थितियों में JNDI को प्रभावी रूप से लागू कर सकते हैं।

#### मुख्य संदर्भ
- [Oracle Java Tutorials JNDI Overview](https://docs.oracle.com/en/ java/ tutorial/jndi/ overview/index.html)
- [Baeldung Java Naming and Directory Interface Overview](https://www.baeldung.com/jndi)
- [Simple-JNDI Access property files via JNDI lookups](https://github.com/h-thurow/Simple-JNDI)