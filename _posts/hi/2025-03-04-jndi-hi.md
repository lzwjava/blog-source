---
audio: false
generated: true
lang: hi
layout: post
title: जावा नामकरण और निर्देशिका इंटरफेस
translated: true
type: note
---

### मुख्य बिंदु
- ऐसा लगता है कि `javax.naming` का उपयोग Java Naming और Directory Interface (JNDI) के लिए किया जाता है ताकि डेटाबेस जैसी सेवाओं में नामित ऑब्जेक्ट्स को देखा और प्रबंधित किया जा सके।
- शोध से पता चलता है कि शुरुआत करने के लिए आपको एक प्रारंभिक संदर्भ (initial context) की आवश्यकता होती है, जो आमतौर पर प्रोडक्शन के लिए Java EE एप्लिकेशन सर्वर द्वारा, या टेस्टिंग के लिए मैन्युअल रूप से सेटअप किया जाता है।
- सबूत `InitialContext` का उपयोग करने की ओर इशारा करते हैं, जैसे कि "java:comp/env/jdbc/datasource" जैसे नामों के साथ DataSource ढूंढना।

### `javax.naming` के साथ शुरुआत करना
`javax.naming` JNDI का हिस्सा है, जो Java एप्लिकेशन को नामकरण और निर्देशिका सेवाओं, जैसे डेटाबेस कनेक्शन ढूंढने, के साथ इंटरैक्ट करने में मदद करता है। Java EE एनवायरनमेंट में, एप्लिकेशन सर्वर आमतौर पर इसे सेटअप करता है, जिससे संसाधनों को उनके नाम से ढूंढना आसान हो जाता है।

### उदाहरण उपयोग
यहाँ एक Java EE ऐप में DataSource ढूंढने का एक सरल तरीका है:
```java
InitialContext ctx = new InitialContext();
DataSource ds = (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
```
यह मानता है कि DataSource आपके सर्वर में पहले से ही कॉन्फ़िगर है। सर्वर के बिना टेस्टिंग के लिए, आपको Simple-JNDI जैसी अतिरिक्त लाइब्रेरीज़ की आवश्यकता हो सकती है।

### अप्रत्याशित विवरण
आप शायद यह उम्मीद नहीं करेंगे कि स्टैंडअलोन एप्लिकेशन के लिए, JNDI सेटअप करने में एक कस्टम संदर्भ (custom context) कॉन्फ़िगर करना आवश्यक हो सकता है, जो Simple-JNDI जैसे टूल्स के बिना जटिल हो सकता है।

---

### सर्वे नोट: `javax.naming` का उपयोग करने के लिए व्यापक गाइड

यह नोट `javax.naming` के उपयोग की एक विस्तृत जांच प्रदान करता है, जो Java Naming और Directory Interface (JNDI) का हिस्सा है, जो Java एप्लिकेशन में नामकरण और निर्देशिका सेवाओं के साथ इंटरैक्शन की सुविधा प्रदान करता है। JNDI को विशिष्ट सेवा कार्यान्वयन से स्वतंत्र होने के लिए डिज़ाइन किया गया है, जो विभिन्न सेवाओं जैसे डेटाबेस, LDAP, और फ़ाइल सिस्टम तक एकीकृत तरीके से पहुंच की अनुमति देता है। यह खंड सीधे उत्तर का विस्तार करता है, जो डेवलपर्स के लिए एक संपूर्ण समझ प्रदान करता है, जिसमें सेटअप, उदाहरण और विभिन्न वातावरणों के लिए विचार शामिल हैं।

#### `javax.naming` और JNDI को समझना
`javax.naming` JNDI के लिए कोर पैकेज है, जो Java की स्टैंडर्ड लाइब्रेरी के हिस्से के रूप में नामकरण और निर्देशिका कार्यक्षमता प्रदान करने के लिए पेश किया गया है। यह `Context` इंटरफेस को परिभाषित करता है, जो JNDI ऑपरेशन के लिए केंद्रीय है, जिसमें ऑब्जेक्ट्स को देखने (lookup), बांधने (bind), खोलने (unbind) और नाम बदलने (rename) के साथ-साथ उप-संदर्भ (subcontexts) बनाने और नष्ट करने के तरीके शामिल हैं। `lookup()` विधि का उपयोग आमतौर पर उनके नाम से ऑब्जेक्ट्स को पुनः प्राप्त करने के लिए किया जाता है, जो इसे एंटरप्राइज़ एप्लिकेशन में संसाधन पहुंच के लिए आवश्यक बनाता है।

JNDI विशेष रूप से Java EE वातावरण में उपयोगी है, जहाँ यह एप्लिकेशन को विशिष्ट सेवा विवरणों से अलग करने की अनुमति देता है, जिससे पोर्टेबिलिटी और लचीलापन बढ़ता है। उदाहरण के लिए, इसका उपयोग अक्सर डेटाबेस कनेक्शन (DataSources), JMS प्रोवाइडर, और JavaMail सेवाओं जैसे संसाधनों तक पहुंचने के लिए किया जाता है, जिन्हें एप्लिकेशन सर्वर द्वारा प्रबंधित किया जाता है।

#### JNDI को सेटअप और उपयोग करना
`javax.naming` का उपयोग करने के लिए, आप एक प्रारंभिक संदर्भ (initial context) बनाकर शुरुआत करते हैं, जो नामकरण ऑपरेशन के लिए एंट्री पॉइंट के रूप में कार्य करता है। यह आमतौर पर `InitialContext` क्लास का उपयोग करके किया जाता है। सेटअप वातावरण के आधार पर भिन्न होता है:

- **Java EE एप्लिकेशन में:** एप्लिकेशन सर्वर (जैसे, Tomcat, JBoss, WebSphere) प्रारंभिक संदर्भ को कॉन्फ़िगर करता है। आप मानक JNDI नामों का उपयोग करके संसाधनों को देख सकते हैं, जिनमें अक्सर "java:comp/env/" उपसर्ग होता है। उदाहरण के लिए, एक DataSource तक "java:comp/env/jdbc/datasource" पर पहुंचा जा सकता है।
- **स्टैंडअलोन एप्लिकेशन में:** एप्लिकेशन सर्वर के बिना, आपको प्रारंभिक संदर्भ को मैन्युअल रूप से कॉन्फ़िगर करने की आवश्यकता होती है, जिसमें नामकरण सेवा प्रदाता और URL जैसी विशेषताएं निर्दिष्ट करनी होती हैं। यह जटिल हो सकता है, और टेस्टिंग के लिए अतिरिक्त लाइब्रेरीज़, जैसे Simple-JNDI, की आवश्यकता हो सकती है, जो एक इन-मेमोरी कार्यान्वयन प्रदान करती है।

यहाँ `javax.naming` में प्रमुख कक्षाओं और उनकी भूमिकाओं को सारांशित करने वाली तालिका दी गई है:

| क्लास/इंटरफेस         | भूमिका                                                                 |
|-------------------------|------------------------------------------------------------------------|
| `Context`              | नामकरण ऑपरेशन जैसे lookup, bind, और unbind के लिए कोर इंटरफेस।        |
| `InitialContext`       | JNDI ऑपरेशन शुरू करने के लिए प्रारंभिक संदर्भ बनाता है।               |
| `Name`                 | एक सामान्य नाम, घटकों का एक क्रमबद्ध अनुक्रम, का प्रतिनिधित्व करता है।|
| `NamingException`      | नामकरण ऑपरेशन के दौरान फेंके गए अपवादों के लिए बेस क्लास।             |

#### व्यावहारिक उदाहरण
आइए Java EE और स्टैंडअलोन दोनों परिदृश्यों के लिए उदाहरणों का पता लगाएं:

##### उदाहरण 1: Java EE में DataSource ढूंढना
एक Java EE एप्लिकेशन में, आप एक कॉन्फ़िगर किया गया DataSource इस प्रकार देख सकते हैं:

```java
import javax.naming.InitialContext;
import javax.sql.DataSource;
import java.sql.*;

public class JNDIExample {
    public static void main(String[] args) throws Exception {
        InitialContext ctx = new InitialContext();
        DataSource ds = (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
        Connection conn = ds.getConnection();
        // कनेक्शन का उपयोग करें...
        conn.close();
        ctx.close();
    }
}
```

यह उदाहरण मानता है कि DataSource एप्लिकेशन सर्वर में कॉन्फ़िगर है, जो आमतौर पर Tomcat के लिए `context.xml` जैसी फ़ाइलों में होता है। JNDI नाम "java:comp/env/jdbc/datasource" एक मानक कन्वेंशन है, लेकिन यह सर्वर कॉन्फ़िगरेशन के आधार पर भिन्न हो सकता है।

##### उदाहरण 2: कस्टम ऑब्जेक्ट को बाइंड और लुकअप करना
टेस्टिंग या स्टैंडअलोन उपयोग के लिए, आप एक सरल इन-मेमोरी संदर्भ बनाना चाह सकते हैं। हालांकि स्टैंडर्ड API में एक इन-मेमोरी कॉन्टेक्स्ट फैक्टरी शामिल नहीं है, लाइब्रेरीज़ जैसे Simple-JNDI मदद कर सकती हैं। यहाँ एक वैचारिक उदाहरण दिया गया है जो ऐसे सेटअप को मानता है:

```java
import javax.naming.*;

public class JNDIExample {
    public static void main(String[] args) throws NamingException {
        Context ctx = new InitialContext();
        ctx.rebind("myObject", "Hello, World!");
        String value = (String) ctx.lookup("myObject");
        System.out.println(value);
        ctx.close();
    }
}
```

नोट: इस स्टैंडअलोन उदाहरण के लिए उचित गुणों (properties) के साथ प्रारंभिक संदर्भ को कॉन्फ़िगर करने की आवश्यकता होती है, जिसमें `java.naming.factory.initial` को एक कस्टम कॉन्टेक्स्ट फैक्टरी पर सेट करना शामिल हो सकता है, जैसे कि Simple-JNDI द्वारा प्रदान किया गया।

#### विभिन्न वातावरणों के लिए विचार
- **प्रोडक्शन (Java EE):** प्रोडक्शन में, एप्लिकेशन सर्वर JNDI सेटअप को संभालता है, जिससे संसाधनों को देखना सीधा हो जाता है। डेटाबेस कनेक्शन पूल के लिए JNDI का उपयोग करना आम है, जहाँ सर्वर कनेक्शन प्रबंधित करता है, जिससे स्केलेबिलिटी और सुरक्षा में सुधार होता है। उदाहरण के लिए, डेटाबेस क्रेडेंशियल बदलने के लिए केवल सर्वर कॉन्फ़िगरेशन को अपडेट करने की आवश्यकता होती है, एप्लिकेशन कोड को नहीं।
- **टेस्टिंग (स्टैंडअलोन):** यूनिट और इंटीग्रेशन टेस्ट के लिए, एप्लिकेशन सर्वर के बिना चलाना अक्सर आवश्यक होता है। Simple-JNDI ([Simple-JNDI GitHub](https://github.com/h-thurow/Simple-JNDI)) जैसी लाइब्रेरीज़ आपको JNDI वातावरण का अनुकरण करने की अनुमति देती हैं, जिससे संसाधनों को प्रोग्रामेटिक रूप से बांधा जा सकता है। यह उस कोड को टेस्ट करने के लिए महत्वपूर्ण है जो JNDI लुकअप पर निर्भर करता है, यह सुनिश्चित करते हुए कि यह सर्वर पर डिप्लॉय किए बिना काम करता है।
- **सुरक्षा और सर्वोत्तम प्रथाएँ:** JNDI इंजेक्शन से सावधान रहें, विशेष रूप से पुराने Java वर्जन में, क्योंकि ये रिमोट कोड एक्जिक्यूशन जैसी सुरक्षा कमजोरियों का कारण बन सकते हैं। Oracle ने ऐसे कई मुद्दों को संबोधित किया है, जैसे Java 8u191 के अपडेट के साथ LDAP वेक्टर एक्सप्लॉइट्स को बंद करना। सुरक्षा के लिए हमेशा इनपुट वैलिडेट करें और नवीनतम Java वर्जन का उपयोग करें।

#### अप्रत्याशित विवरण: स्टैंडअलोन सेटअप में जटिलता
कोई यह उम्मीद नहीं कर सकता कि एप्लिकेशन सर्वर के बिना JNDI सेटअप करने में शामिल जटिलता। जबकि Java EE सर्वर-प्रबंधित संदर्भों के साथ इसे सरल बनाता है, स्टैंडअलोन सेटअप में कॉन्टेक्स्ट फैक्टरी और गुणों को कॉन्फ़िगर करना आवश्यक होता है, जिसके लिए अक्सर तृतीय-पक्ष लाइब्रेरीज़ की आवश्यकता होती है। यह JNDI में नए डेवलपर्स के लिए एक बाधा हो सकती है, लेकिन Simple-JNDI जैसे टूल मेमोरी-आधारित कार्यान्वयन प्रदान करके इसे कम करते हैं।

#### आगे पढ़ने और संसाधन
गहरी समझ के लिए, निम्नलिखित से परामर्श लें:
- आधिकारिक दस्तावेज़ के लिए [Oracle Java Tutorials: JNDI Overview](https://docs.oracle.com/en/ java/ tutorial/jndi/ overview/index.html)।
- व्यावहारिक उदाहरण और आधुनिक उपयोग के लिए [Baeldung: Java Naming and Directory Interface Overview](https://www.baeldung.com/jndi)।
- सर्वर के बिना JNDI टेस्ट करने के लिए [Simple-JNDI GitHub](https://github.com/h-thurow/Simple-JNDI)।

ये संसाधन कोड उदाहरण, ट्यूटोरियल और सर्वोत्तम प्रथाएँ प्रदान करते हैं, यह सुनिश्चित करते हुए कि आप विभिन्न परिदृश्यों में JNDI को प्रभावी ढंग से लागू कर सकते हैं।

#### प्रमुख उद्धरण
- [Oracle Java Tutorials JNDI Overview](https://docs.oracle.com/en/ java/ tutorial/jndi/ overview/index.html)
- [Baeldung Java Naming and Directory Interface Overview](https://www.baeldung.com/jndi)
- [Simple-JNDI Access property files via JNDI lookups](https://github.com/h-thurow/Simple-JNDI)