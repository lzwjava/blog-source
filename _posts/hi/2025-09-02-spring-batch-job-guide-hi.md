---
audio: false
generated: true
image: false
lang: hi
layout: post
title: स्प्रिंग बैच जॉब एक्सेक्यूशन गाइड
translated: true
type: note
---

स्प्रिंग बैच स्प्रिंग इकोसिस्टम का एक हल्का, ओपन-सोर्स फ्रेमवर्क है जिसे **बैच प्रोसेसिंग** — बड़ी मात्रा में डेटा को विश्वसनीय और स्केलेबल तरीके से पढ़ने, प्रोसेस करने और लिखने वाले जॉब्स को निष्पादित करने के लिए डिज़ाइन किया गया है।

यहाँ एक स्प्रिंग बैच जॉब के काम करने का व्यापक विवरण दिया गया है:

---

## 1. मुख्य अवधारणाएँ

* **जॉब**
  जॉब सबसे शीर्ष स्तर की इकाई है। यह पूरी बैच प्रक्रिया को दर्शाता है और एक या अधिक स्टेप्स से मिलकर बना होता है।

* **स्टेप**
  प्रत्येक स्टेप जॉब में एक चरण का प्रतिनिधित्व करता है (जैसे, पढ़ना → प्रोसेस करना → लिखना)। स्टेप्स चंक-ओरिएंटेड या टास्कलेट-ओरिएंटेड हो सकते हैं।

* **जॉबलॉन्चर**
  यह कंपोनेंट एक जॉब को शुरू करने के लिए जिम्मेदार होता है, आमतौर पर कोड, एक शेड्यूलर (Quartz, cron), या कमांड लाइन के माध्यम से ट्रिगर किया जाता है।

* **जॉबरिपॉजिटरी**
  यह एक डेटाबेस-बैक्ड स्टोर है जो जॉब एक्जिक्यूशन के बारे में मेटाडेटा रखता है, जैसे स्थिति, शुरू/समाप्ति समय, एक्जिट कोड, और रीस्टार्ट पॉइंट्स।

* **जॉबएक्जिक्यूशन और स्टेपएक्जिक्यूशन**
  ये एक जॉब और उसके स्टेप्स की रनटाइम स्थिति का प्रतिनिधित्व करते हैं, जिसमें सफलता, विफलता, या आंशिक पूर्णता शामिल है।

---

## 2. निष्पादन प्रवाह

1. **जॉब लॉन्च**
   एक `JobLauncher` एक `Job` इंस्टेंस और `JobParameters` पास करके जॉब शुरू करता है।

2. **जॉब इंस्टेंस और मेटाडेटा**
   फ्रेमवर्क `JobRepository` जांचता है कि क्या उन पैरामीटर्स वाली जॉब इंस्टेंस पहले से मौजूद है।

   * यदि हाँ, तो यह जारी रख सकता है/दोबारा शुरू कर सकता है।
   * यदि नहीं, तो यह एक नई इंस्टेंस बनाता है।

3. **स्टेप निष्पादन**
   प्रत्येक स्टेप क्रमिक रूप से चलता है (जब तक कि आप समानांतर फ्लो कॉन्फ़िगर नहीं करते)।

   * यदि एक स्टेप विफल हो जाता है और उसे "रीस्टार्ट की अनुमति" के लिए सेट नहीं किया गया है, तो जॉब रुक जाता है।
   * अन्यथा, जॉब अगले स्टेप पर जारी रहता है।

4. **चंक-ओरिएंटेड प्रोसेसिंग** (सबसे आम)

   * **रीडर**: डेटा का एक चंक पढ़ता है (जैसे, किसी फ़ाइल/डीबी से 100 रिकॉर्ड)।
   * **प्रोसेसर**: वैकल्पिक रूप से डेटा को ट्रांसफॉर्म या वैलिडेट करता है।
   * **राइटर**: प्रोसेस्ड चंक को एक टार्गेट (जैसे, डीबी, फ़ाइल, एपीआई) में लिखता है।
   * कमिट के बाद, स्प्रिंग बैच `JobRepository` में चेकपॉइंट को सहेज देता है।

5. **फॉल्ट टॉलरेंस**

   * रिट्राय लॉजिक, स्किप पॉलिसीज़, और रीस्टार्ट क्षमताएँ अंतर्निहित होती हैं।
   * यदि जॉब क्रैश हो जाती है, तो यह अंतिम कमिट किए गए चेकपॉइंट से दोबारा शुरू हो सकती है।

---

## 3. उदाहरण

एक CSV फ़ाइल को प्रोसेस करने की कल्पना करें:

* **रीडर**: `FlatFileItemReader` CSV से पंक्तियाँ लोड करता है।
* **प्रोसेसर**: एक कस्टम क्लास उन्हें वैलिडेट करती है और डोमेन ऑब्जेक्ट्स में कन्वर्ट करती है।
* **राइटर**: `JdbcBatchItemWriter` उन्हें बैचों में एक डेटाबेस में इन्सर्ट करता है।
* **जॉब फ्लो**:

  * स्टेप 1: लेन-देन को पढ़ें/प्रोसेस करें/लिखें।
  * स्टेप 2: एक सारांश रिपोर्ट जनरेट करें।

---

## 4. फायदे

* डिक्लेरेटिव कॉन्फ़िगरेशन (Java config या XML)।
* स्केलेबल (समानांतर स्टेप्स, पार्टीशनिंग, रिमोट चंकिंग)।
* मजबूत एरर हैंडलिंग और रीस्टार्ट क्षमता।
* स्प्रिंग इकोसिस्टम के साथ एकीकरण (Spring Boot, Spring Data, आदि)।

---

✅ संक्षेप में: **एक स्प्रिंग बैच जॉब स्टेप्स की एक सुनिर्मित पाइपलाइन है जहाँ डेटा इनपुट → प्रोसेसिंग → आउटपुट की ओर बहता है, जिसमें अंतर्निहित लेन-देन प्रबंधन, फॉल्ट टॉलरेंस और रीस्टार्ट क्षमता होती है।**

---

क्या आप चाहते हैं कि मैं आपको एक स्प्रिंग बैच जॉब का **न्यूनतम Java config कोड उदाहरण** (रीडर, प्रोसेसर, राइटर के साथ) भी दिखाऊं ताकि आप देख सकें कि यह व्यवहार में कैसा दिखता है?