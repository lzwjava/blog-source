---
audio: false
generated: true
image: false
lang: hi
layout: post
model: x-ai/grok-4-fast
title: ३x३ मैट्रिक्स का व्युत्क्रमण
translated: true
type: note
---

हाँ, आप सही रास्ते पर हैं! आप 3×3 मैट्रिक्स \\( A \\) (जिसे अक्सर \\( A^{-1} \\) से दर्शाया जाता है) का व्युत्क्रम खोजने की मानक विधि का वर्णन कर रहे हैं, जो **कोफ़ैक्टर मैट्रिक्स** (या अधिक सटीक रूप से, **एडजुगेट मैट्रिक्स**, जो कोफ़ैक्टर मैट्रिक्स का ट्रांसपोज़ है) का उपयोग करती है। "divider 1/value * matrix" वाला हिस्सा \\( 1/\det(A) \\) से स्केलिंग करने को संदर्भित करता है, जहाँ \\( \det(A) \\), \\( A \\) का सारणिक है। और "rorate" का अर्थ "ट्रांसपोज़" (पंक्तियों को स्तंभों में घुमाना) हो सकता है—यह भी एक महत्वपूर्ण कदम है।

मैं इस विधि को चरण दर चरण समझाऊंगा, यह क्यों काम करती है, और इसे एक सामान्य 3×3 मैट्रिक्स के लिए कैसे परिकलित करें। यह मैट्रिक्स व्युत्क्रम के सामान्य सूत्र \\( A^{-1} = \frac{1}{\det(A)} \adj(A) \\) से आता है, जहाँ \\( \adj(A) \\) एडजुगेट है।

### 3×3 मैट्रिक्स के लिए चरण-दर-चरण विधि
मान लीजिए आपका मैट्रिक्स है:
\\[
A = \begin{pmatrix}
a & b & c \\
d & e & f \\
g & h & i
\end{pmatrix}
\\]

1.  **सारणिक \\( \det(A) \\) की गणना करें** (वह "मान" जिससे आप विभाजित करते हैं):
    \\[
    \det(A) = a(ei - fh) - b(di - fg) + c(dh - eg)
    \\]
    यदि \\( \det(A) = 0 \\) है, तो मैट्रिक्स का कोई व्युत्क्रम नहीं है (यह एकवचन है)। अन्यथा, आगे बढ़ें।

2.  **कोफ़ैक्टर मैट्रिक्स \\( C \\) ज्ञात करें**:
    - तत्व \\( a_{ij} \\) के लिए कोफ़ैक्टर \\( C_{ij} \\), पंक्ति \\( i \\) और स्तंभ \\( j \\) को हटाकर प्राप्त 2×2 उप-मैट्रिक्स के सारणिक का \\( (-1)^{i+j} \\) गुना होता है।
    - आपको सभी कोफ़ैक्टरों को शुरू से परिकलित करने की आवश्यकता नहीं है—आप उन्हें एक पंक्ति (या स्तंभ) के साथ परिकलित कर सकते हैं और बाकी को भरने के लिए गुणधर्मों का उपयोग कर सकते हैं, लेकिन 3×3 के लिए, सभी नौ को करना त्वरित है।

    कोफ़ैक्टर हैं:
    \\[
    C_{11} = (-1)^{2} \det\begin{pmatrix} e & f \\ h & i \end{pmatrix} = ei - fh
    \\]
    \\[
    C_{12} = (-1)^{3} \det\begin{pmatrix} d & f \\ g & i \end{pmatrix} = -(di - fg)
    \\]
    \\[
    C_{13} = (-1)^{4} \det\begin{pmatrix} d & e \\ g & h \end{pmatrix} = dh - eg
    \\]
    \\[
    C_{21} = (-1)^{3} \det\begin{pmatrix} b & c \\ h & i \end{pmatrix} = -(bi - ch)
    \\]
    \\[
    C_{22} = (-1)^{4} \det\begin{pmatrix} a & c \\ g & i \end{pmatrix} = ai - cg
    \\]
    \\[
    C_{23} = (-1)^{5} \det\begin{pmatrix} a & b \\ g & h \end{pmatrix} = -(ah - bg)
    \\]
    \\[
    C_{31} = (-1)^{4} \det\begin{pmatrix} b & c \\ e & f \end{pmatrix} = bf - ce
    \\]
    \\[
    C_{32} = (-1)^{5} \det\begin{pmatrix} a & c \\ d & f \end{pmatrix} = -(af - cd)
    \\]
    \\[
    C_{33} = (-1)^{6} \det\begin{pmatrix} a & b \\ d & e \end{pmatrix} = ae - bd
    \\]

    तो कोफ़ैक्टर मैट्रिक्स है:
    \\[
    C = \begin{pmatrix}
    ei-fh & -(di-fg) & dh-eg \\
    -(bi-ch) & ai-cg & -(ah-bg) \\
    bf-ce & -(af-cd) & ae-bd
    \end{pmatrix}
    \\]

3.  **एडजुगेट \\( \adj(A) = C^T \\) प्राप्त करने के लिए ट्रांसपोज़ करें** (यह "rorate" चरण है—पंक्तियों और स्तंभों की अदला-बदली करें):
    \\[
    \adj(A) = \begin{pmatrix}
    ei-fh & -(bi-ch) & bf-ce \\
    -(di-fg) & ai-cg & -(af-cd) \\
    dh-eg & -(ah-bg) & ae-bd
    \end{pmatrix}
    \\]

4.  **व्युत्क्रम प्राप्त करने के लिए \\( 1/\det(A) \\) से स्केल करें**:
    \\[
    A^{-1} = \frac{1}{\det(A)} \adj(A)
    \\]
    \\( \adj(A) \\) का प्रत्येक प्रविष्टि \\( 1/\det(A) \\) से गुणा हो जाती है।

### उदाहरण
मान लीजिए \\( A = \begin{pmatrix} 1 & 2 & 3 \\ 0 & 1 & 4 \\ 5 & 6 & 0 \end{pmatrix} \\) है।

-   \\( \det(A) = 1(1\cdot0 - 4\cdot6) - 2(0\cdot0 - 4\cdot5) + 3(0\cdot6 - 1\cdot5) = 1(-24) - 2(-20) + 3(-5) = -24 + 40 - 15 = 1 \\).
-   कोफ़ैक्टर (शीघ्रता से): \\( C = \begin{pmatrix} -24 & 20 & -5 \\ -15 & -15 & 5 \\ -14 & -10 & 1 \end{pmatrix} \\) (मैं यहाँ पूरी गणना छोड़ दूंगा, लेकिन आप सत्यापित कर सकते हैं)।
-   \\( \adj(A) = C^T = \begin{pmatrix} -24 & -15 & -14 \\ 20 & -15 & -10 \\ -5 & 5 & 1 \end{pmatrix} \\).
-   \\( A^{-1} = \frac{1}{1} \adj(A) = \begin{pmatrix} -24 & -15 & -14 \\ 20 & -15 & -10 \\ -5 & 5 & 1 \end{pmatrix} \\).

आप जाँच सकते हैं: \\( A \cdot A^{-1} = I \\) (तत्समक मैट्रिक्स)।

### यह विधि क्यों काम करती है?
मुख्य कारण सारणिकों और कोफ़ैक्टरों का एक गुणधर्म है: किसी भी वर्ग मैट्रिक्स \\( A \\) के लिए,
\\[
A \cdot \adj(A) = \det(A) \cdot I
\\]
(जहाँ \\( I \\) तत्समक मैट्रिक्स है)। यह पंक्तियों/स्तंभों के साथ सारणिक के **लाप्लास विस्तार** से आता है। \\( A \cdot \adj(A) \\) में प्रत्येक प्रविष्टि एक योग में विस्तारित होती है जो विकर्ण पर \\( \det(A) \\) के बराबर होती है और अन्यत्र 0 होती है (क्योंकि ऑफ-विकर्ण पद कोफ़ैक्टर चिह्नों के माध्यम से कैंसल हो जाते हैं)।

व्युत्क्रम प्राप्त करने के लिए, दोनों पक्षों को \\( \det(A) \\) से विभाजित करें (यह मानते हुए कि यह गैर-शून्य है):
\\[
A \cdot \left( \frac{1}{\det(A)} \adj(A) \right) = I \implies A^{-1} = \frac{1}{\det(A)} \adj(A)
\\]
इसी तरह, \\( \adj(A) \cdot A = \det(A) \cdot I \\), इसलिए यह दोनों ओर से काम करता है।

यह विधि किसी भी \\( n \times n \\) मैट्रिक्स के लिए सामान्यीकृत होती है, लेकिन 3×3 के लिए, यह कुशल है। बड़े मैट्रिक्स के लिए, गॉसियन एलिमिनेशन अक्सर कम्प्यूटेशनल रूप से तेज़ होता है।

यदि आपके पास कोई विशिष्ट मैट्रिक्स है जिसे आप व्युत्क्रमित करवाना चाहते हैं या किसी चरण को स्पष्ट करना चाहते हैं, तो बस इसे साझा करें!