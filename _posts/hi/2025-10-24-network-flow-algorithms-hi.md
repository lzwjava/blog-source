---
audio: false
generated: true
image: false
lang: hi
layout: post
model: x-ai/grok-4-fast
title: नेटवर्क फ्लो एल्गोरिदम की व्याख्या
translated: true
type: note
---

### नेटवर्क फ्लो एल्गोरिदम को समझना

नेटवर्क फ्लो एल्गोरिदम ग्राफ थ्योरी और कंप्यूटर साइंस का एक मौलिक विषय है, जिसका उपयोग नेटवर्क (जैसे पाइप, सड़कें, या डेटा स्ट्रीम) के माध्यम से संसाधनों के प्रवाह से जुड़ी समस्याओं को मॉडल और हल करने के लिए किया जाता है। ये ऑप्टिमाइजेशन कार्यों जैसे कि अधिकतम प्रवाह (उदाहरण के लिए, पाइपों की एक प्रणाली से कितना पानी बह सकता है), न्यूनतम कट (उदाहरण के लिए, बॉटलनेक ढूंढना), और परिवहन, शेड्यूलिंग और मैचिंग में अनुप्रयोगों के लिए आवश्यक हैं।

मैं इसे चरणबद्ध तरीके से समझाऊंगा: मुख्य अवधारणाएं, एक सरल उदाहरण, मुख्य एल्गोरिदम और गहन सीखने के लिए सुझाव। हम मैक्स-फ्लो समस्या पर ध्यान केंद्रित करेंगे, क्योंकि यह मूल है।

#### 1. मुख्य अवधारणाएं
- **ग्राफ प्रतिनिधित्व**: एक नेटवर्क एक निर्देशित ग्राफ \\( G = (V, E) \\) होता है जिसमें शीर्ष \\( V \\) (नोड्स) और किनारे \\( E \\) (कनेक्शन) होते हैं। प्रत्येक किनारे की एक **क्षमता** \\( c(u, v) \\) होती है, नोड \\( u \\) से \\( v \\) तक वह अधिकतम प्रवाह जिसे वह वहन कर सकता है।
- **स्रोत और सिंक**: एक नोड **स्रोत** \\( s \\) होता है (जहां से प्रवाह शुरू होता है) और एक **सिंक** \\( t \\) होता है (जहां यह समाप्त होता है)।
- **प्रवाह**: एक फ़ंक्शन \\( f(u, v) \\) जो प्रत्येक किनारे पर जाने वाले प्रवाह की मात्रा निर्दिष्ट करता है, जो निम्नलिखित को संतुष्ट करता है:
  - **क्षमता बाध्यता**: \\( 0 \leq f(u, v) \leq c(u, v) \\)।
  - **संरक्षण**: किसी भी नोड के लिए जो \\( s \\) या \\( t \\) नहीं है, इनफ्लो = आउटफ्लो (कोई संचय नहीं)।
- **नेट प्रवाह**: प्रवाह एंटीसिमेट्रिक होता है: \\( f(u, v) = -f(v, u) \\)।
- **अवशिष्ट ग्राफ**: प्रवाह भेजने के बाद शेष क्षमता को ट्रैक करता है। यदि आप क्षमता \\( c \\) वाले किनारे पर \\( f \\) प्रवाह भेजते हैं, तो अवशिष्ट फॉरवर्ड \\( c - f \\) है, और बैकवर्ड \\( f \\) है (प्रवाह को "पूर्ववत" करने के लिए)।
- **लक्ष्य**:
  - **अधिकतम प्रवाह**: \\( s \\) से \\( t \\) तक कुल प्रवाह को अधिकतम करना।
  - **न्यूनतम कट**: नोड्स को \\( S \\) (\\( s \\) के साथ) और \\( T \\) (\\( t \\) के साथ) में विभाजित करना; \\( S \\) से \\( T \\) तक की क्षमताओं के योग को कम करना। मैक्स-फ्लो मिन-कट प्रमेय के अनुसार, अधिकतम प्रवाह = न्यूनतम कट क्षमता।

#### 2. एक सरल उदाहरण
माल ढुलाई के लिए एक छोटे नेटवर्क की कल्पना करें:

- नोड्स: \\( s \\) (स्रोत), A, B, \\( t \\) (सिंक)।
- किनारे:
  - \\( s \to A \\): क्षमता 10
  - \\( s \to B \\): क्षमता 10
  - \\( A \to B \\): क्षमता 2
  - \\( A \to t \\): क्षमता 8
  - \\( B \to t \\): क्षमता 9

ASCII विज़ुअलाइज़ेशन:
```
  s
 / \
10  10
A   B
| \ / |
8  2  9
 \ /  
  t
```

अधिकतम प्रवाह क्या है? सहज रूप से, A को 10 और B को 10 भेजें, लेकिन A केवल 8 को t तक धकेल सकता है (2 B को चला जाता है, जो B को 9+2=11 धकेलने में मदद करता है, लेकिन B की सीमा 9 है? रुकिए, आइए ठीक से गणना करें।

एक एल्गोरिदम (नीचे) का उपयोग करते हुए, अधिकतम प्रवाह 17 है:
- पथ 1: s→A→t (प्रवाह 8), अवशिष्ट अपडेट।
- पथ 2: s→B→t (प्रवाह 9), अवशिष्ट अपडेट।
- पथ 3: s→A→B→t (प्रवाह 0? रुकिए, पहले के बाद, A के पास B को देने के लिए 2 बचा है, लेकिन B से t तक 0 बचा है—वास्तव में, समायोजित करें।

बेहतर: s से कुल 20 है, लेकिन बॉटलनेक 17 तक सीमित करते हैं (A से सीधे 8 + B से 9, जिसमें 2 रीरूट किया गया? नहीं—सटीकता के लिए एल्गो चलाएं।

#### 3. मुख्य एल्गोरिदम
मूल बातों से शुरू करें; कुशल वाले बनाएं। सभी अवशिष्ट ग्राफ में पथों के साथ प्रवाह को तब तक बढ़ाते हैं जब तक कोई और ऑगमेंटिंग पथ मौजूद नहीं रहता।

- **फोर्ड-फुलकरसन विधि** (1956, आधारभूत):
  - अवशिष्ट ग्राफ में s से t तक कोई भी पथ बार-बार ढूंढें (उदाहरण के लिए, DFS/BFS के माध्यम से)।
  - उस पथ पर न्यूनतम अवशिष्ट क्षमता द्वारा प्रवाह बढ़ाएं।
  - कोई पथ न होने तक दोहराएं।
  - **समय**: कार्यान्वयन पर निर्भर करता है; यदि क्षमताएं अपरिमेय हैं तो धीमा हो सकता है (लेकिन पूर्णांक: O(|E| * max_flow))।
  - **पेशेवर**: सरल। **विपक्ष**: बड़े ग्राफ़ के लिए अक्षम।
  - स्यूडोकोड:
    ```
    जब तक अवशिष्ट ग्राफ में s से t तक कोई पथ P है:
        बॉटलनेक = P पर न्यूनतम अवशिष्ट क्षमता
        P के साथ प्रवाह को बॉटलनेक द्वारा बढ़ाएं
        अवशिष्ट को अपडेट करें
    कुल प्रवाह लौटाएं
    ```

- **एडमंड्स-कार्प** (1972, फोर्ड-फुलकरसन का BFS वेरिएंट):
  - सबसे छोटा ऑगमेंटिंग पथ खोजने के लिए BFS का उपयोग करें (लंबे रास्तों से बचता है)।
  - **समय**: O(|V| * |E|^2) — बहुपद, छोटे ग्राफ़ के लिए व्यावहारिक।
  - सीखने के लिए बढ़िया; कोड की ~50 पंक्तियों में लागू करने योग्य।

- **डिनिक का एल्गोरिदम** (1970, तेज़):
  - BFS के माध्यम से **स्तर ग्राफ** बनाता है (s से दूरी के अनुसार परतें)।
  - ब्लॉकिंग फ्लो (प्रति स्तर कई पथ) खोजने के लिए DFS का उपयोग करता है।
  - **समय**: O(|V|^2 * |E|) वर्स्ट-केस, लेकिन यूनिट क्षमताओं के लिए O(|V| * |E|); व्यवहार में बहुत तेज़।
  - **कब उपयोग करें**: मध्यम-बड़े ग्राफ़।

- **पुश-रिलेबल (या प्रीफ्लो-पुश)** (1980s, गोल्डबर्ग-तरजान):
  - ह्युरिस्टिक्स का उपयोग करके नोड्स से अतिरिक्त प्रवाह को सिंक की ओर "धकेलता" है।
  - **समय**: O(|V|^3) या FIFO/गैप ह्युरिस्टिक्स के साथ बेहतर।
  - **पेशेवर**: विशाल ग्राफ़ को संभालता है (उदाहरण के लिए, इंटरनेट रूटिंग)।

मिन-कट के लिए: मैक्स-फ्लो के बाद, कट अंतिम अवशिष्ट ग्राफ में s से पहुंच योग्य नोड्स बनाम अन्य होते हैं।

#### 4. कार्यान्वयन सुझाव
- ग्राफ़ के लिए आसन्न सूचियों का उपयोग करें।
- कोड में (Python जैसा): अवशिष्ट क्षमताओं को dict of dicts के रूप में दर्शाएं।
- लाइब्रेरीज: NetworkX (Python) में `maximum_flow` जैसे बिल्ट-इन हैं।
- छोटे उदाहरणों पर परीक्षण करें; Graphviz जैसे टूल के साथ विज़ुअलाइज़ करें।

#### 5. सामान्य गलतियाँ और एक्सटेंशन
- **चक्र**: अवशिष्ट "बैकफ्लो" को समायोजित करने के लिए संभालते हैं।
- **एकाधिक स्रोत/सिंक**: सुपर-स्रोत/सिंक जोड़ें।
- **लागत**: न्यूनतम लागत प्रवाह के लिए, किनारे की लागत जोड़ें और सक्सेसिव शॉर्टेस्ट पथ का उपयोग करें।
- **अनुप्रयोग**: एयरलाइन शेड्यूलिंग, इमेज सेगमेंटेशन (विजन), बाइपार्टाइट मैचिंग (फ्लो=1 सेट करें)।

#### सीखने का पथ
- CLRS (कॉर्मेन एट अल.) अध्याय 26 पढ़ें।
- LeetCode/HackerRank पर अभ्यास करें (उदाहरण के लिए, "Minimum Cost to Make at Least One Valid Path")।
- विज़ुअलाइज़ करें: प्रत्येक वृद्धि के बाद अवशिष्ट बनाएं।

[Introduction to Network Flows](https://www.geeksforgeeks.org/maximum-bipartite-matching/)  
[Max Flow Min Cut Theorem](https://en.wikipedia.org/wiki/Max-flow_min-cut_theorem)  
[NetworkX Tutorial](https://networkx.org/documentation/stable/tutorial.html)