---
audio: false
generated: true
lang: hi
layout: post
title: जेके फ्लिप-फ्लॉप का निर्माण और परीक्षण
translated: true
type: note
---

एक पिछले वीडियो में, हमने JK फ्लिप-फ्लॉप और इसके संचालन का पता लगाया था, और देखा था कि यह SR फ्लिप-फ्लॉप के समान है लेकिन इसमें फीडबैक तंत्र जुड़ा हुआ है। यह फीडबैक आउटपुट को टॉगल करने की अनुमति देता है जब दोनों इनपुट राइजिंग क्लॉक एज पर हाई होते हैं, न कि अनिर्धारित अवस्था में प्रवेश करने के बजाय। इस वीडियो में, मेरा उद्देश्य इसके व्यावहारिक कार्यात्मकता का निर्माण और अवलोकन करना है।

मैंने प्रदान की गई सर्किट डायग्राम के अनुसार एक JK फ्लिप-फ्लॉप बनाया है। निर्माण के दौरान, मुझे डायग्राम में एक लेबलिंग त्रुटि का एहसास हुआ: यह वास्तव में K इनपुट है, और यह J इनपुट है। J सेटिंग से मेल खाता है, मतलब जब यह हाई जाता है, तो Q आउटपुट भी हाई जाना चाहिए। इसके विपरीत, K रीसेट करने से मेल खाता है, इसलिए जब यह हाई जाता है, तो Q आउटपुट लो जाना चाहिए। इस मामूली लेबलिंग सुधार के अलावा, सर्किट का बाकी हिस्सा सटीक है।

NOR गेट्स के लिए, मैं 74LS02 चिप का उपयोग कर रहा हूं, विशेष रूप से इसके शीर्ष भाग के दो NOR गेट्स। दूसरी चिप, 74LS11, एक ट्रिपल 3-इनपुट AND गेट है। मैं सर्किट के लिए इन तीन-इनपुट AND गेट्स में से दो का उपयोग कर रहा हूं।

पावर सप्लाई देने पर, सर्किट एक अवस्था में स्थिर हो जाता है, और Q आउटपुट "ऑन" दिखाई देता है। फिर मैंने अपनी क्लॉक सर्किट को जोड़ा। आप जो दो स्विच देख रहे हैं, वे पुल-डाउन रेसिस्टर्स के माध्यम से लो की ओर खिंचे हुए हैं; एक बटन दबाने से इनपुट हाई हो जाता है। ये स्विच हरी तारों द्वारा दोनों AND गेट्स से जुड़े हैं, और K और J इनपुट के रूप में कार्य करते हैं।

क्लॉक सिग्नल भी AND गेट्स में फीड होता है। यह एक RC सर्किट से होकर गुजरता है, जिसमें एक 0.0001 माइक्रोफैरड कैपेसिटर और एक 1000 ओम रेसिस्टर होता है। इस RC सर्किट का आउटपुट, दो सफेद तारों द्वारा ले जाया जाता है, दोनों AND गेट्स पर एक और इनपुट में जाता है। इन AND गेट्स के आउटपुट को नीले तारों द्वारा दर्शाया गया है, जो NOR गेट्स पर दो इनपुट्स से जुड़ते हैं। NOR गेट्स के अन्य इनपुट उनके अपने आउटपुट से पीले तारों के माध्यम से फीडबैक प्राप्त करते हैं। ये पीले तार AND गेट्स में वापस लूप भी बनाते हैं। अंत में, NOR गेट आउटपुट दो एलईडी को ड्राइव करते हैं: एक Q के लिए और एक Q कॉम्प्लीमेंट के लिए।

जब K इनपुट को हाई किया जाता है, तो लैच रीसेट होना चाहिए, और Q आउटपुट ऑफ होना चाहिए, जो यह करता है। इसी तरह, J इनपुट को हाई करने पर लैच सेट होना चाहिए, और Q आउटपुट ऑन होना चाहिए, जो यह करता है। महत्वपूर्ण बात यह है कि ध्यान दें कि बटन दबाने पर परिवर्तन तत्काल नहीं होता है; यह अगले क्लॉक सिग्नल के साथ होता है, क्योंकि यह ऑपरेशन क्लॉक के राइजिंग एज द्वारा नियंत्रित होता है।

अब, चूंकि यह एक JK फ्लिप-फ्लॉप है, यदि J और K दोनों इनपुट हाई सेट किए जाते हैं, तो हम उम्मीद करते हैं कि आउटपुट प्रत्येक क्लॉक पल्स के साथ टॉगल होगा। हालांकि, यह लगातार टॉगल नहीं हो रहा है। कभी-कभी ऐसा होता है, खासकर अगर मैं सर्किट को थोड़ा हेरफेर करता हूं, लेकिन यह बहुत असंगत है। यह सुनिश्चित करने के लिए कि मैं दोनों बटन दबा रहा हूं, मैं उनके पार जम्पर लगा दूंगा, जिससे प्रभावी रूप से J और K दोनों को लगातार हाई इनपुट मिलेगा। इससे *हर* राइजिंग क्लॉक एज के साथ इसे टॉगल करना चाहिए। हालांकि अब यह बेहतर काम कर रहा है, फिर भी यह असंगत है।

इस असंगत व्यवहार की एक स्पष्ट व्याख्या है, और इसे समझने का सबसे अच्छा तरीका सिग्नलों की जांच के लिए एक ऑसिलोस्कोप का उपयोग करना है।

सबसे पहले, संदर्भ के लिए क्लॉक इनपुट को देखते हैं। ऑसिलोस्कोप दिखाता है कि क्लॉक सिग्नल लगभग दो बार प्रति सेकंड ऑन और ऑफ हो रहा है। स्कोप पर प्रत्येक डिवीजन 100 मिलीसेकंड का प्रतिनिधित्व करता है, इसलिए 10 डिवीजनों में, यह दो बार प्रति सेकंड पल्स करता है।

अगला, मैं आउटपुट देखना चाहता हूं, क्योंकि यही वह है जिसके हर क्लॉक पल्स के साथ टॉगल होने की हम उम्मीद करते हैं। क्लॉक वास्तव में लगभग दो पल्स प्रति सेकंड की दर से पल्स कर रहा है। वर्तमान में, आउटपुट टॉगल नहीं हो रहा है, लेकिन कुछ हल्के समायोजन के साथ, यह टॉगल करता है, हालांकि असंगत रूप से। जब यह टॉगल *करता है*, तो यह क्लॉक के राइजिंग एज पर ऐसा करता है, जैसा वांछित है।

दिलचस्प हिस्सा तब सामने आता है जब हम क्लॉक के राइजिंग एज पर ज़ूम इन करते हैं। हम वहां कुछ गतिविधि देखते हैं। और ज़ूम इन करने पर, यह काफी स्पष्ट हो जाता है: जब क्लॉक हाई जाता है, तो आउटपुट टॉगल *करता है*, लेकिन यह अंततः स्थिर अवस्था में बसने से पहले कई बार आगे-पीछे टॉगल होता है। यही कारण है कि व्यवहार इतना असंगत है। आउटपुट राइजिंग क्लॉक एज पर वांछित अनुसार टॉगल होता है, लेकिन फिर यह उसके तुरंत बाद तेजी से फिर से टॉगल होता है। इन तेज टॉगल की अवधि लगभग 82 नैनोसेकंड है।

यह घटना, जिसे "रेसिंग" के नाम से जाना जाता है, समझ में आती है जब हम सर्किट डायग्राम को फिर से देखते हैं। क्लॉक पल्स, भले ही हम इसके केवल लीडिंग एज का उपयोग करना चाहते हैं, काफी अवधि (इस मामले में 250 मिलीसेकंड) के लिए हाई रहता है। यदि आउटपुट इस पल्स के शून्य पर वापस जाने से *पहले* स्विच करता है, तो फीडबैक लूप के कारण यह फिर से और फिर से स्विच करता है, जिससे कई टॉगल होते हैं। तो, जब क्लॉक पल्स हाई जाता है, तो आउटपुट ऑन हो जाता है, लेकिन फिर तुरंत बार-बार ऑफ और ऑन हो जाता है। यह विशुद्ध रूप से संयोग है कि यह कभी-कभी वांछित अवस्था में स्थिर हो जाता है।

इस रेसिंग कंडीशन का मूल कारण राइजिंग एज का पता लगाने के लिए उपयोग किए गए RC सर्किट में निहित है। मैंने बताया था कि कैपेसिटर 0.0001 माइक्रोफैरड और रेसिस्टर 1000 ओम का है। इन मूल्यों को गुणा करने पर RC सर्किट का टाइम कॉन्स्टेंट मिलता है, जो पल्स चौड़ाई को दर्शाता है। यह टाइम कॉन्स्टेंट लगभग 100 नैनोसेकंड है।

आइए सर्किट के लिए पल्स इनपुट को मापें। शुरू में, ज़ूम आउट करने पर यह बढ़िया दिखता है – क्लॉक के राइजिंग एज पर एक त्वरित पल्स, जैसा वांछित है। समस्या यह है कि यह पल्स *पर्याप्त* त्वरित नहीं है। यह एक 1-माइक्रोसेकंड पल्स है, और उस 1 माइक्रोसेकंड के दौरान, आउटपुट पल्स के लॉजिक जीरो पर गिरने से पहले बार-बार ऑन और ऑफ टॉगल करता रहता है, अंत में स्थिर होता है।

इसके बारे में क्या किया जा सकता है? एक विकल्प पल्स को छोटा बनाना है। चूंकि टॉगलिंग की अवधि लगभग 80 नैनोसेकंड है, हमें 1 माइक्रोसेकंड से काफी छोटे पल्स की आवश्यकता है। हम 1000-ओम रेसिस्टर को 100-ओम रेसिस्टर से बदलने का प्रयास कर सकते हैं, जिससे टाइम कॉन्स्टेंट घटकर 100 नैनोसेकंड हो जाना चाहिए।

रेसिस्टर को बदलने के बाद, हम एक बहुत छोटा पल्स देखते हैं। हालांकि, यह अभी भी लगातार काम नहीं कर रहा है। इस बिंदु पर, हम ब्रेडबोर्ड की सीमाओं का सामना कर रहे हैं। दसियों नैनोसेकंड रेंज में हाई-स्पीड सिग्नल ब्रेडबोर्ड पर चुनौतीपूर्ण होते हैं, क्योंकि स्ट्रे कैपेसिटेंस, इंडक्टेंस और अन्य पैरासिटिक प्रभाव होते हैं। यही कारण है कि सर्किट के पास हाथ लहराने मात्र से इसके व्यवहार को बदला जा सकता है, क्योंकि मेरा हाथ एक ग्राउंडेड ऑब्जेक्ट के रूप में कार्य करके कैपेसिटेंस को बदल देता है।

आप देख सकते हैं कि आउटपुट अब हाई हो रहा है, फिर लो हो रहा है, और लो बना रहा है। लेकिन फिर, अगर मैं अपना हाथ समायोजित करता हूं, तो यह टॉगल करना शुरू कर सकता है। मैं कोई कनेक्शन नहीं बदल रहा हूं, बस अपना हाथ हिला रहा हूं, जो कैपेसिटेंस को प्रभावित करता है।

इस टाइमस्केल पर हमारे क्लॉक का राइजिंग एज भी ब्रेडबोर्ड सीमाओं के कारण पूरी तरह से तेज नहीं है। जो पल्स हम जनरेट कर रहे हैं, वह बड़े रेसिस्टर के साथ जितना साफ था उतना साफ नहीं है। अंततः, यह सब इस तथ्य की ओर इशारा करता है कि हम उस सीमा को पार कर रहे हैं जो ब्रेडबोर्ड पर संभव है। राइजिंग एज का पता लगाने के लिए RC सर्किट का उपयोग करने की यह विशेष विधि रेसिंग कंडीशन के कारण JK फ्लिप-फ्लॉप में स्वाभाविक रूप से समस्याग्रस्त है। यदि पल्स पर्याप्त संकीर्ण नहीं है (आदर्श रूप से केवल कुछ नैनोसेकंड), तो आउटपुट फीडबैक करेगा और प्रति क्लॉक राइजिंग एज एक से अधिक बार टॉगल होगा।

तो, समाधान क्या है? अगले वीडियो में, मैं JK फ्लिप-फ्लॉप बनाने के लिए एक बेहतर विधि प्रदर्शित करूंगा जो इस रेसिंग समस्या को पूरी तरह से समाप्त कर देती है: मास्टर-स्लेव JK फ्लिप-फ्लॉप। यह एक बहुत अधिक मजबूत डिजाइन है और ब्रेडबोर्ड पर बिना किसी समस्या के काम करना चाहिए।