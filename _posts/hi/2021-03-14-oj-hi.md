---
audio: false
generated: false
image: true
lang: hi
layout: post
title: Python प्रोग्रामिंग में ऑनलाइन प्रश्न हल करना
translated: true
type: post
---

यहां हम ऑनलाइन जज सिस्टम का उपयोग करके प्रश्न हल करेंगे। अगर आपकी अंग्रेजी अच्छी है, तो आप `Codeforces` और `LeetCode` का उपयोग कर सकते हैं। चीनी भाषा में आप `计蒜客` और `力扣` का उपयोग कर सकते हैं। यहां हम `LeetCode` का उपयोग करेंगे। मैंने यहां 10 प्रश्न हल किए हैं। साथ ही, अंतिम प्रश्न को कई तरीकों से हल किया गया है, जिससे प्रोग्राम की दक्षता को 10% सबमिशन से बेहतर करके 99% तक पहुंचाया गया है।

![cf](assets/images/oj/cf.png)

![jsk](assets/images/oj/jsk.png)

![leetcode](assets/images/oj/leetcode.png)

## 1480. 1डी ऐरे का रनिंग योग

### समस्या का विवरण
एक सरणी `nums` दी गई है। हमें एक नई सरणी `runningSum` लौटानी है जहां `runningSum[i] = sum(nums[0]…nums[i])` हो।

**उदाहरण 1:**
```
इनपुट: nums = [1,2,3,4]
आउटपुट: [1,3,6,10]
व्याख्या: रनिंग योग इस प्रकार प्राप्त होता है: [1, 1+2, 1+2+3, 1+2+3+4]।
```

**उदाहरण 2:**
```
इनपुट: nums = [1,1,1,1,1]
आउटपुट: [1,2,3,4,5]
व्याख्या: रनिंग योग इस प्रकार प्राप्त होता है: [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1]।
```

**उदाहरण 3:**
```
इनपुट: nums = [3,1,2,10,1]
आउटपुट: [3,4,6,16,17]
```

**प्रतिबंध:**
- `1 <= nums.length <= 1000`
- `-10^6 <= nums[i] <= 10^6`

### समाधान
हम इस समस्या को एक साधारण लूप का उपयोग करके हल कर सकते हैं। हम एक नई सरणी `runningSum` बनाएंगे और प्रत्येक इंडेक्स पर पिछले सभी तत्वों का योग जोड़ेंगे।

```python
class Solution:
    def runningSum(self, nums: List[int]) -> List[int]:
        runningSum = []
        current_sum = 0
        for num in nums:
            current_sum += num
            runningSum.append(current_sum)
        return runningSum
```

### व्याख्या
1. हम एक खाली सूची `runningSum` बनाते हैं और एक वेरिएबल `current_sum` को 0 पर सेट करते हैं।
2. हम `nums` सरणी के प्रत्येक तत्व को लूप करते हैं।
3. प्रत्येक तत्व को `current_sum` में जोड़ते हैं और इसे `runningSum` सूची में जोड़ते हैं।
4. अंत में, `runningSum` सूची को लौटाते हैं।

यह समाधान O(n) समय जटिलता में चलता है, जहां n सरणी की लंबाई है।

> एक सरणी `nums` दी गई है। हम एक सरणी का रनिंग योग (running sum) इस प्रकार परिभाषित करते हैं: `runningSum[i] = sum(nums[0]…nums[i])`।
>
> `nums` का रनिंग योग लौटाएं।

```python
class Solution:
    def runningSum(self, nums: [int]) -> [int]:         
      running = []
      s = 0
      for num in nums:
        s += num
        running.append(s)
      
      return running
```

इस कोड में, `Solution` नामक एक क्लास है जिसमें `runningSum` नामक एक मेथड है। यह मेथड एक इनपुट लिस्ट `nums` लेता है और एक नई लिस्ट `running` वापस करता है। `running` लिस्ट में `nums` लिस्ट के तत्वों का क्रमशः योग (running sum) होता है।

1. `running` एक खाली लिस्ट है जिसमें हम रनिंग योग को स्टोर करेंगे।
2. `s` एक वेरिएबल है जो योग को ट्रैक करता है, शुरुआत में यह 0 है।
3. `for` लूप `nums` लिस्ट के हर तत्व को लेता है और उसे `s` में जोड़ता है।
4. हर बार जब `s` अपडेट होता है, तो उसे `running` लिस्ट में जोड़ दिया जाता है।
5. अंत में, `running` लिस्ट को वापस कर दिया जाता है।

उदाहरण के लिए, यदि `nums = [1, 2, 3, 4]`, तो `runningSum` मेथड `[1, 3, 6, 10]` वापस करेगा।

```python
print(Solution().runningSum([1,2,3,4]))
```

![ac](assets/images/oj/ac.png)

पहला प्रश्न पास हो गया।

## 1108. IP एड्रेस को डिफैंग करना

एक IP एड्रेस को डिफैंग करने का मतलब है कि एड्रेस में मौजूद सभी डॉट्स (`.`) को `[.]` से बदल देना। यह सुरक्षा कारणों से किया जाता है ताकि IP एड्रेस को टेक्स्ट के रूप में सुरक्षित रूप से प्रदर्शित किया जा सके।

उदाहरण के लिए, यदि IP एड्रेस `192.168.1.1` है, तो इसे डिफैंग करने के बाद यह `192[.]168[.]1[.]1` हो जाएगा।

### समस्या का विवरण

आपको एक वैध IPv4 एड्रेस दिया गया है, और आपको इसे डिफैंग करना है।

### उदाहरण

**उदाहरण 1:**

```
Input: address = "1.1.1.1"
Output: "1[.]1[.]1[.]1"
```

**उदाहरण 2:**

```
Input: address = "255.100.50.0"
Output: "255[.]100[.]50[.]0"
```

### समाधान

इस समस्या को हल करने के लिए, हम सरलता से IP एड्रेस में मौजूद सभी डॉट्स को `[.]` से बदल सकते हैं। यह काम Python में `replace()` मेथड का उपयोग करके आसानी से किया जा सकता है।

```python
def defangIPaddr(address: str) -> str:
    return address.replace('.', '[.]')
```

### समय और स्थान जटिलता

- **समय जटिलता:** O(n), जहां n इनपुट स्ट्रिंग की लंबाई है।
- **स्थान जटिलता:** O(n), क्योंकि हम एक नई स्ट्रिंग बना रहे हैं।

### परीक्षण

आइए उपरोक्त समाधान को दिए गए उदाहरणों पर परीक्षण करें:

```python
print(defangIPaddr("1.1.1.1"))      # Output: "1[.]1[.]1[.]1"
print(defangIPaddr("255.100.50.0")) # Output: "255[.]100[.]50[.]0"
```

यह समाधान सरल और प्रभावी है, और यह समस्या को O(n) समय में हल करता है।

> एक वैध (IPv4) IP `address` दिया गया है, उस IP पते का एक डिफेंज्ड (defanged) संस्करण लौटाएं।
>
> एक *डिफेंज्ड IP पता* हर पीरियड `"."` को `"[.]"` से बदल देता है।

```python
class Solution:
    def defangIPaddr(self, address: str) -> str:
        return address.replace('.', '[.]')
```

यह कोड एक IP एड्रेस को "डिफैंग" करता है, जिसका अर्थ है कि इसमें मौजूद सभी डॉट्स (`.`) को `[.]` से बदल दिया जाता है। उदाहरण के लिए, `"192.168.1.1"` को `"192[.]168[.]1[.]1"` में बदल दिया जाएगा।

# print(Solution().defangIPaddr('1.1.1.1'))
```

## 1431. सबसे अधिक कैंडी वाले बच्चे

**समस्या:**

आपको `n` बच्चों की संख्या और एक सरणी `candies` दी गई है, जहां `candies[i]` `i`-वें बच्चे के पास मौजूद कैंडी की संख्या को दर्शाता है। आपको एक पूर्णांक `extraCandies` भी दिया गया है, जो अतिरिक्त कैंडी की संख्या को दर्शाता है।

आपका कार्य एक बूलियन सरणी `result` लौटाना है, जहां `result[i]` `true` होगा यदि `i`-वें बच्चे को `extraCandies` देने के बाद उसके पास सभी बच्चों में से सबसे अधिक कैंडी होगी, अन्यथा `false` होगा। ध्यान दें कि एक से अधिक बच्चे सबसे अधिक कैंडी रख सकते हैं।

**उदाहरण:**

**उदाहरण 1:**

```
Input: candies = [2,3,5,1,3], extraCandies = 3
Output: [true,true,true,false,true]
```

**स्पष्टीकरण:**

- पहले बच्चे को 3 अतिरिक्त कैंडी देने के बाद, उसके पास 5 कैंडी होंगी, जो सबसे अधिक है।
- दूसरे बच्चे को 3 अतिरिक्त कैंडी देने के बाद, उसके पास 6 कैंडी होंगी, जो सबसे अधिक है।
- तीसरे बच्चे को 3 अतिरिक्त कैंडी देने के बाद, उसके पास 8 कैंडी होंगी, जो सबसे अधिक है।
- चौथे बच्चे को 3 अतिरिक्त कैंडी देने के बाद, उसके पास केवल 4 कैंडी होंगी, जो सबसे अधिक नहीं है।
- पांचवें बच्चे को 3 अतिरिक्त कैंडी देने के बाद, उसके पास 6 कैंडी होंगी, जो सबसे अधिक है।

**उदाहरण 2:**

```
Input: candies = [4,2,1,1,2], extraCandies = 1
Output: [true,false,false,false,false]
```

**स्पष्टीकरण:**

- केवल पहले बच्चे के पास अतिरिक्त कैंडी देने के बाद सबसे अधिक कैंडी होगी।

**समाधान:**

```python
def kidsWithCandies(candies, extraCandies):
    max_candies = max(candies)
    result = []
    for candy in candies:
        if candy + extraCandies >= max_candies:
            result.append(True)
        else:
            result.append(False)
    return result
```

**समय जटिलता:** O(n), जहां `n` बच्चों की संख्या है।

**स्पेस जटिलता:** O(n), क्योंकि हम एक नई सरणी `result` बना रहे हैं।

> दिया गया है सरणी `candies` और पूर्णांक `extraCandies`, जहां `candies[i]` ***iवें\*** बच्चे के पास मौजूद कैंडी की संख्या को दर्शाता है।
>
> प्रत्येक बच्चे के लिए जांचें कि क्या `extraCandies` को बच्चों के बीच इस तरह वितरित किया जा सकता है कि वह उनमें से **सबसे अधिक** कैंडी रख सके। ध्यान दें कि एक से अधिक बच्चे **सबसे अधिक** कैंडी रख सकते हैं।

```python
class Solution:
    def kidsWithCandies(self, candies: [int], extraCandies: int) -> [bool]:
        max = 0
        for candy in candies:
          if candy > max:
            max = candy
        greatests = []
        for candy in candies:
          if candy + extraCandies >= max:
            greatests.append(True)
          else:
            greatests.append(False)
        return greatests
```

इस कोड में, `Solution` नामक एक क्लास है जिसमें `kidsWithCandies` नामक एक मेथड है। यह मेथड दो इनपुट लेता है: `candies` (एक लिस्ट जिसमें प्रत्येक बच्चे के पास कैंडी की संख्या होती है) और `extraCandies` (एक पूर्णांक जो अतिरिक्त कैंडी की संख्या को दर्शाता है)। 

1. पहले, यह `candies` लिस्ट में से सबसे ज्यादा कैंडी की संख्या (`max`) को ढूंढता है।
2. फिर, यह `candies` लिस्ट के प्रत्येक बच्चे के लिए जांचता है कि क्या उनके पास `extraCandies` जोड़ने के बाद भी `max` से ज्यादा या बराबर कैंडी होगी।
3. यदि हां, तो `True` को `greatests` लिस्ट में जोड़ा जाता है, अन्यथा `False` जोड़ा जाता है।
4. अंत में, `greatests` लिस्ट को रिटर्न किया जाता है, जो यह दर्शाता है कि कौन से बच्चे `extraCandies` जोड़ने के बाद सबसे ज्यादा कैंडी वाले बच्चे बन सकते हैं।

# print(Solution().kidsWithCandies([2,3,5,1,3], 3))
```

## 1672. सबसे धनी ग्राहक की संपत्ति

> आपको एक `m x n` पूर्णांक ग्रिड `accounts` दिया गया है जहां `accounts[i][j]` `ith` ग्राहक के पास `jth` बैंक में राशि है। *सबसे अमीर ग्राहक की **संपत्ति** लौटाएं।*
>
> एक ग्राहक की **संपत्ति** उनके सभी बैंक खातों में राशि का योग है। सबसे अमीर ग्राहक वह है जिसकी **संपत्ति** सबसे अधिक है।

```python
class Solution:
    def maximumWealth(self, accounts: [[int]]) -> int:
        max = 0      
        for account in accounts:
          s = sum(account) 
          if max < s:
            max = s
        return max
```

इस कोड को हिंदी में समझाएं:

यह एक Python क्लास `Solution` है जिसमें एक मेथड `maximumWealth` है। यह मेथड `accounts` नामक एक 2D लिस्ट (जो कि इंटीजर की लिस्ट्स की लिस्ट है) को इनपुट के रूप में लेता है और एक इंटीजर वैल्यू रिटर्न करता है।

1. `max` नामक एक वेरिएबल को 0 से इनिशियलाइज़ किया गया है। यह वेरिएबल अधिकतम धन (wealth) को स्टोर करेगा।
2. `accounts` लिस्ट में प्रत्येक `account` (जो कि एक लिस्ट है) के लिए:
   - `s` नामक वेरिएबल में `account` लिस्ट के सभी एलिमेंट्स का योग (sum) स्टोर किया जाता है।
   - यदि `max` की वैल्यू `s` से कम है, तो `max` को `s` के बराबर सेट कर दिया जाता है।
3. अंत में, `max` की वैल्यू रिटर्न की जाती है, जो कि सभी खातों (accounts) में से अधिकतम धन (wealth) को दर्शाती है।

इस प्रकार, यह फंक्शन दिए गए खातों (accounts) में से सबसे अधिक धन (wealth) वाले खाते की राशि को ढूंढता है और उसे रिटर्न करता है।

```python
#print(Solution().maximumWealth([[1,2,3],[3,2,1]]))
```

इस कोड को हिंदी में समझाया जाए तो:

यह कोड एक `Solution` क्लास के `maximumWealth` मेथड को कॉल कर रहा है और इसे एक 2D लिस्ट `[[1,2,3],[3,2,1]]` पास कर रहा है। यह लिस्ट दो ग्राहकों की संपत्ति को दर्शाती है, जहां प्रत्येक ग्राहक की संपत्ति एक लिस्ट में है। उदाहरण के लिए, पहले ग्राहक की संपत्ति `[1,2,3]` है और दूसरे ग्राहक की संपत्ति `[3,2,1]` है।

`maximumWealth` मेथड का उद्देश्य इन ग्राहकों की कुल संपत्ति की गणना करना और सबसे अधिक संपत्ति वाले ग्राहक की कुल संपत्ति को वापस करना है।

इस कोड को रन करने पर, यह `maximumWealth` मेथड के आउटपुट को प्रिंट करेगा, जो कि सबसे अधिक संपत्ति वाले ग्राहक की कुल संपत्ति होगी।

## 1470. ऐरे को शफल करें

> दिया गया है `2n` तत्वों वाला सरणी `nums`, जो `[x1,x2,...,xn,y1,y2,...,yn]` के रूप में है।
>
> *सरणी को इस रूप में लौटाएं* `[x1,y1,x2,y2,...,xn,yn]`।

```python
class Solution:
  def shuffle(self, nums: [int], n: int) -> [int]:
    ns1 = nums[:n]
    ns2 = nums[n:]
    ns = []
    for i in range(n):
      ns.append(ns1[i])
      ns.append(ns2[i])
    return ns
```

इस कोड में, `Solution` क्लास में `shuffle` नामक एक मेथड है जो दो पैरामीटर लेती है: `nums` (एक इंटीजर लिस्ट) और `n` (एक इंटीजर)। यह मेथड `nums` लिस्ट को दो हिस्सों में बांटती है: `ns1` और `ns2`। फिर यह इन दोनों हिस्सों के एलिमेंट्स को एक नई लिस्ट `ns` में बारी-बारी से जोड़ती है और अंत में इस नई लिस्ट को रिटर्न करती है।

# print(Solution().shuffle([2,5,1,3,4,7], 3))
```

## 1512. अच्छे जोड़ों की संख्या

> एक पूर्णांकों की सरणी `nums` दी गई है।
>
> एक जोड़ी `(i,j)` को *अच्छा* कहा जाता है यदि `nums[i]` == `nums[j]` और `i` < `j` हो।
>
> *अच्छे* जोड़ों की संख्या लौटाएं।

```python
class Solution:
    def numIdenticalPairs(self, nums: [int]) -> int:
        j = 1
        n = len(nums)
        p = 0
        while j < n:
          for i in range(j):
            if nums[i] == nums[j]:
              p += 1
          j+=1
        return p
```

यह कोड एक समाधान प्रदान करता है जो एक सूची में समान संख्याओं के जोड़े (pairs) की संख्या गिनता है। यहां `nums` एक पूर्णांकों की सूची है, और `numIdenticalPairs` फ़ंक्शन इस सूची में समान संख्याओं के जोड़े की संख्या लौटाता है।

### कोड का विवरण:
1. `j` को 1 से शुरू किया जाता है और `n` को सूची `nums` की लंबाई के रूप में सेट किया जाता है।
2. `p` को 0 से शुरू किया जाता है, जो समान जोड़े की संख्या को संग्रहीत करेगा।
3. एक `while` लूप का उपयोग करके, `j` को `n` से कम होने तक चलाया जाता है।
4. एक `for` लूप का उपयोग करके, `i` को 0 से `j-1` तक चलाया जाता है।
5. यदि `nums[i]` और `nums[j]` समान हैं, तो `p` को 1 से बढ़ाया जाता है।
6. अंत में, `p` को लौटाया जाता है, जो समान जोड़े की कुल संख्या को दर्शाता है।

यह कोड समान संख्याओं के सभी संभावित जोड़े की संख्या की गणना करता है।

# print(Solution().numIdenticalPairs([1,2,3,1,1,3]))
```

## 771. ज्वेल्स एंड स्टोन्स

> आपको दो स्ट्रिंग्स दिए गए हैं: `jewels` जो ज्वेल्स (रत्न) के प्रकारों को दर्शाता है, और `stones` जो आपके पास मौजूद पत्थरों को दर्शाता है। `stones` में हर एक कैरेक्टर एक प्रकार के पत्थर को दर्शाता है। आप यह जानना चाहते हैं कि आपके पास मौजूद कितने पत्थर ज्वेल्स भी हैं।
>
> अक्षर केस सेंसिटिव हैं, इसलिए `"a"` को `"A"` से अलग प्रकार का पत्थर माना जाएगा।

```python
class Solution:
    def numJewelsInStones(self, jewels: str, stones: str) -> int:
        n = 0
        for i in range(len(jewels)):
          js = jewels[i:i+1]
          n += stones.count(js)
        return n
```

इस कोड में, `Solution` नामक एक क्लास है जिसमें `numJewelsInStones` नामक एक मेथड है। यह मेथड दो स्ट्रिंग्स `jewels` और `stones` को इनपुट के रूप में लेता है और एक इंटीजर वैल्यू रिटर्न करता है। 

इस मेथड का उद्देश्य यह जांचना है कि `stones` स्ट्रिंग में `jewels` स्ट्रिंग के कितने कैरेक्टर्स मौजूद हैं। 

1. `n` नामक एक वेरिएबल को 0 से इनिशियलाइज़ किया जाता है।
2. एक लूप `jewels` स्ट्रिंग के हर कैरेक्टर के लिए चलाया जाता है।
3. `js` वेरिएबल में `jewels` स्ट्रिंग का वर्तमान कैरेक्टर स्टोर किया जाता है।
4. `stones` स्ट्रिंग में `js` कैरेक्टर की संख्या गिनी जाती है और `n` में जोड़ दी जाती है।
5. अंत में, `n` को रिटर्न किया जाता है, जो `stones` में `jewels` के कैरेक्टर्स की कुल संख्या को दर्शाता है।

# print(Solution().numJewelsInStones("aA", "aAAbbbb"))
```

## 1603. पार्किंग सिस्टम डिज़ाइन करें

> एक पार्किंग लॉट के लिए पार्किंग सिस्टम डिज़ाइन करें। पार्किंग लॉट में तीन प्रकार के पार्किंग स्थान हैं: बड़े, मध्यम और छोटे, जिनमें प्रत्येक आकार के लिए एक निश्चित संख्या में स्लॉट हैं।
>
> `ParkingSystem` क्लास को इम्प्लीमेंट करें:
>
> - `ParkingSystem(int big, int medium, int small)` `ParkingSystem` क्लास के ऑब्जेक्ट को इनिशियलाइज़ करता है। प्रत्येक पार्किंग स्थान के लिए स्लॉट की संख्या कंस्ट्रक्टर के हिस्से के रूप में दी जाती है।
> - `bool addCar(int carType)` जांचता है कि क्या पार्किंग लॉट में `carType` के लिए पार्किंग स्थान उपलब्ध है। `carType` तीन प्रकार का हो सकता है: बड़ा, मध्यम, या छोटा, जिन्हें क्रमशः `1`, `2`, और `3` द्वारा दर्शाया जाता है। **एक कार केवल अपने** `carType` के पार्किंग स्थान में पार्क कर सकती है। यदि कोई स्थान उपलब्ध नहीं है, तो `false` वापस करें, अन्यथा कार को उस आकार के स्थान में पार्क करें और `true` वापस करें।

```python
class ParkingSystem:
    slots = [0, 0, 0]
```

    def __init__(self, big: int, medium: int, small: int):
      self.slots[0] = big
      self.slots[1] = medium
      self.slots[2] = small

    def addCar(self, carType: int) -> bool:
      if self.slots[carType - 1] > 0:
        self.slots[carType - 1] -=1
        return True
      else:
        return False

(यह कोड ब्लॉक है, इसे अपरिवर्तित छोड़ दिया गया है।)

# parkingSystem = ParkingSystem(1, 1, 0)
# print(parkingSystem.addCar(1))
# print(parkingSystem.addCar(2))
# print(parkingSystem.addCar(3))
# print(parkingSystem.addCar(1))
```

## 1773. नियम से मेल खाने वाली वस्तुओं की गिनती

> आपको एक सरणी `items` दी गई है, जहां प्रत्येक `items[i] = [typei, colori, namei]` `ith` आइटम के प्रकार, रंग और नाम का वर्णन करता है। आपको दो स्ट्रिंग्स, `ruleKey` और `ruleValue` द्वारा प्रस्तुत एक नियम भी दिया गया है।
>
> `ith` आइटम को नियम से मेल खाने वाला कहा जाता है यदि **एक** निम्नलिखित सत्य है:
>
> - `ruleKey == "type"` और `ruleValue == typei`।
> - `ruleKey == "color"` और `ruleValue == colori`।
> - `ruleKey == "name"` और `ruleValue == namei`।
>
> *दिए गए नियम से मेल खाने वाले आइटम्स की संख्या लौटाएं*।

```python
class Solution:
    def countMatches(self, items: [[str]], ruleKey: str, ruleValue: str) -> int:
      i = 0
      if ruleKey == "type":
        i = 0
      elif ruleKey == "color":
        i = 1
      else:
        i = 2
      n = 0
      for item in items:
        if item[i] == ruleValue:
          n +=1
      return n
```

यह कोड एक समस्या को हल करता है जहां आपको `items` नामक एक सूची दी जाती है, जिसमें प्रत्येक आइटम एक सूची होती है जिसमें `type`, `color`, और `name` शामिल होते हैं। `ruleKey` और `ruleValue` के आधार पर, आपको उन आइटम्स की संख्या गिननी होती है जो दिए गए नियम से मेल खाते हैं।

- `ruleKey` यह बताता है कि किस प्रॉपर्टी (`type`, `color`, या `name`) के आधार पर मिलान करना है।
- `ruleValue` वह मान है जिसके साथ मिलान करना है।

कोड का काम निम्नलिखित है:
1. `ruleKey` के आधार पर यह निर्धारित करता है कि `items` की किस इंडेक्स (0, 1, या 2) की जांच करनी है।
2. फिर यह `items` की सूची में से प्रत्येक आइटम की जांच करता है और देखता है कि क्या उस आइटम का चयनित इंडेक्स `ruleValue` के बराबर है।
3. यदि मिलान होता है, तो `n` की संख्या बढ़ा दी जाती है।
4. अंत में, `n` को वापस कर दिया जाता है, जो मिलान करने वाले आइटम्स की संख्या को दर्शाता है।

# print(Solution().countMatches([["phone","blue","pixel"],["computer","silver","lenovo"],["phone","gold","iphone"]], "color", "silver"))
        
```

## 1365. वर्तमान संख्या से छोटी संख्याएँ कितनी हैं

> दिए गए सरणी `nums` में, प्रत्येक `nums[i]` के लिए यह पता लगाएं कि सरणी में कितने संख्याएं इससे छोटी हैं। यानी, प्रत्येक `nums[i]` के लिए आपको वैध `j's` की संख्या गिननी होगी जैसे कि `j != i` **और** `nums[j] < nums[i]`।
>
> उत्तर को एक सरणी में वापस करें।

> ```
> इनपुट: nums = [8,1,2,2,3]
> आउटपुट: [4,0,1,1,3]
> व्याख्या: 
> nums[0]=8 के लिए, इससे छोटे चार संख्याएँ हैं (1, 2, 2 और 3)। 
> nums[1]=1 के लिए, इससे छोटी कोई संख्या नहीं है।
> nums[2]=2 के लिए, इससे छोटी एक संख्या है (1)। 
> nums[3]=2 के लिए, इससे छोटी एक संख्या है (1)। 
> nums[4]=3 के लिए, इससे छोटी तीन संख्याएँ हैं (1, 2 और 2)।
> ```

```python
class Solution:
    def smallerNumbersThanCurrent(self, nums: [int]) -> [int]:
        ns = []
        l = len(nums)
        for i in range(l):
          n = 0
          for j in range(l):
            if i != j:
              if nums[j] < nums[i]:
                n += 1
          ns.append(n)
        return ns
```

यह कोड एक सूची `nums` में दिए गए प्रत्येक संख्या के लिए उससे छोटे संख्याओं की संख्या गिनता है और उसे एक नई सूची `ns` में संग्रहीत करता है। अंत में, यह सूची `ns` को वापस लौटाता है।

# print(Solution().smallerNumbersThanCurrent([8,1,2,2,3]))
```

528ms में पूरा हुआ, 11.81% प्रोग्राम को हराया। इसे ऑप्टिमाइज़ करें।

```python
class Solution:
    def smallerNumbersThanCurrent(self, nums: [int]) -> [int]:
        l = len(nums)
```

यह कोड एक Python क्लास `Solution` को परिभाषित करता है जिसमें एक मेथड `smallerNumbersThanCurrent` है। यह मेथड एक इनपुट लिस्ट `nums` लेता है, जो पूर्णांकों (integers) की एक सूची है, और एक आउटपुट लिस्ट रिटर्न करता है। आउटपुट लिस्ट में प्रत्येक तत्व यह दर्शाता है कि इनपुट लिस्ट में उस तत्व से छोटे कितने तत्व हैं।

अभी कोड अधूरा है, और इसे पूरा करने के लिए और लॉजिक जोड़ने की आवश्यकता है।

```python
sort_nums = nums.copy()
```

```python
ins = list(range(l))
for i in range(l):          
    for j in range(i+1, l):
        if sort_nums[i] > sort_nums[j]:
            a = sort_nums[i]
            sort_nums[i] = sort_nums[j]
            sort_nums[j] = a
            
            a = ins[i]
            ins[i] = ins[j]
            ins[j] = a
        
smalls = [0]
for i in range(1, l):
    if sort_nums[i-1] == sort_nums[i]:
        smalls.append(smalls[i-1])
    else:
        smalls.append(i)
```

### हिंदी व्याख्या:

1. **`ins = list(range(l))`**:
   - यह कोड `ins` नामक एक सूची बनाता है जिसमें `0` से `l-1` तक के नंबर होते हैं। यह सूची मूल इंडेक्स को स्टोर करने के लिए उपयोग की जाती है।

2. **बाहरी लूप (`for i in range(l)`)**:
   - यह लूप `i` को `0` से `l-1` तक चलाता है। यह सूची के प्रत्येक तत्व को एक-एक करके चुनता है।

3. **आंतरिक लूप (`for j in range(i+1, l)`)**:
   - यह लूप `j` को `i+1` से `l-1` तक चलाता है। यह `i` के बाद के सभी तत्वों को चुनता है।

4. **स्वैपिंग (`if sort_nums[i] > sort_nums[j]`)**:
   - यदि `sort_nums[i]` का मान `sort_nums[j]` से बड़ा है, तो दोनों तत्वों को स्वैप किया जाता है। इसके साथ ही, `ins` सूची में भी संबंधित इंडेक्स को स्वैप किया जाता है।

5. **`smalls = [0]`**:
   - यह `smalls` नामक एक सूची बनाता है जिसमें पहला तत्व `0` होता है। यह सूची छोटे तत्वों की संख्या को स्टोर करने के लिए उपयोग की जाती है।

6. **दूसरा लूप (`for i in range(1, l)`)**:
   - यह लूप `i` को `1` से `l-1` तक चलाता है। यह सूची के प्रत्येक तत्व को एक-एक करके चुनता है।

7. **`if sort_nums[i-1] == sort_nums[i]`**:
   - यदि वर्तमान तत्व और पिछला तत्व समान हैं, तो `smalls` सूची में पिछले तत्व का मान जोड़ा जाता है।

8. **`else`**:
   - यदि वर्तमान तत्व और पिछला तत्व समान नहीं हैं, तो `smalls` सूची में `i` का मान जोड़ा जाता है।

इस कोड का उद्देश्य `sort_nums` सूची को सॉर्ट करना है और साथ ही `ins` सूची में मूल इंडेक्स को भी अपडेट करना है। इसके बाद, `smalls` सूची में यह स्टोर किया जाता है कि कितने तत्व वर्तमान तत्व से छोटे हैं।

```python
# print(sort_nums)
# print(smalls)
```

```python
r_is = list(range(l))
for i in ins:
    r_is[ins[i]] = i

ns = []
for i in range(l):          
    ns.append(smalls[r_is[i]])
return ns
```

यह कोड एक लिस्ट `r_is` बनाता है जो `0` से `l-1` तक की संख्याओं से भरी होती है। फिर यह `ins` लिस्ट के माध्यम से लूप करता है और `r_is` लिस्ट को अपडेट करता है। अंत में, यह `smalls` लिस्ट से मान लेकर एक नई लिस्ट `ns` बनाता है और उसे वापस करता है।

# print(Solution().smallerNumbersThanCurrent([8,1,2,2,3]))
```

इस टेस्ट का समय `284ms` था, जो पिछले `528ms` से कम है।

सिस्टम के फ़ंक्शन को संक्षिप्त में लिखने के लिए।

```python
class Solution:
    def smallerNumbersThanCurrent(self, nums: [int]) -> [int]:
        sort_nums = nums.copy()
        sort_nums.sort()
        
        ns = []
        for num in nums:
          ns.append(sort_nums.index(num))
        return ns
```

इस कोड को हिंदी में समझाएं:

यह कोड एक क्लास `Solution` को परिभाषित करता है जिसमें एक मेथड `smallerNumbersThanCurrent` है। यह मेथड एक इनपुट लिस्ट `nums` लेता है, जो पूर्णांकों (integers) की एक लिस्ट है, और एक आउटपुट लिस्ट रिटर्न करता है जिसमें प्रत्येक तत्व के लिए यह दर्शाता है कि मूल लिस्ट में उस तत्व से छोटे कितने तत्व हैं।

1. `sort_nums = nums.copy()`: यह लाइन `nums` लिस्ट की एक कॉपी बनाती है और इसे `sort_nums` में स्टोर करती है।
2. `sort_nums.sort()`: यह लाइन `sort_nums` लिस्ट को सॉर्ट करती है, यानी इसे आरोही क्रम (ascending order) में व्यवस्थित करती है।
3. `ns = []`: यह एक खाली लिस्ट `ns` को इनिशियलाइज़ करती है जो अंतिम परिणाम स्टोर करेगी।
4. `for num in nums:`: यह लूप `nums` लिस्ट के प्रत्येक तत्व के लिए चलता है।
5. `ns.append(sort_nums.index(num))`: यह लाइन `sort_nums` लिस्ट में `num` की इंडेक्स को ढूंढती है और इसे `ns` लिस्ट में जोड़ती है। चूंकि `sort_nums` सॉर्टेड है, इसलिए `num` की इंडेक्स यह दर्शाती है कि `nums` लिस्ट में `num` से छोटे कितने तत्व हैं।
6. `return ns`: अंत में, यह लाइन `ns` लिस्ट को रिटर्न करती है, जिसमें प्रत्येक तत्व के लिए छोटे तत्वों की संख्या होती है।

उदाहरण के लिए, यदि `nums = [8, 1, 2, 2, 3]` है, तो `sort_nums` होगा `[1, 2, 2, 3, 8]`। `ns` लिस्ट में प्रत्येक तत्व के लिए `sort_nums` में उसकी इंडेक्स होगी, जो `[4, 0, 1, 1, 3]` होगी। यह दर्शाता है कि `8` से छोटे 4 तत्व हैं, `1` से छोटे 0 तत्व हैं, `2` से छोटे 1 तत्व है, और इसी तरह।

# print(Solution().smallerNumbersThanCurrent([8,1,2,2,3]))
```

यह केवल `64ms` का समय लेता है और `71%` सबमिशन को पीछे छोड़ देता है।

```python
class Solution:
    def smallerNumbersThanCurrent(self, nums: [int]) -> [int]:
        l = len(nums)
        ns = [0] * l
        for i in range(l):
          for j in range(i+1, l):
            if nums[i] > nums[j]:
              ns[i] +=1
            elif nums[i] < nums[j]:
              ns[j] +=1
            else:
              pass
        return ns
```

इस कोड में, `Solution` क्लास में एक मेथड `smallerNumbersThanCurrent` है जो एक लिस्ट `nums` लेता है और एक नई लिस्ट `ns` रिटर्न करता है। `ns` में प्रत्येक इंडेक्स पर वह संख्या होती है जो दर्शाती है कि `nums` में उस इंडेक्स की संख्या से छोटी कितनी संख्याएँ हैं।

उदाहरण के लिए, यदि `nums = [8,1,2,2,3]` है, तो `ns` होगा `[4,0,1,1,3]`। यह इसलिए क्योंकि:
- 8 से छोटी संख्याएँ हैं: 1, 2, 2, 3 (कुल 4)
- 1 से छोटी कोई संख्या नहीं है (कुल 0)
- 2 से छोटी संख्या है: 1 (कुल 1)
- 2 से छोटी संख्या है: 1 (कुल 1)
- 3 से छोटी संख्याएँ हैं: 1, 2, 2 (कुल 3)

इस कोड में दो नेस्टेड लूप्स हैं जो `nums` लिस्ट के हर जोड़े की तुलना करते हैं और `ns` लिस्ट को अपडेट करते हैं।

# print(Solution().smallerNumbersThanCurrent([8,1,2,2,3]))
```

एक और समाधान सोचा है। समय लगा `400ms`।

```python
class Solution:
    def smallerNumbersThanCurrent(self, nums: [int]) -> [int]:        
        ss = sorted((e,i) for i,e in enumerate(nums))
```

यह कोड एक `Solution` क्लास को परिभाषित करता है जिसमें एक मेथड `smallerNumbersThanCurrent` है। यह मेथड एक इनपुट लिस्ट `nums` लेता है और एक आउटपुट लिस्ट रिटर्न करता है जिसमें प्रत्येक एलिमेंट के लिए यह बताया जाता है कि उससे छोटे कितने एलिमेंट्स हैं।

`ss` वेरिएबल में, `nums` लिस्ट के एलिमेंट्स को उनके इंडेक्स के साथ जोड़कर सॉर्ट किया जाता है। यह सॉर्टिंग एलिमेंट्स के मान के आधार पर होती है।

यह कोड एक सूची `nums` की लंबाई `l` निकालता है और फिर एक नई सूची `smalls` बनाता है। `smalls` सूची में प्रत्येक इंडेक्स `i` के लिए, यह जाँचता है कि `ss` सूची में पिछले इंडेक्स `i-1` और वर्तमान इंडेक्स `i` के तत्व `e0` और `e1` समान हैं या नहीं। यदि वे समान हैं, तो `smalls` में पिछले इंडेक्स `i-1` का मान जोड़ा जाता है। यदि वे समान नहीं हैं, तो `smalls` में वर्तमान इंडेक्स `i` जोड़ा जाता है।

हिंदी में समझाएं:

```python
l = len(nums)  # nums सूची की लंबाई निकालें
smalls = [0]   # smalls सूची को शुरू करें, पहला मान 0 है

for i in range(1, l):  # 1 से l-1 तक लूप चलाएं
    (e0, j0) = ss[i-1]  # ss सूची में पिछले इंडेक्स का तत्व और उसका इंडेक्स
    (e1, j1) = ss[i]    # ss सूची में वर्तमान इंडेक्स का तत्व और उसका इंडेक्स
    
    if e0 == e1:  # यदि पिछला और वर्तमान तत्व समान हैं
        smalls.append(smalls[i-1])  # smalls में पिछले इंडेक्स का मान जोड़ें
    else:  # यदि पिछला और वर्तमान तत्व समान नहीं हैं
        smalls.append(i)  # smalls में वर्तमान इंडेक्स जोड़ें
```

इस कोड का उद्देश्य `smalls` सूची को इस तरह से भरना है कि यदि `ss` सूची में लगातार दो तत्व समान हों, तो `smalls` में उसी इंडेक्स का मान दोहराया जाए, अन्यथा नया इंडेक्स जोड़ा जाए।

```python
ns = [0]*l
for i in range(l):
    (e, j) = ss[i]
    ns[j] = smalls[i]
return ns
```

यह कोड एक सूची `ns` को शून्य से प्रारंभ करता है जिसकी लंबाई `l` है। फिर यह एक लूप के माध्यम से `ss` सूची के प्रत्येक तत्व को पढ़ता है, जहां प्रत्येक तत्व एक टपल `(e, j)` है। `j` का उपयोग `ns` सूची में इंडेक्स के रूप में किया जाता है, और `smalls[i]` का मान `ns[j]` में असाइन किया जाता है। अंत में, `ns` सूची को वापस लौटाया जाता है।

# print(Solution().smallerNumbersThanCurrent([8,1,2,2,3]))
```

> रनटाइम: 52 मिलीसेकंड, Python3 में ऑनलाइन सबमिशन्स के 91.45% से तेज़ है "हाउ मेनी नंबर्स आर स्मॉलर दैन द करंट नंबर" के लिए।
>
> मेमोरी उपयोग: 14.6 MB, Python3 में ऑनलाइन सबमिशन्स के 15.18% से कम है "हाउ मेनी नंबर्स आर स्मॉलर दैन द करंट नंबर" के लिए।

आखिरकार सफलता मिल गई! यह तरीका और भी तेज़ है और `91.45%` सबमिशन को पीछे छोड़ दिया है।

और संक्षिप्त करें।

```python
class Solution:
    def smallerNumbersThanCurrent(self, nums: [int]) -> [int]:
        ss = sorted((e,i) for i,e in enumerate(nums))
```

```python
l = len(nums)
smalls = [0]
ns = [0]*l
for i in range(1, l):
    (e0, j0) = ss[i-1]
    (e1, j1) = ss[i]
    if e0 == e1:
        smalls.append(smalls[i-1])
    else:
        smalls.append(i)
```

```python
ns[j1] = smalls[i]
return ns
```

# print(Solution().smallerNumbersThanCurrent([8,1,2,2,3]))
```

जारी रखें।

```python
class Solution:
    def smallerNumbersThanCurrent(self, nums: [int]) -> [int]:
        ss = sorted((e,i) for i,e in enumerate(nums))
```

यह कोड एक क्लास `Solution` को परिभाषित करता है जिसमें एक मेथड `smallerNumbersThanCurrent` है। यह मेथड एक लिस्ट `nums` लेता है और एक नई लिस्ट रिटर्न करता है जिसमें प्रत्येक एलिमेंट के लिए यह दर्शाता है कि मूल लिस्ट में उससे छोटे कितने एलिमेंट्स हैं।

`ss` वेरिएबल में, `nums` लिस्ट के एलिमेंट्स को उनके इंडेक्स के साथ जोड़कर सॉर्ट किया जाता है। यह सॉर्टिंग एलिमेंट्स के मान के आधार पर की जाती है।

```python
l = len(nums)
last = 0
ns = [0]*l
for i in range(1, l):
  (e0, j0) = ss[i-1]
  (e1, j1) = ss[i]
  if e0 == e1:
    pass
  else:
    last = i
```

```python
ns[j1] = last
return ns
```

यह कोड `ns` नामक सूची में `j1` इंडेक्स पर `last` वैल्यू को असाइन करता है और फिर `ns` सूची को वापस लौटाता है।

# print(Solution().smallerNumbersThanCurrent([8,1,2,2,3]))
```

इस समय हम `40ms` तक पहुँच गए हैं, जो `99.81%` प्रोग्राम को पीछे छोड़ देता है।

> रनटाइम: 40 मिलीसेकंड, Python3 में ऑनलाइन सबमिशन्स में से 99.81% से तेज़ है, "How Many Numbers Are Smaller Than the Current Number" के लिए।
>
> मेमोरी उपयोग: 14.4 MB, Python3 में ऑनलाइन सबमिशन्स में से 15.18% से कम है, "How Many Numbers Are Smaller Than the Current Number" के लिए।

एक और समाधान।

```python
class Solution:
    def smallerNumbersThanCurrent(self, nums: [int]) -> [int]:
      l = len(nums)
      n = [0] * 101
      max_num = 0
      for num in nums:
        n[num] += 1
        if num > max_num:
          max_num = num
```

यह कोड एक समस्या को हल करने के लिए है जहां हमें एक सूची `nums` दी जाती है और हमें यह पता लगाना होता है कि प्रत्येक संख्या से छोटी संख्याओं की संख्या कितनी है। 

1. `l = len(nums)` - यह सूची `nums` की लंबाई को `l` में स्टोर करता है।
2. `n = [0] * 101` - यह एक सूची `n` बनाता है जिसमें 101 शून्य होते हैं। यह सूची संख्याओं की गिनती को स्टोर करने के लिए उपयोग की जाएगी।
3. `max_num = 0` - यह वेरिएबल `max_num` को 0 पर सेट करता है, जो सूची में सबसे बड़ी संख्या को ट्रैक करेगा।
4. `for num in nums:` - यह लूप सूची `nums` में प्रत्येक संख्या के लिए चलता है।
   - `n[num] += 1` - यह संख्या `num` की गिनती को सूची `n` में बढ़ाता है।
   - `if num > max_num:` - यह जांचता है कि क्या वर्तमान संख्या `num` अब तक की सबसे बड़ी संख्या `max_num` से बड़ी है।
     - `max_num = num` - यदि हां, तो `max_num` को वर्तमान संख्या `num` पर अपडेट करता है।

इस कोड का उद्देश्य यह है कि हम प्रत्येक संख्या के लिए यह पता लगा सकें कि सूची में उससे छोटी कितनी संख्याएं हैं।

```python
sm = [0] * (max_num + 1)
sum = 0
for i in range(max_num+1):
    sm[i] = sum
    sum += n[i]
  
ns = [0] * l
for i in range(l):
    ns[i] = sm[nums[i]]
```

      return ns

# print(Solution().smallerNumbersThanCurrent([8,1,2,2,3]))
```

यहाँ थोड़ा और जटिल उदाहरण है।

```python
class Solution:
    def smallerNumbersThanCurrent(self, nums: [int]) -> [int]:
      l = len(nums)
      n = [0] * 101
      max_num = 0
      for num in nums:
        n[num] += 1
        if num > max_num:
          max_num = num
```

यह कोड एक क्लास `Solution` को परिभाषित करता है जिसमें एक मेथड `smallerNumbersThanCurrent` है। यह मेथड एक इनपुट लिस्ट `nums` लेता है और एक आउटपुट लिस्ट रिटर्न करता है जिसमें प्रत्येक एलिमेंट के लिए यह बताया जाता है कि उससे छोटे कितने नंबर हैं।

1. `l = len(nums)`: इनपुट लिस्ट `nums` की लंबाई को `l` में स्टोर करता है।
2. `n = [0] * 101`: एक लिस्ट `n` बनाता है जिसमें 101 एलिमेंट हैं, सभी शुरू में 0 से इनिशियलाइज़ होते हैं। यह लिस्ट प्रत्येक नंबर की फ्रीक्वेंसी को स्टोर करेगी।
3. `max_num = 0`: `max_num` वेरिएबल को 0 से इनिशियलाइज़ करता है, जो इनपुट लिस्ट में सबसे बड़े नंबर को ट्रैक करेगा।
4. `for num in nums`: इनपुट लिस्ट `nums` के प्रत्येक एलिमेंट के लिए लूप चलाता है।
   - `n[num] += 1`: `n` लिस्ट में `num` इंडेक्स पर वैल्यू को 1 से इन्क्रीमेंट करता है, यह `num` की फ्रीक्वेंसी को ट्रैक करता है।
   - `if num > max_num: max_num = num`: यदि `num` `max_num` से बड़ा है, तो `max_num` को `num` के साथ अपडेट करता है।

यह कोड अभी पूरा नहीं हुआ है, लेकिन यह इनपुट लिस्ट में प्रत्येक नंबर की फ्रीक्वेंसी और सबसे बड़े नंबर को ट्रैक कर रहा है।

```python
short_n = []
short_num = [] * l
zn = [0] * 101
j = 0
for i in range(max_num+1):
    if n[i] > 0:
        zn[i] = j          
        short_n.append(n[i])          
        short_num.append(num)
        j+=1
```

यह कोड एक सूची `short_n` और `short_num` को प्रारंभ करता है, और एक सूची `zn` को 101 शून्य मानों के साथ प्रारंभ करता है। फिर यह `max_num+1` तक एक लूप चलाता है। यदि `n[i]` का मान 0 से अधिक है, तो यह `zn[i]` को `j` के मान से सेट करता है, `short_n` में `n[i]` को जोड़ता है, और `short_num` में `num` को जोड़ता है। अंत में, `j` को 1 से बढ़ाया जाता है।

```python
sm = [0] * j
sum = 0
for i in range(j):
    sm[i] = sum
    sum += short_n[i]
  
ns = [0] * l
for i in range(l):
    ns[i] = sm[zn[nums[i]]]
return ns
```

यह कोड निम्नलिखित कार्य करता है:

1. `sm` नामक एक सूची बनाई जाती है जिसमें `j` शून्य होते हैं।
2. `sum` नामक एक वेरिएबल को 0 पर सेट किया जाता है।
3. एक लूप `j` बार चलता है और `sm` सूची में `sum` का मान डालता है, फिर `sum` में `short_n[i]` को जोड़ता है।
4. `ns` नामक एक सूची बनाई जाती है जिसमें `l` शून्य होते हैं।
5. एक लूप `l` बार चलता है और `ns` सूची में `sm[zn[nums[i]]]` का मान डालता है।
6. अंत में, `ns` सूची को वापस लौटाया जाता है।

# print(Solution().smallerNumbersThanCurrent([8,1,2,2,3]))
```

```python
class Solution:    

    def smallerNumbersThanCurrent(self, nums: [int]) -> [int]:
      max_num = max(nums)
```

```python
n = [0] * (max_num + 1)
for num in nums:
    n[num] += 1
```

```python
sorted_ls = []
for i in range(max_num + 1):
    if n[i] > 0:
        sorted_ls.append(i)
```

यह कोड एक खाली सूची `sorted_ls` बनाता है और फिर `0` से `max_num` तक के सभी नंबरों के लिए लूप चलाता है। यदि `n[i]` (यानी `n` सूची में `i` इंडेक्स पर मौजूद मान) `0` से बड़ा है, तो `i` को `sorted_ls` सूची में जोड़ दिया जाता है। इस तरह, `sorted_ls` सूची में उन इंडेक्स के मान शामिल होते हैं जिनके लिए `n` सूची में मान `0` से अधिक होता है।

```python
sm = [0] * (max_num + 1)
sum = 0
for i in range(len(sorted_ls)):
    v = sorted_ls[i]
    sm[v] = sum
    sum += n[v]
  
ns = [] 
for i in range(len(nums)):
    ns.append(sm[nums[i]])
return ns
# print(Solution().smallerNumbersThanCurrent([72,48,32,16,10,59,83,38,1,4,68,7,67,16,5,35,99,15,55,11,24,3,63,81,16,95,35,87,24,84,57,49,42,80,34,33,82,81,31,31,7,75,100,75,22,44,54,77,89,71,81,66,7]))
```

## अभ्यास

* छात्र ऊपर दिए गए उदाहरण की तरह कुछ प्रश्नों को हल कर सकते हैं।