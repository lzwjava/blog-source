---
audio: false
generated: true
lang: hi
layout: post
title: रस्ट आउटपुट स्थान विकल्प
translated: true
type: note
---

आप एक बहुत अच्छा सवाल पूछ रहे हैं जो रस्ट प्रोजेक्ट्स की सामान्य संरचना और बिल्ड प्रक्रिया को छूता है!

जब आप सीधे `rustc` का उपयोग करते हैं, तो आउटपुट लोकेशन निर्दिष्ट करने के आपके पास दो मुख्य विकल्प हैं:

1.  **`-o <output_filename>`**: यह विकल्प कंपाइल की गई executable या लाइब्रेरी के लिए *सटीक पथ और फ़ाइलनाम* निर्दिष्ट करता है।

    ```bash
    rustc scripts/rust/example.rs -o test/example
    ```

    यह `example.rs` को कंपाइल करेगा और `example` नाम की executable को सीधे `test/` डायरेक्टरी में रख देगा। यदि `test/` मौजूद नहीं है, तो `rustc` इसे बना देगा।

2.  **`--out-dir <output_directory>`**: यह विकल्प एक *डायरेक्टरी* निर्दिष्ट करता है जहां `rustc` सभी जनरेटेड आउटपुट फाइलों (executable/लाइब्रेरी, साथ ही कोई भी इंटरमीडिएट फाइलें जैसे `.d`, `.rmeta`, आदि) को रखेगा।

    ```bash
    rustc scripts/rust/example.rs --out-dir test/
    ```

    इस मामले में, `rustc` `example.rs` को कंपाइल करेगा और executable (जिसका नाम डिफ़ॉल्ट रूप से `example` होगा, सोर्स फाइल के नाम से लिया गया) को `test/` डायरेक्टरी के अंदर रख देगा।

**सिफारिश: प्रोजेक्ट्स के लिए Cargo का उपयोग करें**

हालांकि सीधे `rustc` का उपयोग आपको बारीक नियंत्रण देता है, अधिकांश रस्ट प्रोजेक्ट्स के लिए, आप **Cargo** का उपयोग करना चाहेंगे। Cargo रस्ट का बिल्ड सिस्टम और पैकेज मैनेजर है, और यह dependencies को मैनेज करने, कोड बनाने, टेस्ट करने और चलाने को सरल बनाता है।

Cargo के साथ, आउटपुट बाइनरीज़ आमतौर पर आपकी प्रोजेक्ट रूट के अंदर एक `target` डायरेक्टरी में रखी जाती हैं। उदाहरण के लिए, यदि आपके पास Cargo के साथ सेटअप किया गया कोई प्रोजेक्ट है:

```
my_project/
├── Cargo.toml
└── src/
    └── main.rs
```

जब आप `cargo build` या `cargo run` चलाते हैं, तो कंपाइल की गई executable `my_project/target/debug/my_project` (डीबग बिल्ड्स के लिए) या `my_project/target/release/my_project` (रिलीज़ बिल्ड्स के लिए) में रखी जाएगी।

यदि आप Cargo के लिए `target` डायरेक्टरी को नियंत्रित करना चाहते हैं, तो आप कर सकते हैं:

  * **`CARGO_TARGET_DIR` environment variable**:

    ```bash
    CARGO_TARGET_DIR=./test cargo build
    ```

    यह पूरी `target` डायरेक्टरी (जिसमें `debug`, `release`, आदि शामिल हैं) को आपकी `test/` डायरेक्टरी के अंदर रख देगा। executable फिर `test/debug/my_project` पर होगी।

  * **Cargo के लिए `--target-dir` command-line option**:

    ```bash
    cargo build --target-dir test/
    ```

    यह environment variable के समान काम करता है।

  * **`.cargo/config.toml`**: आप अपनी मशीन पर सभी Cargo प्रोजेक्ट्स के लिए या किसी विशिष्ट workspace के लिए एक डिफ़ॉल्ट `target-dir` सेट कर सकते हैं, इसे `.cargo/config.toml` फाइल में जोड़कर।

**Cargo का उपयोग क्यों करें?**

  * **मानकीकृत प्रोजेक्ट लेआउट:** Cargo एक सामान्य प्रोजेक्ट संरचना लागू करता है, जिससे अन्य रस्ट डेवलपर्स के लिए आपका कोड समझना आसान हो जाता है।
  * **डिपेंडेंसी मैनेजमेंट:** Cargo आपकी प्रोजेक्ट की dependencies को स्वचालित रूप से डाउनलोड और कंपाइल करने का काम संभालता है।
  * **टेस्टिंग और बेंचमार्किंग:** Cargo में टेस्ट चलाने (`cargo test`) और बेंचमार्क (`cargo bench`) के लिए बिल्ट-इन कमांड्स हैं।
  * **रिलीज़ मैनेजमेंट:** Cargo रिलीज़ बिल्ड्स (`cargo build --release`) बनाने और crates.io पर क्रेट्स पब्लिश करने में मदद करता है।

जब तक आपके पास कोई बहुत ही विशिष्ट कारण न हो, यह अत्यधिक अनुशंसा की जाती है कि आप अपने रस्ट कोड को एक Cargo प्रोजेक्ट में व्यवस्थित करें।

**आपके `git status` आउटपुट को देखते हुए:**

आपका `git status` `example` और `scripts/rust/` को अनट्रैक्ड दिखा रहा है। इससे पता चलता है कि आप शायद Cargo प्रोजेक्ट के बाहर सीधे `rustc` के साथ `scripts/rust/example.rs` को कंपाइल कर रहे हैं।

यदि `example` कंपाइल की गई बाइनरी है, तो पिछले `rustc scripts/rust/example.rs` कमांड ने इसे वर्तमान डायरेक्टरी (`lzwjava.github.io`) में रख दिया है।

आपके लक्ष्य को प्राप्त करने के लिए, इसे `test/example` में रखना (यह मानते हुए कि `test` `lzwjava.github.io` की रूट पर एक डायरेक्टरी है), आप इसका उपयोग करेंगे:

```bash
rustc scripts/rust/example.rs -o test/example
```

यह `rustc` का उपयोग करके आपके द्वारा पूछे गए विशिष्ट आउटपुट पथ को प्राप्त करने का सबसे सीधा तरीका है।