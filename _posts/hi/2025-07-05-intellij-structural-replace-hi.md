---
audio: false
generated: true
lang: hi
layout: post
title: इंटेलीजे की संरचनात्मक प्रतिस्थापन में महारत
translated: true
type: note
---

ठीक है, आइए IntelliJ IDEA की Structural Replace सुविधा को समझते हैं।

IntelliJ IDEA की Structural Replace एक अविश्वसनीय रूप से शक्तिशाली, लेकिन अक्सर अल्प-उपयोग की जाने वाली सुविधा है जो आपको कोड पैटर्न को उनकी **संरचना** के आधार पर ढूंढने और बदलने की अनुमति देती है, न कि केवल उनकी शाब्दिक सामग्री के आधार पर। यह साधारण टेक्स्ट खोज और प्रतिस्थापन से कहीं आगे जाती है, जो बड़े कोडबेस में जटिल रीफैक्टरिंग, कोड स्टाइल लागू करने और बग ठीक करने में सक्षम बनाती है।

यहाँ एक व्यापक गाइड है:

-----

## IntelliJ IDEA Structural Replace: एक व्यापक गाइड

### 1. Structural Search और Replace (SSR) क्या है?

मूल रूप से, IntelliJ IDEA में SSR Abstract Syntax Trees (ASTs) के साथ काम करने के बारे में है। शाब्दिक स्ट्रिंग्स को खोजने के बजाय, आप एक *पैटर्न* परिभाषित करते हैं जो उस कोड की संरचना का वर्णन करता है जिसे आप ढूंढना चाहते हैं (Structural Search) और एक दूसरा पैटर्न जो बताता है कि आप उसे कैसे बदलना चाहते हैं (Structural Replace)।

यह आपको यह करने की अनुमति देता है:

  * **कोड रीफैक्टर करना:** मेथड्स को कॉल करने का तरीका बदलना, पैरामीटर्स का क्रम बदलना, फ़ील्ड्स को एनकैप्सुलेट करना, आदि।
  * **कोडिंग मानकों को लागू करना:** विशिष्ट भाषा निर्माणों या API कॉल्स के सुसंगत उपयोग को सुनिश्चित करना।
  * **सामान्य बग्स ठीक करना:** आवर्ती तार्किक त्रुटियों की पहचान करना और सुधारना।
  * **APIs माइग्रेट करना:** लाइब्रेरीज़ या फ्रेमवर्क बदलने पर कोड अपडेट करना।
  * **Deprecated कोड साफ़ करना:** पुराने API उपयोगों को ढूंढकर नए वाले से बदलना।

### 2. Structural Search और Replace तक पहुँचना

आप SSR डायलॉग को दो तरीकों से एक्सेस कर सकते हैं:

  * **Edit -> Find -> Search Structurally... पर जाएँ** (खोजने के लिए)
  * **Edit -> Find -> Replace Structurally... पर जाएँ** (सीधे बदलने के लिए)

दोनों के लिए डायलॉग बहुत समान है, जिसमें "Replace Structurally" बस एक "Replace Template" फ़ील्ड जोड़ता है।

### 3. Structural Search डायलॉग को समझना

Structural Search डायलॉग वह जगह है जहाँ आप अपना खोज पैटर्न परिभाषित करते हैं।

#### 3.1. Search Template

यह सबसे महत्वपूर्ण हिस्सा है। आप एक कोड स्निपेट लिखते हैं जो उस *संरचना* का प्रतिनिधित्व करता है जिसे आप ढूंढ रहे हैं।

**मुख्य अवधारणाएँ:**

  * **शाब्दिक कोड:** आप जो कोड सीधे लिखते हैं वह शाब्दिक रूप से मेल खाएगा।
  * **वेरिएबल्स:** कोड के उन हिस्सों का प्रतिनिधित्व करने के लिए वेरिएबल्स का उपयोग करें जो भिन्न हो सकते हैं। वेरिएबल्स को एक विशेष सिंटैक्स का उपयोग करके परिभाषित किया जाता है और फिर उन पर constraints के साथ कॉन्फ़िगर किया जाता है।
      * **सामान्य वेरिएबल सिंटैक्स:** `$variableName$` (डॉलर चिह्न में enclosed)।
      * **उदाहरण:** `System.out.println($arg$);` कोई भी `System.out.println` कॉल ढूंढेगा, जहाँ `$arg$` कोष्ठक के अंदर जो कुछ भी है उससे मेल खाएगा।

#### 3.2. Script Constraints (वेरिएबल्स पर)

अपने "Search Template" में वेरिएबल्स को परिभाषित करने के बाद, आपको उनकी constraints निर्दिष्ट करने की आवश्यकता होती है। यह टेम्पलेट में वेरिएबल का चयन करके और फिर "Edit variables" बटन (अक्सर टेम्पलेट फ़ील्ड के बगल में एक छोटा पेंसिल आइकन या "Variables" टैब के माध्यम से एक्सेस करने योग्य) का उपयोग करके किया जाता है।

सामान्य constraints में शामिल हैं:

  * **टेक्स्ट (regexp):** एक regular expression जिससे वेरिएबल की टेक्स्ट सामग्री का मेल होना चाहिए।
  * **टाइप (regexp):** एक regular expression जिससे वेरिएबल के प्रकार का मेल होना चाहिए (जैसे, `java.lang.String`, `int[]`)।
  * **काउंट:** निर्दिष्ट करता है कि एक वेरिएबल एलिमेंट कितनी बार दिखाई दे सकता है (जैसे, `[0, N]`, `[1, N]`, `[1, 1]`)। यह विशेष रूप से स्टेटमेंट्स या मेथड पैरामीटर्स के संग्रह के लिए उपयोगी है।
  * **रिफरेन्स:** यदि वेरिएबल एक आइडेंटिफायर (जैसे मेथड नाम या वेरिएबल नाम) का प्रतिनिधित्व करता है, तो आप इसे किसी विशिष्ट प्रकार या डिक्लेरेशन को refer करने के लिए constrain कर सकते हैं।
  * **विदिन:** वेरिएबल को एक निश्चित स्कोप या डिक्लेरेशन के भीतर होने के लिए constrain करता है।
  * **नॉट RegExp:** एक regular expression के आधार पर matches को बाहर करता है।
  * **कंडीशन (Groovy script):** यह सबसे शक्तिशाली constraint है। आप एक Groovy script लिख सकते हैं जो `true` या `false` का मूल्यांकन करती है। इस script की मेल खाने वाले एलिमेंट और उसके गुणों तक पहुंच होती है, जो बहुत जटिल लॉजिक की अनुमति देती है।
      * **उदाहरण स्क्रिप्ट:** यह जांचने के लिए कि क्या एक integer वेरिएबल का मान 10 से अधिक है: `_target.text.toInteger() > 10` (जहाँ `_target` वेरिएबल के लिए मेल खाने वाला एलिमेंट है)।

#### 3.3. विकल्प

टेम्पलेट के नीचे, आपकी खोज को परिष्कृत करने के लिए विभिन्न विकल्प हैं:

  * **कॉन्टेक्स्ट:** खोज के स्कोप को परिभाषित करता है (जैसे, संपूर्ण प्रोजेक्ट, मॉड्यूल, डायरेक्टरी, चयनित फ़ाइलें, कस्टम स्कोप)।
  * **फ़ाइल प्रकार:** खोज को विशिष्ट फ़ाइल प्रकारों (Java, Kotlin, XML, आदि) तक सीमित करता है।
  * **केस सेंसिटिव:** मानक केस संवेदनशीलता टॉगल।
  * **मैच केस/व्होल वर्ड्स:** टेम्पलेट के भीतर टेक्स्ट के लिए लागू।
  * **मैच लाइन ब्रेक्स:** मल्टी-लाइन पैटर्न के लिए महत्वपूर्ण।
  * **टेम्पलेट सेव करें:** भविष्य के उपयोग के लिए आपके वर्तमान खोज टेम्पलेट को सहेजता है।

### 4. Structural Replace डायलॉग को समझना

Structural Replace डायलॉग "Search Template" और "Variables" के लिए जो आप खोज के लिए परिभाषित करते हैं, उसमें एक "Replace Template" फ़ील्ड जोड़ता है।

#### 4.1. Replace Template

यह वह जगह है जहाँ आप परिभाषित करते हैं कि पाए गए कोड संरचना को कैसे बदला जाना चाहिए।

  * **Search Template से वेरिएबल्स:** आप "Replace Template" के भीतर अपने "Search Template" में परिभाषित समान वेरिएबल्स का उपयोग कर सकते हैं। खोज में वेरिएबल द्वारा मेल खाई गई सामग्री को replace टेम्पलेट में डाला जाएगा।
  * **नया कोड:** आप नए कोड एलिमेंट्स पेश कर सकते हैं, मौजूदा लोगों को पुन: व्यवस्थित कर सकते हैं, या भागों को हटा सकते हैं।
  * **उदाहरण:**
      * **खोज टेम्पलेट:** `System.out.println($arg$);`
      * **बदलें टेम्पलेट:** `LOGGER.info($arg$);`
      * यह `System.out.println("Hello");` को `LOGGER.info("Hello");` में बदल देगा।

#### 4.2. Shorten FQ Names

यह विकल्प (अक्सर स्वचालित रूप से सक्षम) fully qualified class names (जैसे, `java.util.ArrayList`) को उनके short names (जैसे, `ArrayList`) से बदलने और आवश्यक import स्टेटमेंट्स जोड़ने का प्रयास करता है। पठनीय कोड बनाए रखने के लिए यह महत्वपूर्ण है।

#### 4.3. फॉर्मेटिंग

IntelliJ IDEA आमतौर पर आपकी प्रोजेक्ट की कोड स्टाइल सेटिंग्स के अनुसार बदले गए कोड को reformat करेगी, जो अत्यधिक वांछनीय है।

### 5. व्यावहारिक उदाहरण

आइए कुछ सामान्य परिदृश्यों के साथ समझाते हैं।

#### उदाहरण 1: `System.out.println` को Logger से बदलना

**लक्ष्य:** सभी `System.out.println("message");` को `LOGGER.info("message");` में बदलें (मानते हुए कि `LOGGER` एक static final फ़ील्ड है)।

1.  **Structural Replace खोलें:** `Edit -> Find -> Replace Structurally...`
2.  **खोज टेम्पलेट:**
    ```java
    System.out.println($arg$);
    ```
3.  **वेरिएबल्स:** "Edit variables" पर क्लिक करें या "Variables" टैब पर जाएँ।
      * `$arg$` का चयन करें।
      * **काउंट:** `[1, 1]` (एक argument)।
      * **टाइप (regexp):** `java.lang.String` (यदि आप केवल string literals को बदलना चाहते हैं, अन्यथा किसी भी प्रकार के लिए इसे खाली छोड़ दें)।
4.  **बदलें टेम्पलेट:**
    ```java
    LOGGER.info($arg$);
    ```
5.  **रन:** परिवर्तनों का पूर्वावलोकन करने के लिए "Find" पर क्लिक करें, फिर यदि आप संतुष्ट हैं तो "Replace All" पर क्लिक करें।

#### उदाहरण 2: मेथड पैरामीटर्स की अदला-बदली

**लक्ष्य:** `someMethod(paramA, paramB)` को `someMethod(paramB, paramA)` में बदलें।

1.  **खोज टेम्पलेट:**
    ```java
    someMethod($paramA$, $paramB$);
    ```
2.  **वेरिएबल्स:**
      * `$paramA$`: `काउंट: [1,1]`, `टाइप (regexp): .*` (कोई भी प्रकार)
      * `$paramB$`: `काउंट: [1,1]`, `टाइप (regexp): .*` (कोई भी प्रकार)
3.  **बदलें टेम्पलेट:**
    ```java
    someMethod($paramB$, $paramA$);
    ```

#### उदाहरण 3: एक फ़ील्ड को Encapsulate करना (सरल मामला)

**लक्ष्य:** यदि आपके पास public फ़ील्ड्स हैं जैसे `public String name;` और आप सीधे एक्सेस `obj.name` को `obj.getName()` से बदलना चाहते हैं। (यह एक सरलीकृत उदाहरण है; अक्सर आप encapsulation के लिए समर्पित रीफैक्टरिंग का उपयोग करेंगे)।

1.  **खोज टेम्पलेट:**
    ```java
    $object$.$fieldName$;
    ```
2.  **वेरिएबल्स:**
      * `$object$`: `काउंट: [1,1]`, `टाइप (regexp): .*`
      * `$fieldName$`: `काउंट: [1,1]`, `टेक्स्ट (regexp): name` (विशेष रूप से `name` फ़ील्ड को टारगेट करें)।
3.  **बदलें टेम्पलेट:**
    ```java
    $object$.get$fieldName$();
    ```
      * **नोट:** आपको कैपिटलाइज़ेशन को एडजस्ट करने की आवश्यकता हो सकती है यदि `get$fieldName$` स्वचालित रूप से `name` को `Name` में नहीं बदलता है। इसके लिए, आप replace टेम्पलेट के भीतर `$fieldName$` पर एक Groovy script का उपयोग कर सकते हैं, लेकिन यह अधिक जटिल हो जाता है। इस विशिष्ट मामले के लिए एक सरल दृष्टिकोण अक्सर दो SSR या एक समर्पित रीफैक्टरिंग होता है। `get$fieldName$()` के लिए, IDE आमतौर पर सामान्य getter पैटर्न के लिए कैपिटलाइज़ेशन को संभालता है।

#### उदाहरण 4: खाली `catch` ब्लॉक ढूँढना

**लक्ष्य:** सभी `catch` ब्लॉक ढूंढें जो खाली हैं (या केवल comments/whitespace शामिल करते हैं)।

1.  **खोज टेम्पलेट:**
    ```java
    try {
        $statements$;
    } catch ($exceptionType$ $exceptionVariable$) {
        $emptyBody$;
    }
    ```
2.  **वेरिएबल्स:**
      * `$statements$`: `काउंट: [0, N]` (try ब्लॉक में शून्य या अधिक स्टेटमेंट्स)
      * `$exceptionType$`: `काउंट: [1,1]`
      * `$exceptionVariable$`: `काउंट: [1,1]`
      * `$emptyBody$`: `काउंट: [0, 0]` (यह खाली बॉडी के लिए कुंजी है)

#### उदाहरण 5: उन्नत शर्तों के लिए Groovy Script का उपयोग करना

**लक्ष्य:** `if` स्टेटमेंट्स ढूंढें जहाँ condition एक constant `true` है।

1.  **खोज टेम्पलेट:**
    ```java
    if ($condition$) {
        $thenBranch$;
    }
    ```
2.  **वेरिएबल्स:**
      * `$condition$`: `काउंट: [1,1]`
          * **कंडीशन (Groovy script):** `_target.text == "true"` (यह condition के शाब्दिक टेक्स्ट की जांच करता है)।
      * `$thenBranch$`: `काउंट: [0, N]`

### 6. सुझाव और सर्वोत्तम अभ्यास

  * **सरल शुरुआत करें:** बुनियादी पैटर्न से शुरुआत करें और धीरे-धीरे जटिलता जोड़ें।
  * **पहले `Find` का उपयोग करें:** "Replace" से पहले हमेशा "Find" (Structural Search) का उपयोग करके matches का पूर्वावलोकन करें और सुनिश्चित करें कि आपका पैटर्न सही है।
  * **छोटे स्कोप पर टेस्ट करें:** बड़े पैमाने पर replacement चलाने से पहले, अपने पैटर्न को फ़ाइलों के एक छोटे, अलग-थलग सेट पर टेस्ट करें।
  * **टेम्पलेट्स सेव करें:** अक्सर उपयोग किए जाने वाले या जटिल टेम्पलेट्स को आसान पुन: उपयोग के लिए सहेजें।
  * **मौजूदा टेम्पलेट्स का लाभ उठाएँ:** IntelliJ IDEA कई पूर्वनिर्धारित Structural Search और Replace टेम्पलेट्स के साथ आता है। आप उन्हें SSR डायलॉग में "magnifying glass with plus" आइकन पर क्लिक करके और मौजूदा टेम्पलेट्स को ब्राउज़ करके पा सकते हैं। ये उत्कृष्ट सीखने के संसाधन हैं।
  * **Groovy Script शक्ति:** अत्यधिक विशिष्ट या context-sensitive matches के लिए, Groovy scripts अमूल्य हैं। स्क्रिप्ट के भीतर एलिमेंट्स (`_target`, `_target.parent`, `_target.text`, `_target.type`, आदि) तक पहुँचने के मूल सिद्धांतों को सीखें।
  * **मैच प्रकारों को समझें:** अपने वेरिएबल्स किससे मेल खा रहे हैं (जैसे, एक स्टेटमेंट, एक एक्सप्रेशन, एक प्रकार, एक वेरिएबल नाम) इसके प्रति सजग रहें। यह उन constraints को प्रभावित करता है जो आप लागू कर सकते हैं।
  * **Regular Expressions:** regular expressions की अच्छी समझ आपकी `टेक्स्ट` और `टाइप` constraints को परिभाषित करने की क्षमता को काफी बढ़ा देगी।
  * **डीबगिंग:** यदि आपका पैटर्न अपेक्षा के अनुरूप मेल नहीं खा रहा है, तो इसे सरल बनाएं। जब तक यह मेल खाना शुरू न हो जाए, constraints को एक-एक करके हटाएं, फिर समस्या का पता लगाने के लिए उन्हें फिर से लागू करें।
  * **अपने कोड का बैकअप लें:** एक बड़े कोडबेस पर किसी भी बड़े structural replacement ऑपरेशन से पहले, सुनिश्चित करें कि आपके पास बैकअप है या आप एक ऐसी वर्जन कंट्रोल सिस्टम के भीतर काम कर रहे हैं जहाँ आप आसानी से परिवर्तनों को वापस ले सकते हैं।

### 7. सीमाएँ

  * **जटिलता:** बहुत जटिल या अत्यधिक प्रासंगिक replacements को केवल SSR के साथ व्यक्त करना मुश्किल या असंभव हो सकता है। कभी-कभी, एक कस्टम IntelliJ IDEA प्लगइन या एक समर्पित स्क्रिप्ट अधिक उपयुक्त हो सकती है।
  * **प्रदर्शन:** एक बहुत बड़े कोडबेस पर चलने वाले अत्यधिक व्यापक या जटिल पैटर्न धीमे हो सकते हैं।
  * **अस्पष्टता:** अत्यधिक सामान्य पैटर्न के साथ सावधान रहें, क्योंकि वे अनजाने में उस कोड से मेल खा सकते हैं और उसे संशोधित कर सकते हैं जिसका आपने इरादा नहीं किया था।

-----

IntelliJ IDEA के Structural Search और Replace में महारत हासिल करके, आप कोड गुणवत्ता बनाए रखने, बड़े पैमाने पर रीफैक्टरिंग करने और थकाऊ कोड संशोधनों को स्वचालित करने के लिए एक शक्तिशाली उपकरण प्राप्त करते हैं। यह एक ऐसी सुविधा है जो वास्तव में डेवलपर्स को उनकी परियोजनाओं में अधिक कुशल और सुसंगत रूप से काम करने का सशक्तिकरण देती है।