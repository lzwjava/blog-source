---
audio: false
generated: true
lang: hi
layout: post
title: 'क्यूबिटटोरेंट फ़ाइल सत्यापन: एसएचए-1 हैशिंग'
translated: true
type: note
---

जब आप qBittorrent में फ़ाइल स्थानों को स्थानांतरित करते हैं और यह सीडिंग से पहले फ़ाइलों को फिर से जांचता है, तो यह सुनिश्चित कर रहा होता है कि नए स्थान पर मौजूद फ़ाइलें वही हैं जिनके साथ यह मूल रूप से काम कर रहा था। टोरेंटिंग में गलत या दूषित डेटा साझा करने से रोकने के लिए यह सत्यापन महत्वपूर्ण है। यहां बताया गया है कि यह प्रक्रिया कैसे काम करती है और यह किस एल्गोरिदम का उपयोग करती है:

### qBittorrent फ़ाइलों को कैसे सत्यापित करता है
qBittorrent केवल यह विश्वास नहीं करता कि स्थानांतरित फ़ाइलें सही हैं - यह टोरेंट फ़ाइल में संग्रहीत जानकारी के साथ उनकी तुलना करके उनकी अखंडता की जांच करता है। टोरेंटिंग में, डेटा को छोटे-छोटे हिस्सों में विभाजित किया जाता है जिन्हें **पीस** कहा जाता है, और प्रत्येक पीस का एक अद्वितीय हैश मान होता है। ये हैश टोरेंट फ़ाइल में शामिल होते हैं और डेटा के प्रत्येक हिस्से के लिए एक फिंगरप्रिंट के रूप में कार्य करते हैं। जब आप फ़ाइलों को एक नए स्थान पर ले जाते हैं, तो qBittorrent यह पुष्टि करने के लिए इन पीस हैश का उपयोग करता है कि फ़ाइलें नहीं बदली हैं।

इस प्रक्रिया को इन चरणों में विभाजित किया जा सकता है:

1. **नया स्थान निर्दिष्ट करें**: आप नया फ़ाइल पथ सेट करके qBittorrent को बताते हैं कि फ़ाइलें अब कहां स्थित हैं।
2. **फ़ाइलों को टोरेंट से मैप करें**: qBittorrent नए स्थान पर मौजूद फ़ाइलों को टोरेंट में सूचीबद्ध फ़ाइलों से मिलाता है, जो आमतौर पर फ़ाइल नामों और आकारों का उपयोग करके किया जाता है (क्योंकि यह जानकारी टोरेंट फ़ाइल में होती है)।
3. **पीस हैश सत्यापित करें**: qBittorrent नई फ़ाइलों से डेटा को पीस दर पीस पढ़ता है, प्रत्येक पीस के लिए एक हैश की गणना करता है, और उसकी तुलना टोरेंट फ़ाइल में संग्रहीत संबंधित हैश से करता है।
4. **अखंडता की पुष्टि करें**: यदि सभी गणना किए गए हैश टोरेंट के हैश से मेल खाते हैं, तो फ़ाइलों के समान होने की पुष्टि हो जाती है, और qBittorrent सीडिंग फिर से शुरू कर सकता है। यदि किसी पीस का हैश मेल नहीं खाता है, तो उस पीस को अधूरा या गायब चिह्नित किया जाता है, और qBittorrent को उसे फिर से डाउनलोड करने की आवश्यकता हो सकती है।

### यह किस एल्गोरिदम का उपयोग करता है?
qBittorrent पूर्ण-फ़ाइल चेकसम (जैसे पूरी फ़ाइल के लिए MD5 या SHA-256) का उपयोग नहीं करता है, क्योंकि यह धीमा और अक्षम होगा, खासकर बड़ी फ़ाइलों के लिए। इसके बजाय, यह BitTorrent प्रोटोकॉल द्वारा परिभाषित **पीस हैश** पर निर्भर करता है। इन पीस हैश के लिए उपयोग किया जाने वाला एल्गोरिदम **SHA-1** है, जो एक व्यापक रूप से उपयोग की जाने वाली क्रिप्टोग्राफिक हैश फ़ंक्शन है। डेटा के प्रत्येक हिस्से (जो टोरेंट के आधार पर कुछ किलोबाइट से लेकर कुछ मेगाबाइट तक का हो सकता है) को SHA-1 के साथ हैश किया जाता है, और qBittorrent उन्हीं हैश के विरुद्ध जांच करता है।

पूर्ण-फ़ाइल चेकसम के बजाय पीस हैश का उपयोग करने के दो बड़े फायदे हैं:
- **दक्षता**: छोटे हिस्सों की जांच करना पूरी फ़ाइल को हैश करने की तुलना में तेज़ होता है।
- **सूक्ष्मता**: अगर कुछ गलत है, तो qBittorrent ठीक-ठीक पता लगा सकता है कि किन हिस्सों को ठीक करने की आवश्यकता है, न कि पूरी फ़ाइल को अस्वीकार करना।

### यह क्यों महत्वपूर्ण है
यह हैश-आधारित सत्यापन सुनिश्चित करता है कि आप जो डेटा नए स्थान से सीड कर रहे हैं वह अन्य पीयर्स द्वारा अपेक्षित डेटा से मेल खाता है, जिससे टोरेंट स्वार्म की अखंडता बनी रहती है। इस जांच के बिना, फ़ाइलों को स्थानांतरित करने से दूषित या बेमेल डेटा साझा हो सकता है, जो टोरेंटिंग प्रक्रिया में बाधा उत्पन्न करेगा।

संक्षेप में, जब आप qBittorrent में फ़ाइल स्थानों को स्थानांतरित करते हैं, तो यह प्रत्येक पीस के **SHA-1 हैश** की गणना करके और उनकी तुलना टोरेंट फ़ाइल में मौजूद हैश से करके फ़ाइलों को फिर से जांचता है। इस तरह यह सीडिंग फिर से शुरू होने से पहले पुष्टि करता है कि सब कुछ सही है।

---

यह दर्शाने के लिए कि qBittorrent फ़ाइल स्थानों को स्थानांतरित करते समय पीस हैश (विशेष रूप से SHA-1 हैश) का उपयोग करके फ़ाइल अखंडता को कैसे सत्यापित करता है, यहां एक सरल Python स्क्रिप्ट दी गई है। qBittorrent, BitTorrent प्रोटोकॉल का पालन करते हुए, फ़ाइलों को टुकड़ों में विभाजित करता है, प्रत्येक टुकड़े के लिए SHA-1 हैश की गणना करता है, और इन हैश का उपयोग यह सुनिश्चित करने के लिए करता है कि फ़ाइल की सामग्री उसके स्थान की परवाह किए बिना अपरिवर्तित रहे। यह स्क्रिप्ट एक नमूना फ़ाइल बनाकर, उसके पीस हैश की गणना करके, एक समान प्रति को सत्यापित करके, और फिर यह दिखाकर इस प्रक्रिया का अनुकरण करती है कि संशोधन सत्यापन को विफल कैसे करता है।

### व्याख्या
- **पीस हैश**: स्क्रिप्ट एक फ़ाइल को निश्चित आकार के टुकड़ों (जैसे, 10 बाइट्स) में विभाजित करती है और प्रत्येक टुकड़े के लिए SHA-1 हैश की गणना करती है, जो इस बात का अनुकरण करती है कि एक टोरेंट फ़ाइल इन हैश को कैसे संग्रहीत करती है।
- **सत्यापन**: यह जांचता है कि किसी फ़ाइल के गणना किए गए हैश अपेक्षित हैश से मेल खाते हैं या नहीं, जिससे अखंडता सुनिश्चित होती है।
- **अनुकरण**: यह एक फ़ाइल बनाती है, उसकी प्रतिलिपि बनाती है (स्थानांतरण का अनुकरण करते हुए), उसे सत्यापित करती है, फिर प्रतिलिपि को संशोधित करती है और फिर से सत्यापित करती है ताकि यह दिखाया जा सके कि परिवर्तनों का पता कैसे लगाया जाता है।

स्पष्टता के लिए टिप्पणियों के साथ स्क्रिप्ट यहां दी गई है:

```python
import hashlib
import shutil
import os

def compute_piece_hashes(file_path, piece_size):
    """Compute SHA-1 hashes for each piece of the file."""
    hashes = []
    with open(file_path, 'rb') as f:
        while True:
            piece = f.read(piece_size)
            if not piece:
                break
            hash_obj = hashlib.sha1(piece)
            hashes.append(hash_obj.hexdigest())
    return hashes

def verify_file_integrity(file_path, piece_size, expected_hashes):
    """Verify the file's integrity by comparing piece hashes."""
    current_hashes = compute_piece_hashes(file_path, piece_size)
    if len(current_hashes) != len(expected_hashes):
        return False
    for current, expected in zip(current_hashes, expected_hashes):
        if current != expected:
            return False
    return True

# Create a sample file with known content
with open('file1.txt', 'w') as f:
    f.write("Hello, this is a test file.")

piece_size = 10  # bytes, small for demonstration

# Compute expected hashes from file1.txt (simulates torrent hashes)
expected_hashes = compute_piece_hashes('file1.txt', piece_size)
print("Expected hashes:", [h[:8] for h in expected_hashes])  # Show first 8 chars for readability

# Copy file1.txt to file2.txt to simulate moving the file
shutil.copyfile('file1.txt', 'file2.txt')

# Verify file2.txt against expected hashes (should pass)
is_valid = verify_file_integrity('file2.txt', piece_size, expected_hashes)
print("Verification of file2.txt (unchanged):", "Valid" if is_valid else "Invalid")

# Modify file2.txt to simulate corruption or change
with open('file2.txt', 'a') as f:
    f.write(" Modified")

# Verify again (should fail due to changed content)
is_valid = verify_file_integrity('file2.txt', piece_size, expected_hashes)
print("Verification of file2.txt (modified):", "Valid" if is_valid else "Invalid")

# Clean up the created files
os.remove('file1.txt')
os.remove('file2.txt')
```

### यह कैसे काम करता है
1. **फ़ाइल निर्माण**: "Hello, this is a test file." (25 बाइट्स) को `file1.txt` में लिखता है।
2. **हैश गणना**: `file1.txt` को 10 बाइट्स प्रत्येक के टुकड़ों में विभाजित करता है (जैसे, "Hello, thi", "s is a tes", "t file."), SHA-1 हैश की गणना करता है, और उन्हें `expected_hashes` के रूप में संग्रहीत करता है।
3. **स्थानांतरण का अनुकरण**: `file1.txt` की प्रतिलिपि `file2.txt` में बनाता है, जो एक फ़ाइल के नए स्थान पर स्थानांतरित होने का प्रतिनिधित्व करता है।
4. **प्रारंभिक सत्यापन**: `file2.txt` की `expected_hashes` के विरुद्ध जांच करता है। चूंकि सामग्री समान है, यह "Valid" प्रिंट करता है।
5. **संशोधन**: `file2.txt` में " Modified" जोड़ता है, जिससे उसकी सामग्री और आकार बदल जाता है (अब 34 बाइट्स, 4 टुकड़ों में विभाजित)।
6. **दूसरा सत्यापन**: संशोधित `file2.txt` की जांच करता है। टुकड़ों की संख्या या उनके हैश भिन्न होते हैं, इसलिए यह "Invalid" प्रिंट करता है।
7. **सफाई**: अस्थायी फ़ाइलों को हटा देता है।

### आउटपुट उदाहरण
```
Expected hashes: ['dffd6021', 'a2b3c4d5', 'e6f789ab']  # उदाहरण हैश उपसर्ग
Verification of file2.txt (unchanged): Valid
Verification of file2.txt (modified): Invalid
```
(वास्तविक हैश मान भिन्न होंगे लेकिन इस पैटर्न का पालन करेंगे।)

यह स्क्रिप्ट दर्शाती है कि qBittorrent पीस हैश की तुलना करके फ़ाइल अखंडता कैसे सुनिश्चित करता है, फ़ाइल के स्थानांतरित होने के बाद भी किसी भी परिवर्तन का पता लगाता है, जिससे यह प्रक्रिया का एक सरल लेकिन प्रभावी प्रदर्शन बन जाता है।