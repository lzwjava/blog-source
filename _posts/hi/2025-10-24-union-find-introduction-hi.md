---
audio: false
generated: true
image: false
lang: hi
layout: post
model: x-ai/grok-4-fast
title: यूनियन-फाइंड एल्गोरिदम का परिचय
translated: true
type: note
---

### यूनियन-फाइंड (डिसजॉइंट सेट यूनियन) एल्गोरिदम का परिचय

**यूनियन-फाइंड** एल्गोरिदम (जिसे **डिसजॉइंट सेट यूनियन** या **DSU** भी कहा जाता है) एक डेटा स्ट्रक्चर और ऑपरेशन्स का एक सेट है जिसका उपयोग असंयुक्त सेटों (ऐसे तत्वों के समूह जो ओवरलैप नहीं करते) के संग्रह को प्रबंधित करने के लिए किया जाता है। यह ग्रुपिंग, मर्जिंग, या कनेक्टिविटी जांचने जैसी समस्याओं के लिए कुशल है, जैसे कि ग्राफ एल्गोरिदम या क्लस्टरिंग में।

मुख्य ऑपरेशन:
- **फाइंड**: यह निर्धारित करता है कि कोई तत्व किस सेट से संबंधित है (अक्सर सेट के "रूट" या प्रतिनिधि को ढूंढकर)।
- **यूनियन**: दो सेटों को एक में मिलाता है।

यह एल्गोरिदम ऑप्टिमाइज़ेशन जैसे **पाथ कम्प्रेशन** (फाइंड के दौरान ट्री स्ट्रक्चर को चपटा करना) और **यूनियन बाय रैंक/साइज** (स्ट्रक्चर को संतुलित रखने के लिए छोटे पेड़ों को बड़े पेड़ों में मिलाना) के कारण बहुत कारगर है। इससे प्रति ऑपरेशन समय लगभग O(1) एमोर्टाइज्ड हो जाता है—बड़े डेटासेट के लिए अत्यंत तेज़।

#### मूल डेटा स्ट्रक्चर
- एक ऐरे `p[]` (पैरेंट ऐरे): `p[i]` तत्व `i` के पैरेंट की ओर इशारा करता है। शुरुआत में, प्रत्येक तत्व स्वयं का पैरेंट होता है (`p[i] = i`)।
- वैकल्पिक: मर्ज को संतुलित करने के लिए यूनियन बाय रैंक के लिए एक `rank[]` ऐरे।

#### फाइंड ऑपरेशन (पाथ कम्प्रेशन के साथ)
`find` फंक्शन किसी तत्व से उसके रूट तक पीछे का पता लगाता है। आपके द्वारा उल्लिखित लाइन—`if (p[i] != -1) i = p[i]`—इस प्रक्रिया में एक पुनरावर्ती या पुनरावृत्तीय चरण है। यह पैरेंट पॉइंटर्स का तब तक पालन करता है जब तक कि रूट नहीं मिल जाता (जहां `p[root] == root` या सेंटिनल के लिए `p[root] == -1`)।

यहां स्यूडोकोड में एक सरल पुनरावृत्तीय कार्यान्वयन दिया गया है:

```
function find(i):
    if p[i] != -1:  # रूट नहीं है (या सेंटिनल नहीं है)
        i = p[i]     # पैरेंट पर जाएं (यह आपकी लाइन है!)
        return find(i)  # पुनरावर्ती: रूट मिलने तक जारी रखें
    else:
        return i     # रूट मिल गया
```

**पूर्ण पाथ कम्प्रेशन** के साथ (भविष्य की फाइंड को ऑप्टिमाइज़ करने के लिए), हम सभी नोड्स को सीधे रूट पर सेट करके पाथ को चपटा कर देते हैं:

```
function find(i):
    if p[i] != i:  # रूट नहीं है
        p[i] = find(p[i])  # कम्प्रेशन: पैरेंट को मिले हुए रूट पर सेट करें
    return p[i]
```

- `-1` का उपयोग अक्सर रूट्स के लिए एक सेंटिनल के रूप में किया जाता है (स्व-पैरेंटिंग के लिए `i` के बजाय), खासकर कुछ कार्यान्वयनों में अनइनिशियलाइज्ड या अमान्य नोड्स को अलग करने के लिए।
- कम्प्रेशन के बिना, बार-बार फाइंड करने से स्ट्रक्चर एक लंबी श्रृंखला (O(n) वर्स्ट केस) बन सकता है। कम्प्रेशन इसे लगभग चपटा बना देता है।

#### यूनियन ऑपरेशन
`x` और `y` के सेटों को मर्ज करने के लिए:
1. रूट ढूंढें: `rootX = find(x)`, `rootY = find(y)`।
2. यदि `rootX != rootY`, तो एक को दूसरे से लिंक करें (उदाहरण के लिए, रैंक के आधार पर: छोटे रैंक वाले को बड़े रैंक वाले से जोड़ें)।

स्यूडोकोड:
```
function union(x, y):
    rootX = find(x)
    rootY = find(y)
    if rootX != rootY:
        if rank[rootX] > rank[rootY]:
            p[rootY] = rootX
        elif rank[rootX] < rank[rootY]:
            p[rootX] = rootY
        else:
            p[rootY] = rootX
            rank[rootX] += 1  # नए पैरेंट के लिए रैंक बढ़ाएं
```

#### एल्गोरिदम का उपयोग कैसे करें
यूनियन-फाइंड डायनामिक कनेक्टिविटी समस्याओं के लिए आदर्श है। यहां उदाहरणों सहित एक चरण-दर-चरण मार्गदर्शिका दी गई है:

1. **इनिशियलाइज़ेशन**:
   - `p[]` को साइज `n` (तत्वों की संख्या) का बनाएं: `for i in 0 to n-1: p[i] = -1` (या स्व-पैरेंट के लिए `i`)।
   - वैकल्पिक: `rank[]` सभी को 0 या 1 पर सेट करें।

2. **बेसिक उपयोग प्रवाह**:
   - यह जांचने के लिए कि क्या दो तत्व एक ही सेट में हैं: `if find(a) == find(b)`।
   - मर्ज करने के लिए: `union(a, b)`।
   - क्वेरीज़/मर्ज को किसी भी क्रम में प्रोसेस करें—यह डायनामिक है!

3. **उदाहरण: एक ग्राफ में कनेक्टेड कम्पोनेंट्स का पता लगाना**
   कल्पना करें 5 नोड्स (0-4) वाला एक ग्राफ और एजेज जैसे (0-1), (1-2), (3-4)।
   ```
   // इनिशियलाइज़ेशन
   p = [-1, -1, -1, -1, -1]
   rank = [0, 0, 0, 0, 0]

   // एजेज को यूनियन करें
   union(0, 1)  // 0 और 1 को मर्ज करता है, मान लें p[0]=-1, p[1]=0
   union(1, 2)  // 2 को {0,1} में मर्ज करता है, p[2]=0
   union(3, 4)  // {3,4} को मर्ज करता है, मान लें p[3]=-1, p[4]=3

   // क्वेरी: क्या 0 और 2 कनेक्टेड हैं? find(0)=0, find(2)=0 → हाँ
   // क्या 2 और 3 कनेक्टेड हैं? find(2)=0, find(3)=-1 → नहीं
   ```

4. **वास्तविक दुनिया के अनुप्रयोग**:
   - **क्रुस्कल का मिनिमम स्पैनिंग ट्री**: एजेज को वजन के आधार पर सॉर्ट करें, गैर-साइकल बनाने वाली एजेज को यूनियन करें (यदि `find(u) == find(v)` हो तो छोड़ दें)।
   - **सोशल नेटवर्क फ्रेंड्स**: फ्रेंड्स को यूनियन करें, म्यूचुअल कनेक्शन ढूंढें।
   - **इमेज सेगमेंटेशन**: समान रंग के आसन्न पिक्सेल्स को यूनियन करें।
   - **अनडायरेक्टेड ग्राफ में साइकल डिटेक्शन**: एंडपॉइंट्स को यूनियन करें; यदि पहले से ही समान सेट में हैं, तो साइकल मौजूद है।

#### सरल पायथन इम्प्लीमेंटेशन
```python
class UnionFind:
    def __init__(self, n):
        self.p = [-1] * n
        self.rank = [0] * n
    
    def find(self, i):
        if self.p[i] != -1 and self.p[i] != i:  # सेंटिनल + स्व-पैरेंट को हैंडल करता है
            self.p[i] = self.find(self.p[i])  # पाथ कम्प्रेशन
        return self.p[i] if self.p[i] != -1 else i
    
    def union(self, x, y):
        px, py = self.find(x), self.find(y)
        if px != py:
            if self.rank[px] > self.rank[py]:
                self.p[py] = px
            elif self.rank[px] < self.rank[py]:
                self.p[px] = py
            else:
                self.p[py] = px
                self.rank[px] += 1

# उपयोग
uf = UnionFind(5)
uf.union(0, 1)
uf.union(1, 2)
print(uf.find(0) == uf.find(2))  # True
```

यह चीजों को कुशल बनाए रखता है—गति देखने के लिए बड़े `n` के साथ इसे आज़माएं!

अधिक गहराई के लिए, देखें [GeeksforGeeks: Union-Find Algorithm](https://www.geeksforgeeks.org/union-find-algorithm-set-2-union-by-rank-and-path-compression/) या [CP-Algorithms: DSU](https://cp-algorithms.com/data_structures/disjoint_set_union.html)।