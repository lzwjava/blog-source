---
audio: false
generated: true
image: false
lang: hi
layout: post
model: x-ai/grok-4-fast
title: मेवेन बहु-मॉड्यूल निर्भरता समाधान
translated: true
type: note
---

हां, यह सही है - एक Maven multi-module प्रोजेक्ट में, जब एक मॉड्यूल (जैसे, एक EAR मॉड्यूल) दूसरे मॉड्यूल (जैसे, एक WAR मॉड्यूल) पर निर्भर करता है, तो Maven डिफ़ॉल्ट रूप से डिपेंडेंसी को local `.m2/repository` से रिज़ॉल्व करता है, न कि सीधे दूसरे मॉड्यूल के `target/` डायरेक्टरी से। ऐसा इसलिए है क्योंकि Maven इंटर-मॉड्यूल डिपेंडेंसी को स्टैंडर्ड आर्टिफैक्ट रेफरेंस (जैसे एक्सटर्नल लाइब्रेरी) की तरह ट्रीट करता है, इसलिए डिपेंडेंट आर्टिफैक्ट को इंस्टॉल किया जाना चाहिए (या कम से कम पैकेज किया गया हो और बिल्ड रिएक्टर के माध्यम से डिस्कवरेबल हो)।

### ऐसा क्यों होता है
- **लोकल रिपॉजिटरी रेजोल्यूशन**: Maven का डिपेंडेंसी रेजोल्यूशन मैकेनिज्म सबसे पहले लोकल रिपॉजिटरी में आर्टिफैक्ट्स को ढूंढता है। `target/` डायरेक्टरी का उपयोग केवल एक सिंगल मॉड्यूल के बिल्ड के दौरान अस्थायी रूप से किया जाता है, लेकिन क्रॉस-मॉड्यूल रेफरेंस के लिए, यह अपेक्षा करता है कि आर्टिफैक्ट "प्रकाशित" (इंस्टॉल) किया गया हो।
- **रिएक्टर बिल्ड मदद करते हैं, लेकिन हमेशा पर्याप्त नहीं होते**: यदि आप **पैरेंट POM** रूट से `mvn package` (या `mvn install`) चलाते हैं, तो Maven का रिएक्टर स्वचालित रूप से मॉड्यूल्स को टोपोलॉजिकल ऑर्डर में बनाता है। यह इंटर-मॉड्यूल डिपेंडेंसी को सेशन के दौरान दूसरे मॉड्यूल के ताज़ा `target/` आउटपुट से खींचकर, बिना एक्सप्लिसिट इंस्टॉल के, ऑन-द-फ्लाई रिज़ॉल्व करता है। लेकिन यदि आप डिपेंडेंट मॉड्यूल (जैसे EAR) को **स्वतंत्र रूप से** बनाते हैं (जैसे, `cd ear-module && mvn package`), तो यह WAR के `target/` को नहीं देख पाएगा—यह तब तक फेल हो जाएगा जब तक कि WAR आर्टिफैक्ट पहले से ही `.m2` में मौजूद न हो।

### विशेष रूप से WAR-to-EAR पैकेजिंग के लिए
एक EAR प्रोजेक्ट में:
- EAR प्लगइन (`maven-ear-plugin`) अपेक्षा करता है कि WAR (और अन्य मॉड्यूल) रिज़ॉल्व किए गए आर्टिफैक्ट के रूप में हों ताकि उन्हें EAR आर्काइव में शामिल किया जा सके (जैसे, EAR POM में `<modules>` के माध्यम से)।
- यदि WAR इंस्टॉल नहीं है, तो आपको "Could not resolve dependencies" जैसी errors मिलेंगी या EAR में मॉड्यूल गायब होंगे।

**समाधान**: हां, यदि आप स्वतंत्र रूप से बिल्ड कर रहे हैं तो आपको आम तौर पर पहले "मूल" (डिपेंडेंसी) मॉड्यूल पर `mvn install` (या कम से कम एक पूर्ण रिएक्टर बिल्ड में `mvn package`) चलाने की आवश्यकता होती है। सर्वोत्तम प्रथाएं:
1.  **पसंदीदा: पैरेंट से बिल्ड करें**: प्रोजेक्ट रूट पर `mvn clean install`। यह सब कुछ `.m2` में इंस्टॉल कर देता है और ऑर्डरिंग को स्वचालित रूप से हैंडल करता है।
2.  **यदि मॉड्यूल अलग-अलग बना रहे हैं**:
    - `cd war-module && mvn clean install` (WAR JAR को `.m2` में इंस्टॉल करता है)।
    - फिर `cd ear-module && mvn clean package` (या `install`—EARs को अक्सर केवल `package` की आवश्यकता होती है)।
3.  **डायरेक्ट टार्गेट रेफरेंस से बचें**: `<systemPath>` या `target/` के लिए फाइल पाथ का उपयोग करके इसके आसपास हैक न करें—यह नाजुक होता है और Maven की चेकसम/ट्रांजिटिविटी को स्किप करता है।

यह व्यवहार हाल के Maven वर्जन (2025 तक 3.9.x) में नहीं बदला है। अधिक जानकारी के लिए, ऑफिशियल multi-module गाइड देखें।

[बिल्ड लाइफसाइकिल का परिचय - मल्टी-मॉड्यूल प्रोजेक्ट्स](https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html#multi-module)  
[Maven EAR प्लगइन डॉक्यूमेंटेशन](https://maven.apache.org/plugins/maven-ear-plugin/ear-mojo.html)