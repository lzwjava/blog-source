---
audio: false
generated: true
lang: fr
layout: post
title: Guide WebGL
translated: true
type: note
---

Plongeons dans un guide complet sur WebGL (Web Graphics Library). Cela couvrira ce que c'est, comment cela fonctionne, pourquoi c'est utile, comment commencer, et son contexte plus large—parfait pour comprendre son rôle dans des outils comme Figma ou au-delà. Attachez vos ceintures !

---

### **1. Qu'est-ce que WebGL ?**
WebGL est une API JavaScript qui apporte des graphiques 2D et 3D accélérés par matériel au web. Elle est basée sur OpenGL ES (Embedded Systems), un sous-ensemble de la norme OpenGL utilisée dans les applications natives, adapté pour les navigateurs. Avec WebGL, vous pouvez rendre des graphiques directement dans un élément `<canvas>` en utilisant le GPU, contournant le rendu plus lent basé sur le CPU du HTML/CSS traditionnel.

- **Caractéristiques Clés :**
  - **Accélération Matérielle :** Tire parti du GPU pour un rendu rapide.
  - **Multi-Plateforme :** Fonctionne dans tous les navigateurs majeurs (Chrome, Firefox, Safari, Edge).
  - **Programmable :** Utilise des shaders (petits programmes) pour définir l'apparence et le mouvement des éléments.
  - **Aucun Plugin :** Natif du navigateur, contrairement à Flash ou aux technologies plus anciennes.

- **Historique :**
  - Introduit en 2011 par le Khronos Group (les personnes derrière OpenGL).
  - WebGL 1.0 est basé sur OpenGL ES 2.0 ; WebGL 2.0 (2017) s'appuie sur OpenGL ES 3.0.

- **Cas d'Usage :**
  - Jeux (par exemple, des titres 3D en ligne).
  - Visualisation de données (par exemple, des graphiques ou cartes interactives).
  - Outils créatifs (par exemple, le rendu vectoriel de Figma).
  - Simulations (par exemple, des moteurs physiques ou de la modélisation 3D).

---

### **2. Comment fonctionne WebGL ?**
WebGL fonctionne en vous donnant un accès de bas niveau au GPU via une API JavaScript. Il est construit autour d'un **pipeline de rendu**—une série d'étapes qui transforment le code en pixels à l'écran.

1. **Configuration :**
   - Vous créez un élément `<canvas>` en HTML.
   - Obtenez un contexte WebGL : `canvas.getContext('webgl')` (ou `'webgl2'` pour la version 2.0).

2. **Shaders :**
   - **Vertex Shader :** Définit la position des points (vertices) dans l'espace 3D.
   - **Fragment Shader :** Colorie chaque pixel entre les vertices.
   - Écrits en GLSL (OpenGL Shading Language), compilés à l'exécution.

3. **Buffers :**
   - Les données (par exemple, les positions des vertices, les couleurs) sont stockées dans la mémoire du GPU via des buffers.
   - Exemple : Les trois coins d'un triangle sont envoyés sous forme de tableau de coordonnées.

4. **Rendu :**
   - Vous liez les buffers, configurez les shaders et émettez un appel de dessin (par exemple, `gl.drawArrays()`).
   - Le GPU traite cela en parallèle, envoyant le résultat vers le canvas.

- **Système de Coordonnées :** WebGL utilise un espace 3D normalisé (-1 à 1 sur les axes x, y, z), que vous transformez avec des matrices (par exemple, pour la perspective ou la rotation).

- **Machine à États :** WebGL est sans état—vous définissez les paramètres (par exemple, les textures, le mélange) avant chaque appel de dessin.

---

### **3. Pourquoi utiliser WebGL ?**
- **Performance :** L'accélération GPU surpasse le rendu CPU pour les graphiques complexes.
- **Flexibilité :** Les shaders vous permettent de personnaliser les visuels jusqu'au pixel.
- **Intégration Web :** Fonctionne de manière transparente avec JavaScript, les événements DOM et d'autres APIs.
- **Aucune Installation :** Fonctionne partout où un navigateur fonctionne.

**Compromis :**
- Courbe d'apprentissage abrupte—niveau bas comparé à HTML5 Canvas 2D.
- Le débogage est délicat (les erreurs GLSL sont cryptiques).
- La compatibilité des navigateurs peut varier (surtout pour WebGL 2.0).

---

### **4. Commencer avec WebGL**
Rendons un simple triangle coloré pour voir WebGL en action.

#### **Étape 1 : Configuration HTML**
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
</head>
<body>
    <canvas id="glCanvas" width="400" height="400"></canvas>
    <script>
        // Le JavaScript va ici
    </script>
</body>
</html>
```

#### **Étape 2 : Bases du JavaScript**
Ajoutez ceci à l'intérieur de la balise `<script>` :
```javascript
// Obtenir le canvas et le contexte
const canvas = document.getElementById('glCanvas');
const gl = canvas.getContext('webgl');
if (!gl) {
    alert('WebGL non supporté !');
}

// Source du vertex shader (GLSL)
const vsSource = `
    attribute vec2 a_position;
    void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
    }
`;

// Source du fragment shader (GLSL)
const fsSource = `
    void main() {
        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); // Rouge
    }
`;

// Compiler les shaders
function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
    }
    return shader;
}

const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);

// Lier dans un programme
const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);
if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error(gl.getProgramInfoLog(program));
}

// Données des vertices (un triangle)
const positions = new Float32Array([
    0.0,  0.5,  // Haut
   -0.5, -0.5,  // Bas-gauche
    0.5, -0.5   // Bas-droit
]);

// Configuration du buffer
const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

// Dire à WebGL comment lire le buffer
const positionLocation = gl.getAttribLocation(program, 'a_position');
gl.enableVertexAttribArray(positionLocation);
gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

// Effacer et dessiner
gl.clearColor(0.0, 0.0, 0.0, 1.0); // Fond noir
gl.clear(gl.COLOR_BUFFER_BIT);
gl.useProgram(program);
gl.drawArrays(gl.TRIANGLES, 0, 3); // Dessiner 3 vertices
```

#### **Étape 3 : Testez-le**
- Enregistrez sous `index.html`, servez-le (par exemple, `python -m http.server 8080`), et ouvrez dans un navigateur.
- Vous verrez un triangle rouge sur un fond noir.

---

### **5. Concepts de Base**
- **Shaders :** Les vertex shaders positionnent la géométrie ; les fragment shaders la colorent. Le GLSL est similaire au C mais spécifique au GPU.
- **Buffers :** Stockent les données des vertices (positions, normales, couleurs) dans la mémoire du GPU.
- **Textures :** Images 2D mappées sur des objets 3D (par exemple, `gl.texImage2D()`).
- **Matrices :** Utilisées pour les transformations (translation, rotation, mise à l'échelle) via des bibliothèques comme `glMatrix`.
- **Appels de Dessin :** `gl.drawArrays()` pour les formes simples ; `gl.drawElements()` pour la géométrie indexée.

**Ajouts de WebGL 2.0 :**
- Meilleures textures (par exemple, textures 3D).
- Cibles de rendu multiples.
- Fonctionnalités de shader améliorées (par exemple, les uniform buffer objects).

---

### **6. Écosystème et Outils**
- **Bibliothèques :**
  - **Three.js :** Framework 3D de haut niveau (cache la complexité brute de WebGL).
  - **Babylon.js :** Moteur 3D axé sur le jeu.
  - **PixiJS :** Rendu 2D avec repli sur WebGL.
  - **glMatrix :** Utilitaires mathématiques pour les transformations.

- **Support des Navigateurs :**
  - WebGL 1.0 : Quasiment universel.
  - WebGL 2.0 : La plupart des navigateurs modernes (vérifiez caniuse.com).

- **Débogage :**
  - Outils de développement des navigateurs (par exemple, WebGL Inspector de Chrome).
  - Extensions comme Spector.js.

---

### **7. WebGL dans la Nature**
- **Figma :** Utilise WebGL pour le rendu des graphiques vectoriels, associé à WebAssembly pour le calcul.
- **Jeux :** Unity et Unreal Engine exportent vers WebGL pour jouer dans le navigateur.
- **Cartes :** Google Maps et Mapbox l'utilisent pour un zoom fluide et un terrain 3D.

---

### **8. Le Futur**
- **WebGPU :** La nouvelle génération d'API (basée sur Vulkan/Metal) émerge, promettant de meilleures performances et des fonctionnalités modernes. Ce n'est pas encore un remplacement mais un complément.
- **Adoption Plus Large :** WebGL reste dominant pour l'instant, surtout avec les améliorations de WebGL 2.0.

---

### **9. Ressources**
- **Officiel :** [webglfundamentals.org](https://webglfundamentals.org/)—d'excellents tutoriels pour débutants.
- **MDN :** [Documentation WebGL](https://developer.mozilla.org/fr/docs/Web/API/WebGL_API).
- **Livres :** « WebGL Programming Guide » par Kouichi Matsuda.
- **Posts X :** Recherchez #WebGL pour des exemples et des astuces de la communauté.

---

### **Récapitulatif**
WebGL est votre passerelle vers les graphiques alimentés par GPU dans le navigateur. C'est de bas niveau, puissant et un peu intimidant—mais avec de la pratique (et des bibliothèques), vous pouvez construire n'importe quoi, des simples animations aux mondes 3D complets. Vous voulez essayer un projet spécifique ou approfondir les shaders ? Faites-le moi savoir !