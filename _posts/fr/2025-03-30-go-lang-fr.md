---
audio: false
generated: true
lang: fr
layout: post
title: Guide Complet du Langage de Programmation Go
translated: true
type: note
---

Ce guide vise à fournir un aperçu complet du langage de programmation Go, couvrant ses fondamentaux, ses concepts de base et ses fonctionnalités avancées. Il est conçu à la fois pour les débutants ayant une certaine expérience en programmation et pour ceux souhaitant transitionner depuis d'autres langages.

**I. Introduction à Go**

* **Qu'est-ce que Go ?**
    * Go (souvent appelé Golang) est un langage de programmation compilé et statiquement typé conçu chez Google par Robert Griesemer, Rob Pike et Ken Thompson.
    * Il met l'accent sur la simplicité, la concurrence et les performances.
    * Go est open-source et possède une communauté dynamique et en croissance.
* **Caractéristiques et Principes de Conception Clés :**
    * **Simplicité et Lisibilité :** Syntaxe épurée, mots-clés minimaux et accent mis sur le fait de bien faire une seule chose.
    * **Concurrence :** La prise en charge intégrée des goroutines légères et des channels facilite et rend plus efficace la programmation concurrente.
    * **Performance :** Langage compilé avec une gestion efficace de la mémoire (garbage collection) conduisant à une exécution rapide.
    * **Typage Fort :** Aide à détecter les erreurs tôt dans le processus de développement.
    * **Liaison Statique :** Produit des exécutables autonomes, simplifiant le déploiement.
    * **Garbage Collection :** La gestion automatique de la mémoire réduit la charge pour les développeurs.
    * **Bibliothèque Standard :** Une bibliothèque standard riche et complète fournit des outils pour diverses tâches.
    * **Outillage :** D'excellents outils intégrés pour le formatage (gofmt), le linting (golint, staticcheck), les tests (go test) et la gestion des dépendances (go modules).
* **Cas d'Usage :**
    * Programmation Système
    * Programmation Réseau (APIs, serveurs web)
    * Infrastructure Cloud (Docker, Kubernetes)
    * Outils en Ligne de Commande
    * Systèmes Distribués
    * Traitement de Données Massives (Big Data)

**II. Configuration de l'Environnement Go**

* **Installation :**
    * Téléchargez la distribution Go appropriée pour votre système d'exploitation depuis le site officiel ([https://go.dev/dl/](https://go.dev/dl/)).
    * Suivez les instructions d'installation pour votre plateforme.
* **Vérification de l'Installation :**
    * Ouvrez votre terminal ou invite de commande et exécutez `go version`. Cela devrait afficher la version de Go installée.
* **Workspace et `GOPATH` (Legacy) :**
    * Historiquement, les projets Go étaient organisés dans une variable d'environnement `GOPATH`. Bien que toujours supportée, elle est largement remplacée par les Go Modules.
* **Go Modules (Recommandé) :**
    * Go Modules est la solution officielle de gestion des dépendances.
    * Pour démarrer un nouveau projet avec les modules, naviguez dans votre répertoire de projet dans le terminal et exécutez `go mod init <your_module_path>` (par exemple, `go mod init github.com/yourusername/myproject`).
    * Les dépendances sont déclarées dans le fichier `go.mod`.

**III. Syntaxe et Concepts de Base de Go**

* **Hello, World !**
    ```go
    package main

    import "fmt"

    func main() {
        fmt.Println("Hello, World!")
    }
    ```
    * `package main` : Déclare le package comme point d'entrée d'un programme exécutable.
    * `import "fmt"` : Importe le package "fmt", qui fournit des fonctions d'E/S formatées.
    * `func main()` : La fonction principale où l'exécution du programme commence.
    * `fmt.Println()` : Affiche une ligne de texte dans la console.
* **Packages et Imports :**
    * Le code Go est organisé en packages.
    * Les packages aident à l'organisation du code, à la réutilisabilité et à éviter les conflits de nommage.
    * Utilisez le mot-clé `import` pour importer des fonctionnalités d'autres packages (bibliothèque standard ou tiers).
    * Les chemins d'import peuvent être des packages simples (ex: `"fmt"`) ou imbriqués (ex: `"net/http"`).
    * Alias d'import : `import f "fmt"` (vous pouvez ensuite utiliser `f.Println`).
    * Identificateur vide (`_`) pour les effets de bord : `import _ "net/http/pprof"` (initialise les handlers pprof sans utilisation directe).
* **Variables :**
    * Déclaration :
        * `var nom type` (ex: `var age int`)
        * `var nom = valeur` (inférence de type, ex: `var nom = "Alice"`)
        * `nom := valeur` (déclaration courte de variable, uniquement à l'intérieur des fonctions, ex: `count := 0`)
    * Déclarations multiples :
        ```go
        var (
            firstName string = "John"
            lastName  string = "Doe"
            age       int    = 30
        )
        ```
    * Constantes :
        * `const PI float64 = 3.14159`
        * Les constantes doivent être déclarées à la compilation.
        * Les constantes non typées peuvent prendre différents types selon leur utilisation.
* **Types de Données :**
    * **Types de Base :**
        * **Entiers :** `int`, `int8`, `int16`, `int32` (`rune` - alias pour `int32`), `int64`, `uint`, `uint8` (`byte` - alias pour `uint8`), `uint16`, `uint32`, `uint64`, `uintptr` (entier non signé suffisamment grand pour contenir un pointeur).
        * **Nombres à Virgule Flottante :** `float32`, `float64`.
        * **Nombres Complexes :** `complex64`, `complex128`.
        * **Booléens :** `bool` (`true`, `false`).
        * **Chaînes de Caractères :** `string` (séquence immuable d'octets, typiquement encodée en UTF-8).
    * **Types Composés :**
        * **Tableaux (Arrays) :** Séquence de taille fixe d'éléments du même type (ex: `[5]int`).
        * **Slices :** Vue dynamiquement dimensionnée et flexible sur les éléments d'un tableau (le plus couramment utilisé).
        * **Maps :** Collection non ordonnée de paires clé-valeur (tables de hachage).
        * **Structs :** Types de données composites qui regroupent zéro ou plusieurs champs nommés de types différents.
        * **Pointeurs :** Contiennent l'adresse mémoire d'une valeur.
        * **Fonctions :** Citoyens de première classe, peuvent être assignées à des variables et passées comme arguments.
        * **Interfaces :** Définissent un ensemble de méthodes qu'un type doit implémenter.
        * **Channels :** Fournissent un moyen pour les goroutines de communiquer et de se synchroniser.
* **Opérateurs :**
    * **Arithmétiques :** `+`, `-`, `*`, `/`, `%`, `++`, `--`.
    * **Comparaison :** `==`, `!=`, `>`, `<`, `>=`, `<=`.
    * **Logiques :** `&&` (ET), `||` (OU), `!` (NON).
    * **Binaires :** `&` (ET), `|` (OU), `^` (OU Exclusif), `&^` (ET NON), `<<` (Décalage à Gauche), `>>` (Décalage à Droite).
    * **Affectation :** `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`.
* **Structures de Contrôle :**
    * **`if`, `else if`, `else` :** Exécution conditionnelle.
        ```go
        if age >= 18 {
            fmt.Println("Adulte")
        } else if age >= 13 {
            fmt.Println("Adolescent")
        } else {
            fmt.Println("Enfant")
        }
        ```
    * **Boucle `for` :** La seule construction de boucle en Go.
        * Boucle `for` basique :
            ```go
            for i := 0; i < 5; i++ {
                fmt.Println(i)
            }
            ```
        * Boucle de type `while` :
            ```go
            j := 0
            for j < 5 {
                fmt.Println(j)
                j++
            }
            ```
        * Boucle infinie :
            ```go
            for {
                // Faire quelque chose
            }
            ```
        * Itération sur des collections (`range`) :
            ```go
            numbers := []int{1, 2, 3}
            for index, value := range numbers {
                fmt.Printf("Index: %d, Valeur: %d\n", index, value)
            }

            m := map[string]string{"a": "apple", "b": "banana"}
            for key, val := range m {
                fmt.Printf("Clé: %s, Valeur: %s\n", key, val)
            }
            ```
    * **Instruction `switch` :** Exécution conditionnelle à plusieurs branches.
        ```go
        grade := "B"
        switch grade {
        case "A":
            fmt.Println("Excellent !")
        case "B":
            fmt.Println("Bien")
        case "C":
            fmt.Println("Moyen")
        default:
            fmt.Println("Doit s'améliorer")
        }
        ```
        * Pas de fallthrough automatique (utilisez le mot-clé `fallthrough` si nécessaire).
        * Les cas peuvent avoir plusieurs valeurs.
        * Switch sans condition (comme `if-else if-else`).
    * **Instruction `defer` :** Planifie l'exécution d'un appel de fonction à la fin de la fonction englobante (souvent utilisé pour les tâches de nettoyage comme la fermeture de fichiers).
        ```go
        func example() {
            f, err := os.Open("file.txt")
            if err != nil {
                fmt.Println(err)
                return
            }
            defer f.Close() // f.Close() sera appelé quand example() retournera

            // ... traiter le fichier ...
        }
        ```
    * **Instruction `goto` :** Transfère le contrôle à une instruction étiquetée (à utiliser avec parcimonie, peut conduire à du code spaghetti).
    * **`break` et `continue` :** Contrôlent l'exécution des boucles.

**IV. Types de Données Composés en Détail**

* **Tableaux (Arrays) :**
    * Taille fixe, éléments du même type.
    * Moins couramment utilisés que les slices.
    * Exemple : `var a [3]int; a[0] = 1; a[1] = 2; a[2] = 3` ou `b := [2]string{"hello", "world"}`.
* **Slices :**
    * Taille dynamique, soutenus par un tableau sous-jacent.
    * Créés en utilisant des littéraux de slice (ex: `[]int{1, 2, 3}`), la fonction `make()` (`make([]int, length, capacity)`), ou en découpant un tableau ou slice existant (`mySlice[start:end]`).
    * `len()` : Retourne le nombre d'éléments dans le slice.
    * `cap()` : Retourne la capacité du tableau sous-jacent.
    * `append()` : Ajoute des éléments à la fin d'un slice (peut réallouer le tableau sous-jacent si la capacité est atteinte).
    * `copy()` : Copie les éléments d'un slice vers un autre.
* **Maps :**
    * Collection non ordonnée de paires clé-valeur.
    * Les clés doivent être d'un type comparable (ex: entiers, chaînes de caractères, booléens, structs contenant uniquement des champs comparables).
    * Les valeurs peuvent être de n'importe quel type.
    * Créés en utilisant des littéraux de map (ex: `map[string]int{"apple": 1, "banana": 2}`) ou la fonction `make()` (`make(map[string]string)`).
    * Accéder aux valeurs : `value := myMap["key"]` (retourne la valeur et un booléen indiquant si la clé existe).
    * Vérifier l'existence d'une clé : `value, ok := myMap["key"]` (`ok` est `true` si la clé existe).
    * Ajouter/Mettre à jour des entrées : `myMap["newKey"] = "newValue"`.
    * Supprimer des entrées : `delete(myMap, "keyToDelete")`.
* **Structs :**
    * Types définis par l'utilisateur qui regroupent des champs nommés de types différents.
    * Utilisés pour représenter des entités avec plusieurs attributs.
    * Déclaration :
        ```go
        type Person struct {
            FirstName string
            LastName  string
            Age       int
        }
        ```
    * Création d'instances :
        ```go
        var p1 Person
        p1.FirstName = "Alice"
        p1.LastName = "Smith"
        p1.Age = 25

        p2 := Person{FirstName: "Bob", LastName: "Johnson", Age: 30}

        p3 := Person{"Charlie", "Brown", 20} // L'ordre compte si les noms de champs sont omis
        ```
    * Accéder aux champs : `p1.FirstName`.
    * Structs embarquées (composition).
    * Champs anonymes.
* **Pointeurs :**
    * Contiennent l'adresse mémoire d'une valeur.
    * Déclarés en utilisant l'opérateur `*` (ex: `var ptr *int`).
    * Obtenir l'adresse d'une variable en utilisant l'opérateur `&` (ex: `ptr = &age`).
    * Déréférencer un pointeur pour accéder à la valeur pointée en utilisant l'opérateur `*` (ex: `value := *ptr`).
    * Go n'a pas d'arithmétique de pointeurs explicite.
    * Les pointeurs sont utiles pour passer des données par référence, modifier des valeurs directement et travailler avec certaines structures de données.

**V. Fonctions**

* **Déclaration de Fonction :**
    ```go
    func nomFonction(nomParametre1 type1, nomParametre2 type2) typeRetour {
        // Corps de la fonction
        return valeurRetour
    }
    ```
    * Les paramètres multiples du même type peuvent être déclarés ensemble : `func sum(a, b int) int`.
    * Fonctions variadiques (acceptant un nombre variable d'arguments) : `func sum(numbers ...int) int`.
    * Retours multiples :
        ```go
        func divide(a, b float64) (float64, error) {
            if b == 0 {
                return 0, fmt.Errorf("division par zéro")
            }
            return a / b, nil
        }

        result, err := divide(10, 2)
        if err != nil {
            fmt.Println("Erreur:", err)
        } else {
            fmt.Println("Résultat:", result)
        }
        ```
    * Valeurs de retour nommées.
* **Fonctions de Première Classe :**
    * Les fonctions peuvent être assignées à des variables, passées comme arguments à d'autres fonctions et retournées par des fonctions.
    * Exemple :
        ```go
        func add(a, b int) int { return a + b }

        func operate(f func(int, int) int, x, y int) int {
            return f(x, y)
        }

        result := operate(add, 5, 3) // result sera 8
        ```
* **Fonctions Anonymes (Closures) :**
    * Fonctions sans nom, souvent utilisées comme callbacks inline.
    * Peuvent capturer des variables de leur portée environnante (closures).
    * Exemple :
        ```go
        func multiplier(factor int) func(int) int {
            return func(x int) int {
                return x * factor
            }
        }

        double := multiplier(2)
        fmt.Println(double(5)) // Sortie: 10
        ```

**VI. Méthodes**

* **Déclaration de Méthode :**
    * Une méthode est une fonction associée à un type récepteur spécifique.
    * Syntaxe :
        ```go
        func (recepteur Type) nomMethode(parametres) typeRetour {
            // Corps de la méthode
        }
        ```
    * Le récepteur peut être une valeur ou un pointeur.
    * Les récepteurs valeur opèrent sur une copie du récepteur.
    * Les récepteurs pointeur opèrent sur le récepteur original et peuvent modifier son état.
* **Exemple :**
    ```go
    type Circle struct {
        Radius float64
    }

    func (c Circle) Area() float64 {
        return math.Pi * c.Radius * c.Radius
    }

    func (c *Circle) SetRadius(newRadius float64) {
        c.Radius = newRadius
    }

    func main() {
        myCircle := Circle{Radius: 5}
        fmt.Println("Aire:", myCircle.Area()) // Appelle la méthode Area sur un récepteur valeur

        myCircle.SetRadius(10) // Appelle la méthode SetRadius sur un récepteur pointeur
        fmt.Println("Nouvelle Aire:", myCircle.Area())
    }
    ```

**VII. Interfaces**

* **Définition d'Interface :**
    * Une interface définit un ensemble de signatures de méthodes.
    * Un type implémente une interface s'il fournit des implémentations pour toutes les méthodes définies dans l'interface.
    * Les interfaces sont satisfaites implicitement (pas de mot-clé `implements` explicite).
    * Syntaxe :
        ```go
        type Writer interface {
            Write(p []byte) (n int, err error)
        }

        type Reader interface {
            Read(p []byte) (n int, err error)
        }

        type ReadWriter interface {
            Reader
            Writer // Emboîtement d'interfaces
            Close() error
        }
        ```
* **Utilisation des Interfaces :**
    * Permettent le polymorphisme (traiter des objets de types différents de manière uniforme).
    * Découplent le code en programmant vers des interfaces plutôt que vers des types concrets.
    * Exemple :
        ```go
        import "io"
        import "os"

        func writeData(w io.Writer, data []byte) error {
            _, err := w.Write(data)
            return err
        }

        func main() {
            file, err := os.Create("output.txt")
            if err != nil {
                fmt.Println("Erreur création fichier:", err)
                return
            }
            defer file.Close()

            data :=[]byte("Hello, Go interfaces!\n")
            err = writeData(file, data)
            if err != nil {
                fmt.Println("Erreur écriture fichier:", err)
                return
            }

            // On peut aussi utiliser os.Stdout qui implémente aussi io.Writer
            err = writeData(os.Stdout, []byte("Écriture vers stdout via l'interface.\n"))
            if err != nil {
                fmt.Println("Erreur écriture stdout:", err)
                return
            }
        }
        ```
* **Interface Vide (`interface{}`) :**
    * L'interface vide n'a aucune méthode.
    * Tous les types implémentent l'interface vide.
    * Peut être utilisée pour représenter des valeurs de n'importe quel type, mais des assertions de type sont souvent nécessaires pour accéder à la valeur sous-jacente.
    ```go
    var i interface{}
    i = 42
    fmt.Println(i)
    i = "hello"
    fmt.Println(i)

    value, ok := i.(string) // Assertion de type vers string
    if ok {
        fmt.Println("La valeur est une chaîne:", value)
    } else {
        fmt.Println("La valeur n'est pas une chaîne")
    }
    ```
* **Assertions de Type et Switches de Type :**
    * **Assertion de Type :** Utilisée pour extraire la valeur concrète sous-jacente d'une variable d'interface.
        * Syntaxe : `value, ok := interfaceVar.(ConcreteType)`
        * Si l'assertion est correcte, `value` contiendra la valeur concrète et `ok` sera `true`.
        * Si l'assertion est incorrecte et que vous ne vérifiez pas `ok`, cela provoquera une panique.
    * **Switch de Type :** Utilisé pour effectuer différentes actions basées sur le type concret contenu par une variable d'interface.
        ```go
        func describe(i interface{}) {
            switch v := i.(type) {
            case int:
                fmt.Printf("Le double de %v est %v\n", v, v*2)
            case string:
                fmt.Printf("%q fait %v octets de long\n", v, len(v))
            default:
                fmt.Printf("Je ne connais pas le type %T !\n", v)
            }
        }

        func main() {
            describe(42)
            describe("hello")
            describe(true)
        }
        ```

**VIII. Goroutines et Concurrence**

Le modèle de concurrence de Go est basé sur les goroutines et les channels.

* **Goroutines :**
    * Fonctions concurrentes légères.
    * Créées en utilisant le mot-clé `go` suivi d'un appel de fonction.
    * Les goroutines s'exécutent concurremment avec d'autres fonctions et goroutines.
    * Beaucoup moins coûteuses à créer et gérer que les threads OS traditionnels.
    ```go
    package main

    import (
        "fmt"
        "time"
    )

    func say(s string) {
        for i := 0; i < 5; i++ {
            time.Sleep(100 * time.Millisecond)
            fmt.Println(s)
        }
    }

    func main() {
        go say("world") // Démarre une nouvelle goroutine
        say("hello")    // S'exécute dans la goroutine principale

        // Attendre un peu pour voir la sortie de la goroutine
        time.Sleep(time.Second)
    }
    ```
* **Channels :**
    * Conduits typés à travers lesquels les goroutines peuvent envoyer et recevoir des valeurs.
    * Fournissent un moyen sûr pour le code concurrent de communiquer et de se synchroniser.
    * Créés en utilisant la syntaxe `make(chan Type)`.
    * Envoi vers un channel : `channel <- valeur`
    * Réception depuis un channel : `valeur := <-channel`
    ```go
    package main

    import "fmt"

    func sum(s []int, c chan int) {
        sum := 0
        for _, v := range s {
            sum += v
        }
        c <- sum // Envoie la somme vers le channel
    }

    func main() {
        s := []int{7, 2, 8, -9, 4, 0}

        c := make(chan int)
        go sum(s[:len(s)/2], c) // Calcule la somme de la première moitié dans une goroutine
        go sum(s[len(s)/2:], c) // Calcule la somme de la seconde moitié dans une goroutine
        x, y := <-c, <-c       // Reçoit les résultats du channel

        fmt.Println(x, y, x+y)
    }
    ```
* **Channels Tamponnés (Buffered Channels) :**
    * Channels avec une capacité pour contenir un certain nombre de valeurs sans qu'un récepteur soit immédiatement prêt.
    * Créés en utilisant `make(chan Type, capacity)`.
    * Les envois vers un channel tamponné bloquent uniquement lorsque le tampon est plein.
    * Les réceptions bloquent uniquement lorsque le tampon est vide.
* **Direction des Channels :**
    * Vous pouvez spécifier la direction du flux de données dans un type de channel :
        * `chan<- int` : Channel envoi uniquement (ne peut qu'envoyer des entiers).
        * `<-chan int` : Channel réception uniquement (ne peut que recevoir des entiers).
    * Utile pour restreindre l'utilisation des channels dans les fonctions.
    ```go
    func sender(out chan<- string) {
        out <- "Hello from sender"
    }

    func receiver(in <-chan string) {
        msg := <-in
        fmt.Println("Reçu:", msg)
    }

    func main() {
        ch := make(chan string)
        go sender(ch)
        go receiver(ch)
        time.Sleep(time.Second)
    }
    ```
* **Instruction `select` :**
    * Permet à une goroutine d'attendre sur plusieurs opérations de communication.
    * Bloque jusqu'à ce qu'un de ses cas puisse procéder, puis exécute ce cas.
    * Si plusieurs cas sont prêts, un est choisi au hasard.
    * Peut avoir un cas `default` qui s'exécute immédiatement si aucun autre cas n'est prêt.
    ```go
    package main

    import (
        "fmt"
        "time"
    )

    func main() {
        c1 := make(chan string)
        c2 := make(chan string)

        go func() {
            time.Sleep(1 * time.Second)
            c1 <- "one"
        }()
        go func() {
            time.Sleep(2 * time.Second)
            c2 <- "two"
        }()

        for i := 0; i < 2; i++ {
            select {
            case msg1 := <-c1:
                fmt.Println("reçu", msg1)
            case msg2 := <-c2:
                fmt.Println("reçu", msg2)
            }
        }
    }
    ```
* **Primitives de Synchronisation :**
    * **`sync.WaitGroup` :** Attend qu'une collection de goroutines se termine.
    * **`sync.Mutex` :** Fournit un verrou d'exclusion mutuelle de base.
    * **`sync.RWMutex` :** Fournit un verrou lecteur/rédacteur, permettant plusieurs lecteurs ou un seul rédacteur.
    * **`sync.Once` :** Garantit qu'une fonction n'est exécutée qu'une seule fois.

**IX. Gestion des Erreurs**

Go favorise la gestion explicite des erreurs en utilisant l'interface `error`.

* **L'Interface `error` :**
    * Définie comme : `type error interface { Error() string }`
    * Les fonctions qui peuvent échouer retournent typiquement une valeur de type `error` comme dernière valeur de retour.
    * La valeur `nil` indique le succès ; une valeur `error` non nulle indique un échec.
* **Création d'Erreurs :**
    * Utilisez la fonction `errors.New()` du package `errors` pour créer des valeurs d'erreur simples.
    * Utilisez `fmt.Errorf()` pour créer des messages d'erreur formatés.
* **Gestion des Erreurs :**
    * Vérifiez la valeur `error` retournée après avoir appelé une fonction qui peut échouer.
    * Utilisez `if err != nil` pour gérer l'erreur.
    * Vous pouvez encapsuler (wrap) les erreurs pour fournir plus de contexte en utilisant des bibliothèques comme `fmt.Errorf()` avec `%w`.
* **Types d'Erreur Personnalisés :**
    * Vous pouvez créer vos propres types d'erreur en définissant une struct qui implémente l'interface `error` (c'est-à-dire qui a une méthode `Error() string`).
    ```go
    package main

    import (
        "errors"
        "fmt"
        "time"
    )

    type TimeoutError struct {
        duration time.Duration
    }

    func (e *TimeoutError) Error() string {
        return fmt.Sprintf("opération expirée après %v", e.duration)
    }

    func performOperation(timeout time.Duration) error {
        time.Sleep(timeout + 1*time.Second) // Simule une opération longue
        return &TimeoutError{duration: timeout}
    }

    func main() {
        err := performOperation(2 * time.Second)
        if err != nil {
            fmt.Println("Erreur:", err)
            if te, ok := err.(*TimeoutError); ok {
                fmt.Printf("C'était une erreur de timeout de %v\n", te.duration)
            }
        } else {
            fmt.Println("Opération réussie")
        }
    }
    ```
* **`panic` et `recover` :**
    * `panic` est utilisé pour signaler une erreur d'exécution dont le programme ne peut pas se remettre. Il arrête l'exécution de la fonction courante et déroule la pile, appelant les fonctions différées au passage.
    * `recover` est une fonction intégrée qui peut reprendre le contrôle d'une goroutine en panique. Elle doit être appelée dans une fonction différée. `recover` retourne la valeur passée à `panic`, ou `nil` si la goroutine n'est pas en panique.
    * `panic` et `recover` doivent être utilisés avec parcimonie, principalement pour des erreurs critiques et irrécupérables. Pour la plupart des erreurs attendues, utilisez l'interface `error`.
    ```go
    package main

    import "fmt"

    func mightPanic() {
        panic("quelque chose s'est mal passé")
    }

    func recoverFunc() {
        if r := recover(); r != nil {
            fmt.Println("Récupéré de la panique:", r)
        }
    }

    func main() {
        defer recoverFunc()
        fmt.Println("Avant mightPanic")
        mightPanic()
        fmt.Println("Après mightPanic (ceci ne sera pas atteint)")
    }
    ```

**X. Packages et Modules**

Le code Go est organisé en packages.

* **Packages :**
    * Une collection de fichiers source dans le même répertoire qui sont compilés ensemble.
    * Fournissent des espaces de noms pour éviter les conflits de nommage.
    * Les noms de packages sont généralement le nom du répertoire.
    * Les programmes exécutables doivent avoir un package `main` avec une fonction `main`.
    * Les bibliothèques peuvent avoir n'importe quel nom de package.
* **Imports :**
    * Utilisez le mot-clé `import` pour importer des fonctionnalités d'autres packages.
    * Les packages de la bibliothèque standard sont importés par leur nom court (ex: `"fmt"`, `"net/http"`).
    * Les packages tiers sont typiquement importés en utilisant leur chemin de module (ex: `"github.com/gin-gonic/gin"`).
    * **Chemins d'Import :**
        * Imports relatifs (déconseillés et ont des règles spécifiques au sein d'un module).
        * Imports absolus (recommandés), commençant par le chemin du module.
    * **Alias d'Import :** Vous pouvez donner un nom différent localement à un package en utilisant un alias : `import f "fmt"`.
    * **Identificateur Vide (`_`) :** Utilisé pour importer un package uniquement pour ses effets de bord (ex: initialiser un état interne) : `import _ "net/http/pprof"`.
* **Modules (Go 1.11 et supérieur) :**
    * Le moyen principal de gérer les dépendances en Go.
    * Définis par un fichier `go.mod` à la racine de votre projet.
    * Le fichier `go.mod` suit le chemin du module et les dépendances de votre projet.
    * **`go mod init <module_path>` :** Initialise un nouveau module.
    * **`go get <package>@<version>` :** Ajoute ou met à jour une dépendance.
    * **`go build`, `go run`, `go test` :** Gèrent automatiquement les dépendances du module.
    * **`go.sum` :** Contient les hachages cryptographiques des dépendances pour garantir l'intégrité.
* **Visibilité :**
    * Les identificateurs (variables, fonctions, types, etc.) qui commencent par une lettre majuscule sont exportés (publics) et peuvent être accédés depuis d'autres packages.
    * Les identificateurs qui commencent par une lettre minuscule sont non exportés (privés) et ne peuvent être accédés qu'au sein du même package.

**XI. Tests**

Go a une prise en charge intégrée des tests.

* **Fichiers de Test :**
    * Les fichiers de test sont nommés avec le suffixe `_test.go` (ex: `myfunction_test.go`).
    * Ils résident dans le même package que le code testé.
* **Fonctions de Test :**
    * Les fonctions de test ont des noms qui commencent par `Test` et prennent un seul argument de type `*testing.T`.
    * Utilisez les méthodes sur `*testing.T` (ex: `t.Log`, `t.Error`, `t.Errorf`, `t.Fatal`, `t.Fatalf`) pour rapporter les résultats des tests.
* **Exemple de Test :**
    ```go
    // myfunction.go
    package mypackage

    func Add(a, b int) int {
        return a + b
    }

    // myfunction_test.go
    package mypackage_test

    import "testing"

    func TestAdd(t *testing.T) {
        result := Add(2, 3)
        expected := 5
        if result != expected {
            t.Errorf("Add(2, 3) a retourné %d, attendu %d", result, expected)
        }
    }
    ```
* **Exécution des Tests :**
    * Utilisez la commande `go test` dans le répertoire contenant votre package.
    * `go test -v` : Sortie verbeuse, affichant le nom de chaque test.
    * `go test ./...` : Exécute les tests dans le répertoire courant et tous les sous-répertoires.
    * `go test -run <pattern>` : Exécute uniquement les tests dont les noms correspondent à l'expression régulière donnée.
* **Tests de Benchmark :**
    * Mesurent la performance de votre code.
    * Les fonctions de benchmark ont des noms qui commencent par `Benchmark` et prennent un seul argument de type `*testing.B`.
    * Utilisez la boucle `b.N` pour exécuter le code benchmarké plusieurs fois.
    ```go
    // myfunction_test.go
    package mypackage_test

    import (
        "testing"
    )

    func BenchmarkAdd(b *testing.B) {
        for i := 0; i < b.N; i++ {
            Add(2, 3)
        }
    }
    ```
    * Exécutez les benchmarks en utilisant `go test -bench=.`
* **Tests d'Exemple (Example Tests) :**
    * Fournissent des exemples exécutables dans la documentation de votre package.
    *