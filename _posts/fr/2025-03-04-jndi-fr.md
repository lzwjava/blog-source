---
audio: false
generated: true
lang: fr
layout: post
title: Interface de Dénomination et d'Annuaire Java
translated: true
type: note
---

### Points Clés
- Il semble probable que `javax.naming` soit utilisé pour Java Naming and Directory Interface (JNDI) pour rechercher et gérer des objets nommés dans des services comme les bases de données.
- Les recherches suggèrent qu'un contexte initial est nécessaire pour commencer, généralement configuré par un serveur d'applications Java EE pour la production, ou manuellement pour les tests.
- Les preuves penchent en faveur de l'utilisation d'`InitialContext` pour les recherches, comme pour trouver une DataSource avec des noms tels que "java:comp/env/jdbc/datasource".

### Premiers Pas avec `javax.naming`
`javax.naming` fait partie de JNDI, qui aide les applications Java à interagir avec les services d'annuaire et de nommage, comme la recherche de connexions à des bases de données. Dans un environnement Java EE, le serveur d'applications configure généralement cela, ce qui facilite la recherche de ressources par leur nom.

### Exemple d'Utilisation
Voici un moyen simple de rechercher une DataSource dans une application Java EE :
```java
InitialContext ctx = new InitialContext();
DataSource ds = (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
```
Cela suppose que la DataSource est déjà configurée dans votre serveur. Pour les tests sans serveur, vous pourriez avoir besoin de bibliothèques supplémentaires comme Simple-JNDI.

### Détail Inattendu
Il pourrait être surprenant de constater que pour les applications autonomes, la configuration de JNDI peut nécessiter la configuration d'un contexte personnalisé, ce qui peut être complexe sans des outils comme Simple-JNDI.

---

### Note d'Enquête : Guide Complet sur l'Utilisation de `javax.naming`

Cette note fournit une exploration détaillée de l'utilisation de `javax.naming`, qui fait partie de Java Naming and Directory Interface (JNDI), et facilite l'interaction avec les services d'annuaire et de nommage dans les applications Java. JNDI est conçu pour être indépendant des implémentations de services spécifiques, permettant d'accéder de manière unifiée à divers services comme les bases de données, LDAP et les systèmes de fichiers. Cette section développe la réponse directe, offrant une compréhension approfondie pour les développeurs, incluant la configuration, des exemples et des considérations pour différents environnements.

#### Comprendre `javax.naming` et JNDI
`javax.naming` est le package principal pour JNDI, introduit dans le cadre de la bibliothèque standard de Java pour fournir des fonctionnalités de nommage et d'annuaire. Il définit l'interface `Context`, centrale pour les opérations JNDI, qui inclut des méthodes pour rechercher, lier, dissocier et renommer des objets, ainsi que pour créer et détruire des sous-contextes. La méthode `lookup()` est couramment utilisée pour récupérer des objets par leur nom, ce qui la rend essentielle pour l'accès aux ressources dans les applications d'entreprise.

JNDI est particulièrement utile dans les environnements Java EE, où il permet aux applications de se découpler des détails spécifiques des services, améliorant ainsi la portabilité et la flexibilité. Par exemple, il est souvent utilisé pour accéder à des ressources comme les connexions à des bases de données (DataSources), les fournisseurs JMS et les services JavaMail, gérés par le serveur d'applications.

#### Configuration et Utilisation de JNDI
Pour utiliser `javax.naming`, vous commencez par créer un contexte initial, qui sert de point d'entrée pour les opérations de nommage. Cela se fait généralement en utilisant la classe `InitialContext`. La configuration varie selon l'environnement :

- **Dans les Applications Java EE :** Le serveur d'applications (par exemple, Tomcat, JBoss, WebSphere) configure le contexte initial. Vous pouvez rechercher des ressources en utilisant des noms JNDI standard, souvent préfixés par "java:comp/env/". Par exemple, une DataSource pourrait être accessible via "java:comp/env/jdbc/datasource".
- **Dans les Applications Autonomes :** Sans serveur d'applications, vous devez configurer le contexte initial manuellement, en spécifiant des propriétés comme le fournisseur de service de nommage et l'URL. Cela peut être complexe et nécessiter des bibliothèques supplémentaires pour les tests, comme Simple-JNDI, qui fournit une implémentation en mémoire.

Voici un tableau résumant les classes clés et leurs rôles dans `javax.naming` :

| Classe/Interface        | Rôle                                                                 |
|-------------------------|----------------------------------------------------------------------|
| `Context`              | Interface principale pour les opérations de nommage comme lookup, bind et unbind. |
| `InitialContext`       | Crée le contexte initial pour démarrer les opérations JNDI.          |
| `Name`                 | Représente un nom générique, une séquence ordonnée de composants.    |
| `NamingException`      | Classe de base pour les exceptions levées lors des opérations de nommage. |

#### Exemples Pratiques
Explorons des exemples pour les scénarios Java EE et autonomes :

##### Exemple 1 : Recherche d'une DataSource en Java EE
Dans une application Java EE, vous pourriez rechercher une DataSource configurée comme suit :

```java
import javax.naming.InitialContext;
import javax.sql.DataSource;
import java.sql.*;

public class JNDIExample {
    public static void main(String[] args) throws Exception {
        InitialContext ctx = new InitialContext();
        DataSource ds = (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
        Connection conn = ds.getConnection();
        // Utiliser la connexion...
        conn.close();
        ctx.close();
    }
}
```

Cet exemple suppose que la DataSource est configurée dans le serveur d'applications, généralement dans des fichiers comme `context.xml` pour Tomcat. Le nom JNDI "java:comp/env/jdbc/datasource" est une convention standard, mais il peut varier selon la configuration du serveur.

##### Exemple 2 : Liaison et Recherche d'un Objet Personnalisé
Pour les tests ou une utilisation autonome, vous pourriez vouloir créer un contexte simple en mémoire. Bien que l'API standard n'inclue pas de fabrique de contexte en mémoire, des bibliothèques comme Simple-JNDI peuvent aider. Voici un exemple conceptuel supposant une telle configuration :

```java
import javax.naming.*;

public class JNDIExample {
    public static void main(String[] args) throws NamingException {
        Context ctx = new InitialContext();
        ctx.rebind("myObject", "Hello, World!");
        String value = (String) ctx.lookup("myObject");
        System.out.println(value);
        ctx.close();
    }
}
```

Remarque : Cet exemple autonome nécessite de configurer le contexte initial avec les propriétés appropriées, ce qui peut impliquer de définir `java.naming.factory.initial` sur une fabrique de contexte personnalisée, comme celle fournie par Simple-JNDI.

#### Considérations pour Différents Environnements
- **Production (Java EE) :** En production, le serveur d'applications gère la configuration JNDI, ce qui facilite la recherche de ressources. Il est courant d'utiliser JNDI pour les pools de connexions à des bases de données, où le serveur gère les connexions, améliorant l'évolutivité et la sécurité. Par exemple, changer les identifiants de base de données ne nécessite que de mettre à jour la configuration du serveur, pas le code de l'application.
- **Tests (Autonome) :** Pour les tests unitaires et d'intégration, il est souvent nécessaire de fonctionner sans serveur d'applications. Des bibliothèques comme Simple-JNDI ([Simple-JNDI GitHub](https://github.com/h-thurow/Simple-JNDI)) permettent de simuler des environnements JNDI, en liant des ressources programmatiquement. Ceci est crucial pour tester le code qui repose sur les recherches JNDI, garantissant qu'il fonctionne sans déploiement sur un serveur.
- **Sécurité et Bonnes Pratiques :** Soyez prudent avec les injections JNDI, en particulier dans les anciennes versions de Java, car elles peuvent conduire à des vulnérabilités de sécurité comme l'exécution de code à distance. Oracle a résolu de nombreux problèmes de ce type, avec des mises à jour comme Java 8u191 fermant les exploits de vecteurs LDAP. Validez toujours les entrées et utilisez les dernières versions de Java pour la sécurité.

#### Détail Inattendu : Complexité de la Configuration Autonome
On pourrait ne pas s'attendre à la complexité impliquée dans la configuration de JNDI sans serveur d'applications. Alors que Java EE simplifie cela avec des contextes gérés par le serveur, les configurations autonomes nécessitent de configurer des fabriques de contexte et des propriétés, nécessitant souvent des bibliothèques tierces. Cela peut être un obstacle pour les nouveaux développeurs sur JNDI, mais des outils comme Simple-JNDI atténuent ce problème en fournissant des implémentations en mémoire.

#### Lectures Complémentaires et Ressources
Pour une compréhension plus approfondie, consultez les ressources suivantes :
- [Tutoriels Java Oracle : Aperçu JNDI](https://docs.oracle.com/en/ java/ tutorial/jndi/ overview/index.html) pour la documentation officielle.
- [Baeldung : Aperçu de Java Naming and Directory Interface](https://www.baeldung.com/jndi) pour des exemples pratiques et une utilisation moderne.
- [Simple-JNDI GitHub](https://github.com/h-thurow/Simple-JNDI) pour tester JNDI sans serveurs.

Ces ressources fournissent des exemples de code, des tutoriels et des bonnes pratiques, vous assurant de pouvoir mettre en œuvre JNDI efficacement dans divers scénarios.

#### Citations Clés
- [Tutoriels Java Oracle Aperçu JNDI](https://docs.oracle.com/en/ java/ tutorial/jndi/ overview/index.html)
- [Baeldung Java Naming and Directory Interface Overview](https://www.baeldung.com/jndi)
- [Simple-JNDI Access property files via JNDI lookups](https://github.com/h-thurow/Simple-JNDI)