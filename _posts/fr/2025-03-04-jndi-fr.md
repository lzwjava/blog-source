---
audio: false
generated: true
lang: fr
layout: post
title: Interface de Nommage et d'Annuaires Java (JNDI)
translated: true
---

### Points Clés
- Il semble probable que `javax.naming` soit utilisé pour l'interface Java Naming and Directory (JNDI) pour rechercher et gérer des objets nommés dans des services comme les bases de données.
- La recherche suggère que vous avez besoin d'un contexte initial pour commencer, généralement configuré par un serveur d'applications Java EE pour la production, ou manuellement pour les tests.
- Les preuves penchent en faveur de l'utilisation de `InitialContext` pour les recherches, comme trouver une source de données avec des noms comme "java:comp/env/jdbc/datasource".

### Démarrage avec `javax.naming`
`javax.naming` fait partie de JNDI, qui aide les applications Java à interagir avec les services de nommage et d'annuaire, comme la recherche de connexions de base de données. Dans un environnement Java EE, le serveur d'applications configure généralement cela, rendant facile la recherche de ressources par leurs noms.

### Exemple d'Utilisation
Voici une manière simple de rechercher une source de données dans une application Java EE :
```java
InitialContext ctx = new InitialContext();
DataSource ds = (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
```
Cela suppose que la source de données est déjà configurée sur votre serveur. Pour les tests sans serveur, vous pourriez avoir besoin de bibliothèques supplémentaires comme Simple-JNDI.

### Détail Inattendu
Vous ne vous attendez peut-être pas à ce que pour les applications autonomes, la configuration de JNDI puisse nécessiter la configuration d'un contexte personnalisé, ce qui peut être complexe sans outils comme Simple-JNDI.

---

### Note de l'Enquête : Guide Complet de l'Utilisation de `javax.naming`

Cette note fournit une exploration détaillée de l'utilisation de `javax.naming`, partie de l'interface Java Naming and Directory (JNDI), qui facilite l'interaction avec les services de nommage et d'annuaire dans les applications Java. JNDI est conçu pour être indépendant des implémentations de services spécifiques, permettant l'accès à divers services comme les bases de données, LDAP et les systèmes de fichiers de manière unifiée. Cette section développe la réponse directe, offrant une compréhension approfondie pour les développeurs, y compris la configuration, des exemples et des considérations pour différents environnements.

#### Compréhension de `javax.naming` et JNDI
`javax.naming` est le package principal pour JNDI, introduit comme partie de la bibliothèque standard Java pour fournir des fonctionnalités de nommage et d'annuaire. Il définit l'interface `Context`, centrale aux opérations JNDI, qui inclut des méthodes pour rechercher, lier, délier et renommer des objets, ainsi que créer et détruire des sous-contextes. La méthode `lookup()` est couramment utilisée pour récupérer des objets par leurs noms, la rendant essentielle pour l'accès aux ressources dans les applications d'entreprise.

JNDI est particulièrement utile dans les environnements Java EE, où il permet aux applications de se découpler des détails spécifiques des services, améliorant ainsi la portabilité et la flexibilité. Par exemple, il est souvent utilisé pour accéder à des ressources comme les connexions de base de données (DataSources), les fournisseurs JMS et les services JavaMail, gérés par le serveur d'applications.

#### Configuration et Utilisation de JNDI
Pour utiliser `javax.naming`, vous commencez par créer un contexte initial, qui sert de point d'entrée pour les opérations de nommage. Cela est généralement fait en utilisant la classe `InitialContext`. La configuration varie en fonction de l'environnement :

- **Dans les Applications Java EE :** Le serveur d'applications (par exemple, Tomcat, JBoss, WebSphere) configure le contexte initial. Vous pouvez rechercher des ressources en utilisant des noms JNDI standard, souvent préfixés par "java:comp/env/". Par exemple, une source de données pourrait être accessible à "java:comp/env/jdbc/datasource".
- **Dans les Applications Autonomes :** Sans serveur d'applications, vous devez configurer le contexte initial manuellement, en spécifiant des propriétés comme le fournisseur de service de nommage et l'URL. Cela peut être complexe, nécessitant des bibliothèques supplémentaires pour les tests, comme Simple-JNDI, qui fournit une implémentation en mémoire.

Voici un tableau résumant les classes clés et leurs rôles dans `javax.naming` :

| Classe/Interface        | Rôle                                                                 |
|-------------------------|----------------------------------------------------------------------|
| `Context`              | Interface principale pour les opérations de nommage comme lookup, bind, et unbind.   |
| `InitialContext`       | Crée le contexte initial pour commencer les opérations JNDI.             |
| `Name`                 | Représente un nom générique, une séquence ordonnée de composants.         |
| `NamingException`      | Classe de base pour les exceptions lancées pendant les opérations de nommage.            |

#### Exemples Pratiques
Explorons des exemples pour les scénarios Java EE et autonomes :

##### Exemple 1 : Recherche d'une Source de Données dans Java EE
Dans une application Java EE, vous pourriez rechercher une source de données configurée comme suit :

```java
import javax.naming.InitialContext;
import javax.sql.DataSource;
import java.sql.*;

public class JNDIExample {
    public static void main(String[] args) throws Exception {
        InitialContext ctx = new InitialContext();
        DataSource ds = (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
        Connection conn = ds.getConnection();
        // Utiliser la connexion...
        conn.close();
        ctx.close();
    }
}
```

Cet exemple suppose que la source de données est configurée dans le serveur d'applications, généralement dans des fichiers comme `context.xml` pour Tomcat. Le nom JNDI "java:comp/env/jdbc/datasource" est une convention standard, mais il peut varier en fonction de la configuration du serveur.

##### Exemple 2 : Liaison et Recherche d'un Objet Personnalisé
Pour les tests ou l'utilisation autonome, vous pourriez vouloir créer un contexte en mémoire simple. Bien que l'API standard n'inclue pas de contexte en mémoire, des bibliothèques comme Simple-JNDI peuvent aider. Voici un exemple conceptuel en supposant une telle configuration :

```java
import javax.naming.*;

public class JNDIExample {
    public static void main(String[] args) throws NamingException {
        Context ctx = new InitialContext();
        ctx.rebind("myObject", "Hello, World!");
        String value = (String) ctx.lookup("myObject");
        System.out.println(value);
        ctx.close();
    }
}
```

Note : Cet exemple autonome nécessite la configuration du contexte initial avec les propriétés appropriées, ce qui pourrait impliquer la définition de `java.naming.factory.initial` à une usine de contexte personnalisée, telle que celle fournie par Simple-JNDI.

#### Considérations pour Différents Environnements
- **Production (Java EE) :** En production, le serveur d'applications gère la configuration JNDI, rendant la recherche de ressources simple. Il est courant d'utiliser JNDI pour les pools de connexions de base de données, où le serveur gère les connexions, améliorant ainsi la scalabilité et la sécurité. Par exemple, le changement des informations d'identification de la base de données nécessite uniquement la mise à jour de la configuration du serveur, et non du code de l'application.
- **Test (Autonome) :** Pour les tests unitaires et d'intégration, il est souvent nécessaire de fonctionner sans serveur d'applications. Des bibliothèques comme Simple-JNDI ([Simple-JNDI GitHub](https://github.com/h-thurow/Simple-JNDI)) permettent de simuler des environnements JNDI, en liant des ressources de manière programmatique. Cela est crucial pour tester le code qui dépend des recherches JNDI, en s'assurant qu'il fonctionne sans déployer sur un serveur.
- **Sécurité et Bonnes Pratiques :** Soyez prudent avec les injections JNDI, surtout dans les anciennes versions de Java, car elles peuvent conduire à des vulnérabilités de sécurité comme l'exécution de code à distance. Oracle a abordé de nombreux problèmes de ce type, avec des mises à jour comme Java 8u191 fermant les vecteurs d'exploitation LDAP. Validez toujours les entrées et utilisez les dernières versions de Java pour la sécurité.

#### Détail Inattendu : Complexité dans la Configuration Autonome
On ne s'attend peut-être pas à la complexité impliquée dans la configuration de JNDI sans serveur d'applications. Bien que Java EE simplifie cela avec des contextes gérés par le serveur, les configurations autonomes nécessitent de configurer des usines de contexte et des propriétés, nécessitant souvent des bibliothèques tierces. Cela peut être un obstacle pour les développeurs nouveaux à JNDI, mais des outils comme Simple-JNDI atténuent cela en fournissant des implémentations en mémoire.

#### Lectures Complémentaires et Ressources
Pour une compréhension plus approfondie, consultez les ressources suivantes :
- [Oracle Java Tutorials : Vue d'ensemble de JNDI](https://docs.oracle.com/en/java/tutorial/jndi/overview/index.html) pour la documentation officielle.
- [Baeldung : Vue d'ensemble de l'interface Java Naming and Directory](https://www.baeldung.com/jndi) pour des exemples pratiques et une utilisation moderne.
- [Simple-JNDI GitHub](https://github.com/h-thurow/Simple-JNDI) pour tester JNDI sans serveurs.

Ces ressources fournissent des exemples de code, des tutoriels et des bonnes pratiques, assurant que vous pouvez mettre en œuvre JNDI efficacement dans divers scénarios.

#### Citations Clés
- [Oracle Java Tutorials Vue d'ensemble de JNDI](https://docs.oracle.com/en/java/tutorial/jndi/overview/index.html)
- [Baeldung Vue d'ensemble de l'interface Java Naming and Directory](https://www.baeldung.com/jndi)
- [Simple-JNDI Accéder aux fichiers de propriétés via des recherches JNDI](https://github.com/h-thurow/Simple-JNDI)