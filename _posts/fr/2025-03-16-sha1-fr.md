---
audio: false
generated: true
lang: fr
layout: post
title: Fonction de hachage SHA-1
translated: true
type: note
---

Voyons comment fonctionne l'extrait de code donné, plus précisément les lignes :

```python
hash_obj = hashlib.sha1(piece)
hashes.append(hash_obj.hexdigest())
return hashes
```

L'utilisateur nous a demandé d'expliquer cela sans utiliser de bibliothèque, donc je vais d'abord expliquer ce que fait le code avec la bibliothèque `hashlib`, puis explorer comment la même fonctionnalité pourrait être réalisée sans elle.

---

### Comprendre le code avec `hashlib`

Cet extrait calcule un hash pour un morceau de données et le stocke dans une liste. Voici une explication étape par étape de ce qui se passe :

1. **`hash_obj = hashlib.sha1(piece)`**
   - **Ce que cela fait** : Cette ligne utilise le module `hashlib` de Python pour créer un objet de hachage SHA-1. SHA-1 (Secure Hash Algorithm 1) est une fonction de hachage cryptographique qui prend une entrée (ici, `piece`) et produit une valeur de hachage de 160 bits (20 octets).
   - **Entrée** : `piece` est un morceau de données, probablement des octets, lus à partir d'un fichier ou d'une autre source.
   - **Processus** : La fonction `hashlib.sha1()` initialise un objet de hachage et le met immédiatement à jour avec les données de `piece`. Considérez cela comme l'alimentation des données dans une machine de hachage qui commence à traiter les nombres.

2. **`hashes.append(hash_obj.hexdigest())`**
   - **Ce que cela fait** : La méthode `hexdigest()` récupère la valeur de hachage calculée par l'objet de hachage et la convertit en une chaîne hexadécimale (un format lisible par l'homme utilisant les chiffres 0-9 et les lettres a-f).
   - **Sortie** : Pour SHA-1, cette chaîne fait 40 caractères de long car chacun des 20 octets est représenté par deux chiffres hexadécimaux (par exemple, une valeur d'octet de 255 devient "ff").
   - **Stockage** : La chaîne résultante est ajoutée à une liste appelée `hashes`, qui collecte vraisemblablement les hashs pour plusieurs morceaux de données.

3. **`return hashes`**
   - **Ce que cela fait** : Après avoir traité tous les morceaux (en supposant que ce code se trouve dans une boucle ou une fonction), la liste `hashes` contenant toutes les chaînes de hachage hexadécimales est renvoyée.

**En résumé** : Pour chaque `piece` de données, le code calcule son hash SHA-1 en utilisant `hashlib.sha1()`, convertit le hash en une chaîne hexadécimale avec `hexdigest()`, et le stocke dans la liste `hashes`, qui est ensuite renvoyée.

---

### Sans utiliser de bibliothèque : Calculer SHA-1 à partir de zéro

L'instruction de l'utilisateur "do not use lib" suggère qu'il souhaite comprendre comment cela pourrait fonctionner sans s'appuyer sur `hashlib`. Implémenter SHA-1 à partir de zéro est complexe, mais je vais expliquer le processus clairement et fournir une version simplifiée sur laquelle vous pourriez vous appuyer.

#### Qu'est-ce que SHA-1 ?
SHA-1 est une fonction de hachage qui :
- Prend n'importe quelle donnée en entrée (par exemple, `piece`).
- Produit une sortie fixe de 160 bits (20 octets).
- Utilise une série d'opérations bit à bit, de rotations et d'additions pour transformer l'entrée.

Sans `hashlib`, nous devrions reproduire nous-mêmes cet algorithme. Voici comment cela pourrait fonctionner pour le code donné :

#### Processus SHA-1 étape par étape

1. **Préparer l'entrée (Remplissage - Padding)**
   - SHA-1 traite les données par blocs de 512 bits (64 octets). Si `piece` ne fait pas exactement 64 octets, nous le complétons :
     - Ajouter un bit `1` (par exemple, `0x80` en octets).
     - Ajouter suffisamment de bits `0` pour que la longueur soit de 448 bits (56 octets) modulo 512.
     - Ajouter la longueur originale de `piece` (en bits) sous forme d'entier 64 bits.
   - Pour simplifier, si `piece` est plus petit que 64 octets, nous pouvons le compléter pour former un seul bloc.

2. **Initialiser les valeurs de hachage**
   - SHA-1 utilise cinq variables de 32 bits (160 bits au total), initialisées à des constantes spécifiques :
     - `h0 = 0x67452301`
     - `h1 = 0xEFCDAB89`
     - `h2 = 0x98BADCFE`
     - `h3 = 0x10325476`
     - `h4 = 0xC3D2E1F0`

3. **Traiter le bloc de données**
   - Diviser le bloc de 64 octets en 16 mots de 32 bits (4 octets chacun).
   - Les développer en 80 mots en utilisant la formule :
     ```python
     w[i] = left_rotate(w[i-3] ^ w[i-8] ^ w[i-14] ^ w[i-16], 1)  # pour i = 16 à 79
     ```
     où `left_rotate` décale les bits vers la gauche et les fait boucler.
   - Pendant 80 tours, mettre à jour les variables temporaires `a`, `b`, `c`, `d`, `e` (commençant comme des copies de `h0` à `h4`) :
     - Utiliser différentes fonctions et constantes en fonction du numéro du tour (0-19, 20-39, etc.).
     - Exemple pour les tours 0-19 :
       ```python
       f = (b & c) | (~b & d)
       k = 0x5A827999
       temp = (left_rotate(a, 5) + f + e + k + w[i]) & 0xFFFFFFFF
       ```
     - Décaler les variables : `e = d`, `d = c`, `c = left_rotate(b, 30)`, `b = a`, `a = temp`.

4. **Mettre à jour les valeurs de hachage**
   - Après 80 tours, ajouter les résultats aux valeurs de hachage initiales :
     ```python
     h0 = (h0 + a) & 0xFFFFFFFF
     h1 = (h1 + b) & 0xFFFFFFFF
     # ...et ainsi de suite pour h2, h3, h4
     ```

5. **Produire la sortie hexadécimale**
   - Concaténer `h0` à `h4` en une valeur de 160 bits et la convertir en une chaîne hexadécimale de 40 caractères.

#### Implémentation Python simplifiée

Voici une version basique de comment vous pourriez réécrire le code sans `hashlib` :

```python
def left_rotate(value, shift):
    """Faire tourner un entier 32 bits vers la gauche de 'shift' bits."""
    return ((value << shift) | (value >> (32 - shift))) & 0xFFFFFFFF

def custom_sha1(piece):
    """Calculer le hash SHA-1 de 'piece' et le renvoyer sous forme de chaîne hexadécimale."""
    # Pour simplifier, supposons que piece fait moins de 56 octets et complétons pour un bloc
    message = piece + b'\x80' + (b'\x00' * (55 - len(piece))) + (len(piece) * 8).to_bytes(8, 'big')
    
    # Initialiser les valeurs de hachage
    h0, h1, h2, h3, h4 = (
        0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0
    )
    
    # Diviser en 16 mots de 32 bits
    w = [int.from_bytes(message[i:i+4], 'big') for i in range(0, 64, 4)]
    
    # Développer en 80 mots
    for i in range(16, 80):
        w.append(left_rotate(w[i-3] ^ w[i-8] ^ w[i-14] ^ w[i-16], 1))
    
    # Initialiser les variables de travail
    a, b, c, d, e = h0, h1, h2, h3, h4
    
    # 80 tours de traitement
    for i in range(80):
        if 0 <= i < 20:
            f = (b & c) | (~b & d)
            k = 0x5A827999
        elif 20 <= i < 40:
            f = b ^ c ^ d
            k = 0x6ED9EBA1
        elif 40 <= i < 60:
            f = (b & c) | (b & d) | (c & d)
            k = 0x8F1BBCDC
        else:
            f = b ^ c ^ d
            k = 0xCA62C1D6
        
        temp = (left_rotate(a, 5) + f + e + k + w[i]) & 0xFFFFFFFF
        e = d
        d = c
        c = left_rotate(b, 30)
        b = a
        a = temp
    
    # Mettre à jour les valeurs de hachage
    h0 = (h0 + a) & 0xFFFFFFFF
    h1 = (h1 + b) & 0xFFFFFFFF
    h2 = (h2 + c) & 0xFFFFFFFF
    h3 = (h3 + d) & 0xFFFFFFFF
    h4 = (h4 + e) & 0xFFFFFFFF
    
    # Renvoyer sous forme de chaîne hexadécimale de 40 caractères
    return f"{h0:08x}{h1:08x}{h2:08x}{h3:08x}{h4:08x}"

# Code réécrit sans hashlib
def compute_hashes(pieces):
    hashes = []
    for piece in pieces:  # En supposant que pieces est une liste de morceaux d'octets
        hash_value = custom_sha1(piece)
        hashes.append(hash_value)
    return hashes

# Exemple d'utilisation
pieces = [b"hello", b"world"]
hashes = compute_hashes(pieces)
print(hashes)
```

#### Comment cela correspond à l'original
- **`hash_obj = hashlib.sha1(piece)`** : Remplacé par `custom_sha1(piece)`, qui calcule le hash SHA-1 manuellement.
- **`hashes.append(hash_obj.hexdigest())`** : La fonction `custom_sha1` renvoie directement la chaîne hexadécimale, donc nous l'ajoutons à `hashes`.
- **`return hashes`** : Reste le même, renvoyant la liste des chaînes de hachage.

---

### Différences clés et mises en garde
- **Simplification** : Cette implémentation suppose que chaque `piece` tient dans un seul bloc de 512 bits (moins de 56 octets en raison du remplissage). Une implémentation SHA-1 complète gérerait plusieurs blocs.
- **Performance** : Une implémentation manuelle est plus lente et moins optimisée que `hashlib`.
- **Fiabilité** : Les bibliothèques comme `hashlib` sont testées et sécurisées ; une version personnalisée pourrait avoir des bugs à moins d'être validée minutieusement.

En substance, le code original utilise `hashlib` comme un raccourci pour calculer efficacement les hashs SHA-1, tandis que le faire sans bibliothèque nécessite de coder manuellement l'intégralité de l'algorithme SHA-1, de gérer le remplissage et de convertir le résultat au format hexadécimal. La logique reste la même : traiter chaque morceau, calculer son hash, le stocker et renvoyer la collection.