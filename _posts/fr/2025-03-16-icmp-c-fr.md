---
audio: false
generated: true
lang: fr
layout: post
title: Programme de Ping ICMP en C
translated: true
type: note
---

ICMP (Internet Control Message Protocol) est un protocole de couche réseau utilisé à des fins de diagnostic et de signalement d'erreurs dans les réseaux IP. Il est surtout connu pour être utilisé par l'utilité `ping` pour tester la connectivité entre les hôtes. Les messages ICMP sont encapsulés directement dans des paquets IP (aucune couche TCP ou UDP) et se composent d'un type, d'un code, d'une somme de contrôle et d'une charge utile. Pour `ping`, les messages "Echo Request" (Type 8) et "Echo Reply" (Type 0) sont essentiels.

Voici comment fonctionne ICMP à un haut niveau :
1. Un expéditeur (par exemple, votre machine) envoie une requête ICMP Echo Request à une IP cible.
2. La cible, si elle est joignable et configurée pour répondre, renvoie une réponse ICMP Echo Reply.
3. L'expéditeur mesure le temps aller-retour (RTT) en fonction du moment où la réponse arrive.

Pour implémenter un programme similaire à `ping` en C sans bibliothèques comme `libpcap` ou `libnet`, nous utiliserons des sockets bruts (`SOCK_RAW`) pour construire et envoyer directement des paquets ICMP. Cela nécessite des privilèges root (par exemple, `sudo`) car les sockets bruts contournent les abstractions de plus haut niveau.

Ci-dessous se trouve un programme C simplifié qui envoie des requêtes ICMP Echo Request et écoute les réponses Echo Reply, imitant les fonctionnalités de base de `ping`.

---

### Programme ICMP Ping en C

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>
#include <time.h>
#include <errno.h>

// Calcule la somme de contrôle ICMP
unsigned short checksum(void *b, int len) {
    unsigned short *buf = b;
    unsigned int sum = 0;
    unsigned short result;

    for (sum = 0; len > 1; len -= 2) {
        sum += *buf++;
    }
    if (len == 1) {
        sum += *(unsigned char *)buf;
    }
    sum = (sum >> 16) + (sum & 0xFFFF);
    sum += (sum >> 16);
    result = ~sum;
    return result;
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: %s <destination_ip>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    int sock_fd;
    struct sockaddr_in dest_addr;
    char packet[64];  // En-tête ICMP + quelques données
    struct icmphdr *icmp;
    char recv_buffer[1024];
    struct timespec start, end;

    // Créer un socket brut pour ICMP
    sock_fd = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);
    if (sock_fd < 0) {
        perror("Échec de la création du socket (exécuter en root ?)");
        exit(EXIT_FAILURE);
    }

    // Configurer l'adresse de destination
    dest_addr.sin_family = AF_INET;
    if (inet_pton(AF_INET, argv[1], &dest_addr.sin_addr) <= 0) {
        perror("Adresse IP invalide");
        close(sock_fd);
        exit(EXIT_FAILURE);
    }

    // Préparer le paquet ICMP Echo Request
    memset(packet, 0, sizeof(packet));
    icmp = (struct icmphdr *)packet;
    icmp->type = ICMP_ECHO;        // Type 8 : Echo Request
    icmp->code = 0;
    icmp->un.echo.id = getpid();   // Utiliser l'ID du processus comme identifiant
    icmp->un.echo.sequence = 1;    // Numéro de séquence
    for (int i = sizeof(*icmp); i < 64; i++) {
        packet[i] = i;             // Remplir la charge utile avec des données factices
    }
    icmp->checksum = 0;            // Calculer la somme de contrôle après avoir rempli le paquet
    icmp->checksum = checksum(packet, 64);

    printf("Envoi de ping à %s...\n", argv[1]);

    for (int i = 0; i < 4; i++) { // Envoyer 4 pings
        // Enregistrer l'heure d'envoi
        clock_gettime(CLOCK_MONOTONIC, &start);

        // Envoyer la requête ICMP Echo Request
        if (sendto(sock_fd, packet, 64, 0, (struct sockaddr *)&dest_addr, sizeof(dest_addr)) < 0) {
            perror("Échec de l'envoi");
            close(sock_fd);
            exit(EXIT_FAILURE);
        }

        // Recevoir la réponse ICMP Echo Reply
        struct sockaddr_in from_addr;
        socklen_t from_len = sizeof(from_addr);
        int bytes_received = recvfrom(sock_fd, recv_buffer, sizeof(recv_buffer), 0,
                                      (struct sockaddr *)&from_addr, &from_len);
        if (bytes_received < 0) {
            perror("Échec de la réception");
            continue;
        }

        // Enregistrer l'heure de réception
        clock_gettime(CLOCK_MONOTONIC, &end);

        // Analyser les en-têtes IP et ICMP reçus
        struct iphdr *ip = (struct iphdr *)recv_buffer;
        struct icmphdr *icmp_reply = (struct icmphdr *)(recv_buffer + (ip->ihl * 4));
        if (icmp_reply->type == ICMP_ECHOREPLY && icmp_reply->un.echo.id == getpid()) {
            double rtt = (end.tv_sec - start.tv_sec) * 1000.0 +
                         (end.tv_nsec - start.tv_nsec) / 1000000.0;
            printf("%d octets de %s : seq=%d temps=%.2f ms\n",
                   bytes_received - (ip->ihl * 4), argv[1], icmp_reply->un.echo.sequence, rtt);
        } else {
            printf("Réponse ICMP inattendue : type=%d\n", icmp_reply->type);
        }

        sleep(1); // Attendre 1 seconde entre les pings
        icmp->un.echo.sequence++; // Incrémenter le numéro de séquence
        icmp->checksum = 0;
        icmp->checksum = checksum(packet, 64); // Recalculer la somme de contrôle
    }

    close(sock_fd);
    return 0;
}
```

---

### Comment cela fonctionne

1. **Création du Socket** :
   - `socket(AF_INET, SOCK_RAW, IPPROTO_ICMP)` crée un socket brut pour ICMP. Cela nous permet de construire manuellement les paquets ICMP.

2. **Construction du Paquet ICMP** :
   - L'en-tête ICMP (`struct icmphdr`) est rempli avec :
     - `type = ICMP_ECHO` (8) pour Echo Request.
     - `code = 0`.
     - `id` défini sur l'ID du processus pour identifier nos pings.
     - `sequence` pour suivre les requêtes individuelles.
   - Une charge utile (données factices) est ajoutée, et la somme de contrôle est calculée sur l'ensemble du paquet.

3. **Envoi** :
   - `sendto()` envoie le paquet à l'IP de destination. Aucun port n'est nécessaire car ICMP opère en dessous de la couche de transport.

4. **Réception** :
   - `recvfrom()` capture le paquet IP brut contenant la réponse ICMP Echo Reply.
   - Nous sautons l'en-tête IP (`ihl * 4` octets) pour atteindre l'en-tête ICMP.
   - Vérifier s'il s'agit d'une Echo Reply (Type 0) et si elle correspond à notre `id`.

5. **Chronométrage** :
   - `clock_gettime()` mesure le RTT en millisecondes.

6. **Somme de contrôle** :
   - La fonction `checksum()` calcule la somme de complément à un sur 16 bits, comme requis par ICMP.

---

### Compilation et Utilisation
- Compilation : `gcc ping.c -o ping`
- Exécution (en root) : `sudo ./ping 8.8.8.8`
- Exemple de sortie :
  ```
  Envoi de ping à 8.8.8.8...
  64 octets de 8.8.8.8 : seq=1 temps=12.34 ms
  64 octets de 8.8.8.8 : seq=2 temps=11.89 ms
  ...
  ```

---

### Notes
- **Privilèges Root** : Les sockets bruts nécessitent `sudo` car ils manipulent directement les paquets réseau.
- **Pare-feu** : La cible doit répondre aux requêtes ICMP Echo Request (certains hôtes les bloquent).
- **Simplifications** : Cette version ne gère pas tous les cas particuliers (par exemple, les timeouts, la perte de paquets complètement, ou les options IP).

C'est le niveau le plus bas que vous puissiez atteindre dans l'espace utilisateur avec ICMP. En dessous, vous auriez besoin de code au niveau du noyau pour interagir directement avec la pile IP. Faites-moi savoir si vous souhaitez l'ajuster davantage !