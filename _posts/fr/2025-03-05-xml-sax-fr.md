---
audio: false
generated: true
lang: fr
layout: post
title: Utilisation de SAX (Simple API for XML)
translated: true
---

Pour utiliser le package `org.xml.sax` en Java pour analyser des documents XML, vous pouvez suivre un processus simple en utilisant l'approche d'analyse SAX (Simple API for XML). SAX est un analyseur basé sur les événements qui lit un document XML de manière séquentielle et déclenche des méthodes de rappel lorsqu'il rencontre diverses parties du document, telles que des éléments ou du contenu texte. Cela le rend efficace en termes de mémoire, surtout pour les grands fichiers XML, car il ne charge pas le document entier en mémoire comme le fait DOM. Voici un guide étape par étape pour utiliser `org.xml.sax`.

---

### Étape 1 : Configurer l'analyseur SAX
Pour commencer à analyser XML avec SAX, vous devez créer une instance de `SAXParser` en utilisant la classe `SAXParserFactory`. Cette usine vous permet de configurer le comportement de l'analyseur avant de le créer.

Voici comment créer un `SAXParser` :

```java
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;

public class SAXExample {
    public static void main(String[] args) {
        try {
            // Créer une instance de SAXParserFactory
            SAXParserFactory factory = SAXParserFactory.newInstance();

            // Optionnel : Configurer l'usine (par exemple, activer la prise en charge des espaces de noms)
            factory.setNamespaceAware(true); // Définir sur true si votre XML utilise des espaces de noms

            // Créer un SAXParser
            SAXParser parser = factory.newSAXParser();

            // Les étapes suivantes iront ici
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

- **`SAXParserFactory.newInstance()`** : Crée une nouvelle instance d'usine.
- **`factory.setNamespaceAware(true)`** : Optionnel. Active le traitement des espaces de noms si votre XML utilise des espaces de noms. Par défaut, il est `false`.
- **`factory.newSAXParser()`** : Crée un `SAXParser`. Cela peut lancer `ParserConfigurationException` ou `SAXException` si l'analyseur ne peut pas être configuré ou initialisé.

---

### Étape 2 : Créer un gestionnaire pour les événements XML
L'analyse SAX repose sur un gestionnaire pour traiter les événements XML qu'il rencontre, tels que le début d'un élément, la fin d'un élément ou le contenu texte. L'interface principale pour cela est `ContentHandler`, mais pour plus de simplicité, vous pouvez étendre la classe `DefaultHandler`, qui fournit des implémentations vides de `ContentHandler` et d'autres interfaces de gestionnaire (`ErrorHandler`, `DTDHandler`, etc.). Vous n'avez besoin de remplacer que les méthodes qui vous intéressent.

Voici un exemple de gestionnaire personnalisé :

```java
import org.xml.sax.Attributes;
import org.xml.sax.helpers.DefaultHandler;

public class MyHandler extends DefaultHandler {
    // Variable pour accumuler le contenu texte
    private StringBuilder content = new StringBuilder();

    @Override
    public void startElement(String uri, String localName, String qName, Attributes attributes) {
        // Effacer le tampon de contenu pour le nouvel élément
        content.setLength(0);
        System.out.println("Début de l'élément : " + qName);

        // Si l'élément a des attributs, les traiter
        for (int i = 0; i < attributes.getLength(); i++) {
            System.out.println("Attribut : " + attributes.getQName(i) + " = " + attributes.getValue(i));
        }
    }

    @Override
    public void characters(char[] ch, int start, int length) {
        // Accumuler le contenu texte (peut être appelé plusieurs fois par élément)
        content.append(ch, start, length);
    }

    @Override
    public void endElement(String uri, String localName, String qName) {
        // Traiter le contenu texte accumulé
        String text = content.toString().trim();
        if (!text.isEmpty()) {
            System.out.println("Contenu : " + text);
        }
        System.out.println("Fin de l'élément : " + qName);
        content.setLength(0); // Réinitialiser pour le prochain élément
    }

    @Override
    public void startDocument() {
        System.out.println("Début de l'analyse du document");
    }

    @Override
    public void endDocument() {
        System.out.println("Fin de l'analyse du document");
    }
}
```

- **`startElement`** : Appelé lorsque l'analyseur rencontre le début d'un élément. Les paramètres incluent :
  - `uri` : URI de l'espace de noms (si sensible aux espaces de noms).
  - `localName` : Nom local de l'élément (sans préfixe, si sensible aux espaces de noms).
  - `qName` : Nom qualifié (inclut le préfixe, le cas échéant).
  - `attributes` : Liste des attributs de l'élément.
- **`characters`** : Appelé pour le contenu texte à l'intérieur d'un élément. Notez que cela peut être appelé plusieurs fois pour le contenu d'un seul élément, utilisez donc un `StringBuilder` pour l'accumuler.
- **`endElement`** : Appelé lorsque l'élément se termine.
- **`startDocument` et `endDocument`** : Appelés au début et à la fin du document XML.

---

### Étape 3 : Analyser le XML
Avec l'analyseur et le gestionnaire prêts, vous pouvez analyser une source XML (par exemple, un fichier, `InputStream` ou une chaîne) en appelant la méthode `parse` sur le `SAXParser` et en passant votre gestionnaire.

Voici comment analyser un fichier XML :

```java
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import java.io.File;

public class SAXExample {
    public static void main(String[] args) {
        try {
            // Créer l'analyseur
            SAXParserFactory factory = SAXParserFactory.newInstance();
            SAXParser parser = factory.newSAXParser();

            // Créer le gestionnaire
            MyHandler handler = new MyHandler();

            // Analyser un fichier XML
            File xmlFile = new File("example.xml");
            parser.parse(xmlFile, handler);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

- **`parser.parse`** : Prend une source XML (par exemple, `File`) et un `DefaultHandler`. Cela peut lancer `IOException` (pour les erreurs d'entrée) ou `SAXException` (pour les erreurs d'analyse).

Pour une chaîne XML au lieu d'un fichier, utilisez `InputSource` :

```java
import org.xml.sax.InputSource;
import java.io.StringReader;

// À l'intérieur de la méthode main
String xml = "<book><title>Analyse XML</title></book>";
InputSource inputSource = new InputSource(new StringReader(xml));
parser.parse(inputSource, handler);
```

---

### Étape 4 : Gérer les exceptions
L'analyse SAX implique plusieurs exceptions que vous devez gérer :

- **`ParserConfigurationException`** : Lancée par `newSAXParser()` si l'analyseur ne peut pas être configuré.
- **`SAXException`** : Lancée par `newSAXParser()` ou `parse()` pour les erreurs d'analyse générales.
- **`IOException`** : Lancée par `parse()` s'il y a un problème de lecture de la source d'entrée.

Enveloppez votre code dans un bloc `try-catch` :

```java
try {
    SAXParserFactory factory = SAXParserFactory.newInstance();
    SAXParser parser = factory.newSAXParser();
    MyHandler handler = new MyHandler();
    parser.parse(new File("example.xml"), handler);
} catch (ParserConfigurationException e) {
    System.err.println("Erreur de configuration de l'analyseur : " + e.getMessage());
} catch (SAXException e) {
    System.err.println("Erreur SAX : " + e.getMessage());
} catch (IOException e) {
    System.err.println("Erreur d'E/S : " + e.getMessage());
}
```

---

### Étape 5 : Fonctionnalités optionnelles
#### Gestion des erreurs
`DefaultHandler` implémente également `ErrorHandler`. Remplacez ses méthodes pour gérer les erreurs d'analyse :

```java
public class MyHandler extends DefaultHandler {
    @Override
    public void error(SAXParseException e) {
        System.err.println("Erreur d'analyse : " + e.getMessage());
    }

    @Override
    public void fatalError(SAXParseException e) throws SAXException {
        System.err.println("Erreur fatale : " + e.getMessage());
        throw e; // Arrêter l'analyse
    }

    @Override
    public void warning(SAXParseException e) {
        System.out.println("Avertissement : " + e.getMessage());
    }
    // Autres méthodes comme ci-dessus
}
```

#### Gestion des espaces de noms
Si votre XML utilise des espaces de noms, définissez `factory.setNamespaceAware(true)` et utilisez `uri` et `localName` dans vos méthodes de gestionnaire au lieu de `qName` pour identifier correctement les éléments.

#### Validation
Pour valider XML contre un DTD ou un schéma, définissez `factory.setValidating(true)`. Vous devrez peut-être également un `ErrorHandler` pour gérer les erreurs de validation.

---

### Exemple XML et sortie
Pour un fichier XML `example.xml` :
```xml
<book id="123">
    <title>Analyse XML</title>
    <author>John Doe</author>
</book>
```

L'exécution du code ci-dessus pourrait produire :
```
Début de l'analyse du document
Début de l'élément : book
Attribut : id = 123
Début de l'élément : title
Contenu : Analyse XML
Fin de l'élément : title
Début de l'élément : author
Contenu : John Doe
Fin de l'élément : author
Fin de l'élément : book
Fin de l'analyse du document
```

---

### Résumé
Pour utiliser `org.xml.sax` :
1. Créez un `SAXParser` en utilisant `SAXParserFactory`.
2. Implémentez un gestionnaire en étendant `DefaultHandler` et en remplaçant les méthodes comme `startElement`, `endElement` et `characters`.
3. Analysez le XML en appelant `parser.parse()` avec votre gestionnaire et la source XML.
4. Gérez les exceptions (`SAXException`, `IOException`, `ParserConfigurationException`).
5. Configurez optionnellement la prise en charge des espaces de noms, la validation ou la gestion des erreurs.

Cette approche est idéale pour analyser efficacement de grands documents XML lorsque vous avez seulement besoin d'extraire des données spécifiques sans construire un arbre en mémoire.