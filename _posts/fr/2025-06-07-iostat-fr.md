---
audio: false
generated: true
lang: fr
layout: post
title: Commande iostat et analyse des métriques système
translated: true
type: note
---

La sortie de la commande `iostat -x` fournit des statistiques détaillées d'E/S (entrée/sortie) pour le CPU et les périphériques de disque de votre système. Voici une explication de ce que signifie la sortie :

### **Statistiques CPU**
La section `avg-cpu` montre l'utilisation du CPU :
- `%user` : 0,38 % du temps CPU est consacré aux processus utilisateur.
- `%nice` : 0,00 % sur les processus avec une priorité modifiée (nice).
- `%system` : 0,12 % sur les processus système (noyau).
- `%iowait` : 0,01 % du temps CPU est en attente de la fin des opérations d'E/S (très faible, indiquant des goulots d'étranglement E/S minimes).
- `%steal` : 0,00 % (pertinent dans les environnements virtualisés, indique le temps CPU volé par l'hyperviseur).
- `%idle` : 99,48 % du temps CPU est inactif, ce qui signifie que le système n'est globalement pas sous charge lourde.

**Interprétation** : Votre CPU est à peine utilisé, presque tout son temps étant passé inactif. Cela suggère que le système n'est pas sous une contrainte computationnelle ou E/S significative.

### **Statistiques des Périphériques**
La section `Device` liste l'activité E/S pour chaque périphérique de bloc (par exemple, `loop0`, `nvme0n1`, `sda`). Voici ce que signifient les colonnes :

1.  **Device** : Le nom du périphérique de bloc (par exemple, `loop0` à `loop38` sont probablement des périphériques loop pour les packages snap ; `nvme0n1` est un SSD NVMe ; `sda` est probablement un HDD traditionnel ou un SSD).
2.  **r/s** : Lectures par seconde.
3.  **rkB/s** : Kilooctets lus par seconde.
4.  **rrqm/s** : Requêtes de lecture fusionnées par seconde (lectures en file d'attente combinées en une seule requête).
5.  **%rrqm** : Pourcentage de requêtes de lecture fusionnées.
6.  **r_await** : Temps moyen (ms) pour que les requêtes de lecture soient servies.
7.  **rareq-sz** : Taille moyenne (kB) des requêtes de lecture.
8.  **w/s** : Écritures par seconde.
9.  **wkB/s** : Kilooctets écrits par seconde.
10. **wrqm/s** : Requêtes d'écriture fusionnées par seconde.
11. **%wrqm** : Pourcentage de requêtes d'écriture fusionnées.
12. **w_await** : Temps moyen (ms) pour que les requêtes d'écriture soient servies.
13. **wareq-sz** : Taille moyenne (kB) des requêtes d'écriture.
14. **d/s** : Suppressions (discards) par seconde (pour les SSD avec support TRIM).
15. **dkB/s** : Kilooctets supprimés par seconde.
16. **drqm/s** : Requêtes de suppression fusionnées par seconde.
17. **%drqm** : Pourcentage de requêtes de suppression fusionnées.
18. **d_await** : Temps moyen (ms) pour les requêtes de suppression.
19. **dareq-sz** : Taille moyenne (kB) des requêtes de suppression.
20. **f/s** : Requêtes de vidage (flush) par seconde.
21. **f_await** : Temps moyen (ms) pour les requêtes de vidage.
22. **aqu-sz** : Taille moyenne de la file d'attente (nombre de requêtes en attente).
23. **%util** : Pourcentage d'utilisation du périphérique (à quel point le périphérique est occupé).

### **Observations Clés**
-   **Périphériques Loop (`loop0` à `loop38`)** :
    - Ils sont probablement associés aux packages snap (courants sous Ubuntu).
    - La plupart montrent une activité très faible (par exemple, `r/s` et `rkB/s` proches de 0), avec des lectures minimes et aucune écriture ou suppression.
    - Certains périphériques (par exemple, `loop15`, `loop33`, `loop4`) ont des taux de lecture légèrement plus élevés (par exemple, 4,32 ko/s, 7,11 ko/s, 5,82 ko/s), mais toujours négligeables.
    - `r_await` varie (par exemple, 0,04 ms pour `loop19` à 1,83 ms pour `loop21`), indiquant des différences de latence mineures.
    - L'utilisation (`%util`) est de 0,00 % pour tous les périphériques loop, ce qui signifie qu'ils ne sont pas fortement utilisés.

-   **nvme0n1 (SSD NVMe)** :
    - Activité significative par rapport aux autres :
        - Lectures : 7,46 lectures/s, 617,52 ko/s.
        - Écritures : 3,56 écritures/s, 107,86 ko/s.
        - Latence de lecture (`r_await`) : 0,30 ms (très rapide).
        - Latence d'écriture (`w_await`) : 3,02 ms (légèrement plus élevée mais toujours bonne pour un SSD).
        - Tailles de requête : 82,73 ko pour les lectures, 30,30 ko pour les écritures.
        - Fusion : 15,06 % des lectures et 49,38 % des écritures sont fusionnées, indiquant une certaine optimisation des E/S.
        - Utilisation : 0,24 %, toujours très faible, ce qui signifie que le SSD n'est pas sous charge lourde.

-   **sda (HDD ou SSD)** :
    - Activité minimale : 0,00 lecture/s, 0,10 ko/s, aucune écriture ou suppression.
    - Utilisation très faible (0,00 %), suggérant qu'il est à peine utilisé.

### **Interprétation Globale**
-   **Charge du Système** : Le système est sous une charge très légère, avec 99,48 % de CPU inactif et une activité E/S minimale sur la plupart des périphériques.
-   **Activité E/S** : Le SSD NVMe (`nvme0n1`) gère la majorité des E/S, avec une activité de lecture/écriture modérée mais une faible latence et une faible utilisation, indiquant de bonnes performances. Les périphériques loop et `sda` ont une activité négligeable, probablement parce qu'ils sont utilisés pour des tâches de fond ou un stockage rarement accédé.
-   **Performances** : Aucun goulot d'étranglement n'est évident. Le faible `%iowait` (0,01 %) et la faible utilisation des périphériques (`%util`) suggèrent que le système gère les E/S efficacement.
-   **Actions Potentielles** :
    - Si vous diagnostiquez un problème de performance, cette sortie suggère que les E/S ne sont pas le problème. Cherchez ailleurs (par exemple, les processus liés au CPU, la mémoire ou les problèmes d'application).
    - Si vous surveillez, le système est sain avec une grande capacité E/S disponible.

Souhaitez-vous un graphique pour visualiser les taux de lecture/écriture des périphériques clés (par exemple, `nvme0n1`, `sda`, et quelques périphériques loop) ? Ou avez-vous un aspect spécifique que vous aimeriez explorer plus en détail ?