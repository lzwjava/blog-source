---
audio: false
generated: true
lang: ar
layout: post
title: فهم أمر جيت فيتش
translated: true
type: note
---

دعوني أشرح أمر Git التالي `/usr/bin/git -c protocol.version=2 fetch --no-tags --prune --no-recurse-submodules --depth=5 origin` خطوة بخطوة. هذا الأمر يُستخدم لجلب التحديثات من مستودع Git بعيد مع خيارات محددة للتحكم في البيانات التي يتم استردادها وكميتها. إليك التحليل:

### تحليل الأمر

1. **`/usr/bin/git`**
   هذا هو ببساطة المسار إلى ملف تنفيذ Git على النظام. يخبر النظام بتشغيل برنامج Git مع الخيارات والأمر التي تليه.

2. **`-c protocol.version=2`**
   يضبط هذا خيار تكوين محدد لأمر Git هذا، مجبرًا إياه على استخدام إصدار البروتوكول 2 عند التواصل مع المستودع البعيد. إصدار البروتوكول 2 هو إصدار أحدث من بروتوكول اتصال Git، والذي يمكن أن يوفر أداءً أو ميزات محسنة مقارنة بالإصدار الأقدم 1.

3. **`fetch`**
   يأمر `fetch` باسترداد التحديثات (مثل النقاط والفواصل الجديدة) من مستودع بعيد. على عكس `pull`، لا يدمج هذه التغييرات في فروعك المحلية — فهو يقوم فقط بتحديث *فروع التتبع البعيدة* الخاصة بك (مثل `origin/main`) حتى تتمكن من رؤية الجديد في المستودع البعيد.

4. **`--no-tags`**
   عادةً، يقوم `fetch` أيضًا باسترداد الوسوم (العلامات التي تميز نقاطًا محددة، مثل أرقام الإصدارات). يخبر هذا الخيار Git *بعدم* جلب الوسوم من المستودع البعيد، مما يحافظ على مستودعك المحلي خاليًا من تلك العلامات.

5. **`--prune`**
   ينظف هذا الخيار فروع التتبع البعيدة المحلية الخاصة بك. إذا تم حذف فرع في المستودع البعيد، فإن `--prune` يزيل فرع التتبع البعيد المقابل (مثل `origin/old-branch`) من مستودعك المحلي، مما يحافظ على ترتيب الأشياء.

6. **`--no-recurse-submodules`**
   الوحدات الفرعية هي مستودعات منفصلة متداخلة داخل مستودعك الرئيسي. افتراضيًا، قد يقوم `fetch` بجلب التحديثات لهذه الوحدات الفرعية أيضًا. يمنع هذا الخيار ذلك، بحيث يتم جلب بيانات المستودع الرئيسي فقط، متجاهلاً أي وحدات فرعية.

7. **`--depth=5`**
   ينشئ هذا الخيار *جلبًا سطحيًا*، محدّدًا السجل التاريخي بآخر 5 نقاط لكل فرع. بدلاً من تنزيل سجل النقاط الكامل، تحصل على نسخة مختصرة، مما يوفر الوقت ومساحة القرص — وهو مفيد إذا كنت لا تحتاج إلى السجل الكامل.

8. **`origin`**
   هذا هو اسم المستودع البعيد الذي تقوم بالجلب منه. `origin` هو الاسم الافتراضي الذي يعطيه Git للمستودع البعيد الرئيسي عندما تقوم باستنساخ مشروع، لذا فإن هذا الأمر يقوم بجلب التحديثات من ذلك المصدر.

### ماذا يفعل هذا الأمر بشكل عام؟

يأمر Git هذا بجلب التحديثات من المستودع البعيد `origin` مع عدة قيود:

- يستخدم إصدار البروتوكول 2 للاتصال.
- يسترجع فقط آخر 5 نقاط لكل فرع (`--depth=5`).
- يتخطى جلب الوسوم (`--no-tags`).
- يحذف أي فروع تتبع بعيدة محلية لم تعد موجودة في المستودع البعيد (`--prune`).
- يتجاهل الوحدات الفرعية (`--no-recurse-submodules`).

باختصار، إنها طريقة خفيفة الوزن لتحديث العرض المحلي الخاص بك للمستودع البعيد، مع التركيز على التغييرات الحديثة وتجنب البيانات الإضافية مثل الوسوم أو الوحدات الفرعية أو السجل الكامل. قد يُستخدم هذا لتوفير عرض النطاق الترددي أو تسريع العملية أو الحفاظ على المستودع المحلي في حدوده الدنيا.

### مثال على سيناريو
تخيل أنك تعمل على مشروع بمستودع كبير، وتحتاج فقط إلى أحدث التغييرات من الفرع `main` للتحقق من شيء ما بسرعة. تشغيل هذا الأمر سوف:
- يحدّث `origin/main` بآخر 5 نقاط.
- يزيل أي فروع قديمة (مثلًا، إذا تم حذف `origin/feature-x` عن بُعد).
- يتخطى الوسوم والوحدات الفرعية، مما يحافظ على عملية الجلب سريعة ومركزة.

هذا كل شيء! هذا الأمر يدور حول الكفاءة والتحكم عند المزامنة مع مستودع بعيد.