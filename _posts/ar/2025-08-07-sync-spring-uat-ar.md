---
audio: false
generated: true
image: false
lang: ar
layout: post
title: مزامنة فروع اختبار القبول للمستخدم في الربيع والكود
translated: true
type: note
---

إليك مجموعة من أفضل الممارسات والأنماط التي يمكنك مزجها وتطابقها للحفاظ على تزامن فروع الاختبار القبولية الثلاثة (UAT) الخاصة بك، والحفاظ على تاريخ نظيف، والتعامل مع التعليمات البرمجية الخاصة بكل بلد في تطبيق Spring—بالإضافة إلى القليل عن كيفية مساعدة الذكاء الاصطناعي.

---

## 1. التفرع والمزامنة

1.  **التطوير على الفرع الرئيسي مع فروع ميزات قصيرة الأجل**

    * احتفظ بفرع رئيسي واحد (**main**) أو ( **develop**).
    * لكل تذكرة جيرا (مثل FT-103) ولكل بلد، أنشئ فروع ميزات بأسماء:

      ```
      feature/FT-103-cn
      feature/FT-103-sg
      feature/FT-103-tw
      ```
    * عندما يكون العمل جاهزًا، قم بدمجه مرة أخرى في الفرع **main**، ثم اختر انتقائيًا (cherry-pick) أو ادمج في كل فرع من الفروع `uat_cn`، `uat_sg`، `uat_tw`.
    * الفائدة: يتم الدمج في الفرع الرئيسي مرة واحدة؛ وتقوم الفروع الخاصة بكل بلد بجلب ما تحتاجه فقط.

2.  **مزامنة فروع UAT بانتظام**

    * حدد موعدًا يوميًا (أو لكل بناء) لوظيفة تقوم بإعادة قاعدة (rebase) كل فرع `uat_*` على الفرع `main` حتى لا تتباعد كثيرًا.
    * أتمتة هذه العملية في التكامل المستمر (CI) (مثل إجراء GitHub يعيد قاعدة `uat_cn` كل ليلة).

3.  **استخدم طلبات السحب (Pull-Requests) مع فرض المراجعة**

    * اشترط وجود طلب سحب (PR) لكل دمج لفرع ميزة في الفرع الرئيسي (main).
    * تأكد من أن تذكرة "FT-xxx" موجودة في اسم الفرع وفي عنوان/وصف طلب السحب.

---

## 2. اتفاقيات رسائل الالتزام ودمجها في commit واحد (Squashing)

1.  **نمط تقليدي مع مفتاح JIRA**

    ```
    FT-103: إصلاح مؤشر Null في البحث عن العميل
    ```

2.  **التزامات صغيرة (Micro-commit) → دمجها في commit واحد عند الدمج**

    * أثناء العمل على الميزة، يقوم المطورون بالالتزام (commit) أثناء تقدمهم:

      ```
      FT-103 #1: التهيئة الأولية لحبوب الخدمة (service beans)
      FT-103 #2: إضافة منطق التحقق (validation logic)
      FT-103 #3: تحديث معالجة الأخطاء (error handling)
      ```
    * عند دمج طلب السحب، استخدم خيار "Squash and merge" لدمج جميع التزامات FT-103 في commit واحد موجز:

      ```
      FT-103: التحقق من خدمة العملاء (customer-service) ومعالجة الأخطاء
      ```

3.  **الترقيم داخل التذكرة الواحدة**

    * إذا كنت تتابع خطوات متعددة ومميزة في نفس التذكرة، فإن الترقيم (`#1`, `#2`) مقبول أثناء التطوير.
    * بمجرد الدمج، ادمج كل شيء في commit *واحد* لـ FT-103؛ يبقى التاريخ مرتبًا وتمثل كل تذكرة تغييرًا منطقيًا واحدًا.

4.  **أتمتة فحص رسائل الالتزام (commit-lint)**

    * استخدم خطاف (hook) في Git أو إضافة في التكامل المستمر (مثل [commitlint](https://commitlint.js.org)) لفرض وجود `FT-\d+` في بداية كل رسالة.
    * يمكنك فرض نطاق (scope) اختياريًا: `FT-103(sg): …`.

---

## 3. التعامل مع التعليمات البرمجية الخاصة بكل بلد في Spring

1.  **الملفات الشخصية (Profiles) وحبوب Spring المشروطة (conditional beans)**

    * حدد ملفًا شخصيًا (profile) في Spring لكل بلد: `@Profile("cn")`، `@Profile("sg")`، `@Profile("tw")`.
    * في ملفات `application-cn.yml`، `application-sg.yml`، إلخ، عيّن الخصائص الخاصة بكل بلد.
    * أثناء بدء التشغيل، مرر `--spring.profiles.active=cn` (أو sg أو tw) لاختيار الحبوب (beans) الصحيحة.

2.  **نمط الاستراتيجية (Strategy pattern) / وحدات البرنامج المساعد (plugin modules)**

    * أنشئ واجهة `PaymentProcessor` بثلاثة تطبيقات (`CnPaymentProcessor`، إلخ).
    * استخدم `@Component` + `@Profile` أو مصنع (factory) يختار الحبة (bean) بناءً على علم (flag) وقت التشغيل.

3.  **حزم الموارد (Resource bundles) / أعلام الميزات (feature flags)**

    * إذا كانت الاختلافات صغيرة (مثل تنسيقات التاريخ، عناوين URL للنقاط الطرفية (endpoint URLs))، حافظ على مسار تعليمات برمجية واحد وأخرج الاختلافات إلى ملفات خصائص أو خدمة أعلام ميزات (feature-flag service).

4.  **وحدات منفصلة (إذا كانت كبيرة)**

    * إذا كان المنطق مختلفًا تمامًا، قم بتقسيمه إلى وحدات فرعية:

      ```
      /core
      /country-cn
      /country-sg
      /country-tw
      ```
    * يقوم التطبيق الرئيسي بسحب وحدة البلد النشطة فقط أثناء وقت البناء/النشر.

---

## 4. فصل المهام حسب المؤلف مقابل حسب التذكرة

*   **حسب التذكرة، وليس المؤلف.** يجب أن تكون المهام مجزأة حول *الميزات* (معرفات Jira)، وليس حول الشخص.
*   إذا عمل عدة مطورين على FT-103، فإنهم يتعاونون على نفس الفرع أو يستخدمون فروع موضوعية (topic branches) متفرعة منه— ولكن في النهاية يتم الدمج مرة أخرى في فرع FT-103 الواحد.
*   تبقى بيانات وصفية (metadata) المؤلف في حقل مؤلف الالتزام (commit author)؛ لا تحتاج إلى دمج الالتزامات حسب المؤلف.

---

## 5. توظيف الذكاء الاصطناعي في العمل

1.  **توليد رسائل الالتزام (Commit-message)**

    * يمكن لأدوات مثل GitHub Copilot أو OpenAI اقتراح رسائل التزام نظيفة وتقليدية من خلال الاختلافات (diff) في الكود.
    * قم بدمج خطاف (hook) قبل الالتزام (pre-commit) يقوم بتشغيل `ai-commit --preview` لصياغة رسالة الالتزام للمراجعة.

2.  **وصف طلب السحب (PR) وسجل التغييرات (changelog)**

    * استخدم مساعد ذكي لتلخيص جميع الالتزامات تحت تذكرة معينة في وصف متماسك لطلب السحب أو ملاحظات الإصدار:

      > "لخّص التغييرات في فرع feature/FT-103 في شكل نقاط."

3.  **مساعدة في مراجعة الكود (Code review)**

    * يمكن لأدوات فحص الكود (linters) المدعومة بالذكاء الاصطناعي (مثل SonarQube مع إضافات الذكاء الاصطناعي، DeepCode) الإشارة إلى المشاكل في مسارات التعليمات البرمجية الخاصة بكل بلد.

4.  **أتمتة الاختيار الانتقائي (cherry-picks) وإعادة القاعدة (rebases)**

    * اكتب نصًا برمجيًا صغيرًا (أو استخدم منصة low-code) تقوم، عندما يتم دمج FT-103 في `main`، باختياره انتقائيًا تلقائيًا في كل فرع `uat_*` وفتح طلبات سحب لأي تعارضات في الدمج.

---

### جمع كل شيء معًا

1.  **طوّر على** `feature/FT-XXX-<cn/sg/tw>`.
2.  **قم بالالتزام بحرية** (الترقيم مقبول)، مع الإشارة إلى مفتاح JIRA.
3.  **افتح طلب سحب (PR)** → إلى main؛ اختر **Squash-and-merge** بحيث يمثل كل FT-XXX commit واحد نظيف.
4.  **وظيفة التكامل المستمر (CI job)** تقوم تلقائيًا بإعادة قاعدة/دمج ذلك الالتزام (commit) في كل فرع من الفروع `uat_cn`، `uat_sg`، `uat_tw`.
5.  **الملفات الشخصية لـ Spring (Spring profiles)** في وقت التشغيل تختار منطق البلد الصحيح—لا يوجد تكرار للتعليمات البرمجية في الفروع الثلاثة.
6.  **أدوات الذكاء الاصطناعي** تساعد في فرض نمط الالتزام، وتلخيص طلبات السحب، وإدارة عمليات الدمج.

يحافظ سير العمل هذا على تاريخك مرتبًا، ويضمن إمكانية تتبع كل تذكرة إلى commit واحد عبر جميع البيئات، ويفصل منطق كل بلد في وقت التشغيل بدلاً من فصلها في تاريخ Git، ويستفيد من الذكاء الاصطناعي حيث يضيف أكبر قيمة.