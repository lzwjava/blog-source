---
audio: false
generated: true
lang: ar
layout: post
title: استخدام نيتي في جافا
translated: true
type: note
---

لنغوص في استخدام نيتي (Netty)، إطار العمل القوي للشبكات غير المتزامن والقائم على الأحداث لبناء تطبيقات عالية الأداء في جافا. يُستخدم على نطاق واسع لإنشاء خوادم وعملاء تحتاج إلى معالجة العديد من الاتصالات بكفاءة، مثل خوادم الويب، والوكلاء (proxies)، أو أنظمة المراسلة الفورية. سأرشدك خلال الأساسيات خطوة بخطوة، مع التركيز على إعداد خادم بسيط، نظرًا لأنها نقطة بداية شائعة.

---

### 1. **ما هي نيتي (Netty)؟**
- تقوم نيتي بتجريد التعقيدات الخاصة بـ Java NIO (الإدخال/الإخراج غير الحاجز) وتوفر واجهة برمجة تطبيقات (API) واضحة لبناء التطبيقات الشبكية.
- الميزات الرئيسية: الإدخال/الإخراج غير المتزامن، حلقات الأحداث (event loops)، خطوط الأنابيب (pipelines) لمعالجة البيانات، والقابلية للتوسع.
- فكر فيها كأدوات لمعالجة المقابس (sockets)، والبروتوكولات، والبيانات بكفاءة.

---

### 2. **إعداد مشروعك**
لاستخدام نيتي، أضفها إلى مشروعك. إذا كنت تستخدم Maven، فقم بتضمين هذا في ملف `pom.xml` الخاص بك:
```xml
<dependency>
    <groupId>io.netty</groupId>
    <artifactId>netty-all</artifactId>
    <version>4.1.108.Final</version> <!-- أحدث إصدار مستقر اعتبارًا من فبراير 2025 -->
</dependency>
```
لـ Gradle:
```gradle
implementation 'io.netty:netty-all:4.1.108.Final'
```

---

### 3. **المفاهيم الأساسية**
قبل البدء في البرمجة، استوعب هذه الأساسيات:
- **EventLoop**: يدير عمليات الإدخال/الإخراج وينفذ المهام بشكل غير متزامن.
- **Channel**: يمثل اتصالاً (مثل المقبس - socket).
- **ChannelHandler**: يعالج الأحداث (مثل استقبال البيانات، إنشاء اتصال).
- **ChannelPipeline**: سلسلة من المعالجات (handlers) لمعالجة البيانات الواردة والصادرة.
- **Bootstrap**: يُهيئ ويبدأ تشغيل الخادم أو العميل الخاص بك.

---

### 4. **بناء خادم صدى (Echo) بسيط**
لننشئ خادمًا يرد مرة أخرى على العميل بأي شيء يرسله. هذا مثال كلاسيكي على نيتي.

#### الخطوة 1: إنشاء ChannelInitializer
يقوم هذا بإعداد خط الأنابيب (pipeline) لكل اتصال جديد.
```java
import io.netty.channel.ChannelInitializer;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.ChannelPipeline;
import io.netty.handler.codec.string.StringDecoder;
import io.netty.handler.codec.string.StringEncoder;

public class EchoServerInitializer extends ChannelInitializer<SocketChannel> {
    @Override
    protected void initChannel(SocketChannel ch) throws Exception {
        ChannelPipeline pipeline = ch.pipeline();
        // أضف معالجات لفك تشفير/تشفير النصوص ومعالجة المنطق
        pipeline.addLast(new StringDecoder());  // فك تشفير البايتات إلى نصوص
        pipeline.addLast(new StringEncoder());  // تشفير النصوص إلى بايتات
        pipeline.addLast(new EchoServerHandler());  // المنطق المخصص
    }
}
```

#### الخطوة 2: إنشاء معالج (Handler)
يحدد هذا ما يحدث عند وصول البيانات.
```java
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.SimpleChannelInboundHandler;

public class EchoServerHandler extends SimpleChannelInboundHandler<String> {
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception {
        System.out.println("Received: " + msg);
        ctx.writeAndFlush(msg);  // أعد إرسال الرسالة مرة أخرى إلى العميل
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        cause.printStackTrace();
        ctx.close();  // أغلق الاتصال في حالة حدوث خطأ
    }
}
```

#### الخطوة 3: إعداد الخادم
يجمع هذا كل شيء معًا ويبدأ تشغيل الخادم.
```java
import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.nio.NioServerSocketChannel;
import io.netty.channel.EventLoopGroup;

public class EchoServer {
    private final int port;

    public EchoServer(int port) {
        this.port = port;
    }

    public void run() throws Exception {
        // حلقتا أحداث: واحدة لقبول الاتصالات، والأخرى لمعالجتها
        EventLoopGroup bossGroup = new NioEventLoopGroup(1);  // يقبل الاتصالات الواردة
        EventLoopGroup workerGroup = new NioEventLoopGroup(); // يعالج حركة المرور

        try {
            ServerBootstrap bootstrap = new ServerBootstrap()
                .group(bossGroup, workerGroup)
                .channel(NioServerSocketChannel.class)  // استخدم ناقل NIO
                .childHandler(new EchoServerInitializer());  // تهيئة الاتصالات الجديدة

            // الربط بالمنفذ وبدء تشغيل الخادم
            bootstrap.bind(port).sync().channel().closeFuture().sync();
        } finally {
            // الإيقاف بشكل صحيح
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }
    }

    public static void main(String[] args) throws Exception {
        int port = 8080;  // المنفذ الافتراضي
        new EchoServer(port).run();
    }
}
```

---

### 5. **اختبار الخادم**
- شغّل صنف `EchoServer`.
- استخدم أداة مثل `telnet` (`telnet localhost 8080`) أو اكتب عميل نيتي بسيط:
```java
import io.netty.bootstrap.Bootstrap;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.nio.NioSocketChannel;
import io.netty.channel.EventLoopGroup;

public class EchoClient {
    public static void main(String[] args) throws Exception {
        EventLoopGroup group = new NioEventLoopGroup();
        try {
            Bootstrap bootstrap = new Bootstrap()
                .group(group)
                .channel(NioSocketChannel.class)
                .handler(new EchoServerInitializer());  // إعادة استخدام نفس المُهيئ

            bootstrap.connect("localhost", 8080).sync().channel().closeFuture().sync();
        } finally {
            group.shutdownGracefully();
        }
    }
}
```
- اكتب رسالة في `telnet`، وسيردها الخادم مرة أخرى.

---

### 6. **خيارات التخصيص الرئيسية**
- **البرامج المشفرة (Codecs)**: استخدم `StringDecoder`/`StringEncoder` للنصوص، أو خصص مع `ByteBuf` للبايتات الأولية أو بروتوكولات أخرى (مثل HTTP مع `HttpServerCodec`).
- **التوزيع على الخيوط (Threading)**: اضبط عدد الخيوط في `NioEventLoopGroup` (مثال: `new NioEventLoopGroup(4)` لـ 4 خيوط).
- **خط الأنابيب (Pipeline)**: أضف المزيد من المعالجات للتسجيل (`LoggingHandler`)، أو SSL (`SslHandler`)، أو المنطق المخصص.
- **الخيارات (Options)**: عيّن `SO_BACKLOG`، `SO_REUSEADDR`، إلخ، عبر `bootstrap.option()` أو `childOption()`.

---

### 7. **أفضل الممارسات**
- **إعادة استخدام EventLoopGroups**: شاركها عبر العملاء/الخوادم إذا أمكن لتوفير الموارد.
- **معالجة الاستثناءات**: طبق دائمًا `exceptionCaught` في المعالجات (handlers).
- **الإيقاف الصحيح (Graceful Shutdown)**: استدعِ `shutdownGracefully()` للتنظيف.
- **المخازن المؤقتة (Buffers)**: استخدم `ByteBuf` للإدارة الفعالة للذاكرة (فئة المخزن المؤقت في نيتي).

---

### 8. **الخطوات التالية**
- **خادم HTTP**: أضف `HttpServerCodec` وتعامل مع طلبات HTTP.
- **WebSocket**: استخدم `WebSocketServerProtocolHandler` للتطبيقات الفورية (real-time).
- **الأداء**: اضبط أحجام `EventLoopGroup` واستكشف `Epoll` (لينكس) أو `KQueue` (ماك) للحصول على أداء أفضل.

---

هذه هي الأساسيات! لديك الآن خادم صدى (Echo) يعمل. إذا كنت ترغب في تعديله — مثل إضافة بروتوكول مخصص، أو معالجة البيانات الثنائية، أو توسيع نطاقه — فقط أخبرني، وسأرشدك further! ما هو هدفك من استخدام نيتي؟