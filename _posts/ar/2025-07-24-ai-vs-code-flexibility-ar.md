---
audio: false
generated: true
lang: ar
layout: post
title: 'الذكاء الاصطناعي مقابل البرمجة: القيود والمرونة'
translated: true
type: note
---

أنت محق تمامًا في الإشارة إلى أن حتى أكثر أنظمة الذكاء الاصطناعي تقدمًا مثل Grok (الذي طورته xAI)، أو نماذج OpenAI، أو غيرها ذات الاستخدام المتقدم للأدوات واستدعاء الوظائف، لديها قيود جوهرية مقارنة بكتابة وتنفيذ الكود المخصص — خاصة عندما يتعلق الأمر بالمرونة، ومعالجة المهام شديدة التعقيد أو غير المألوفة، والتفاعل المباشر مع واجهات برمجة التطبيقات (APIs). دعوني أوضح هذا خطوة بخطوة لشرح سبب صحة هذا الأمر في كثير من الأحيان، مع الإشارة أيضًا إلى المجالات التي يتفوق فيها الذكاء الاصطناعي والمجالات التي لا يزال فيها هناك فجوات.

### 1. **مرونة الكود مقابل استخدام أدوات الذكاء الاصطناعي**
   - **مزايا الكود**: كتابة الكود (مثلًا بلغة Python) تتيح مرونة قصوى لأنه يمكنك:
     - استدعاء أي واجهة برمجة تطبيقات (API) بشكل مباشر مع تحكم كامل في المعاملات والمصادقة ومعالجة الأخطاء وإعادة المحاولات والمنطق المخصص. على سبيل المثال، إذا كنت بحاجة للتفاعل مع واجهة برمجة تطبيقات متخصصة تتطلب رؤوسًا (headers) محددة، أو رفع ملفات متعددة الأجزاء (multipart)، أو بثًا (streaming) فوريًا، فإن الكود يسمح لك ببنائها من الصفر دون وسيط.
     - إدارة الحالة (state)، والحلقات (loops)، والشروط (conditionals)، وتحويل البيانات بطرق دقيقة وغير محدودة. يمكن للكود أن يعمل إلى أجل غير مسمى، ويعالج مجموعات بيانات ضخمة، أو يدمج عدة مكتبات بسلاسة.
     - تصحيح الأخطاء (Debug) والتكرار بطريقة حتمية — يمكن تتبع الأخطاء، ويمكنك التحكم في إصدارات كل شيء.
     - مثال: إذا كنت تبني أداة لجمع البيانات من الويب (web scraper) تتكيف مع الهياكل المتغيرة للمواقع، يمكن للكود دمج محددات ديناميكية (dynamic selectors)، ووكلاء (proxies)، وتعلم آلي على الطاير. قد تقترب أدوات الذكاء الاصطناعي من هذا ولكنها غالبًا ما تصطدم بجدران بسبب النطاقات المحددة مسبقًا.

   - **قيود الذكاء الاصطناعي هنا**: تعتمد أنظمة الذكاء الاصطناعي مثل نماذج Grok أو GPT على أدوات محددة مسبقًا، أو استدعاءات وظائف، أو ملحقات (plugins) (مثل أدوات Grok للبحث على الويب، أو تنفيذ الكود، أو تحليل X/Twitter). هذه الأدوات قوية لكنها مقيدة:
     - الأدوات هي في الأساس "صناديق سوداء" مصممة لحالات الاستخدام الشائعة. إذا كانت المهمة لا تتناسب بدقة مع الأدوات المتاحة، على الذكاء الاصطناعي ربطها بطريقة إبداعية، مما قد يقدم أوجه قصور أو إخفاقات.
     - استدعاءات واجهات برمجة التطبيقات عبر الذكاء الاصطناعي غير مباشرة: يفسر النموذج قصودك، يولد استدعاء وظيفة، ينفذه، ثم يحلل الاستجابة. هذا يضيف طبقات من سوء التفسير المحتمل، أو حدود معدل الاستخدام (rate limits)، أو فقدان السياق (مثل أن حدود الرموز (token limits) في المطالبات (prompts) يمكنها اقتطاع التعليمات المعقدة).
     - الأمان والعزل (Sandboxing): بيئات الذكاء الاصطناعي (مثل مفسر الكود في Grok) تمنع الإجراءات الخطيرة، وتحد من تثبيت الحزم، أو تقيد الوصول إلى الإنترنت، مما يجعلها أكثر أمانًا ولكن أقل مرونة من الكود الخام على جهازك.

### 2. **معالجة المهام الصعبة أو المعقدة**
   - **لماذا قد نحتاج إلى مطالبات أو سلاسل أدوات متعددة**: بالنسبة للمشاكل الصعبة، غالبًا ما يتطلب الذكاء الاصطناعي التحليل — أي تقسيمها إلى مهام فرعية عبر مطالبات متعددة، أو استدعاءات أدوات، أو تكرارات. هذا يحاكي كيفية تقسيم المبرمجين للكود إلى وحدات، لكنه أقل كفاءة:
     - المهام البسيطة (مثل "ابحث على الويب عن X") يمكن أن تكون فورية (one-shot) بأداة واحدة.
     - المهام المعقدة (مثل "حلل بيانات الأسهم فورية، وقارنها بالأخبار، وابني نموذجًا تنبؤيًا، وقم بتصوره") قد تحتاج إلى 2+ مطالبة: واحدة لجمع البيانات (بحث ويب + تنفيذ كود)، وأخرى للتحليل (مزيد من الكود)، وهكذا. كل خطوة تحمل خطر تضاعف الأخطاء، مثل المخرجات الوهمية (hallucinated) أو نقل سياق غير مكتمل.
     - إذا كانت المهمة تتضمن بيانات خاصة، أو تعاونًا فوريًا، أو الوصول إلى العتاد (مثل التحكم بذراع روبوت عبر واجهات برمجة تطبيقات)، قد يفشل الذكاء الاصطناعي لأنه لا يستطيع "التفكير" خارج نطاق تدريبه أو مجموعة أدواته دون تدخل بشري.

   - **المهام التي لا يستطيع الذكاء الاصطناعي القيام بها (أو يكافح معها)**:
     - أي شيء يتطلب إبداعًا حقيقيًا أو اختراعًا يتجاوز الأنماط في بيانات التدريب (مثل اختراع خوارزمية جديدة من الصفر دون مراجع — يمكن للذكاء الاصطناعي توليد كود، لكنه مشتق).
     - العمليات الحسابية طويلة الأمد وكثيفة الاستخدام للموارد: جلسات الذكاء الاصطناعي لها مهلات زمنية، وحدود ذاكرة، أو حصص استخدام، بينما يمكن للكود أن يعمل على خادم لأيام.
     - الإجراءات الحساسة أو المقيدة: الضوابط الأخلاقية تمنع استدعاءات واجهات برمجة التطبيقات الضارة (مثل إرسال spam للخدمات)، ولا يمكن للذكاء الاصطناعي الوصول إلى ملفاتك المحلية أو أجهزتك مباشرة.
     - الحالات الاستثنائية (Edge cases) ذات الغموض: إذا كانت المهمة لها أهداف غير واضحة، قد يدور الذكاء الاصطناعي بشكل غير فعال، بينما يسمح لك الكود بتثبيت الافتراضات واختبارها.
     - مثال من العالم الحقيقي: بناء تطبيق كامل (full-stack) مع مصادقة المستخدم، وتكامل قاعدة البيانات، ونشر التطبيق — يمكن للذكاء الاصطناعي المساعدة في بناء نموذج أولي لأجزاء عبر الأدوات، لكن تجميعها وصيانتها يتطلب مرونة الكود البشري.

### 3. **المجالات التي يتفوق فيها الذكاء الاصطناعي (ويقوم بسد الفجوة)**
   - رغم نقاط الضعف، فإن الذكاء الاصطناعي المزود بالأدوات هو معجل هائل: فهو يدمقرطة البرمجة بالسماح لغير الخبراء بتحقيق نتائج معقدة بسرعة. على سبيل المثال، يمكن لـ Grok ربط أدوات مثل تنفيذ الكود، وتصفح الويب، والبحث الدلالي (semantic searches) لحل مشاكل قد تستغرق ساعات من البرمجة اليدوية.
   - مع مرور الوقت، ومع تحسن النماذج (مثل تحسين المنطق، وسياقات أطول، ومزيد من الأدوات)، تضيق الفجوة. ولكن في الأساس، الذكاء الاصطناعي هو "محرك استدلالي" مُطَبق فوق الكود — إنه ليس بديلاً عن القوة الخام للبرمجة.
   - غالبًا ما تفوز النهج الهجينة: استخدم الذكاء الاصطناعي لتوليد هيكل الكود أو تصحيحه، ثم شغل الكود بنفسك لتحقيق المرونة.

باختصار، نعم — الكود بطبيعته أكثر مرونة وقوة للاستدعاءات المباشرة لواجهات برمجة التطبيقات والمهام فائقة التعقيد لأنه غير مقيد بطبقات التفسير في الذكاء الاصطناعي، أو احتياجات هندسة المطالبات (prompt engineering)، أو الحدود المضمنة فيه. تجعل أدوات الذكاء الاصطناعي الأمور أسهل وأسرع في العديد من السيناريوهات، ولكن بالنسبة لأصعب المهام، ستحتاج غالبًا إلى تفاعلات متعددة الخطوات أو العودة إلى الكود الخالص. إذا شعرت أن مهمة ما "مستحيلة" في الذكاء الاصطناعي، فذلك لأنها عادةً ما تتطلب ذلك التحكم منخفض المستوى.

إذا كان لديك مهمة أو مثال محدد في ذهنك، يمكنني محاولة توضيح ذلك باستخدام الأدوات هنا لإظهار الإيجابيات والسلبيات!