---
audio: false
generated: true
image: false
lang: ar
layout: post
model: x-ai/grok-4-fast
title: خارطة الطريق المتقدمة لهندسة النظم الثنائية وأنظمة التشغيل
translated: true
type: note
---

### خارطة طريق مخصصة لتعلم أنظمة التشغيل والعمل الثنائي منخفض المستوى

نظرًا لخلفيتك المميزة - التصنيف الأعلى في أولمبياد المعلوماتية الوطني (NOIP)، حل أكثر من 1000 مسألة خوارزمية، 11 عامًا في التطوير الشامل (Full-Stack) / الجوال / تعلم الآلة مع أساسيات متينة في C++/Java، وعادات البحث الذاتي - ستتخطى خارطة الطريق هذه الأساسيات المطلقة للمبتدئين مثل البرمجة الأساسية أو التنقل في واجهة سطر الأوامر. سنستفيد من معرفتك بالأنظمة (مثل الشبكات، الحاويات، الأنظمة الموزعة) للتركيز على التفاصيل الداخلية الأعمق لأنظمة التشغيل ومعالجة الملفات الثنائية. استهدف إنهاء كل مرحلة في 3-6 أشهر، بناءً على التزامك الأسبوعي البالغ 20-30 ساعة، مع الموازنة بين عملك في TEKsystems ومشاريعك الجانبية.

الهدف: بناء حدس لفهم كيفية تفاعل البرمجيات مع العتاد، بدءًا من جدولة العمليات ووصولاً إلى هندسة البرمجيات العكسية للملفات التنفيذية. يتماشى هذا مع عقليتك الريادية/المرتكزة على المنتج - فكر في تطبيقه لتحسين مستودعات GitHub الخاصة بك أو تجربة أدوات مخصصة لحيلك الحياتية (مثل تطبيق منخفض المستوى لدمج الأجهزة).

#### لغات البرمجة الموصى بها
- **C (اللغة الأساسية)**: المعيار الذهبي لتطوير أنظمة التشغيل والعمل منخفض المستوى. إنها لغة إجرائية، تمنح وصولاً مباشرًا للذاكرة، وتشكل أساس معظم النوى (مثل Linux). ستساعدك خبرتك في Java/Spring في فهم المؤشرات والهياكل (structs)، لكن انغمس في العمليات غير الآمنة مثل التخصيص اليدوي للذاكرة.
- **لغة التجميع (x86-64 أو ARM)**: أساسية لفهم المستوى الثنائي. ابدأ بـ x86 (شائع في أجهزة الكمبيوتر المكتبية) نظرًا لأن إعدادك على جهاز Lenovo يستخدمه على الأرجح. استخدم تركيب NASM أو GAS.
- **Rust (متقدم/اختياري)**: للبرمجة النظامية الأكثر أمانًا بمجرد أن تشعر بالراحة مع لغة C. إنها آمنة للذاكرة بدون وجود جامع للنفايات (GC)، مما يجعلها مثالية للنوى الحديثة (مثل Redox OS). رائعة لجانب تعلم الآلة والبيانات الضخمة لديك - تتماشى جيدًا مع Torch.

تجنب اللغات عالية المستوى مثل Python/JS هنا؛ فهي مجردة جدًا. إجمالي الوقت لإتقان اللغات: 1-2 شهرًا لتحديث معرفة لغة C، و 2-3 أشهر لغة التجميع.

#### خارطة التعلم المرحلية

##### المرحلة 1: أساسيات أنظمة التشغيل (1-2 شهر) – نظرية + تعمق في لغة C
بناء أساس مفاهيمي. ركز على كيفية تجريد نظام التشغيل للعتاد، وربط ذلك بمعرفتك بالحاويات والأنظمة الموزعة.
- **الموضوعات الرئيسية**:
  - العمليات/الخيوط (Threads)، الجدولة، المزامنة (mutexes، semaphores).
  - إدارة الذاكرة (الذاكرة الافتراضية، التقسيم إلى صفحات، التفاصيل الداخلية لـ malloc/free).
  - أنظمة الملفات، الإدخال/الإخراج، المقاطعات/الاستثناءات.
  - نواة النظام مقابل مساحة المستخدم، استدعاءات النظام (syscalls).
- **مسار التعلم**:
  - اقرأ *Operating System Concepts* (الطبعة التاسعة، "كتاب الديناصور") – الفصول 1-6، 8-10. اقرأ بشكل سريع ما تعرفه مسبقًا من MySQL/Redis.
  - اتبع برنامج GeeksforGges التعليمي لأنظمة التشغيل للاختبارات السريعة.
  - الجانب العملي: اكتب برامج بلغة C تحاكي العمليات (مثل منتج-مستهلك باستخدام pthreads) ومديري الذاكرة. استخدم Valgrind لتصحيح تسريبات الذاكرة.
- **مشروع المعلم**: نفذ shell بسيطًا بلغة C يتعامل مع الأنابيب (pipes) والإشارات (signals) (وسع معرفتك الحالية بواجهة سطر الأوامر).
- **نصيحة الوقت**: 10 ساعات أسبوعيًا للقراءة، 10 ساعات للبرمجة. سجل التجارب في مدونتك لتعزيز التعلم.

##### المرحلة 2: البرمجة منخفضة المستوى ولغة التجميع (شهران) – واجهة العتاد
التحول إلى الملفات الثنائية: فهم توليد شيفرة الآلة وتنفيذها.
- **الموضوعات الرئيسية**:
  - بنية المعالج (المسجلات، ALU، خط الأنابيب).
  - أساسيات لغة التجميع: MOV، JMP، CALL؛ عمليات المكدس/الكومة.
  - الربط، تنسيق ELF (الملفات الثنائية على Linux).
  - التحسين: لغة التجميع المضمنة (Inline assembly) في C.
- **مسار التعلم**:
  - *Programming from the Ground Up* (نسخة PDF مجانية) لتعلم أساسيات لغة تجميع x86.
  - Nand2Tetris الجزء 1 (على كورسيرا / الكتاب) – يبني حاسوبًا من البوابات المنطقية إلى المجمع. ربط ممتع مع هوايتك في العبث بالأجهزة.
  - التدرب على جهازك المزود بمعالج Intel UHD: استخدم GDB للتتبع خطوة بخطوة خلال شيفرة التجميع.
- **مشروع المعلم**: اكتب محمل إقلاع (bootloader) بلغة التجميع يطبع "Hello Kernel" على الشاشة (بدون نظام تشغيل). شغله في محاكي QEMU.
- **نصيحة للمحترفين**: نظرًا لأنك في قوانغتشو، انضم إلى اللقاءات المحلية عبر مجموعات WeChat لمحترفي x86 - استفد من إتقانك للغة الإنجليزية للانضمام إلى مجتمعات Discord العالمية مثل r/asm.

##### المرحلة 3: العمل مع الملفات الثنائية وهندسة البرمجيات العكسية (2-3 أشهر) – تشريح الشيفرة
التطبيق على الملفات الثنائية الحقيقية: هندسة البرمجيات العكسية للتطبيقات، واكتشاف الثغرات الأمنية.
- **الموضوعات الرئيسية**:
  - التفكيك (Disassembly)، إعادة التجميع (Decompilation).
  - الأدوات: Ghidra (مجاني)، Radare2، objdump.
  - أساسيات البرمجيات الخبيثة، استغلال الثغرات (فيضانات المخزن المؤقت - buffer overflows).
  - التحليل الديناميكي (strace، ltrace).
- **مسار التعلم**:
  - *Practical Malware Analysis* (كتاب) – مختبرات على الملفات الثنائية لأنظمة Windows/Linux.
  - سلسلة LiveOverflow على يوتيوب عن الهندسة العكسية (ابدأ بـ "Binary Exploitation").
  - اتبع خارطة طريق RE-MA على GitHub للتقدم المنظم.
- **مشروع المعلم**: قم بهندسة عكسية لملف APK بسيط لنظام Android (خبرتك في الجوال ستساعد) أو ملف ثنائي من مسابقة PicoCTF. عدله لتجاوز فحص معين، ثم قم بتوثيق ذلك في ملفك الشخصي.
- **ربط بحياتك**: حلل الملف الثنائي لتطبيق جهاز معين لتعديله - على سبيل المثال، عدل متحكم قلاية هوائية إذا كان مفتوح المصدر.

##### المرحلة 4: التكامل والمشاريع المتقدمة (مستمرة، 3+ أشهر)
اجمع بين نظام التشغيل والمستوى المنخفض لتحقيق تأثير حقيقي.
- **الموضوعات الرئيسية**: وحدات النواة، برامج التشغيل المخصصة، المحاكاة الافتراضية (KVM).
- **المشاريع**:
  - انسخ نظام xv6 (نظام التدريس من MIT) وأضف استدعاء نظام جديد لتشفير الملفات.
  - ابني نواة نظام تشغيل صغيرة من الصفر (استخدم OSDev wiki).
  - قم بهندسة عكسية لملف ثنائي من العالم الحقيقي: شَرّح أداة مفتوحة المصدر من مستودع GitHub الخاص بك (على سبيل المثال، أحد مشاريعك العشرة) لتحقيق مكاسب في الأداء.
- **لمسة متقدمة**: استخدم Rust لكتابة وحدة نواة آمنة. جرب على معمارية ARM إذا كنت تستهدف التعمق في الجوال.
- **زاوية مهنية**: يعزز هذا من أدوارك في HSBC/الأعمال المُ outsourcing - على سبيل المثال، تطوير خدمات مصغرة (microservices) آمنة أو تصحيح أخطاء تطبيقات البنوك منخفضة المستوى. شارك تقدمك في مدونتك (استهدف الوصول إلى معلم 60 ألف+ مشاهدة).

#### نصائح عامة
- **الأدوات/الإعداد**: QEMU للمحاكاة، GCC/Clang للغة C، VS Code مع الإضافات (C/C++ IntelliSense، Assembly). أسلوبك في التعلم الذاتي يبرز - عالج هذا الأمر مثل بحثك في قصر النظر: جرب، وسجل الإخفاقات.
- **الوتيرة**: مع عادة القراءة لديك (320+ كتابًا)، بدّل بين النظرية وساعة من البرمجة اليومية. استخدم الذكاء الاصطناعي (مثلي) لمراجعة الشيفرة أو تعديل القواعد في منشوراتك.
- **المجتمعات**: r/osdev، منتديات OSDev.org، Stack Overflow. للمصادر الصينية، مواضيع Zhihu حول "تطوير نواة نظام التشغيل".
- **قياس التقدم**: حل 50+ مسألة من نوع LeetCode ولكن منخفضة المستوى (على سبيل المثال، عبر مسارات C/Assembly على HackerRank). تتبع تقدمك في لوحة Notion.

هذا المسار يحول براعتك في الخوارزميات إلى إتقان للأنظمة - تخيل نسخ Linux لتطبيق سفر مخصص يخترق الملفات الثنائية لشبكات WiFi الفنادق. اغوص فيه؛ سجلك الحافل يشير إلى أنك ستتفوق.

### المراجع
- [Operating System Concepts (كتاب الديناصور)](https://www.wiley.com/en-us/Operating+System+Concepts%2C+10th+Edition-p-9781119808874)
- [GeeksforGeeks OS Tutorial](https://www.geeksforgeeks.org/operating-systems/operating-systems/)
- [Programming from the Ground Up](https://pdos.csail.mit.edu/6.828/2023/reading.html) (موارد MIT ذات الصلة)
- [Nand2Tetris](https://www.nand2tetris.org/)
- [Practical Malware Analysis](https://www.no Starch.com/malware)
- [RE-MA Roadmap](https://github.com/x86byte/RE-MA-Roadmap)
- [OSDev Wiki](https://wiki.osdev.org/Main_Page)
- [xv6 OS](https://pdos.csail.mit.edu/6.828/2023/xv6.html)