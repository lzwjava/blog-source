---
audio: false
generated: true
lang: ar
layout: post
title: تنفيذ فرز سريع بزيغ
translated: true
type: note
---

إليك التنفيذ المكافئ لـ Quick Sort في Zig.

```zig
const std = @import("std");

// دالة الترتيب السريع
fn quickSort(arr: []i32) void {
    if (arr.len <= 1) {
        return;
    }

    const pivot_index = partition(arr);

    // تقسيم المصفوفة إلى أقسام يسرى ويمين
    // ملاحظة: تقسيم الشرائح في Zig يختلف قليلاً عن Rust
    // نحتاج إلى التعامل بعناية مع العنصر المحوري
    var left_slice = arr[0..pivot_index];
    var right_slice = arr[pivot_index + 1 .. arr.len]; // استبعاد العنصر المحوري من الشريحة اليمنى

    quickSort(left_slice);
    quickSort(right_slice);
}

// دالة التقسيم
fn partition(arr: []i32) usize {
    const len = arr.len;
    // للتبسيط، سنستخدم العنصر الأخير كعنصر محوري، مشابهًا لمثال Rust.
    // في تنفيذ quicksort للإنتاج، قد تختار عنصرًا محوريًا عشوائيًا أو متوسط الثلاثة لأداء أفضل في الحالة المتوسطة.
    const pivot = arr[len - 1];
    var i: usize = 0; // فهرس العنصر الأصغر

    for (0..(len - 1)) |j| {
        if (arr[j] <= pivot) {
            std.mem.swap(i32, &arr[i], &arr[j]);
            i += 1;
        }
    }

    // وضع العنصر المحوري في موضعه الصحيح
    std.mem.swap(i32, &arr[i], &arr[len - 1]);

    return i;
}

pub fn main() !void {
    var arr = [_]i32{ 3, 6, 8, 10, 1, 2, 1 };

    // إنشاء شريحة قابلة للتعديل من المصفوفة لدالة الترتيب السريع
    var slice: []i32 = &arr;

    std.debug.print("Before: {any}\n", .{slice});

    quickSort(slice);

    std.debug.print("After: {any}\n", .{slice});
}

```

### شرح التغييرات ومفاهيم Zig:

1.  **`const std = @import("std");`**: يستورد هذا السطر المكتبة القياسية لـ Zig، والتي توفر أدوات مفيدة مثل `std.debug.print` للطباعة و `std.mem.swap` لتبادل العناصر.
2.  **`fn quickSort(arr: []i32) void`**:
      * `fn` تعلن عن دالة.
      * `arr: []i32` تعلن عن `arr` كشريحة من `i32` (أعداد صحيحة 32 بت). في Zig، `[]T` تشير إلى شريحة قابلة للتعديل من النوع `T`. لا يوجد `&mut` منفصل كما في Rust؛ قابلية التعديل تُفهم ضمنيًا من خلال ما إذا كان المتغير الذي يحمل الشريحة قابلًا للتعديل أم لا.
      * `void` تشير إلى أن الدالة لا ترجع قيمة.
3.  **`if (arr.len <= 1)`**: تستخدم العبارات الشرطية أقواسًا حول الشرط.
4.  **`const pivot_index = partition(arr);`**: `const` تُستخدم للمتغيرات غير القابلة للتغيير.
5.  **تقسيم الشرائح في Zig**:
      * `var left_slice = arr[0..pivot_index];`
      * `var right_slice = arr[pivot_index + 1 .. arr.len];`
      * على عكس `split_at_mut` في Rust التي تنشئ شريحتين قابلتين للتعديل لا تتداخلان، فإن التقطيع `arr[start..end]` في Zig ينشئ شرائح جديدة (عروض) في المصفوفة الأصلية.
      * من المهم جدًا، في الاستدعاءات العودية، أن *نستبعد* العنصر المحوري من كل من المصفوفات الفرعية اليمنى واليسرى، حيث أن العنصر المحوري يكون بالفعل في موقعه النهائي المرتب بعد `partition`. في كود Rust، يحقق `right[1..]` هذا عن طريق تخطي العنصر الأول من الشريحة `right` بشكل فعال، وهو العنصر المحوري. نحن نكرر هذا باستخدام `pivot_index + 1` لبداية `right_slice`.
6.  **`std.mem.swap(i32, &arr[i], &arr[j]);`**:
      * `std.mem.swap` يُستخدم لتبادل العناصر.
      * الوسيط الأول (`i32`) هو نوع العناصر التي يتم تبديلها.
      * الوسيطان التاليان هما مؤشرات لمواقع الذاكرة المراد تبديلها (`&arr[i]` و `&arr[j]`).
7.  **`for (0..(len - 1)) |j| { ... }`**: هذه حلقة `for` تتكرر من `0` إلى (ولكن لا تشمل) `len - 1`. يتم التقاط متغير الحلقة كـ `j`.
8.  **`pub fn main() !void { ... }`**:
      * `pub` تجعل دالة `main` قابلة للوصول بشكل عام.
      * `!void` تشير إلى أن الدالة يمكنها إرجاع خطأ، ولكن في هذه الحالة، لا نتعامل مع أي خطأ بشكل صريح. للبرامج البسيطة، `void` كافية، ولكن غالبًا ما تُرى `!void` في Zig لأنها تشجع على التعامل القوي مع الأخطاء.
9.  **`var arr = [_]i32{ 3, 6, 8, 10, 1, 2, 1 };`**:
      * `[_]i32` تعلن عن مصفوفة بحجم ثابت من `i32`. `_` تخبر المترجم باستنتاج الحجم من قائمة المُهيئ.
10. **`var slice: []i32 = &arr;`**: ننشئ شريحة قابلة للتعديل (`[]i32`) من المصفوفة ذات الحجم الثابت `arr` لأن `quickSort` تتوقع شريحة.
11. **`std.debug.print("Before: {any}\n", .{slice});`**:
      * `std.debug.print` هو المكافئ في Zig لـ `println!` لإخراج التصحيح.
      * `{any}` هو محدد تنسيق يخبر Zig بطباعة القيمة بتنسيق يمكن للبشر قراءته وملائم للتصحيح.
      * `.{slice}` هو "حرفي بنية" (بنية مجهولة) يُستخدم لتمرير الوسائط إلى سلسلة التنسيق.

لتجميع وتشغيل كود Zig هذا:

1.  احفظه كـ `quick_sort.zig`.
2.  افتح طرفيتك في نفس الدليل.
3.  شغل: `zig run quick_sort.zig`