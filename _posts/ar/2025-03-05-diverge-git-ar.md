---
audio: false
generated: true
lang: ar
layout: post
title: الفروع المتباينة في جيت
translated: true
type: note
---

عندما يتباعد فرع `main` المحلي وفرع `origin/main` البعيد في Git — مع وجود 74 و70 commit مختلفة على التوالي — فهذا يعني أنهما يشتركان في سلف مشترك ولكنهما طورا commits فريدة منذ ذلك الحين. هدفك هو جعل فرع `main` المحلي يطابق `origin/main` عن طريق إعادة تعيين فرعك المحلي إلى السلف المشترك ("الأصل المشترك لكليهما") ثم استخدام `git pull` لجلب التغييرات البعيدة، مما يتسبب في تجاهل commits الـ 74 المحلية المتباعدة لصالح commits البعيدة. فيما يلي الخطوات لتحقيق ذلك.

### خطوات إصلاح التباعد

1. **جلب أحدث التغييرات من الفرع البعيد**  
   ابدأ بالتأكد من أن مستودعك المحلي يحتوي على أحدث المعلومات من المستودع البعيد. يقوم هذا بتحديث مرجعك لـ `origin/main` دون تغيير فرع `main` المحلي بعد.

   ```bash
   git fetch origin
   ```

2. **البحث عن commit السلف المشترك**  
   استخدم `git merge-base` لتحديد commit السلف المشترك بين `main` المحلي و `origin/main`. هذه هي النقطة التي تباعدت فيها الفروع.

   ```bash
   ancestor=$(git merge-base main origin/main)
   ```

   يقوم هذا الأمر بتخزين hash commit للسلف المشترك في المتغير `ancestor`.

3. **إعادة تعيين `main` المحلي إلى السلف المشترك**  
   أعد تعيين فرع `main` المحلي إلى commit السلف المشترك. يضمن الخيار `--hard` تحديث كل من مؤشر الفرع ودليل العمل الخاص بك، مع تجاهل جميع commits والتغييرات المحلية التي تم إجراؤها بعد هذه النقطة.

   ```bash
   git reset --hard $ancestor
   ```

   **تحذير**: ستتجاهل هذه الخططة جميع التغييرات غير المُحفظة (uncommitted changes) في دليل العمل ومنطقة التجهيز (staging area)، بالإضافة إلى الـ 74 commits الفريدة لفرع `main` المحلي. إذا كنت بحاجة إلى الحفاظ على هذه، ففكر في إنشاء فرع احتياطي أولاً (انظر "النسخ الاحتياطي الاختياري" أدناه).

4. **سحب التغييرات من الفرع البعيد**  
   الآن، اسحب التغييرات من `origin/main`. بما أن `main` المحلي أصبح الآن عند السلف المشترك، و `origin/main` متقدم بمقدار 70 commit، فإن هذا سيقوم بـ "fast-forward" لفرع `main` المحلي ليطابق `origin/main`.

   ```bash
   git pull origin main
   ```

   بعد هذا، سيكون فرع `main` المحلي مطابقًا تمامًا لـ `origin/main`، مع تجاهل جميع commits المحلية المتباعدة.

### تسلسل الأوامر الكامل

إليك التسلسل الكامل للأوامر لتنفيذه:

```bash
git fetch origin
ancestor=$(git merge-base main origin/main)
git reset --hard $ancestor
git pull origin main
```

### ماذا يحدث؟
- **بعد الخطوة 1**: يعرف مستودعك المحلي أحدث حالة لـ `origin/main`.
- **بعد الخطوة 2**: قمت بتحديد commit السلف المشترك (مثل hash مثل `abc123`).
- **بعد الخطوة 3**: تم إعادة تعيين `main` المحلي إلى `abc123`، مع فقدان الـ 74 commits المحلية الفريدة.
- **بعد الخطوة 4**: يقوم `git pull` بعمل "fast-forward" لـ `main` إلى `origin/main`، مما يجلب الـ 70 commits من الفرع البعيد.

النتيجة هي أن `main` المحلي يطابق `origin/main` تمامًا، مما يحقق هدفك المتمثل في استخدام الفرع البعيد.

### النسخ الاحتياطي الاختياري
إذا كنت غير متأكد من تجاهل commits المحلية وتريد الاحتفاظ بها لوقت لاحق، فأنشئ فرعًا احتياطيًا قبل الإعادة:

```bash
git branch backup-main
```

نفّذ هذا الأمر قبل أمر `git reset`. ستبقى الـ 74 commits المحلية الخاصة بك في الفرع `backup-main`، ويمكنك الرجوع إليها لاحقًا إذا لزم الأمر.

### ملاحظات مهمة
- **التغييرات غير المُحفظة (Uncommitted Changes)**: إذا كان لديك تغييرات غير مُحفظة (في دليل العمل أو منطقة التجهيز) تريد الاحتفاظ بها، فاخبئها (stash) قبل الإعادة:
  ```bash
  git stash
  ```
  بعد إكمال العملية، يمكنك استرجاعها باستخدام `git stash pop`.
- **لماذا هذه الطريقة ناجحة**: تضمن الإعادة إلى السلف المشترك ثم السحب حدوث عملية "fast-forward" نظيفة إلى `origin/main`، مما يتجنب تعارضات الدمج (merge conflicts) التي قد تنشأ من السحب المباشر مع الفروع المتباعدة.

باتباع هذه الخطوات، ستقوم بنجاح بإعادة تعيين `main` المحلي ليطابق `origin/main` كما هو مطلوب.