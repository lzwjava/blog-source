---
audio: false
generated: true
lang: ar
layout: post
title: دليل شامل للغة البرمجة جو
translated: true
type: note
---

يهدف هذا الدليل إلى تقديم نظرة شاملة على لغة البرمجة Go، متضمنة أساسياتها، مفاهيمها الأساسية، وميزاتها المتقدمة. تم تصميمه لكل من المبتدئين الذين لديهم بعض الخبرة في البرمجة وأولئك الذين يتطلعون إلى الانتقال من لغات أخرى.

**I. مقدمة إلى Go**

* **ما هي Go؟**
    * Go (غالباً ما يشار إليها بـ Golang) هي لغة برمجة مكتوبة بشكل ثابت ومترجمة، تم تصميمها في Google بواسطة Robert Griesemer و Rob Pike و Ken Thompson.
    * تؤكد على البساطة، والتزامن، والأداء.
    * Go مفتوحة المصدر ولديها مجتمع نابض بالحياة ومتنامي.
* **الميزات الرئيسية ومبادئ التصميم:**
    * **البساطة وسهولة القراءة:** بناء جملة نظيف، كلمات رئيسية قليلة، وتركيز على أداء شيء واحد بشكل جيد.
    * **التزامن:** الدعم المدمج لـ goroutines الخفيفة الوزن و channels يجعل برمجة التزامن أسهل وأكثر كفاءة.
    * **الأداء:** لغة مترجمة مع إدارة ذاكرة فعالة (جمع القمامة) تؤدي إلى تنفيذ سريع.
    * **الكتابة القوية:** تساعد في اكتشاف الأخطاء مبكراً في عملية التطوير.
    * **الربط الثابت:** ينتج ملفات تنفيذية مستقلة، مما يبسط عملية النشر.
    * **جمع القمامة:** إدارة الذاكرة التلقائية تقلل العبء على المطورين.
    * **المكتبة القياسية:** توفر مكتبة قياسية غنية وشاملة أدوات لمهام متنوعة.
    * **الأدوات:** أدوات مدمجة ممتازة للتنسيق (gofmt)، والتدقيق (golint, staticcheck)، والاختبار (go test)، وإدارة التبعيات (go modules).
* **حالات الاستخدام:**
    * برمجة الأنظمة
    * برمجة الشبكات (APIs، خوادم الويب)
    * بنية تحتية سحابية (Docker, Kubernetes)
    * أدوات سطر الأوامر
    * الأنظمة الموزعة
    * معالجة البيانات الضخمة

**II. إعداد بيئة Go الخاصة بك**

* **التثبيت:**
    * حمل توزيعة Go المناسبة لنظام التشغيل الخاص بك من الموقع الرسمي ([https://go.dev/dl/](https://go.dev/dl/)).
    * اتبع تعليمات التثبيت لمنصتك.
* **التحقق من التثبيت:**
    * افتح الطرفية أو موجه الأوامر وقم بتشغيل `go version`. يجب أن يعرض هذا إصدار Go المثبت.
* **مساحة العمل و `GOPATH` (قديم):**
    * تاريخياً، تم تنظيم مشاريع Go ضمن متغير بيئة `GOPATH`. بينما لا يزال مدعوماً، فقد تم استبداله إلى حد كبير بـ Go Modules.
* **Go Modules (مُوصى به):**
    * Go Modules هو حل إدارة التبعيات الرسمي.
    * لبدء مشروع جديد باستخدام modules، انتقل إلى دليل مشروعك في الطرفية وقم بتشغيل `go mod init <your_module_path>` (مثال: `go mod init github.com/yourusername/myproject`).
    * يتم الإعلان عن التبعيات في ملف `go.mod`.

**III. بناء جملة Go الأساسي والمفاهيم**

* **!Hello, World**
    ```go
    package main

    import "fmt"

    func main() {
        fmt.Println("Hello, World!")
    }
    ```
    * `package main`: يعلن الحزمة كنقطة بداية لبرنامج تنفيذي.
    * `import "fmt"`: يستورد حزمة "fmt"، التي توفر دوال الإدخال/الإخراج المُنسقة.
    * `func main()`: الدالة الرئيسية حيث يبدأ تنفيذ البرنامج.
    * `fmt.Println()`: يطبع سطراً من النص إلى وحدة التحكم.
* **الحزم والاستيراد:**
    * يتم تنظيم كود Go في حزم.
    * تساعد الحزم في تنظيم الكود، إعادة الاستخدام، وتجنب تعارضات التسمية.
    * استخدم الكلمة الرئيسية `import` لجلب الوظائف من حزم أخرى (مكتبة قياسية أو طرف ثالث).
    * يمكن أن تكون مسارات الاستيراد لحزم مفردة (مثال: `"fmt"`) أو متداخلة (مثال: `"net/http"`).
    * إعطاء أسماء مستعارة للاستيراد: `import f "fmt"` (الآن يمكنك استخدام `f.Println`).
    * معرف فارغ (`_`) للتأثيرات الجانبية: `import _ "net/http/pprof"` (تهيئة معالجات pprof دون استخدام مباشر).
* **المتغيرات:**
    * التصريح:
        * `var name type` (مثال: `var age int`)
        * `var name = value` (استدلال النوع، مثال: `var name = "Alice"`)
        * `name := value` (تصريح متغير قصير، فقط داخل الدوال، مثال: `count := 0`)
    * تصريح متعدد:
        ```go
        var (
            firstName string = "John"
            lastName  string = "Doe"
            age       int    = 30
        )
        ```
    * الثوابت:
        * `const PI float64 = 3.14159`
        * يجب تصريح الثوابت في وقت الترجمة.
        * يمكن للثوابت غير المحددة النوع أن تأخذ أنواعاً مختلفة بناءً على استخدامها.
* **أنواع البيانات:**
    * **الأنواع الأساسية:**
        * **الأعداد الصحيحة:** `int`, `int8`, `int16`, `int32` (`rune` - اسم مستعار لـ `int32`), `int64`, `uint`, `uint8` (`byte` - اسم مستعار لـ `uint8`), `uint16`, `uint32`, `uint64`, `uintptr` (عدد صحيح بدون إشارة كبير بما يكفي لحمل مؤشر).
        * **الأعداد العشرية:** `float32`, `float64`.
        * **الأعداد المركبة:** `complex64`, `complex128`.
        * **القيم المنطقية:** `bool` (`true`, `false`).
        * **السلاسل النصية:** `string` (تسلسل ثابت للبايتات، مشفر عادةً بـ UTF-8).
    * **الأنواع المركبة:**
        * **المصفوفات:** تسلسل بحجم ثابت لعناصر من نفس النوع (مثال: `[5]int`).
        * **الشرائح:** عرض بحجم ديناميكي ومرن لعناصر مصفوفة (الأكثر استخداماً).
        * **الخرائط:** مجموعة غير مرتبة من أزواج المفتاح-القيمة (جداول التجزئة).
        * **الهياكل:** أنواع بيانات مركبة تجمع معاً صفر أو أكثر من الحقول المسماة ذات أنواع مختلفة.
        * **المؤشرات:** تحمل عنوان الذاكرة لقيمة.
        * **الدوال:** مواطن من الدرجة الأولى، يمكن تعيينها لمتغيرات وتمريرها كمعاملات.
        * **الواجهات:** تحدد مجموعة من الدوال التي يجب على نوع أن ينفذها.
        * **القنوات:** توفر طريقة لـ goroutines للتواصل والمزامنة.
* **العوامل:**
    * **الحسابية:** `+`, `-`, `*`, `/`, `%`, `++`, `--`.
    * **المقارنة:** `==`, `!=`, `>`, `<`, `>=`, `<=`.
    * **المنطقية:** `&&` (AND), `||` (OR), `!` (NOT).
    * **البتية:** `&` (AND), `|` (OR), `^` (XOR), `&^` (AND NOT), `<<` (إزاحة لليسار), `>>` (إزاحة لليمين).
    * **التعيين:** `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`.
* **تحكم في التدفق:**
    * **`if`, `else if`, `else`:** تنفيذ شرطي.
        ```go
        if age >= 18 {
            fmt.Println("Adult")
        } else if age >= 13 {
            fmt.Println("Teenager")
        } else {
            fmt.Println("Child")
        }
        ```
    * **حلقة `for`:** بناء الحلقة الوحيد في Go.
        * حلقة `for` أساسية:
            ```go
            for i := 0; i < 5; i++ {
                fmt.Println(i)
            }
            ```
        * حلقة شبيهة بـ `while`:
            ```go
            j := 0
            for j < 5 {
                fmt.Println(j)
                j++
            }
            ```
        * حلقة لا نهائية:
            ```go
            for {
                // افعل شيئاً
            }
            ```
        * التكرار عبر المجموعات (`range`):
            ```go
            numbers := []int{1, 2, 3}
            for index, value := range numbers {
                fmt.Printf("Index: %d, Value: %d\n", index, value)
            }

            m := map[string]string{"a": "apple", "b": "banana"}
            for key, val := range m {
                fmt.Printf("Key: %s, Value: %s\n", key, val)
            }
            ```
    * **عبارة `switch`:** تنفيذ شرطي متعدد المسارات.
        ```go
        grade := "B"
        switch grade {
        case "A":
            fmt.Println("Excellent!")
        case "B":
            fmt.Println("Good")
        case "C":
            fmt.Println("Average")
        default:
            fmt.Println("Needs improvement")
        }
        ```
        * لا يوجد انتقال تلقائي (استخدم الكلمة الرئيسية `fallthrough` إذا لزم الأمر).
        * يمكن أن تحتوي الحالات على قيم متعددة.
        * Switch بدون شرط (مثل `if-else if-else`).
    * **عبارة `defer`:** تخطط لاستدعاء دالة ليتم تنفيذها في نهاية الدالة المحيطة (غالباً ما تستخدم لمهام التنظيف مثل إغلاق الملفات).
        ```go
        func example() {
            f, err := os.Open("file.txt")
            if err != nil {
                fmt.Println(err)
                return
            }
            defer f.Close() // سيتم استدعاء f.Close() عندما تعود example()

            // ... معالجة الملف ...
        }
        ```
    * **عبارة `goto`:** تنقل التحكم إلى عبارة موسومة (استخدمها بحذر، يمكن أن تؤدي إلى كود متشابك).
    * **`break` و `continue`:** التحكم في تنفيذ الحلقة.

**IV. أنواع البيانات المركبة بالتفصيل**

* **المصفوفات:**
    * حجم ثابت، عناصر من نفس النوع.
    * أقل استخداماً من الشرائح.
    * مثال: `var a [3]int; a[0] = 1; a[1] = 2; a[2] = 3` أو `b := [2]string{"hello", "world"}`.
* **الشرائح:**
    * حجم ديناميكي، مدعومة بمصفوفة أساسية.
    * يتم إنشاؤها باستخدام حرفيات الشريحة (مثال: `[]int{1, 2, 3}`)، دالة `make()` (`make([]int, length, capacity)`)، أو بتقطيع مصفوفة أو شريحة موجودة (`mySlice[start:end]`).
    * `len()`: تُرجع عدد العناصر في الشريحة.
    * `cap()`: تُرجع سعة المصفوفة الأساسية.
    * `append()`: يضيف عناصر إلى نهاية الشريحة (قد يعيد تخصيص المصفوفة الأساسية إذا تم الوصول إلى السعة).
    * `copy()`: ينسخ عناصر من شريحة إلى أخرى.
* **الخرائط:**
    * مجموعة غير مرتبة من أزواج المفتاح-القيمة.
    * يجب أن تكون المفاتيح من نوع قابل للمقارنة (مثال: أعداد صحيحة، سلاسل نصية، قيم منطقية، هياكل تحتوي فقط على حقول قابلة للمقارنة).
    * يمكن للقيم أن تكون من أي نوع.
    * يتم إنشاؤها باستخدام حرفيات الخريطة (مثال: `map[string]int{"apple": 1, "banana": 2}`) أو دالة `make()` (`make(map[string]string)`).
    * الوصول إلى القيم: `value := myMap["key"]` (تُرجع القيمة وقيمة منطقية تشير إلى وجود المفتاح).
    * التحقق من وجود المفتاح: `value, ok := myMap["key"]` (`ok` تكون `true` إذا كان المفتاح موجوداً).
    * إضافة/تحديث المدخلات: `myMap["newKey"] = "newValue"`.
    * حذف المدخلات: `delete(myMap, "keyToDelete")`.
* **الهياكل:**
    * أنواع معرفة من قبل المستخدم تجمع معاً حقول مسماة من أنواع مختلفة.
    * تُستخدم لتمثيل كيانات ذات سمات متعددة.
    * التصريح:
        ```go
        type Person struct {
            FirstName string
            LastName  string
            Age       int
        }
        ```
    * إنشاء مثيلات:
        ```go
        var p1 Person
        p1.FirstName = "Alice"
        p1.LastName = "Smith"
        p1.Age = 25

        p2 := Person{FirstName: "Bob", LastName: "Johnson", Age: 30}

        p3 := Person{"Charlie", "Brown", 20} // الترتيب مهم إذا تم حذف أسماء الحقول
        ```
    * الوصول إلى الحقول: `p1.FirstName`.
    * هياكل مضمنة (تكوين).
    * حقول مجهولة.
* **المؤشرات:**
    * تحمل عنوان الذاكرة لقيمة.
    * يتم التصريح عنها باستخدام عامل `*` (مثال: `var ptr *int`).
    * احصل على عنوان متغير باستخدام عامل `&` (مثال: `ptr = &age`).
    * إلغاء الإشارة إلى مؤشر للوصول إلى القيمة التي يشير إليها باستخدام عامل `*` (مثال: `value := *ptr`).
    * Go ليس لديها حسابيات مؤشر صريحة.
    * المؤشرات مفيدة لتمرير البيانات بالإشارة، وتعديل القيم مباشرة، والعمل مع هياكل بيانات معينة.

**V. الدوال**

* **تصريح الدالة:**
    ```go
    func functionName(parameterName1 type1, parameterName2 type2) returnType {
        // جسم الدالة
        return returnValue
    }
    ```
    * يمكن التصريح عن معاملات متعددة من نفس النوع معاً: `func sum(a, b int) int`.
    * دوال متغيرة (تقبل عدداً متغيراً من الوسائط): `func sum(numbers ...int) int`.
    * قيم إرجاع متعددة:
        ```go
        func divide(a, b float64) (float64, error) {
            if b == 0 {
                return 0, fmt.Errorf("division by zero")
            }
            return a / b, nil
        }

        result, err := divide(10, 2)
        if err != nil {
            fmt.Println("Error:", err)
        } else {
            fmt.Println("Result:", result)
        }
        ```
    * قيم إرجاع مسماة.
* **الدوال من الدرجة الأولى:**
    * يمكن تعيين الدوال لمتغيرات، وتمريرها كوسائط لدوال أخرى، وإرجاعها من الدوال.
    * مثال:
        ```go
        func add(a, b int) int { return a + b }

        func operate(f func(int, int) int, x, y int) int {
            return f(x, y)
        }

        result := operate(add, 5, 3) // ستكون النتيجة 8
        ```
* **الدوال المجهولة (الإغلاقات):**
    * دوال بدون اسم، غالباً ما تستخدم كـ callbacks مضمنة.
    * يمكنها التقاط متغيرات من النطاق المحيط بها (إغلاقات).
    * مثال:
        ```go
        func multiplier(factor int) func(int) int {
            return func(x int) int {
                return x * factor
            }
        }

        double := multiplier(2)
        fmt.Println(double(5)) // الناتج: 10
        ```

**VI. الطرق**

* **تصريح الطريقة:**
    * الطريقة هي دالة مرتبطة بنوع مستقبل محدد.
    * بناء الجملة:
        ```go
        func (receiver Type) methodName(parameters) returnType {
            // جسم الطريقة
        }
        ```
    * يمكن أن يكون المستقبل قيمة أو مؤشراً.
    * مستقبلات القيمة تعمل على نسخة من المستقبل.
    * مستقبلات المؤشر تعمل على المستقبل الأصلي ويمكنها تعديل حالته.
* **مثال:**
    ```go
    type Circle struct {
        Radius float64
    }

    func (c Circle) Area() float64 {
        return math.Pi * c.Radius * c.Radius
    }

    func (c *Circle) SetRadius(newRadius float64) {
        c.Radius = newRadius
    }

    func main() {
        myCircle := Circle{Radius: 5}
        fmt.Println("Area:", myCircle.Area()) // يستدعي طريقة Area على مستقبل قيمة

        myCircle.SetRadius(10) // يستدعي طريقة SetRadius على مستقبل مؤشر
        fmt.Println("New Area:", myCircle.Area())
    }
    ```

**VII. الواجهات**

* **تعريف الواجهة:**
    * تحدد الواجهة مجموعة من تواقيع الدوال.
    * ينفذ نوع ما واجهة إذا قدم تطبيقات لجميع الدوال المعرفة في الواجهة.
    * يتم تحقيق الواجهات بشكل ضمني (لا توجد كلمة رئيسية `implements` صريحة).
    * بناء الجملة:
        ```go
        type Writer interface {
            Write(p []byte) (n int, err error)
        }

        type Reader interface {
            Read(p []byte) (n int, err error)
        }

        type ReadWriter interface {
            Reader
            Writer // تضمين واجهات
            Close() error
        }
        ```
* **استخدام الواجهة:**
    * تمكين تعدد الأشكال (معاملة كائنات من أنواع مختلفة بطريقة موحدة).
    * فصل الكود من خلال البرمجة للواجهات بدلاً من الأنواع الملموسة.
    * مثال:
        ```go
        import "io"
        import "os"

        func writeData(w io.Writer, data []byte) error {
            _, err := w.Write(data)
            return err
        }

        func main() {
            file, err := os.Create("output.txt")
            if err != nil {
                fmt.Println("Error creating file:", err)
                return
            }
            defer file.Close()

            data :=[]byte("Hello, Go interfaces!\n")
            err = writeData(file, data)
            if err != nil {
                fmt.Println("Error writing to file:", err)
                return
            }

            // يمكننا أيضاً استخدام os.Stdout الذي ينفذ أيضاً io.Writer
            err = writeData(os.Stdout, []byte("Writing to stdout through the interface.\n"))
            if err != nil {
                fmt.Println("Error writing to stdout:", err)
                return
            }
        }
        ```
* **الواجهة الفارغة (`interface{}`):**
    * الواجهة الفارغة ليس لها دوال.
    * جميع الأنواع تنفذ الواجهة الفارغة.
    * يمكن استخدامها لتمثيل قيم من أي نوع، ولكن غالباً ما تكون التأكيدات على النوع مطلوبة للوصول إلى القيمة الأساسية.
    ```go
    var i interface{}
    i = 42
    fmt.Println(i)
    i = "hello"
    fmt.Println(i)

    value, ok := i.(string) // تأكيد النوع إلى string
    if ok {
        fmt.Println("The value is a string:", value)
    } else {
        fmt.Println("The value is not a string")
    }
    ```
* **تأكيدات النوع ومفاتيح النوع:**
    * **تأكيد النوع:** يُستخدم لاستخراج القيمة الملموسة الأساسية من متغير واجهة.
        * بناء الجملة: `value, ok := interfaceVar.(ConcreteType)`
        * إذا كان التأكيد صحيحاً، فسيحمل `value` القيمة الملموسة، وستكون `ok` هي `true`.
        * إذا كان التأكيد غير صحيح، ولم تتحقق من `ok`، فسيؤدي ذلك إلى ذعر.
    * **مفتاح النوع:** يُستخدم لتنفيذ إجراءات مختلفة بناءً على النوع الملموس الذي يحمله متغير الواجهة.
        ```go
        func describe(i interface{}) {
            switch v := i.(type) {
            case int:
                fmt.Printf("Twice %v is %v\n", v, v*2)
            case string:
                fmt.Printf("%q is %v bytes long\n", v, len(v))
            default:
                fmt.Printf("I don't know about type %T!\n", v)
            }
        }

        func main() {
            describe(42)
            describe("hello")
            describe(true)
        }
        ```

**VIII. Goroutines والتزامن**

يعتمد نموذج التزامن في Go على goroutines و channels.

* **Goroutines:**
    * دوال خفيفة الوزن ومتزامنة.
    * يتم إنشاؤها باستخدام الكلمة الرئيسية `go` متبوعة باستدعاء دالة.
    * تعمل Goroutines بشكل متزامن مع الدوال وـ goroutines الأخرى.
    * أرخص بكثير في الإنشاء والإدارة من خيوط نظام التشغيل التقليدية.
    ```go
    package main

    import (
        "fmt"
        "time"
    )

    func say(s string) {
        for i := 0; i < 5; i++ {
            time.Sleep(100 * time.Millisecond)
            fmt.Println(s)
        }
    }

    func main() {
        go say("world") // ابدأ goroutine جديدة
        say("hello")    // شغل في الـ goroutine الرئيسي

        // انتظر قليلاً لرؤية ناتج الـ goroutine
        time.Sleep(time.Second)
    }
    ```
* **Channels:**
    * قنوات مكتوبة يمكن من خلالها لـ goroutines إرسال واستقبال القيم.
    * توفر طريقة آمنة للكود المتزامن للتواصل والمزامنة.
    * يتم إنشاؤها باستخدام بناء الجملة `make(chan Type)`.
    * الإرسال إلى قناة: `channel <- value`
    * الاستقبال من قناة: `value := <-channel`
    ```go
    package main

    import "fmt"

    func sum(s []int, c chan int) {
        sum := 0
        for _, v := range s {
            sum += v
        }
        c <- sum // أرسل المجموع إلى القناة
    }

    func main() {
        s := []int{7, 2, 8, -9, 4, 0}

        c := make(chan int)
        go sum(s[:len(s)/2], c) // احسب مجموع النصف الأول في goroutine
        go sum(s[len(s)/2:], c) // احسب مجموع النصف الثاني في goroutine
        x, y := <-c, <-c       // استقبل النتائج من القناة

        fmt.Println(x, y, x+y)
    }
    ```
* **القنوات المخزنة:**
    * قنوات ذات سعة لاحتواء عدد معين من القيم بدون أن يكون مستقبل جاهزاً فوراً.
    * يتم إنشاؤها باستخدام `make(chan Type, capacity)`.
    * سوف تمنع عمليات الإرسال إلى قناة مخزنة فقط عندما يكون المخزن ممتلئاً.
    * سوف تمنع عمليات الاستقبال فقط عندما يكون المخزن فارغاً.
* **اتجاه القناة:**
    * يمكنك تحديد اتجاه تدفق البيانات في نوع القناة:
        * `chan<- int`: قناة للإرسال فقط (يمكنها إرسال أعداد صحيحة فقط).
        * `<-chan int`: قناة للاستقبال فقط (يمكنها استقبال أعداد صحيحة فقط).
    * مفيدة لتقييد كيفية استخدام القنوات في الدوال.
    ```go
    func sender(out chan<- string) {
        out <- "Hello from sender"
    }

    func receiver(in <-chan string) {
        msg := <-in
        fmt.Println("Received:", msg)
    }

    func main() {
        ch := make(chan string)
        go sender(ch)
        go receiver(ch)
        time.Sleep(time.Second)
    }
    ```
* **عبارة `select`:**
    * تسمح لـ goroutine بالانتظار على عمليات اتصال متعددة.
    * تمنع حتى تتمكن إحدى حالاتها من المتابعة، ثم تنفذ تلك الحالة.
    * إذا كانت حالات متعددة جاهزة، يتم اختيار واحدة عشوائياً.
    * يمكن أن تحتوي على حالة `default` تُنفذ فوراً إذا لم تكن أي حالة أخرى جاهزة.
    ```go
    package main

    import (
        "fmt"
        "time"
    )

    func main() {
        c1 := make(chan string)
        c2 := make(chan string)

        go func() {
            time.Sleep(1 * time.Second)
            c1 <- "one"
        }()
        go func() {
            time.Sleep(2 * time.Second)
            c2 <- "two"
        }()

        for i := 0; i < 2; i++ {
            select {
            case msg1 := <-c1:
                fmt.Println("received", msg1)
            case msg2 := <-c2:
                fmt.Println("received", msg2)
            }
        }
    }
    ```
* **أدوات المزامنة:**
    * **`sync.WaitGroup`:** ينتظر انتهاء مجموعة من goroutines.
    * **`sync.Mutex`:** يوفر قفل استبعاد متبادل أساسي.
    * **`sync.RWMutex`:** يوفر قفل قارئ/كاتب، يسمح بعدة قراء أو كاتب واحد.
    * **`sync.Once`:** يضمن تنفيذ دالة مرة واحدة فقط.

**IX. معالجة الأخطاء**

تفضل Go معالجة الأخطاء الصريحة باستخدام واجهة `error`.

* **واجهة `error`:**
    * مُعرفة كـ: `type error interface { Error() string }`
    * الدوال التي يمكن أن تفشل تُرجع عادة قيمة من نوع `error` كقيمة إرجاع أخيرة.
    * تشير القيمة `nil` إلى النجاح؛ تشير قيمة `error` غير nil إلى الفشل.
* **إنشاء الأخطاء:**
    * استخدم دالة `errors.New()` من حزمة `errors` لإنشاء قيم خطأ بسيطة.
    * استخدم `fmt.Errorf()` لإنشاء رسائل خطأ مُنسقة.
* **معالجة الأخطاء:**
    * تحقق من قيمة `error` المُرجعة بعد استدعاء دالة يمكن أن تفشل.
    * استخدم `if err != nil` لمعالجة الخطأ.
    * يمكنك تغليف الأخطاء لتوفير المزيد من السياق باستخدام مكتبات مثل `fmt.Errorf()` مع `%w`.
* **أنواع الأخطاء المخصصة:**
    * يمكنك إنشاء أنواع أخطاء خاصة بك عن طريق تعريف هيكل ينفذ واجهة `error` (أي لديه دالة `Error() string`).
    ```go
    package main

    import (
        "errors"
        "fmt"
        "time"
    )

    type TimeoutError struct {
        duration time.Duration
    }

    func (e *TimeoutError) Error() string {
        return fmt.Sprintf("operation timed out after %v", e.duration)
    }

    func performOperation(timeout time.Duration) error {
        time.Sleep(timeout + 1*time.Second) // محاكاة لعملية طويلة
        return &TimeoutError{duration: timeout}
    }

    func main() {
        err := performOperation(2 * time.Second)
        if err != nil {
            fmt.Println("Error:", err)
            if te, ok := err.(*TimeoutError); ok {
                fmt.Printf("It was a timeout error of %v\n", te.duration)
            }
        } else {
            fmt.Println("Operation successful")
        }
    }
    ```
* **`panic` و `recover`:**
    * يُستخدم `panic` للإشارة إلى خطأ في وقت التشغيل لا يمكن للبرنامج التعافي منه. يوقف تنفيذ الدالة الحالية ويفك المكدس، مستدعياً أي دوال مؤجلة على طول الطريق.
    * `recover` هي دالة مدمجة يمكنها استعادة السيطرة على goroutine في حالة ذعر. يجب استدعاؤها داخل دالة مؤجلة. يُرجع `recover` القيمة الممررة إلى `panic`، أو `nil` إذا لم تكن الـ goroutine في حالة ذعر.
    * يجب استخدام `panic` و `recover` باعتدال، بشكل أساسي للأخطاء الحرجة التي لا يمكن التعافي منها. لمعظم الأخطاء المتوقعة، استخدم واجهة `error`.
    ```go
    package main

    import "fmt"

    func mightPanic() {
        panic("something went wrong")
    }

    func recoverFunc() {
        if r := recover(); r != nil {
            fmt.Println("Recovered from panic:", r)
        }
    }

    func main() {
        defer recoverFunc()
        fmt.Println("Before mightPanic")
        mightPanic()
        fmt.Println("After mightPanic (this will not be reached)")
    }
    ```

**X. الحزم والوحدات**

يتم تنظيم كود Go في حزم.

* **الحزم:**
    * مجموعة من ملفات المصدر في نفس الدليل يتم ترجمتها معاً.
    * توفر مساحات أسماء لتجنب تعارضات التسمية.
    * أسماء الحزم هي عادة اسم الدليل.
    * يجب أن يكون للبرامج التنفيذية حزمة `main` مع دالة `main`.
    * يمكن للمكتبات أن يكون لها أي اسم حزمة.
* **الاستيراد:**
    * استخدم الكلمة الرئيسية `import` لجلب الوظائف من حزم أخرى.
    * يتم استيراد حزم المكتبة القياسية باسمها المختصر (مثال: `"fmt"`, `"net/http"`).
    * يتم عادة استيراد حزم الطرف الثالث باستخدام مسار الوحدة الخاصة بها (مثال: `"github.com/gin-gonic/gin"`).
    * **مسارات الاستيراد:**
        * استيراد نسبي (غير موصى به وله قواعد محددة داخل الوحدة).
        * استيراد مطلق (موصى به)، يبدأ بمسار الوحدة.
    * **أسماء مستعارة للاستيراد:** يمكنك إعطاء حزمة اسمًا مختلفًا محليًا باستخدام اسم مستعار: `import f "fmt"`.
    * **المعرف الفارغ (`_`):** يُستخدم لاستيراد حزمة فقط لتأثيراتها الجانبية (مثال: تهيئة الحالة الداخلية): `import _ "net/http/pprof"`.
* **الوحدات (Go 1.11 وما بعده):**
    * الطريقة الأساسية لإدارة التبعيات في Go.
    * يتم تعريفها بواسطة ملف `go.mod` في جذر مشروعك.
    * يتتبع ملف `go.mod` مسار الوحدة وتبعيات مشروعك.
    * **`go mod init <module_path>`:** يهيئ وحدة جديدة.
    * **`go get <package>@<version>`:** يضيف أو يحدث تبعية.
    * **`go build`, `go run`, `go test`:** تدير تبعيات الوحدة تلقائياً.
    * **`go.sum`:** يحتوي على تجزئات تشفيرية للتبعيات لضمان السلامة.
* **الرؤية:**
    * المعرفات (المتغيرات، الدوال، الأنواع، إلخ.) التي تبدأ بحرف كبير يتم تصديرها (عامة) ويمكن الوصول إليها من حزم أخرى.
    * المعرفات التي تبدأ بحرف صغير غير مُصدَّرة (خاصة) ويمكن الوصول إليها فقط داخل نفس الحزمة.

**XI. الاختبار**

لدى Go دعم مدمج للاختبار.

* **ملفات الاختبار:**
    * تُسمى ملفات الاختبار باللاحقة `_test.go` (مثال: `myfunction_test.go`).
    * تقع في نفس الحزمة مثل الكود الذي يتم اختباره.
* **دوال الاختبار:**
    * دوال الاختبار لها أسماء تبدأ بـ `Test` وتأخذ معاملاً واحداً من نوع `*testing.T`.
    * استخدم دوال على `*testing.T` (مثال: `t.Log`, `t.Error`, `t.Errorf`, `t.Fatal`, `t.Fatalf`) للإبلاغ عن نتائج الاختبار.
* **مثال اختبار:**
    ```go
    // myfunction.go
    package mypackage

    func Add(a, b int) int {
        return a + b
    }

    // myfunction_test.go
    package mypackage_test

    import "testing"

    func TestAdd(t *testing.T) {
        result := Add(2, 3)
        expected := 5
        if result != expected {
            t.Errorf("Add(2, 3) returned %d, expected %d", result, expected)
        }
    }
    ```
* **تشغيل الاختبارات:**
    * استخدم أمر `go test` في الدليل الذي يحتوي على حزمتك.
    * `go test -v`: ناتج مفصل، يظهر اسم كل اختبار.
    * `go test ./...`: شغل الاختبارات في الدليل الحالي وجميع الأدلة الفرعية.
    * `go test -run <pattern>`: شغل فقط الاختبارات التي تطابق أسماؤها نمط التعبير النمطي المحدد.
* **اختبارات المعايير:**
    * تقيس أداء الكود الخاص بك.
    * دوال المعايير لها أسماء تبدأ بـ `Benchmark` وتأخذ معاملًا واحد