---
audio: false
generated: true
lang: ar
layout: post
title: واجهة تسمية ودليل جافا
translated: true
type: note
---

### النقاط الرئيسية
- يبدو من المحتمل أن `javax.naming` تُستخدم لواجهة تسمية ودليل جافا (JNDI) للبحث عن الكائنات المسماة وإدارتها في خدمات مثل قواعد البيانات.
- تشير الأبحاث إلى أنك تحتاج إلى سياق أولي للبدء، يتم إعداده عادةً بواسطة خادم تطبيقات Java EE للإنتاج، أو يدويًا لأغراض الاختبار.
- تميل الأدلة نحو استخدام `InitialContext` لإجراء عمليات البحث، مثل العثور على DataSource بأسماء مثل "java:comp/env/jdbc/datasource".

### البدء مع `javax.naming`
`javax.naming` هي جزء من JNDI، والتي تساعد تطبيقات جافا على التفاعل مع خدمات التسمية والدليل، مثل البحث عن اتصالات قواعد البيانات. في بيئة Java EE، يقوم خادم التطبيقات عادةً بإعداد هذا، مما يسهل العثور على الموارد بأسمائها.

### مثال للاستخدام
إليك طريقة بسيطة للبحث عن DataSource في تطبيق Java EE:
```java
InitialContext ctx = new InitialContext();
DataSource ds = (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
```
يفترض هذا أن DataSource تم تكوينها مسبقًا في الخادم الخاص بك. للاختبار بدون خادم، قد تحتاج إلى مكتبات إضافية مثل Simple-JNDI.

### تفصيل غير متوقع
قد لا تتوقع أنه بالنسبة للتطبيقات المستقلة، فإن إعداد JNDI يمكن أن يتطلب تكوين سياق مخصص، وهو ما يمكن أن يكون معقدًا بدون أدوات مثل Simple-JNDI.

---

### ملاحظة المسح: دليل شامل لاستخدام `javax.naming`

توفر هذه الملاحظة استكشافًا مفصلاً لاستخدام `javax.naming`، وهي جزء من واجهة تسمية ودليل جافا (JNDI)، والتي تسهل التفاعل مع خدمات التسمية والدليل في تطبيقات جافا. تم تصميم JNDI ليكون مستقلاً عن تنفيذات الخدمات المحددة، مما يسمح بالوصول إلى خدمات متنوعة مثل قواعد البيانات و LDAP وأنظمة الملفات بطريقة موحدة. يوسع هذا القسم الإجابة المباشرة، ويقدم فهمًا شاملاً للمطورين، بما في ذلك الإعداد والأمثلة والاعتبارات للبيئات المختلفة.

#### فهم `javax.naming` و JNDI
`javax.naming` هي الحزمة الأساسية لـ JNDI، تم تقديمها كجزء من المكتبة القياسية لجافا لتوفير وظائف التسمية والدليل. تحدد واجهة `Context`، وهي مركزية في عمليات JNDI، والتي تتضمن طرقًا للبحث عن الكائنات وربطها وفك ربطها وإعادة تسميتها، وكذلك إنشاء وتدمير السياقات الفرعية. تُستخدم طريقة `lookup()` بشكل شائع لاسترداد الكائنات بأسمائها، مما يجعلها ضرورية للوصول إلى الموارد في التطبيقات المؤسسية.

تعتبر JNDI مفيدة بشكل خاص في بيئات Java EE، حيث تسمح للتطبيقات بالفصل بين تفاصيل الخدمة المحددة، مما يعزل إمكانية النقل والمرونة. على سبيل المثال، تُستخدم غالبًا للوصول إلى موارد مثل اتصالات قواعد البيانات (DataSources) وموفري JMS وخدمات JavaMail، والتي تديرها خادم التطبيقات.

#### إعداد واستخدام JNDI
لاستخدام `javax.naming`، تبدأ بإنشاء سياق أولي، والذي يعمل كنقطة دخول لعمليات التسمية. يتم ذلك عادةً باستخدام فئة `InitialContext`. يختلف الإعداد بناءً على البيئة:

- **في تطبيقات Java EE:** يقوم خادم التطبيقات (مثل Tomcat أو JBoss أو WebSphere) بتكوين السياق الأولي. يمكنك البحث عن الموارد باستخدام أسماء JNDI القياسية، التي غالبًا ما تبدأ ببادئة "java:comp/env/". على سبيل المثال، يمكن الوصول إلى DataSource في "java:comp/env/jdbc/datasource".
- **في التطبيقات المستقلة:** بدون خادم تطبيقات، تحتاج إلى تكوين السياق الأولي يدويًا، مع تحديد خصائص مثل موفر خدمة التسمية وعنوان URL. يمكن أن يكون هذا معقدًا، ويتطلب مكتبات إضافية للاختبار، مثل Simple-JNDI، والتي توفر تنفيذًا في الذاكرة.

إليك جدولاً يلخص الفئات الرئيسية وأدوارها في `javax.naming`:

| الفئة/الواجهة        | الدور                                                                 |
|-------------------------|----------------------------------------------------------------------|
| `Context`              | الواجهة الأساسية لعمليات التسمية مثل البحث والربط وفك الربط.   |
| `InitialContext`       | ينشئ السياق الأولي لبدء عمليات JNDI.             |
| `Name`                 | يمثل اسمًا عامًا، تسلسلاً مرتبًا للمكونات.         |
| `NamingException`      | الفئة الأساسية للاستثناءات التي يتم طرحها أثناء عمليات التسمية.            |

#### أمثلة عملية
لنستكشف أمثلة لكل من سيناريوهات Java EE والتطبيقات المستقلة:

##### المثال 1: البحث عن DataSource في Java EE
في تطبيق Java EE، قد تبحث عن DataSource تم تكوينه على النحو التالي:

```java
import javax.naming.InitialContext;
import javax.sql.DataSource;
import java.sql.*;

public class JNDIExample {
    public static void main(String[] args) throws Exception {
        InitialContext ctx = new InitialContext();
        DataSource ds = (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
        Connection conn = ds.getConnection();
        // استخدام الاتصال...
        conn.close();
        ctx.close();
    }
}
```

يفترض هذا المثال أن DataSource تم تكوينه في خادم التطبيقات، عادةً في ملفات مثل `context.xml` لـ Tomcat. اسم JNDI "java:comp/env/jdbc/datasource" هو اصطلاح قياسي، ولكن يمكن أن يختلف بناءً على تكوين الخادم.

##### المثال 2: ربط والبحث عن كائن مخصص
لأغراض الاختبار أو الاستخدام المستقل، قد ترغب في إنشاء سياق بسيط في الذاكرة. بينما لا تتضمن واجهة برمجة التطبيقات القياسية مصنع سياق في الذاكرة، يمكن للمكتبات مثل Simple-JNDI المساعدة. إليك مثالًا مفاهيميًا يفترض مثل هذا الإعداد:

```java
import javax.naming.*;

public class JNDIExample {
    public static void main(String[] args) throws NamingException {
        Context ctx = new InitialContext();
        ctx.rebind("myObject", "Hello, World!");
        String value = (String) ctx.lookup("myObject");
        System.out.println(value);
        ctx.close();
    }
}
```

ملاحظة: يتطلب هذا المثال المستقل تكوين السياق الأولي بخصائص مناسبة، مما قد يتضمن تعيين `java.naming.factory.initial` إلى مصنع سياق مخصص، مثل ذلك المقدم من Simple-JNDI.

#### اعتبارات للبيئات المختلفة
- **الإنتاج (Java EE):** في بيئة الإنتاج، يتعامل خادم التطبيقات مع إعداد JNDI، مما يجعل البحث عن الموارد مباشرًا. من الشائع استخدام JNDI لـ pools اتصالات قواعد البيانات، حيث يدير الخادم الاتصالات، مما يحسن قابلية التوسع والأمان. على سبيل المثال، يتطلب تغيير بيانات اعتماد قاعدة البيانات تحديث تكوين الخادم فقط، وليس كود التطبيق.
- **الاختبار (التطبيقات المستقلة):** لاختبارات الوحدة والتكامل، غالبًا ما يكون التشغيل بدون خادم تطبيقات ضروريًا. تسمح مكتبات مثل Simple-JNDI ([Simple-JNDI GitHub](https://github.com/h-thurow/Simple-JNDI)) بمحاكاة بيئات JNDI، وربط الموارد برمجيًا. هذا أمر بالغ الأهمية لاختبار الكود الذي يعتمد على عمليات بحث JNDI، مما يضمن عمله بدون النشر على خادم.
- **الأمان وأفضل الممارسات:** كن حذرًا مع حقن JNDI، خاصة في إصدارات جافا القديمة، حيث يمكن أن تؤدي إلى ثغرات أمنية مثل تنفيذ الكود عن بُعد. قامت Oracle بمعالجة العديد من هذه المشكلات، مع تحديثات مثل Java 8u191 التي أغلقت ثغرات استغلال LDAP. تحقق دائمًا من المدخلات واستخدم أحدث إصدارات جافا للأمان.

#### تفصيل غير متوقع: التعقيد في الإعداد المستقل
قد لا يتوقع المرء التعقيد المتضمن في إعداد JNDI بدون خادم تطبيقات. بينما يبسط Java EE هذا مع السياقات المدارة من قبل الخادم، تتطلب الإعدادات المستقلة تكوين مصانع السياق والخصائص، مما يستدعي غالبًا مكتبات خارجية. يمكن أن يكون هذا عائقًا للمطورين الجدد في JNDI، ولكن تقلل الأدوات مثل Simple-JNDI من هذا من خلال توفير تنفيذات قائمة على الذاكرة.

#### قراءات وموارد إضافية
لفهم أعمق، راجع ما يلي:
- [Oracle Java Tutorials: JNDI Overview](https://docs.oracle.com/en/ java/ tutorial/jndi/ overview/index.html) للوثائق الرسمية.
- [Baeldung: Java Naming and Directory Interface Overview](https://www.baeldung.com/jndi) للأمثلة العملية والاستخدام الحديث.
- [Simple-JNDI GitHub](https://github.com/h-thurow/Simple-JNDI) لاختبار JNDI بدون خوادم.

توفر هذه الموارد أمثلة على الكود، ودروسًا، وأفضل الممارسات، مما يضمن أنه يمكنك تنفيذ JNDI بشكل فعال في سيناريوهات مختلفة.

#### الاقتباسات الرئيسية
- [Oracle Java Tutorials JNDI Overview](https://docs.oracle.com/en/ java/ tutorial/jndi/ overview/index.html)
- [Baeldung Java Naming and Directory Interface Overview](https://www.baeldung.com/jndi)
- [Simple-JNDI Access property files via JNDI lookups](https://github.com/h-thurow/Simple-JNDI)