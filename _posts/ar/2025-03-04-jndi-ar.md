---
audio: false
generated: true
lang: ar
layout: post
title: Java Naming and Directory Interface (JNDI)
translated: true
---

### النقاط الرئيسية
- يبدو أن `javax.naming` يستخدم لواجهة Java Naming and Directory (JNDI) للبحث عن وإدارة الكائنات المسماة في الخدمات مثل قواعد البيانات.
- تشير الأبحاث إلى أن عليك بداية سياق أولي، عادة ما يتم إعداده بواسطة خادم تطبيق Java EE للإنتاج، أو يدويًا للتجربة.
- تشير الأدلة إلى استخدام `InitialContext` للبحث، مثل العثور على مصدر البيانات باسم مثل "java:comp/env/jdbc/datasource".

### البدء مع `javax.naming`
`javax.naming` جزء من JNDI، والذي يساعد تطبيقات Java على التفاعل مع خدمات التسمية والمجلدات، مثل البحث عن اتصالات قاعدة البيانات. في بيئة Java EE، عادة ما يقوم الخادم بالتنظيم، مما يجعل من السهل العثور على الموارد باسمها.

### مثال الاستخدام
هنا طريقة بسيطة للبحث عن مصدر البيانات في تطبيق Java EE:
```java
InitialContext ctx = new InitialContext();
DataSource ds = (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
```
يفترض هذا أن مصدر البيانات قد تم تهيئته في خادمك. للتجربة بدون خادم، قد تحتاج إلى مكتبات إضافية مثل Simple-JNDI.

### تفاصيل غير متوقعة
قد لا تتوقع أن إعداد JNDI في تطبيقات مستقلة يتطلب إعداد سياق مخصص، وهو معقد بدون أدوات مثل Simple-JNDI.

---

### ملاحظة الاستطلاع: دليل شامل لاستخدام `javax.naming`

تقدم هذه الملاحظة استكشافًا مفصلًا لاستخدام `javax.naming`، وهو جزء من Java Naming and Directory Interface (JNDI)، والذي يسهل التفاعل مع خدمات التسمية والمجلدات في تطبيقات Java. تم تصميم JNDI ليكون مستقلًا عن تنفيذ الخدمات المحددة، مما يسمح بالوصول إلى خدمات متنوعة مثل قواعد البيانات، LDAP، ومجلدات الملفات بطريقة موحدة. يوسع هذا القسم على الإجابة المباشرة، يقدم فهمًا شاملًا للمطورين، بما في ذلك الإعداد، والأمثلة، والتعليقات للبيئات المختلفة.

#### فهم `javax.naming` و JNDI
`javax.naming` هو الحزمة الأساسية لـ JNDI، تم تقديمها كجزء من مكتبة Java القياسية لتوفير وظائف التسمية والمجلدات. يحدد `Context` الواجهة، التي هي مركزية للعمليات JNDI، والتي تشمل طرقًا للبحث، والربط، والفك، وإعادة تسمية الكائنات، بالإضافة إلى إنشاء وإلغاء المجلدات الفرعية. يتم استخدام طريقة `lookup()` بشكل شائع لاسترجاع الكائنات باسمها، مما يجعلها أساسية للوصول إلى الموارد في تطبيقات الشركات.

JNDI مفيد بشكل خاص في بيئات Java EE، حيث يسمح التطبيقات بالتفكك عن تفاصيل الخدمة المحددة، مما يزيد من قابلية النقل والتكيف. على سبيل المثال، يتم استخدامه غالبًا للوصول إلى الموارد مثل اتصالات قاعدة البيانات (DataSources)، وموفر JMS، وخدمة JavaMail، التي يتم إدارتها بواسطة خادم التطبيق.

#### إعداد واستخدام JNDI
لاستخدام `javax.naming`، تبدأ بإنشاء سياق أولي، الذي يعمل كنقطة الدخول للعمليات التسمية. يتم ذلك عادةً باستخدام فئة `InitialContext`. تختلف الإعدادات بناءً على البيئة:

- **في تطبيقات Java EE:** يقوم الخادم (مثل Tomcat، JBoss، WebSphere) بإعداد السياق الأولي. يمكنك البحث عن الموارد باستخدام أسماء JNDI القياسية، غالبًا ما يتم إضافة "java:comp/env/" إليها. على سبيل المثال، يمكن الوصول إلى مصدر البيانات في "java:comp/env/jdbc/datasource".
- **في التطبيقات المستقلة:** بدون خادم تطبيق، عليك إعداد السياق الأولي يدويًا، تحديد خصائص مثل مزود خدمة التسمية وURL. يمكن أن يكون ذلك معقدًا، يتطلب مكتبات إضافية للتجربة، مثل Simple-JNDI، التي توفر تنفيذًا في الذاكرة.

هنا جدول يوضح الفئات الرئيسية وأدوارها في `javax.naming`:

| فئة/واجهة        | الدور                                                                 |
|-------------------------|----------------------------------------------------------------------|
| `Context`              | الواجهة الأساسية للعمليات التسمية مثل البحث، والربط، والفك.   |
| `InitialContext`       | يخلق السياق الأولي لبدء العمليات JNDI.             |
| `Name`                 | يمثل اسمًا عامًا، تسلسل مرتب من المكونات.         |
| `NamingException`      | فئة أساسية للاستثناءات التي يتم رميها أثناء العمليات التسمية.            |

#### أمثلة عملية
دعونا نستكشف أمثلة لكل من بيئات Java EE والمستقلة:

##### مثال 1: البحث عن مصدر البيانات في Java EE
في تطبيق Java EE، يمكنك البحث عن مصدر البيانات المهيأ كما يلي:

```java
import javax.naming.InitialContext;
import javax.sql.DataSource;
import java.sql.*;

public class JNDIExample {
    public static void main(String[] args) throws Exception {
        InitialContext ctx = new InitialContext();
        DataSource ds = (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
        Connection conn = ds.getConnection();
        // استخدم الاتصال...
        conn.close();
        ctx.close();
    }
}
```

يفترض هذا المثال أن مصدر البيانات مهيأ في خادم التطبيق، عادةً في ملفات مثل `context.xml` لTomcat. اسم JNDI "java:comp/env/jdbc/datasource" هو اتفاقية قياسية، ولكن يمكن أن يختلف بناءً على تهيئة الخادم.

##### مثال 2: ربط و البحث عن كائن مخصص
للاختبار أو الاستخدام المستقل، قد تريد إنشاء سياق في الذاكرة بسيط. بينما لا تتضمن الواجهة القياسية مصنع سياق في الذاكرة، يمكن أن تساعدك المكتبات مثل Simple-JNDI. هنا مثال مفهوم يفترض مثل هذا الإعداد:

```java
import javax.naming.*;

public class JNDIExample {
    public static void main(String[] args) throws NamingException {
        Context ctx = new InitialContext();
        ctx.rebind("myObject", "Hello, World!");
        String value = (String) ctx.lookup("myObject");
        System.out.println(value);
        ctx.close();
    }
}
```

ملاحظة: يتطلب هذا المثال المستقل تكوين السياق الأولي مع الخصائص المناسبة، والتي قد تتضمن تعيين `java.naming.factory.initial` إلى مصنع سياق مخصص، مثل واحد يوفره Simple-JNDI.

#### تعليقات للبيئات المختلفة
- **الإنتاج (Java EE):** في الإنتاج، يقوم الخادم بإعداد JNDI، مما يجعل البحث عن الموارد سهلًا. من الشائع استخدام JNDI لمجموعات اتصالات قاعدة البيانات، حيث يدارة الخادم اتصالات، مما يزيد من قابلية التوسع والأمان. على سبيل المثال، تغيير بيانات اعتماد قاعدة البيانات يتطلب تحديث فقط تهيئة الخادم، لا الكود التطبيقي.
- **التجربة (مستقلة):** للتجربة الوحدوية والتكاملية، غالبًا ما يكون تشغيل التطبيق بدون خادم ضروريًا. تسمح المكتبات مثل Simple-JNDI ([Simple-JNDI GitHub](https://github.com/h-thurow/Simple-JNDI)) بتمثيل بيئات JNDI، ربط الموارد برمجيًا. هذا ضروري للتجربة الكود الذي يعتمد على عمليات البحث JNDI، مما يضمن أن يعمل دون نشر إلى خادم.
- **الأمان والتوصيات:** كن حذرًا من حقن JNDI، خاصة في إصدارات Java القديمة، حيث يمكن أن تؤدي إلى ضعف الأمان مثل تنفيذ الكود عن بُعد. قدم Oracle حلولًا لمثل هذه المشاكل، مع تحديثات مثل Java 8u191 التي أغلقت استغلالات لجهات LDAP. دائمًا التحقق من المدخلات واستخدام أحدث إصدارات Java لأمان.

#### تفاصيل غير متوقعة: تعقيد في إعداد المستقل
قد لا تتوقع التعقيد الذي يتضمنه إعداد JNDI بدون خادم تطبيق. بينما ييسر Java EE هذا مع السياقات التي يديرها الخادم، تتطلب الإعدادات المستقلة تكوين مصانع السياق والخصائص، غالبًا ما تتطلب مكتبات ثالثة. يمكن أن يكون هذا عائقًا للمطورين الجدد في JNDI، ولكن أدوات مثل Simple-JNDI تخفف من ذلك بتقديم تنفيذات في الذاكرة.

#### قراءة إضافية والموارد
للاستكشاف العميق، استعرض التالي:
- [Oracle Java Tutorials: JNDI Overview](https://docs.oracle.com/en/java/tutorial/jndi/overview/index.html) للمستندات الرسمية.
- [Baeldung: Java Naming and Directory Interface Overview](https://www.baeldung.com/jndi) للأمثلة العملية واستخدامات العصر الحديث.
- [Simple-JNDI GitHub](https://github.com/h-thurow/Simple-JNDI) للتجربة JNDI بدون خادم.

تقدم هذه الموارد أمثلة الكود، ودروس، والتوصيات، مما يضمن أن يمكنك تنفيذ JNDI بشكل فعال في مختلف السيناريوهات.

#### الإشارات الرئيسية
- [Oracle Java Tutorials JNDI Overview](https://docs.oracle.com/en/java/tutorial/jndi/overview/index.html)
- [Baeldung Java Naming and Directory Interface Overview](https://www.baeldung.com/jndi)
- [Simple-JNDI Access property files via JNDI lookups](https://github.com/h-thurow/Simple-JNDI)