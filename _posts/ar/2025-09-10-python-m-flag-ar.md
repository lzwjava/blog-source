---
audio: false
date: 2025-09-10
generated: true
image: false
lang: ar
layout: post
model: openai/gpt-5
title: استخدام علامة -m في بايثون للمُعرِّفات
translated: true
type: note
---

نعم، `-m` تعني **تشغيل وحدة كسكريبت**. دعنا نشرح هذا بمزيد من التفصيل باستخدام أمثلتك:

### `python -m unittest`

هذا يأمر Python بما يلي:

* ابحث عن وحدة `unittest` (وهي جزء من المكتبة القياسية).
* شغّلها كما لو كانت سكريبت (هذا ما يفعله `-m`).
* ولهذا يمكنك تنفيذ أوامر مثل:

  ```bash
  python -m unittest test_example.py
  python -m unittest discover
  ```

  هذا يعمل حتى لو لم يكن لديك ملف `unittest` منفرد في مشروعك — فهي وحدة في المكتبة القياسية.

### `python -m pip`

هذا نفس النمط:

* تبحث عن وحدة `pip` (المثبتة مع Python).
* تشغلها كما لو كانت الأداة القابلة للتنفيذ `pip`.
* لذا فإن `python -m pip install requests` هي الطريقة "الرسمية" الآمنة لتشغيل pip، لأنها تضمن أنك تستخدم أداة pip الخاصة بمُفسِّر Python نفسه الذي تستخدمه.
  (في بعض الأحيان قد تشير `pip` في نظامك إلى تثبيت مختلف لـ Python، لذا فإن `python -m pip` يتجنب هذا الالتباس.)

### الفرق عن `python test_xx.py`

عندما تنفذ:

```bash
python test_xx.py
```

فأنت تشغّل ذلك الملف المحدد مباشرة، دون استخدام أداة الاكتشاف أو التشغيل الخاصة بـ `unittest`.

* إذا كان `test_xx.py` يحتوي على `unittest.main()` في أسفله، فسيقوم بتشغيل الاختبارات.
* ولكن إذا أردت من Python أن تكتشف تلقائيًا جميع الاختبارات الموجودة في دليل معين، فعادةً ما تعتمد على `python -m unittest discover`.

---

✅ **الخلاصة**:

* `-m` = تشغيل وحدة كسكريبت.
* `python -m unittest` يشغّل أداة تشغيل الاختبارات الخاصة بالمكتبة القياسية.
* `python -m pip` يضمن أن أداة pip تتوافق مع مُفسِّر Python نفسه.
* `python test_xx.py` يشغّل ملفًا واحدًا فقط، وليس أداة تشغيل الاختبارات العامة.

هل تريد مني أيضًا أن أوضح لك كيف تتعامل **pytest** مع هذا بشكل مختلف، حيث يمكنك مقارنة `unittest` بـ `pytest`؟