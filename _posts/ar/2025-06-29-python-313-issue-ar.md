---
audio: false
generated: true
lang: ar
layout: post
title: خطأ CuPy مع Python 3.13
translated: true
type: note
---

### وصف المشكلة

تواجه خطأ `AttributeError` عند تشغيل سكريبت Python يستورد مكتبة CuPy للحسابات على معالج الرسوميات. يحدث الخطأ أثناء جملة `import cupy as cp`، مما يمنع تنفيذ السكريبت. يشير التتبع إلى مشكلة داخل الكود الداخلي لـ CuPy، تحديدًا في `cupy/cuda/device.pyx` عند السطر 105، حيث تحاول الديكوراتور `memoize` تعديل السمة `__name__` لدالة أو طريقة مضمنة. رسالة الخطأ هي:

```
AttributeError: attribute '__name__' of 'builtin_function_or_method' objects is not writable
```

يبدو أن هذه المشكلة مرتبطة باستخدامك لـ Python 3.13، والذي قد يسبب مشاكل توافق مع إصدار CuPy المثبت لديك.

### سبب الخطأ

ينشأ الخطأ بسبب:

- **الديكوراتور `memoize` في CuPy**: تستخدم CuPy ديكوراتور `memoize` لتخزين نتائج الدالة مؤقتًا لتحسين الأداء. يعتمد هذا الديكوراتور على `functools.update_wrapper` في Python لنسخ السمات (مثل `__name__`) من الدالة الأصلية إلى دالة الغلاف.
- **الدوال المضمنة**: في Python، تحتوي الدوال المضمنة (المكتوبة بلغة C) على سمة `__name__` للقراءة فقط. عندما تحاول `update_wrapper` تعيين هذه السمة، تفشل مع `AttributeError`.
- **توافق Python 3.13**: الدالة التي يتم تخزينها مؤقتًا في `device.pyx` الخاص بـ CuPy هي على الأرجح دالة مضمنة، وقد يطبق Python 3.13 قواعد أكثر صرامة أو يتعامل مع الدوال المضمنة بشكل مختلف عن الإصدارات السابقة، مما يكشف هذه المشكلة.

نظرًا لأن الخطأ يحدث أثناء استيراد CuPy، فهذه مشكلة نظامية مرتبطة بتهيئة المكتبة وليس منطق السكريبت الخاص بك.

### الحل الموصى به

أبسط حل وأكثرها عملية هو تشغيل السكريبت الخاص بك بإصدار سابق من Python حيث يكون CuPy متوافقًا معه، مثل Python 3.11 أو 3.12. هذا يتجنب مشكلة التوافق مع Python 3.13 دون الحاجة إلى تعديل الكود المصدري لـ CuPy أو حلول معقدة.

#### لماذا يعمل هذا

- **التوافق**: إصدارات CuPy حتى أحدث الإصدارات (مثل v11) يتم اختبارها ودعمها على إصدارات Python مثل 3.11 و 3.12، حيث لا يحدث هذا الخطأ المحدد.
- **لا حاجة لتغيير الكود**: يمكن لسكريبتك، الذي يقوم بمعايرة أداء الفرز على معالج الرسوميات باستخدام CuPy، أن يعمل كما هو في بيئة Python سابقة، مما يضمن سلامة المعايرة.
- **سهولة التنفيذ**: تبديل إصدارات Python سهل باستخدام البيئات الافتراضية أو أدوات مثل `conda`.

### خطوات الحل التفصيلية

إليك كيفية حل المشكلة:

#### الخيار 1: استخدام `virtualenv`

1. **تثبيت Python 3.11 أو 3.12**
   - تأكد من تثبيت Python 3.11 أو 3.12 على نظامك (عبر مدير الحزم أو الموقع الرسمي لـ Python).

2. **إنشاء بيئة افتراضية**
   ```bash
   virtualenv -p python3.11 venv
   ```
   ينشئ هذا بيئة افتراضية باسم `venv` باستخدام Python 3.11. استبدل `python3.11` بـ `python3.12` إذا كنت تفضل ذلك.

3. **تفعيل البيئة الافتراضية**
   ```bash
   source venv/bin/activate
   ```

4. **تثبيت CuPy**
   ```bash
   pip install cupy
   ```
   يقوم هذا بتثبيت أحدث إصدار متوافق من CuPy لـ Python 3.11.

5. **تشغيل السكريبت الخاص بك**
   ```bash
   python scripts/benchmark/cudamark.py
   ```
   يجب أن ينفذ السكريبت الخاص بك الآن دون حدوث `AttributeError`.

6. **إلغاء التفعيل (عند الانتهاء)**
   ```bash
   deactivate
   ```

#### الخيار 2: استخدام `conda`

1. **إنشاء بيئة Conda**
   ```bash
   conda create -n cudabench python=3.11
   ```
   ينشئ هذا بيئة باسم `cudabench` مع Python 3.11. استخدم `python=3.12` إذا كنت تفضل Python 3.12.

2. **تفعيل البيئة**
   ```bash
   conda activate cudabench
   ```

3. **تثبيت CuPy**
   ```bash
   pip install cupy
   ```

4. **تشغيل السكريبت الخاص بك**
   ```bash
   python scripts/benchmark/cudamark.py
   ```

5. **إلغاء التفعيل (عند الانتهاء)**
   ```bash
   conda deactivate
   ```

### التحقق من الحل

بعد إعداد البيئة وتشغيل السكريبت، يجب أن ترى ناتجًا مشابهًا لما يلي:

```
CPU cores: <your_cpu_cores>
Threads: 1, Time taken: X.XXXX seconds
Threads: 2, Time taken: X.XXXX seconds
...
ThreadCount,TimeTakenSeconds
1,X.XXXXXX
2,X.XXXXXX
...
```

إذا تم تشغيل السكريبت دون حدوث `AttributeError`، فإن الحل ناجح.

### ملاحظات إضافية

- **عدد الخيوط في السكريبت الخاص بك**: يتكرر السكريبت الخاص بك عبر عدد الخيوط (`1, 2, 4, 8, 16, 32, 64, 128`)، لكن دالة `parallel_sort_gpu` تستخدم الفرز القائم على معالج الرسوميات في CuPy (`cp.sort`)، والذي لا يستخدم خيوط المعالج مباشرة. قد لا تؤثر حلقة عدد الخيوط على أداء الفرز على معالج الرسوميات كما هو متوقع. إذا كان هذا مقصودًا للتعديلات المستقبلية (مثل إضافة خيوط للمعالج)، فلا بأس؛ وإلا، يمكنك تبسيط المعايرة للتركيز فقط على أداء معالج الرسوميات.
- **إصدار CuPy**: إذا كنت تشك في أن إصدار CuPy قديم، فتأكد من تثبيت أحدث إصدار عن طريق تشغيل `pip install cupy --upgrade`. ومع ذلك، فإن المشكلة الأساسية هنا هي توافق Python 3.13، وليس إصدار CuPy بمفرده.
- **الحل طويل الأمد**: إذا كان يجب عليك استخدام Python 3.13، ففكر في التحقق من مستودع GitHub الخاص بـ CuPy أو متعقب المشكلات للحصول على تحديات تدعم Python 3.13 (اعتبارًا من يونيو 2025، قد يكون هذا متاحًا). بدلاً من ذلك، يمكنك عمل fork لـ CuPy وتصحيح الديكوراتور `memoize` للتعامل مع الدوال المضمنة، لكن هذا أكثر تعقيدًا وغير ضروري للمعايرة.

باستخدام Python 3.11 أو 3.12، يمكنك تشغيل معايرة معالج الرسوميات الخاص بك بشكل موثوق دون مواجهة هذا الخطأ.