---
audio: false
generated: true
image: false
lang: ar
layout: post
model: x-ai/grok-code-fast-1
title: استخدام طلبات الجلسة لجلسات بروتوكول نقل النص التشعبي المستمرة
translated: true
type: note
---

### آلية عمل requests.Session

في مكتبة `requests` الخاصة بلغة Python، فإن `requests.Session` هو فئة تسمح لك بالحفاظ على جلسة عمل مستمرة عبر طلبات HTTP متعددة. وهي توفر عدة مزايا مقارنة بإجراء استدعاءات فردية مثل `requests.get()`:

- **استمرارية ملفات تعريف الارتباط (Cookies)**: تقوم بشكل افتراضي بتخزين وإرسال ملفات تعريف الارتباط المستلمة من الخادم تلقائيًا في الطلبات اللاحقة. هذا يمكّن التفاعلات القائمة على الجلسات، مثل تسجيل الدخول مرة واحدة والبقاء معتمدًا.
- **تجمع الاتصالات (Connection Pooling)**: تعيد استخدام اتصالات TCP الأساسية لنفس المضيف، مما يحسن الأداء من خلال تجنب تكلفة إنشاء اتصالات جديدة.
- **التكوينات المشتركة**: يمكنك تعيين رؤوس افتراضية، أو مصادقة، أو وكلاء، أو معلمات أخرى تنطبق على جميع الطلبات داخل الجلسة.
- **خلف الكواليس**: تستخدم مكتبة `urllib3` لمعالجة HTTP. عندما تنشئ `Session`، فإنها تهيئ سمات مثل `cookies` (وهي نسخة من `RequestsCookieJar`)، و `headers`، والمزيد. على سبيل المثال، يتم تضمين ملفات تعريف الارتباط من استجابة واحدة تلقائيًا في الطلب التالي لنفس النطاق.

إليك مثالًا أساسيًا لإنشاء جلسة واستخدامها:

```python
import requests

# إنشاء جلسة
session = requests.Session()

# تعيين رأس افتراضي لجميع الطلبات في هذه الجلسة
session.headers.update({'User-Agent': 'MyApp/1.0'})

# إجراء طلبات متعددة، مع مشاركة الجلسة
response1 = session.get('https://example.com/login')
response2 = session.post('https://example.com/data', data={'key': 'value'})

# الوصول إلى ملفات تعريف الارتباط المخزنة في الجلسة
print(session.cookies)
```

هذا يضمن معالجة ملفات تعريف الارتباط (مثل معرفات الجلسة) بشفافية دون تدخل يدوي.

### استخدام Python لاستدعاء واجهات برمجة التطبيقات (APIs) لمشاريع Java/Spring

للتفاعل مع واجهات برمجة التطبيقات المبنية باستخدام Java/Spring (وعادة ما تكون نقاط نهاية RESTful عبر Spring MVC أو Spring Boot)، يمكنك استخدام `requests.Session` تمامًا كما هو الحال مع أي واجهة برمجة تطبيقات HTTP. غالبًا ما تعرض مشاريع Spring واجهات برمجة التطبيقات عبر HTTP/HTTPS، ويمكن لـ `requests` التعامل مع المصادقة، أو رموز CSRF، أو تحديد معدل الاستخدام إذا تم تطبيقها.

- **المصادقة**: قد يستخدم Spring Security مع النماذج، أو JWT، أو OAuth. للمصادقة القائمة على الجلسات (على سبيل المثال، عبر نماذج تسجيل الدخول)، يقوم `requests.Session` بأتمتة معالجة ملفات تعريف الارتباط بعد طلب تسجيل الدخول.
- **إجراء المكالمات**: استخدم طرق HTTP القياسية مثل `GET`، و`POST`، إلخ. إذا كانت واجهة برمجة تطبيقات Spring تتطلب حمولة JSON، فقم بتمرير `json=your_data`.

مثال على تسجيل الدخول إلى واجهة برمجة تطبيقات معتمدة عبر Spring واستدعاء نقطة نهاية أخرى:

```python
import requests

session = requests.Session()

# تسجيل الدخول (بافتراض إرسال POST إلى /login باسم المستخدم وكلمة المرور)
login_payload = {'username': 'user', 'password': 'pass'}
response = session.post('https://spring-api.example.com/login', data=login_payload)

if response.ok:
    # الآن استدعِ نقطة نهاية واجهة برمجة تطبيقات أخرى، حيث تستمر ملفات تعريف ارتباط الجلسة
    data_response = session.get('https://spring-api.example.com/api/data')
    print(data_response.json())
else:
    print("فشل تسجيل الدخول")
```

عادةً ما تكون واجهات برمجة تطبيقات Spring بدون حالة (stateless) بشكل افتراضي، ولكن يمكنها إدارة الجلسات عبر التخزين على جانب الخادم (على سبيل المثال، في Tomcat أو الخوادم المضمنة). تأكد من أن عميل Python الخاص بك يتعامل مع أي رؤوس CORS أو CSRF أو رؤوس مخصصة مطلوبة من قبل Spring.

### العلاقة بـ JSESSIONID في جانب Java/Spring

- **ما هو JSESSIONID؟**: في تطبيقات Java الويب (بما في ذلك Spring، الذي يعمل غالبًا على حاويات Servlet مثل Tomcat)، يُعد JSESSIONID ملف تعريف ارتباط HTTP قياسيًا تستخدمه الحاوية لتتبع جلسات المستخدم. يتم تعيينه عند إنشاء جلسة (على سبيل المثال، بعد تسجيل الدخول) وإرساله مرة أخرى في الردود. على جانب العميل، تقوم المتصفحات (أو عملاء HTTP مثل `requests`) بتضمينه في الطلبات اللاحقة للحفاظ على الحالة، مثل مصادقة المستخدم أو بيانات عربة التسوق.
- **كيفية ارتباطه بـ requests.Session**: تعامل `requests.Session` JSESSIONID مثل أي ملف تعريف ارتباط آخر - حيث تقوم بتخزينه تلقائيًا من رأس "Set-Cookie" الخاص بالخادم وتضمينه في رأس "Cookie" للطلبات المستقبلية. هذا يمكّن التفاعل السلس مع واجهات برمجة تطبيقات Spring ذات الحالة دون الحاجة إلى تحليل / استخراج ملفات تعريف الارتباط يدويًا.
- **المعالجة على جانب الخادم**: على جانب Java/Spring، تدير ServletContext الجلسات. عندما يرسل عميل Python الخاص بك طلبًا يحتوي على JSESSIONID، تقوم HttpSession التابعة لـ Spring باسترداد البيانات المرتبطة على جانب الخادم. إذا انتهت صلاحية الجلسة أو كانت غير صالحة، فقد يتطلب Spring إعادة المصادقة. للجلسات الآمنة، تأكد من أن إعدادك يستخدم HTTPS، حيث يمكن أن يكون JSESSIONID عرضة للسرقة عبر HTTP.
- **المشكلات المحتملة**: إذا فرض Spring رموز CSRF أو حمايات أخرى، فقد تحتاج إلى استخراجها وتضمينها (على سبيل المثال، من حقول النماذج المخفية). بالنسبة لواجهات برمجة تطبيقات Spring التي تعتمد على JWT بدون حالة، لا يزال `requests.Session` مفيدًا من خلال الإبقاء على رموز المصادقة في الرؤوس، ولكن يصبح JSESSIONID أقل أهمية.

إذا واجهت أخطاء محددة (على سبيل المثال، 401 Unauthorized) عند استدعاء واجهة برمجة تطبيقات Spring، فتحقق من سجلات الشبكة بحثًا عن مشكلات ملفات تعريف الارتباط أو قم بتمكين تصحيح أخطاء `requests` باستخدام `import logging; logging.basicConfig(level=logging.DEBUG)`. للمزيد حول Spring Security، راجع الوثائق الرسمية.