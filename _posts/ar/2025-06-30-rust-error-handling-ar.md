---
audio: false
generated: true
lang: ar
layout: post
title: معالجة الأخطاء في رست دون استثناءات
translated: true
type: note
---

لا تمتلك **Rust** استثناءات بالمعنى التقليدي، مثل Java أو C\#. بدلاً من ذلك، تتعامل مع الأخطاء بشكل أساسي من خلال **قيم الإرجاع**، على غرار النمط `if err != nil` في لغة Go، ولكن بطريقة أكثر متانة وأمانًا من حيث النوع.

إليك تفصيلاً لكيفية تعامل Rust مع الأخطاء:

**1. التعداد `Result<T, E>` للأخطاء القابلة للاسترداد:**

هذه هي الطريقة الأكثر شيوعًا واصطلاحية للتعامل مع الأخطاء في Rust.

  * `Result<T, E>` هو تعداد له حالتين:
      * `Ok(T)`: تمثل النجاح وتحتوي على القيمة الناجحة من النوع `T`.
      * `Err(E)`: تمثل الفشل وتحتوي على قيمة خطأ من النوع `E`.
  * عندما قد تفشل الدالة، فإنها تُرجع `Result`. هذا يُجبر المتصل على التعامل بشكل صريح مع كل من حالتي النجاح (`Ok`) والفشل (`Err`).
  * يمكنك استخدام تعبيرات `match` أو طرق مساعدة متنوعة (مثل `map`، `and_then`، `unwrap_or`، `unwrap_or_else`، إلخ) للتعامل مع الحالتين `Ok` و `Err`.

**مثال:**

```rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Problem creating the file: {:?}", e),
            },
            other_error => panic!("Problem opening the file: {:?}", other_error),
        },
    };

    println!("Successfully opened or created file: {:?}", greeting_file);
}
```

**2. التعداد `Option<T>` للقيم الاختيارية:**

على الرغم من أنها ليست مخصصة حصريًا "للأخطاء"، إلا أن `Option<T>` تشبه `Result` من حيث أنها تمثل *إمكانية الغياب*.

  * `Option<T>` له حالتين:
      * `Some(T)`: القيمة موجودة.
      * `None`: القيمة غير موجودة.
  * يُستخدم هذا عندما لا تُرجع الدالة قيمة بشكل مشروع (مثلًا، البحث عن عنصر في قائمة قد لا يكون موجودًا).

**3. المُعامل `?` (معامل علامة الاستفهام):**

هذا سكر نحوي قوي يجعل نشر الأخطاء أكثر إيجازًا، على غرار كيفية شيوع `if err != nil { return err }` في Go.

  * إذا كانت قيمة `Result` هي `Ok`، فإن المُعامل `?` يقوم بفك `Ok` وتستمر التنفيذ.
  * إذا كانت قيمة `Result` هي `Err`، فإن المُعامل `?` يُرجع فورًا قيمة `Err` من الدالة الحالية.
  * يجب على الدالة التي تستخدم `?` أن تُرجع هي نفسها `Result` (أو `Option` إذا كانت تقوم بفك `Option`).

**مثال باستخدام `?`:**

```rust
use std::fs::File;
use std::io::{self, Read}; // استيراد السمة io::Read

fn read_username_from_file() -> Result<String, io::Error> {
    let mut username_file = File::open("hello.txt")?; // ينشر الخطأ إذا لم يكن الملف موجودًا
    let mut username = String::new();
    username_file.read_to_string(&mut username)?; // ينشر الخطأ إذا فشلت القراءة
    Ok(username)
}

fn main() {
    match read_username_from_file() {
        Ok(username) => println!("Username: {}", username),
        Err(e) => println!("Error reading username: {}", e),
    }
}
```

**4. الماكرو `panic!` للأخطاء غير القابلة للاسترداد:**

يُستخدم `panic!` للأخطاء غير القابلة للاسترداد، والتي تشير عادةً إلى خلل في البرنامج (مثل الوصول إلى مصفوفة خارج حدودها).

  * عند استدعاء `panic!`، سينتهي البرنامج (أو "يرجع" المكدس، اعتمادًا على التكوين).
  * بشكل عام، يُنصح بعدم استخدامه للأخطاء القابلة للاسترداد التي يجب على برنامجك التعامل معها بأسلوب متحضر.

**الاختلافات الرئيسية عن الاستثناءات التقليدية:**

  * **الصراحة:** التعامل مع الأخطاء في Rust صريح للغاية. توقيع الدالة يشير بوضوح إلى أنها يمكن أن تُرجع خطأً، والمترجم *يجبرك* على التعامل معه. لا يمكنك تجاهل خطأ عن طريق الخطأ.
  * **لا توجد كتل "التقاط الكل":** لا توجد كتل `try-catch` تلتقط أي استثناء بصمت. أنت تتعامل مع أنواع أخطاء محددة.
  * **أمان النوع:** الأخطاء هي قيم من أنواع محددة (`Result<T, E>`)، مما يسمح بالتعامل الدقيق مع الأخطاء ويتجنب غموض أنواع الاستثناءات العامة.
  * **الأداء:** إرجاع قيم `Result` يكون بشكل عام أعلى أداءً من رمي الاستثناءات والإمساك بها، حيث غالبًا ما تتضمن الاستثناءات عبئًا كبيرًا (إرجاع للمكدس، إلخ). تم تصميم Rust للتطبيقات الحساسة للأداء.

باختصار، نموذج التعامل مع الأخطاء في Rust أقرب إلى فلسفة "التحقق في كل مستوى" في لغة Go منه إلى استثناءات Java أو C\#. ومع ذلك، مع التعداد `Result` والمعامل `?`، توفر Rust أدوات قوية ومريحة لجعل هذا التعامل الصريح مع الأخطاء ممكنًا بل وممتعًا.