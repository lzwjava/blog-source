---
audio: false
generated: true
lang: ar
layout: post
title: ربيع بوت متعدد الخيوط
translated: true
type: note
---

في مشروع Spring Boot، ترتبط مفاهيم "المُنفذين" (executors) و"الخيوط" (threads) عادةً بكيفية تعامل التطبيق مع المهام المتزامنة وإدارة عبء العمل، خاصة في السيناريوهات التي تتضمن معالجة غير متزامنة، أو جدولة المهام، أو معالجة طلبات متعددة. دعونا نشرح هذا خطوة بخطوة:

---

### **ما هي المنفذين والخيوط في Spring Boot؟**

1.  **الخيوط (Threads)**:
    *   الخيط هو أصغر وحدة تنفيذ في برنامج Java. في تطبيق Spring Boot، تُستخدم الخيوط للتعامل مع مهام مثل معالجة طلبات HTTP، أو تنفيذ الوظائف الخلفية (background jobs)، أو تنفيذ عمليات الإدخال/الإخراج (I/O operations).
    *   يعمل Spring Boot افتراضيًا ضمن خادم ويب مضمن (مثل Tomcat أو Jetty أو Undertow)، والذي يستخدم مجموعة خيوط (thread pool) لإدارة الطلبات الواردة. يتم عادةً تعيين كل طلب إلى خيط من هذه المجموعة.

2.  **المنفذين (Executors)**:
    *   `Executor` في Java (وفي Spring Boot) هو تجريد لإدارة الخيوط. وهو جزء من حزمة `java.util.concurrent` ويوفر طريقة لإدارة وتنفيذ المهام بشكل غير متزامن دون الحاجة إلى إنشاء وإدارة الخيوط يدويًا.
    *   في Spring Boot، غالبًا ما يُستخدم المنفذون لتفريغ المهام من خيط التطبيق الرئيسي (مثل الخيط الذي يعالج طلب HTTP) إلى مجموعة خيوط منفصلة. هذا مفيد للمهام طويلة الأمد، أو المعالجة المتوازية، أو الوظائف المجدولة.

3.  **السياق الخاص بـ Spring**:
    *   يوفر Spring Boot أدوات مثل `ThreadPoolTaskExecutor` (لتنفيذ المهام العامة) و `ThreadPoolTaskScheduler` (للمهام المجدولة) لتبسيط العمل مع المنفذين والخيوط.
    *   تم بناء هذه الأدوات على أساس `ExecutorService` في Java وتُستخدم بشكل شائع في:
        *   التنفيذ غير المتزامن للطرق (عبر `@Async`).
        *   جدولة المهام (عبر `@Scheduled`).
        *   إدارة أعباء العمل في سيناريوهات التزامن العالي.

---

### **كيف تعمل في Spring Boot؟**

#### **1. الإدارة الافتراضية للخيوط في Spring Boot**
*   عند تشغيل تطبيق ويب Spring Boot، يقوم الخادم المضمن (مثل Tomcat) بتهيئة مجموعة خيوط للتعامل مع طلبات HTTP الواردة.
*   على سبيل المثال، قد تخصص التهيئة الافتراضية لـ Tomcat 200 خيط (قابلة للتكوين عبر `server.tomcat.threads.max` في `application.properties`).
*   يتم تعيين كل طلب وارد إلى خيط من هذه المجموعة. إذا كانت جميع الخيوط مشغولة ووصل طلب جديد، فقد يتم اصطفافه في قائمة انتظار (اعتمادًا على تكوين الخادم) أو رفضه.

#### **2. المنفذين في Spring Boot**
*   يوفر Spring Boot واجهة `TaskExecutor` (وهي امتداد لـ `Executor` في Java) لإدارة مجموعات الخيوط المخصصة لمهام محددة.
*   التطبيق الشائع هو `ThreadPoolTaskExecutor`، والذي يسمح لك بتكوين:
    *   **حجم المجموعة الأساسي (Core Pool Size)**: عدد الخيوط التي تظل نشطة دائمًا.
    *   **الحد الأقصى لحجم المجموعة (Max Pool Size)**: الحد الأقصى لعدد الخيوط المسموح بها في المجموعة.
    *   **سعة قائمة الانتظار (Queue Capacity)**: عدد المهام التي يمكن أن تنتظر في قائمة الانتظار قبل إنشاء خيوط جديدة (حتى الحد الأقصى لحجم المجموعة).
    *   **تسمية الخيوط (Thread Naming)**: لتسهيل عملية التصحيح (على سبيل المثال، "MyExecutor-").

    مثال على التكوين في تطبيق Spring Boot:
    ```java
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;
    import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;

    @Configuration
    public class ExecutorConfig {

        @Bean
        public ThreadPoolTaskExecutor taskExecutor() {
            ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
            executor.setCorePoolSize(5);      // 5 خيوط كحد أدنى
            executor.setMaxPoolSize(10);      // 10 خيوط كحد أقصى
            executor.setQueueCapacity(100);   // اصطفاف حتى 100 مهمة
            executor.setThreadNamePrefix("MyExecutor-");
            executor.initialize();
            return executor;
        }
    }
    ```

#### **3. استخدام `@Async` مع المنفذين**
*   يدعم Spring Boot التنفيذ غير المتزامن للطرق باستخدام شرح `@Async`. عندما تشرّح طريقة بـ `@Async`، فإنها تعمل على خيط منفصل يديره منفذ.
*   افتراضيًا، يستخدم Spring `SimpleAsyncTaskExecutor`، والذي ينشئ خيطًا جديدًا لكل مهمة (غير مناسب للحمل العالي). لتحسين هذا، يمكنك توفير `ThreadPoolTaskExecutor` خاص بك (كما هو موضح أعلاه) والاشارة إليه:
    ```java
    @Service
    public class MyService {

        @Async("taskExecutor") // يشير إلى اسم الـ bean من التكوين
        public void doAsyncTask() {
            System.out.println("Running on thread: " + Thread.currentThread().getName());
        }
    }
    ```

#### **4. جدولة المهام**
*   للمهام المجدولة (مثل تشغيل وظيفة كل 5 دقائق)، يستخدم Spring Boot `ThreadPoolTaskScheduler`. إنه مشابه لـ `ThreadPoolTaskExecutor` ولكن مصمم خصيصًا للجدولة.
*   مثال:
    ```java
    @Scheduled(fixedRate = 5000) // يعمل كل 5 ثوانٍ
    public void scheduledTask() {
        System.out.println("Scheduled task on: " + Thread.currentThread().getName());
    }
    ```

#### **5. كيف تتفاعل الخيوط والمنفذين**
*   عند إرسال مهمة إلى منفذ (عبر `@Async` أو الإرسال اليدوي)، يقرر المنفذ ما إذا كان س:
    *   يستخدم خيطًا خاملًا موجودًا في المجموعة.
    *   ينشئ خيطًا جديدًا (إذا تم تجاوز حجم المجموعة الأساسي ولكن دون الحد الأقصى لحجم المجموعة).
    *   يضع المهمة في قائمة الانتظار (إذا تم الوصول إلى الحد الأقصى لحجم المجموعة ولم تكن قائمة الانتظار ممتلئة).
    *   يرفض المهمة (إذا كانت قائمة الانتظار ممتلئة ولا يمكن إنشاء المزيد من الخيوط).
*   تنفذ الخيوط المهام وتعود إلى المجموعة عند الانتهاء، مستعدة للمهمة التالية.

---

### **مثال عملي**
تخيل تطبيق Spring Boot يتعامل مع تسجيلات المستخدمين:
*   **خيط طلب HTTP**: يقدم المستخدم نموذج تسجيل، يتم معالجته بواسطة خيط من مجموعة خيوط Tomcat.
*   **مهمة غير متزامنة**: يتم تفريغ إرسال بريد إلكتروني تأكيدي إلى `ThreadPoolTaskExecutor` عبر طريقة مشروحة بـ `@Async`، حتى يتمكن خيط HTTP من الرد فورًا دون انتظار انتهاء إرسال البريد الإلكتروني.
*   **مهمة مجدولة**: تعمل وظيفة تنظيف كل ساعة لإزالة الحسابات غير المؤكدة، تديرها `ThreadPoolTaskScheduler`.

---

### **نقاط رئيسية**
*   **المنفذون** يجردون إدارة الخيوط، مما يسهل توسيع نطاق التطبيق وضبط التزامن.
*   **الخيوط** تقوم بالعمل الفعلي، وتتم إدارة دورة حياتها بواسطة المنفذين أو خادم الويب.
*   الإعدادات الافتراضية لـ Spring Boot كافية للتطبيقات الصغيرة، ولكن للتطبيقات ذات الحمل العالي أو المعقدة، ستقوم بتكوين منفذين مخصصين لتحسين الأداء.

إذا كان لديك مشروع Spring Boot محدد وتريد المساعدة في تحليل إعدادات المنفذين/الخيوط الخاصة به، فلا تتردد في مشاركة المزيد من التفاصيل!