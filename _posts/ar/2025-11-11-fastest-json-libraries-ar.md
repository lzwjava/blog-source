---
audio: false
generated: true
image: false
lang: ar
layout: post
model: x-ai/grok-4-fast
title: أسرع مكتبات JSON في Rust وJava
translated: true
type: note
---

### أسرع مكتبات JSON في Rust وJava

لمقارنة أسرع مكتبات JSON في Rust وJava، نحتاج إلى النظر في الأداء للتحليل (إزالة التسلسل) والتسلسل، حيث أن هذه هي العمليات الأساسية. عادةً ما يتم قياس الأداء من حيث الإنتاجية (مثل جيجابايت/ثانية) أو الوقت لمجموعات البيانات القياسية مثل twitter.json (مصفوفة كائنات متوسطة الحجم)، وcanada.json (مصفوفة كبيرة من الأرقام)، وcitm_catalog.json (كائنات متداخلة). هذه المجموعات البيانات شائعة في معايير أداء JSON.

#### الأسرع في Rust: sonic-rs
- **نظرة عامة**: sonic-rs هي مكتبة معجَّزة بـ SIMD من CloudWeGo، مصممة للتعامل مع JSON بسرعة عالية في Rust. تقوم بتحليل البيانات مباشرة إلى هياكل Rust دون خطوات وسيطة (مثل "الشريط" في simd-json)، مما يجعلها أسرع في عملية إزالة التسلسل. تدعم كلاً من التحليل المنظم (إلى هياكل) وغير المنظم (إلى نموذج DOM).
- **أبرز نقاط الأداء** (من المعايير على Intel Xeon Platinum 8260 @ 2.40GHz):
  - إزالة التسلسل إلى هيكل (الوقت بالمللي ثانية، الأقل هو الأفضل):
    - twitter.json: ~0.7 مللي ثانية
    - canada.json: ~3.8 مللي ثانية
    - citm_catalog.json: ~1.2 مللي ثانية
  - هذا يجعل sonic-rs أسرع بـ 1.5-2 مرة من simd-json (مكتبة Rust رائدة أخرى) في إزالة التسلسل، وأسرع بـ 3-4 مرات من serde_json (المعيار).
  - التسلسل: مماثل أو أسرع قليلاً من simd-json، على سبيل المثال، ~0.4 مللي ثانية لـ twitter.json.
  - الإنتاجية: غالبًا ما تتجاوز 2-4 جيجابايت/ثانية للمدخلات الكبيرة، وذلك بفضل تحسينات SIMD للسلاسل النصية والأرقام والمسافات البيضاء.
- **نقاط القوة**: Zero-copy حيثما أمكن، استخدام منخفض للذاكرة، أوضاع آمنة (مفحوصة) وغير آمنة (غير مفحوصة) لسرعة إضافية.
- **نقاط الضعف**: مكتبة جديدة، نظام بيئي أقل نضجًا من serde_json.

#### الأسرع في Java: DSL-JSON أو simdjson-java (متعادلة، اعتمادًا على حالة الاستخدام)
- **نظرة عامة**:
  - يستخدم DSL-JSON توليد الكود في وقت الترجمة (عبر annotations مثل @CompiledJson) لتجنب الانعكاس وتقليل حمل GC، مما يجعله سريعًا استثنائيًا في إزالة التسلسل في سيناريوهات الحمل العالي.
  - simdjson-java هو منفذ Java لمكتبة simdjson C++، يستخدم SIMD للتحليل بسرعة جيجابايت/ثانية. إنه قوي بشكل خاص للمدخلات الكبيرة ولكن له قيود مثل الدعم الجزئي لـ Unicode في الإصدارات المبكرة.
- **أبرز نقاط الأداء**:
  - DSL-JSON: أسرع بـ 3-5 مرات من Jackson في إزالة التسلسل في الحلقات الضيقة (مثل الكائنات المتوسطة ~500 بايت). الأرقام المحددة لمجموعات البيانات نادرة، لكن يُدَّعى أنها على قدم المساواة مع بروتوكولات الترميز الثنائية مثل Protobuf. في المعايير العامة، يتفوق على Jackson بأكثر من 3x في التسلسل والتحليل.
  - simdjson-java: ~1450 عملية/ثانية على Intel Core i5-4590 للعمليات النموذجية، أسرع بـ 3 مرات من Jackson وJsoniter وFastjson2. للمدخلات الكبيرة، يقترب من 1-3 جيجابايت/ثانية، مشابهًا لنظيره في C++. في المقارنات، أسرع بـ 3 مرات من Jsoniter في التحليل.
  - Jsoniter (إشارة مشرفة): أسرع بـ 2-6 مرات من Jackson، بسرعات فك تشفير مثل 3.22x Jackson للأعداد الصحيحة و 2.91x لقوائم الكائنات (نسب الإنتاجية في معايير JMH).
  - للسياق، مكتبة Jackson (شائعة ولكن ليست الأسرع) تتعامل مع مجموعات البيانات القياسية في ضعف إلى ثلاثة أضعاف وقت هذه المكتبات القائدة.
- **نقاط القوة**: DSL-JSON للتطبيقات منخفضة حمل GC وعالية الإنتاجية؛ simdjson-java للسرعة الخام على البيانات الكبيرة. كلاهما يتعاملان مع قيود JVM بشكل جيد.
- **نقاط الضعف**: يتطلب DSL-JSON annotations لأقصى سرعة؛ simdjson-java لديه فجوات في الميزات (مثل تحليل float الكامل في الإصدارات القديمة).

#### المقارنة المباشرة: Rust مقابل Java
- **فجوة الأداء**: مكتبة sonic-rs في Rust بشكل عام أسرع بـ 2-5 مرات من أفضل مكتبات Java للمهام المماثلة. على سبيل المثال:
  - في معيار واقعي لـ AWS Lambda يعالج 1 جيجابايت من سجلات JSON (بث + تحليل)، استغرقت Rust مع simd-json ~2 ثانية (0.5 جيجابايت/ثانية)، بينما استغرقت Java مع Jsoniter 8-10 ثوانٍ (0.1 جيجابايت/ثانية). باستخدام simdjson-java يمكن تقليص الفجوة إلى ~3 ثوانٍ (0.3 جيجابايت/ثانية)، لكن Rust لا تزال تفوز بسبب التجميع الأصلي، وعدم وجود توقفات GC، واستخدام أفضل لـ SIMD.
  - في مجموعات البيانات القياسية، تقوم sonic-rs بإزالة تسلسل canada.json في ~4 مللي ثانية، بينما تأخذ مكتبات Java مثل Jsoniter أو DSL-JSON 10-20 مللي ثانية في إعدادات مماثلة (غير مباشر، حيث أن المقارنة المباشرة نادرة).
  - التسلسل أقرب، حيث تكون Rust أسرع أحيانًا بـ 1.5-2 مرة فقط.
- **لماذا Rust أسرع**: الكود الأصلي، لا يوجد عبء JVM، تجريدات بدون تكلفة، وتحكم أفضل في الذاكرة. مكتبات Java محدودة بـ GC و bytecode، على الرغم من أن التحسينات مثل التوليد في وقت الترجمة (DSL-JSON) تساعد.
- **عوامل أخرى**:
  - الميزات: مكتبات Rust تندمج جيدًا مع نظام serde ecosystem للمرونة. مكتبات Java مثل Jackson لديها المزيد من الإضافات للمخططات المعقدة.
  - حالات الاستخدام: Rust للأداء فائق السرعة (مثل الخوادم، أدوات CLI)؛ Java للشركات مع تكامل أسهل.
  - محاذير: تختلف المعايير حسب الأجهزة، ومجموعة البيانات، وإصدار JVM (مثل Java 21+ يحسن GC). فحوصات السلامة في Rust يمكن أن تضيف عبئًا إذا لم تستخدم الأوضاع غير المفحوصة.

إذا كان لديك مجموعة بيانات محددة أو حالة استخدام (مثل التسلسل فقط)، يمكنني البحث بشكل أعمق.

### المراجع
- sonic-rs GitHub (معايير Rust) (https://github.com/cloudwego/sonic-rs)
- simdjson GitHub (الأساس لمنافذ Rust وJava) (https://github.com/simdjson/simdjson)
- Serverless Speed: Rust vs. Go, Java, and Python in AWS Lambda (معيار) (https://scanner.dev/blog/serverless-speed-rust-vs-go-java-and-python-in-aws-lambda-functions)
- The Lightning Fast JSON Parser Library For Java (simdjson-java) (https://www.i-programmer.info/news/80-java/16553-the-lightning-fast-json-parser-library-for-java.html)
- Jsoniter Benchmark (مقارنات Java) (https://jsoniter.com/benchmark.html)
- DSL-JSON vs Jackson (إزالة التسلسل في Java) (https://medium.com/@vishalpriyadarshi/dsl-json-vs-jackson-who-deserializes-faster-in-java-7f0ee164606a)
- Optimizing JSON Performance in Java - 2025 Edition (https://medium.com/towardsdev/optimizing-json-performance-in-java-what-actually-works-2025-edition-4f124e24d786)