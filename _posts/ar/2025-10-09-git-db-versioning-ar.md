---
audio: false
generated: true
image: false
lang: ar
layout: post
model: x-ai/grok-4-fast
title: التحكم في إصدار قاعدة البيانات المتوافق مع جيت
translated: true
type: note
---

### الاختيار بين JSON (أو CSV) و SQLite للتحكم في الإصدارات المتوافق مع Git

لقاعدة بيانات صغيرة تحتوي على 1-2 جدول و 10 آلاف إلى 100 ألف سجل، يعتبر كل من JSON و SQLite خيارين قابلين للتطبيق حيث يجب أن يبقى إجمالي حجم الملف قابلاً للإدارة (على الأرجح أقل من 10-50 ميغابايت حتى للبيانات الأكثر كثافة). التحدي الرئيسي الذي تواجهه — معاملة `git diff` للملف بأكمله ككتلة ثنائية في كل تحديث — شائع مع قواعد البيانات. يتفوق Git في مقارنة الفروقات النصية، لذا فإن التنسيقات مثل JSON تتفوق هنا، بينما تتطلب SQLite (وهي ملف ثنائي واحد) حلولاً للتغلب على هذه المشكلة لعرض التغييرات بشكل مقروء.

سأقوم بتحليلها من حيث الإيجابيات والسلبيات، ثم أوصي بناءً على أولوياتك.

#### مقارنة سريعة

| الجانب              | JSON (أو CSV)                                                                 | SQLite                                                                 |
|---------------------|-------------------------------------------------------------------------------|------------------------------------------------------------------------|
| **تنسيق الملف**    | نصي (يمكن للبشر قراءته). مقارنة فروقات سطر بسطر سهلة في git.                  | ملف ثنائي. يظهر Git تغييرات الملف الكامل؛ مقارنة الفروقات غير قابلة للقراءة افتراضيًا. |
| **الحجم لـ 10 آلاف-100 ألف سجل** | صغير إذا كانت السجلات بسيطة (مثلاً، 1-5 كيلوبايت لكل سجل → 10-500 ميغابايت إجمالاً). يتم ضغطه جيدًا في git. | حجم مشابه، ولكن لا توجد مكاسب من ضغط الفروقات النصية.                |
| **تجربة Git** | ممتازة: رؤية الأسطر المضافة/المعدلة بالضبط. استخدم أدوات مثل `git diff --word-diff` للتغييرات المنظمة. رتب البيانات بشكل متسق للحصول على فروقات نظيفة. | ضعيفة بدون إعدادات إضافية. أصلحها باستخدام إعداد git مخصص (مثل، تفريغ البيانات إلى SQL عند المقارنة). أو استخدم إضافات مثل Dolt للتحكم في إصدارات قاعدة البيانات المشابه لـ git. |
| **التحديثات**        | إعادة كتابة كاملة عند الحفظ، لكن الفروقات تُظهر التغييرات إذا قمت بالتحميل/التعديل/الحفظ بشكل انتقائي (مثلاً، عبر سكريبتات). | معاملات ذرية، لكن كل commit يبدو وكأنه استبدال كامل في git. |
| **الاستعلامات/الميزات** | أساسي (التصفية باستخدام كود مثل jq/Python). لا يوجد فهرسة/معاملات. جيد للبيانات المسطحة. | SQL كامل: استعلامات، joins (لجدولين)، فهارس، قيود. أفضل لأي شعور بـ "قاعدة بيانات". |
| **ملاءمة حالة الاستخدام**   | مثالي إذا كان تطبيقك/سكريبتك يتعامل مع CRUD في الذاكرة وتفضل التعاون/مقارنة الفروقات. | أفضل إذا كنت تحتاج عمليات قاعدة بيانات حقيقية؛ مقارنة الفروق ثانوية.                   |
| **الأدوات المطلوبة**   | Git أصلي + jq (لـ JSON) أو csvkit (لـ CSV).                               | سطر أوامر sqlite3 + سمات git للفروق المخصصة.                         |

#### التوصيات
- **اختر JSON (أو CSV) إذا كانت مقارنة الفروق السهلة هي أولويتك القصوى**: هذا يحافظ على كل شيء نصيًا ومتوافقًا مع git. لـ 1-2 جدول:
  - استخدم **ملف JSON واحدًا** كمصفوفة من الكائنات (مثلاً، `[{"id":1, "name":"foo", ...}, ...]`). إنه مرن للعلاقات البسيطة (تضمين جدول داخل الآخر).
  - أو **ملفات CSV** (واحد لكل جدول) للبيانات الجدولية الأكثر صرامة — خفيفة الوزن جدًا وصديقة لمقارنة الفروق. يمكن لأدوات مثل Pandas تحميلها/تعديلها/تصديرها.
  - **نصيحة سير العمل**: رتب السجلات دائمًا حسب المعرف/المفتاح قبل الحفظ (مثلاً، في Python: `df.sort_values('id').to_csv(...)`). هذا يجعل مقارنة الفروق تُظهر التغييرات الحقيقية فقط، وليس ضوضاء إعادة الترتيب. للتحديثات، اقرأ → عدل صفوفًا محددة → رتب → اكتب. يبقى حجم الملف صغيرًا، ويبقى سجل git نظيفًا.
  - العيب: لـ 100 ألف سجل، قد يكون تحميل الملف بالكامل في الذاكرة في كل مرة بطيئًا دون تحسين (مثلاً، استخدام مكتبات البث مثل ijson).

- **استخدم SQLite إذا كنت تحتاج إلى وظائف قاعدة بيانات**: إنها أكثر متانة للاستعلامات/الربط، وإعداد الملف الواحد بسيط لعمليات commit في git. لإصلاح مشكلة الفروق:
  - أضف ملف `.gitattributes`: `*.db diff=sqlite` ومقتطف `.gitconfig` لتفريغ قاعدة البيانات إلى SQL عند المقارنة (مثلاً، عبر `sqlite3 db dump.sql`). هذا يحول التغييرات الثنائية إلى أوامر SQL مقروءة (إدراج/تحديث).
  - مثال على سكريبت الإعداد (في bash/Python): عند commit، قم بتصدير مخطط البيانات/البيانات كملفات SQL للمراجعة.
  - للاحتياجات المتقدمة، فكر في Dolt — إنه يشبه "git لقواعد البيانات" مع جداول قابلة للتفرع وفروق مناسبة، ولكنه أثقل للإعدادات الصغيرة جدًا.

ابدأ بـ JSON/CSV للبساطة — إنه "جيد بما فيه الكفاية" للنطاق الصغير ويتوافق مع اهتمامك بـ git. إذا تجاوزت قدراته (مثلاً، الحاجة إلى استعلامات معقدة)، انتقل إلى SQLite لاحقًا. أنشئ نموذجًا أوليًا لكليهما: قم بتفريغ بيانات عينة إلى ملفات واختبر بعض عمليات commit في git.

إذا كانت سجلاتك لها هيكل محدد، شارك المزيد من التفاصيل للحصول على مقاطع كود مخصصة.

[التحكم في إصدارات SQLite في Git](https://dunkels.com/adam/git-diff-sqlite3/)  
[JSON مقابل قاعدة البيانات للبيانات الصغيرة](https://www.reddit.com/r/flask/comments/lvccgo/using_a_database_such_as_sqlite3_versus_json_to/)  
[خيارات التحكم في إصدارات البيانات](https://dolthub.com/blog/2022-04-27-data-version-control/)