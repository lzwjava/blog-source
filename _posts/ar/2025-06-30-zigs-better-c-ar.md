---
audio: false
generated: true
lang: ar
layout: post
title: 'زيج: بديل أفضل لسي'
translated: true
type: note
---

زيغ هي لغة برمجة نظامية حديثة متعددة الأغراض، مُكتوبة بشكل ثابت ومُترجمة، مُصممة من أجل المتانة والأمثلية والقابلية للصيانة. تهدف إلى أن تكون "سي أفضل"، حيث تقدم تحكمًا منخفض المستوى وأداءً عاليًا مع معالجة العديد من نقاط الألم طويلة الأمد في لغة سي.

## تاريخ زيغ

تم إنشاء زيغ بواسطة **أندرو كيلي** وظهرت لأول مرة في **2016**. كان دافع تطويرها هو الرغبة في وجود لغة برمجة تجمع بين البساطة والأداء والسلامة، خاصة للبرمجة على مستوى النظام. على الرغم من حداثتها مقارنة بلغات راسخة مثل C و C++ و Rust و Go، إلا أن زيغ اكتسبت زخمًا سريعًا بسبب منهجها وميزاتها الفريدة. تميز رحلتها بمجتمع متنامٍ وتحديثات مستمرة، مع التركيز على تقديم بديل قوي وفعال للمطورين. تبنت مشاريع بارزة مثل وقت تشغيل جافا سكريبت Bun ومحاكي الطرفية Ghostty لغة زيغ، مما يظهر قدراتها.

## خصائص زيغ

تتمتع زيغ بعدة خصائص متميزة تميزها عن غيرها:

* **البساطة وسهولة القراءة:**
    * **لا يوجد تحكم مخفي في التدفق أو تخصيص للذاكرة:** تتجنب زيغ صراحة الميزات التي يمكن أن تحجب سلوك البرنامج، مثل تحميل المشغل overloaded operators، والتحويلات الضمنية implicit conversions، والاستثناءات exceptions، وماكرو macros، وتوجيهات المعالج المسبق preprocessor directives. يتم إدارة كل تحكم في التدفق بواسطة كلمات رئيسية واضحة في اللغة واستدعاءات الدوال.
    * **إدارة الذاكرة اليدوية:** تمنح زيغ المطورين تحكمًا دقيقًا في تخصيص الذاكرة وإلغاء تخصيصها. والأهم من ذلك، لا توجد تخصيصات ضمنية للذاكرة الديناميكية heap، مما يعني أن أي تخصيص للذاكرة يكون مرئيًا بشكل صريح في الكود. هذا يحسن القدرة على التنبؤ ويجعلها مناسبة للبيئات محدودة الموارد.
    * **مساحة لغة صغيرة:** بناء جملة زيغ موجز، مما يسهل تعلمه وفهمه. إنه يعطي أولوية لتصحيح أخطاء تطبيقك بدلاً من تصحيح أخطاء معرفتك باللغة.

* **الأداء والسلامة (فلسفة اختر اثنين):**
    * تقدم زيغ أوضاع بناء مختلفة (التصحيح Debug، الإصدار الآمن ReleaseSafe، الإصدار السريع ReleaseFast، الإصدار الصغير ReleaseSmall) تسمح للمطورين بالموازنة بين الأداء والسلامة على مستوى دقيق.
    * **فحوصات السلامة في وقت الترجمة ووقت التشغيل:** بينما تقدم تحكمًا منخفض المستوى، توفر زيغ ميزات لمنع الأخطاء الشائعة. على سبيل المثال، يمكن اكتشاف تجاوز السعة للأعداد الصحيحة integer overflows في وقت الترجمة أو التسبب في إيقاف التشغيل panic في وقت التشغيل في إصدارات فحص السلامة.
    * **سلوك غير معرف محدد بعناية:** على عكس لغة سي، حيث يمكن أن يؤدي السلوك غير المعرفة undefined behavior إلى نتائج غير متوقعة، فإن نهج زيغ تجاه السلوك غير المعرفة أكثر تحكمًا، مما يسمح بتحسينات محددة مع المساعدة في منع الأخطاء.
    * **لا يوجد جامع للنفايات Garbage Collector (GC) أو عد مراجع تلقائي Automatic Reference Counting (ARC):** يضمن هذا الخيار التصميمي أداءً واستخدامًا للذاكرة يمكن التنبؤ بهما، وهو أمر بالغ الأهمية للبرمجة على مستوى النظام.

* **التشغيل البيني مع لغة سي من الدرجة الأولى:**
    * إحدى أكثر ميزات زيغ إقناعًا هي تكاملها السلس مع مكتبات سي. يمكن لزيغ ترجمة الكود الموجود بلغة سي والترجمة ضده مباشرة، مما يسمح للمطورين بتضمين رؤوس C headers واستدعاء دوال C بأقل قدر من النفقات العامة (غالبًا ما يُوصف بأنه "بدون نفقات overhead"). هذا يعني أيضًا أنه يمكن استخدام نظام البناء المدمج في زيغ لإدارة مشاريع C/C++، ليحل بشكل فعال محل أدوات مثل `autotools` و `cmake` و `make`.

* **Comptime (تنفيذ في وقت الترجمة):**
    * تتيح ميزة `comptime` في زيغ تنفيذ الكود في وقت الترجمة. هذا يمكّن من إنشاء أنواع عامة generics قوية في وقت الترجمة، وقدرات تشبه الانعكاس reflection، وإنشاء كود مُحسن للغاية، مما يلغي في كثير من الأحيان الحاجة إلى معالجات مسبقة preprocessors أو برمجة فوقية معقدة metaprogramming.

* **معالجة الأخطاء كقيم:**
    * تعامل زيغ الأخطاء كقيم يجب التعامل معها بشكل صريح. يشجع هذا على معالجة الأخطاء بشكل قوي ويمنع الاستثناءات المخفية أو حالات الإيقاف التي يمكن أن تجعل الكود أصعب في الفهم.

* **مكتبة標準 اختيارية والترجمة Cross-Compilation عبر المنصات:**
    * مكتبة زيغ القياسية اختيارية بالكامل؛ فقط واجهات برمجة التطبيقات APIs التي تستخدمها يتم ترجمتها إلى برنامجك، مما يؤدي إلى أحجام ثنائية صغيرة جدًا، وهو أمر مفيد بشكل خاص للأنظمة المدمجة أو WebAssembly.
    * تتمتع زيغ بقدرات ممتازة جاهزة للترجمة Cross-Compilation عبر المنصات لمعظم المنصات الرئيسية، مما يبسط تطوير التطبيقات متعددة المنصات.

## المقارنة مع اللغات الرئيسية الأخرى

### زيغ مقابل سي

غالبًا ما يتم وضع زيغ كخليفة مباشر أو "سي أفضل".

* **مزايا زيغ gegenüber سي:**
    * **ميزات حديثة:** تدمج زيغ ميزات لغة حديثة مثل الأنواع الاختيارية option types (لتجنب dereference مؤشرات null)، واتحادات الأخطاء error unions (لمعالجة الأخطاء بشكل صريح)، والأنواع العامة في وقت الترجمة compile-time generics، مما يحسن السلامة والتعبيرية دون التضحية بالتحكم منخفض المستوى.
    * **لا يوجد معالج مسبق أو ماكرو:** تلغي زيغ المعالج المسبق للغة سي، والذي يمثل مصدرًا شائعًا للأخطاء الغامضة والتصحيح الصعب. يوفر `comptime` بديلاً أكثر أمانًا وقوة.
    * **نظام بناء ومدير حزم محسن:** تتضمن زيغ نظام بناء مدمج ومدير حزم يمكنه حتى إدارة مشاريع C/C++، معالجة نقطة ألم كبيرة في تطوير سي.
    * **قابلية أفضل للقراءة والصيانة:** يؤدي بناء جملة زيغ الأبسط والتصميم الصريح إلى كود أكثر قابلية للقراءة والصيانة.
    * **سلوك غير معرف محدد:** تكون زيغ أكثر وضوحًا بشأن سلوكياتها غير المعرفة، مما يسهل كتابة كود صحيح ومُحسن.

* **أوجه التشابه:** كلاهما لغتي برمجة نظامية منخفضة المستوى مع إدارة ذاكرة يدوية وبدون جامع نفايات. تهدفان إلى تحقيق أداء عالي وتقديم وصول مباشر إلى العتاد.

### زيغ مقابل رست

كل من زيغ ورست هما لغتي برمجة نظاميتين حديثتين تهدفان إلى الأداء والسلامة. ومع ذلك، فإنهما يتعاملان مع السلامة والتحكم بشكل مختلف.

* **سلامة الذاكرة:**
    * **رست:** تؤكد على ضمانات قوية لسلامة الذاكرة من خلال نظام الملكية والاستعارة (مدقق الاستعارة "borrow checker") في وقت الترجمة. هذا يلقي virtually فئات كاملة من الأخطاء مثل سباق البيانات data races، و dereference مؤشرات null، وأخطاء use-after-free.
    * **زيغ:** تقدم إدارة ذاكرة يدوية مع مُخصصات ذاكرة memory allocators يتم تمريرها بشكل صريح. بينما توفر فحوصات السلامة (مثل فحص integer overflows، وإمكانية null عبر option types، ومُخصص تصحيح debug allocator لاكتشاف تسريبات الذاكرة use-after-free)، فإنها تسمح بمزيد من التحكم المباشر في الذاكرة، وتكون سلامة الذاكرة في النهاية مسؤولية المبرمج، على غرار سي. يمكن اعتبار هذا "تحكم في الذاكرة" بدلاً من "سلامة الذاكرة افتراضيًا".

* **التعقيد/منحنى التعلم:**
    * **رست:** لديها منحنى تعلم أكثر حدة due to مدقق الاستعارة والمفاهيم المرتبطة به (فترات الحياة lifetimes، الملكية ownership).
    * **زيغ:** تهدف إلى البساطة ومنحنى تعلم أكثر استواءً، خاصة للمطورين المألوفين مع لغات شبيهة بسي. تصميمها أكثر تقليلًا.

* **التشغيل البيني مع سي:**
    * **رست:** تتطلب كتل `unsafe` وربط واجهة الوظائف الأجنبية Foreign Function Interface (FFI) للتشغيل البيني مع سي، وهو ما يمكن أن يكون أكثر تعقيدًا.
    * **زيغ:** لديها تشغيل بيني سلس مع سي من الدرجة الأولى، مما يجعل دمجها مع مكتبات سي الحالية سهلاً للغاية.

* **الفلسفة:**
    * **رست:** تعطي أولوية للسلامة والتزامن fearless concurrency، حتى على حساب بعض الإسهاب الصريح أو النفقات الأولية للتعلم.
    * **زيغ:** تعطي أولوية للتحكم الصريح والبساطة وقوة وقت الترجمة، وتوفر أدوات للمساعدة في تحقيق الصحة في بيئة "غير آمنة" بطبيعتها.

### زيغ مقابل جو

Go هي لغة برمجة نظامية عالية المستوى تحتوي على جامع نفايات وأدوات concurrency مدمجة، مما يجعلها أكثر تركيزًا على تطوير التطبيقات وإنتاجية المطور.

* **إدارة الذاكرة:**
    * **جو:** تستخدم جامع نفايات، مما يبسط إدارة الذاكرة للمطور ولكنها تقدم فترات توقف غير متوقعة و potentially نفقات ذاكرة أعلى.
    * **زيغ:** إدارة ذاكرة يدوية، تقدم تحكمًا دقيقًا في تخطيط الذاكرة واستخدامها، مما يؤدي إلى أداء أكثر قابلية للتنبؤ.

* **التزامن Concurrency:**
    * **جو:** توفر goroutines المدمجة والقنوات channels أدوات concurrency قوية وسهلة الاستخدام.
    * **زيغ:** يتم التعامل مع concurrency بشكل أكثر وضوحًا من قبل المبرمج، عادةً باستخدام الخيوط threads وأدوات المزامنة synchronization primitives التي توفرها نظام التشغيل أو المكتبات.

* **حالات الاستخدام:**
    * **جو:** ممتازة لخدمات الشبكة، وواجهات الويب الخلفية، وأدوات سطر الأوامر، وتطوير التطبيقات العامة حيث يكون التطوير السريع والتزامن أمرًا أساسيًا.
    * **زيغ:** مثالية لأنظمة التشغيل، والأنظمة المدمجة، ومحركات الألعاب، ومكتبات الأداء العالي، والتطبيقات منخفضة المستوى الأخرى حيث يكون التحكم الأقصى والحد الأدنى من النفقات overhead في وقت التشغيل أمرًا بالغ الأهمية.

* **حجم الملف الثنائي:** تنتج زيغ typically ملفات ثنائية أصغر بكثير due to مكتبتها القياسية الاختيارية وعدم وجود وقت تشغيل runtime أو جامع نفايات.

باختصار، تقدم زيغ بديلاً مقنعًا للبرمجة النظامية، بهدف الجمع بين التحكم منخفض المستوى لسي مع ميزات اللغة الحديثة، والتشغيل البيني القوي مع سي، والتركيز على الوضوح والبساطة. إنها جذابة بشكل خاص للمشاريع التي تتطلب تحكمًا دقيقًا في الأداء والتكامل مع قاعدة كود سي existing.