---
audio: false
generated: true
image: false
lang: ar
layout: post
model: x-ai/grok-4-fast
title: فوائد البحث بالعمق في البرمجة التنافسية
translated: true
type: note
---

### لماذا نستخدم البحث بالعمق (DFS) في البرمجة التنافسية؟

البحث بالعمق (DFS) هو خوارزمية أساسية لاجتياز المخططات البيانية تُستخدم على نطاق واسع في البرمجة التنافسية لأنها تستكشف بكفاءة المشكلات المتعلقة بالاتصال والمسارات والهياكل العودية. إليك الأسباب التي تجعلها ذات قيمة خاصة:

- **الكفاءة في الاستكشاف العميق**: يغوص البحث بالعمق (DFS) بعمق في مسار واحد قبل التراجع، مما يجعله مثالياً للمشكلات التي تحتاج فيها إلى إيجاد مسار واحد، أو اكتشاف الدورات، أو استكشاف جميع الاحتمالات بشكل شامل (مثل سيناريوهات التراجع). تعقيده الزمني هو O(V + E) للمخططات البيانية (V = الرؤوس، E = الحواف)، وهو تعقيد خطي وسريع لمعظم قيود المسابقات.

- **يتعامل مع المشكلات العودية بشكل طبيعي**: يمكن نمذجة العديد من المشكلات كأشجار أو مخططات بيانية ذات مشكلات فرعية عودية (مثل المتاهات، الألغاز، أو اجتياز الأشجار). يستخدم البحث بالعمق (DFS) مكدس الاستدعاءات (call stack) للعودية، مما يحافظ على بساطة الكود وكفاءة الذاكرة مقارنة بالأساليب التكرارية.

- **متعدد الاستخدامات لمشكلات المخططات البيانية**: إنه رائع لاكتشاف المكونات المتصلة، وإيجاد الجسور/النقاط المفصلية، والترتيب الطوبولوجي، أو حل المخططات البيانية الثنائية. في المسابقات، غالباً ما تختبئ المخططات البيانية في صورة أخرى (مثل السلاسل النصية أو الشبكات)، ويبرز البحث بالعمق (DFS) هناك.

- **قوة التراجع**: للمشكلات التوافقية مثل N-Queens، Sudoku، أو توليد المجموعات الفرعية/التباديل، فإن البحث بالعمق (DFS) مع التراجع يقوم بتقليم المسارات غير الصالحة مبكراً، متجنباً الانفجار الحاصل في أسلوب القوة الغاشمة.

- **مقايضة المساحة**: يستخدم ذاكرة أقل من البحث بالعرض (BFS) للمخططات البيانية العميقة (فقط مكدس العودية)، وهو أمر يهم في المسابقات ذات الذاكرة المحدودة.

بشكل عام، البحث بالعمق (DFS) هو الخيار الأمثل عندما تصرخ المشكلة "استكشف بعمق وتراجع إذا علقت"، خاصة على منصات مثل Codeforces أو LeetCode.

### أمثلة على البحث بالعمق (DFS)

إليك ثلاثة أمثلة شائعة مع كود زائف (نمط Python للوضوح). هذه الأمثلة مبسطة للتوضيح – قم بتكييفها للمشكلات الكاملة.

#### 1. **اكتشاف الدورات في مخطط بياني غير موجه**
   - **المشكلة**: بمخطط بياني معطى، تحقق مما إذا كان يحتوي على دورة.
   - **لماذا البحث بالعمق (DFS)؟**: اجتز بعمق؛ إذا قمت بزيارة عقدة مرة أخرى في المسار الحالي، فهناك دورة.
   - **الكود الزائف**:
     ```python:disable-run
     def has_cycle(graph, start, visited, parent):
         visited[start] = True
         for neighbor in graph[start]:
             if not visited[neighbor]:
                 if has_cycle(graph, neighbor, visited, start):
                     return True
             elif neighbor != parent:
                 return True  # حافة خلفية إلى سلف
         return False

     # الاستخدام
     visited = {node: False for node in graph}
     cycle_exists = any(has_cycle(graph, node, visited, -1) for node in graph if not visited[node])
     ```

#### 2. **إيجاد المكونات المتصلة في مخطط بياني**
   - **المشكلة**: حدد جميع المجموعات المتصلة المنفصلة في مخطط بياني غير موجه.
   - **لماذا البحث بالعمق (DFS)؟**: ابدأ من عقدة، ضع علامة على جميع العقد التي يمكن الوصول إليها كمكون واحد، ثم انتقل إلى التالية غير المزورة.
   - **الكود الزائف**:
     ```python
     def dfs(graph, start, visited, component):
         visited[start] = True
         component.append(start)
         for neighbor in graph[start]:
             if not visited[neighbor]:
                 dfs(graph, neighbor, visited, component)

     # الاستخدام
     visited = {node: False for node in graph}
     components = []
     for node in graph:
         if not visited[node]:
             component = []
             dfs(graph, node, visited, component)
             components.append(component)
     ```

#### 3. **إيجاد المسار في متاهة (التراجع)**
   - **المشكلة**: ابحث عن مسار من البداية إلى النهاية في متاهة شبكية (0 = مفتوح، 1 = حاجز).
   - **لماذا البحث بالعمق (DFS)؟**: جرب المسارات بشكل عودي؛ تراجع عند المآزق المسدودة.
   - **الكود الزائف** (الشبكة كقائمة ثنائية الأبعاد):
     ```python
     def solve_maze(grid, x, y, end_x, end_y, path):
         if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 1:
             return False
         if x == end_x and y == end_y:
             path.append((x, y))
             return True
         path.append((x, y))
         grid[x][y] = 1  # وضع علامة كمزور
         # جرب الاتجاهات: أسفل، يمين، أعلى، يسار
         if (solve_maze(grid, x+1, y, end_x, end_y, path) or
             solve_maze(grid, x, y+1, end_x, end_y, path) or
             solve_maze(grid, x-1, y, end_x, end_y, path) or
             solve_maze(grid, x, y-1, end_x, end_y, path)):
             return True
         path.pop()  # تراجع
         grid[x][y] = 0  # إزالة العلامة
         return False

     # الاستخدام: path = []; solve_maze(grid, 0, 0, rows-1, cols-1, path)
     ```

هذه الأمثلة تظهر أناقة البحث بالعمق (DFS) العودية – تدرب على مشكلات مثل "Number of Islands" (LeetCode) أو "Cycle Detection" (HackerRank) لتراه في العمل!