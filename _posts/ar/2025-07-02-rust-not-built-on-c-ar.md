---
audio: false
generated: true
lang: ar
layout: post
title: علاقة لغة رست مع لغة سي
translated: true
type: note
---

لا، لغة Rust ليست "مبنية على C" بمعنى أنها تُترجم إلى C أو تتطلب C كطبقة أساسية لتشغيلها. Rust هي لغة منفصلة وحديثة لبرمجة الأنظمة.

إليك تفصيل للعلاقة بين Rust و C، وكيف تتفاعل Rust مع مكتبات C:

**هل Rust مبنية على C؟**

* **المُصرِّف (Compiler):** مُصرِّف Rust (rustc) مكتوب في الأساس بلغة Rust نفسها. كانت الإصدارات الأولى من المُصرِّف تستخدم لغة OCaml للتمهيد، لكنه الآن يعتمد على نفسه (self-hosting).
* **التفاعل منخفض المستوى:** Rust هي لغة منخفضة المستوى يمكنها التفاعل مباشرة مع نظام التشغيل والأجهزة، تمامًا مثل C أو C++. لا تعتمد على C كوسيط لهذه العمليات الأساسية.
* **LLVM:** يستخدم مُصرِّف Rust مشروع LLVM (Low Level Virtual Machine) كواجهة خلفية (backend) لتوليد الكود وتحسينه. مشروع LLVM نفسه مكتوب في الغالب بلغة C++. هذا يعني أن كود Rust يُترجم في النهاية إلى تمثيل وسيط (IR) في LLVM، والذي يتم بعد ذلك تحسينه وتجميعه إلى كود آلة. لذا، بهذا المفهوم، هناك اعتماد على سلسلة أدوات مبنية على C++ (LLVM)، لكن Rust نفسها ليست "مبنية على C."

**هل يمكن لـ Rust استخدام جميع مكتبات C؟**

نعم، تتمتع Rust بإمكانية تشغيل مشترك ممتازة مع مكتبات C من خلال **واجهة الدوال الأجنبية (FFI)**. هذا يعني أنه يمكنك استدعاء دوال واستخدام هياكل بيانات من مكتبات C الموجودة مباشرة داخل كود Rust.

إليك كيف يعمل هذا بشكل عام:

1.  **كتل `extern "C"`: ** تقوم بتعريف كتلة `extern "C"` في كود Rust للإعلان عن تواقيع الدوال C التي تريد استدعاءها. هذا يخبر مُصرِّف Rust أن هذه الدوال تلتزم بـ واجهة الثنائيات التطبيقية (ABI) الخاصة بلغة C، والتي تحدد كيفية استدعاء الدوال وتنظيم البيانات في الذاكرة.
2.  **سمة `#[link]`: ** تستخدم السمة `#[link(name = "foo")]` لإخبار رابط (linker) Rust بالربط مع مكتبة C المحددة (مثل `libfoo.so` أو `foo.lib`).
3.  **كتل `unsafe`: ** عادةً ما يتم تغليف استدعاءات دوال C داخل كتل `unsafe` في Rust. هذا لأنه لا يمكن فرض ضمانات السلامة الذاكرية القوية في Rust عند التفاعل مع كود "أجنبي" لا يتبع قواعد Rust. أنت، كمبرمج، مسؤول عن ضمان سلامة هذه الاستدعاءات.
4.  **`bindgen`: ** لمكتبات C الكبيرة، يمكن أن يكون كتابة جميع تصريحات `extern "C"` يدويًا أمرًا مملًا. يمكن لأدوات مثل `bindgen` توليد روابط FFI الخاصة بـ Rust تلقائيًا من ملفات رأس C، مما يبسط العملية بشكل كبير.
5.  **صندوق `cty`: ** يوفر صندوق `cty` أنواعًا بدائية متوافقة مع C (مثل `c_int`، `c_char`، إلخ) لضمان تعيين نوع البيانات بشكل صحيح بين Rust و C.

**لماذا استخدام مكتبات C في Rust؟**

* **الاستفادة من الكود الموجود:** هناك نظام بيئي واسع من مكتبات C المجربة جيدًا والمحسنة للغاية لمهام متنوعة (مثل استدعاءات النظام، التشفير، الحوسبة العددية، الرسومات). تسمح لك Rust بالاستفادة من هذا المورد الحالي دون إعادة كتابة كل شيء من الصفر.
* **واجهات نظام التشغيل:** تعرض أنظمة التشغيل العديد من وظائفها من خلال واجهات متوافقة مع C. تحتاج Rust إلى أن تكون قادرة على استدعاء هذه الدوال للتفاعل مع نظام التشغيل.
* **الأقسام الحرجة للأداء:** بينما تتميز Rust عمومًا بالسرعة، قد يكون بعض الأكواد الحرجة للأداء والمتخصصة للغاية موجودًا بالفعل في C ويمكن دمجه مباشرة.

باختصار، Rust ليست "مبنية على C،" لكنها توفر آليات قوية (FFI) للتشغيل المشترك السلس مع مكتبات C، مما يسمح لمطوري Rust بالاستفادة من النظام البيئي الواسع لـ C.