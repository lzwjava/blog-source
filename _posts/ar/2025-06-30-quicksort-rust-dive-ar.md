---
audio: false
generated: true
lang: ar
layout: post
title: فرز سريع في رست للمطورين المخضرمين
translated: true
type: note
---

حسنًا، نظرًا لخلفيتك القوية في الخوارزميات، والتطوير الشامل (Full-Stack)، وحتى هندسة الهواتف المحمولة، ستجد أن نهج Rust فيما يتعلق بسلامة الذاكرة والتحكم الصريح مألوفًا لك من حيث المفهوم، حتى لو كانت البنية الجديدة والصارمة جديدة عليك. دعنا نحلل تنفيذ خوارزمية Quicksort في Rust.

-----

### Quicksort في Rust: غوص للمطورين ذوي الخبرة

ينفذ كود Rust هذا **خوارزمية Quicksort** الكلاسيكية. الفكرة الأساسية لـ Quicksort هي اختيار عنصر كمحور وتقسيم المصفوفة حوله، بحيث تكون العناصر الأصغر من المحور على جانب، والعناصر الأكبر على الجانب الآخر. ثم يتم تطبيق هذه العملية بشكل متكرر على المصفوفات الفرعية.

دعنا ننتقل إلى الدوال:

-----

### `fn quick_sort(arr: &mut [i32])`

```rust
fn quick_sort(arr: &mut [i32]) {
    if arr.len() <= 1 {
        return;
    }
    let pivot_index = partition(arr);
    let (left, right) = arr.split_at_mut(pivot_index);
    quick_sort(left);
    quick_sort(&mut right[1..]);
}
```

  * **`arr: &mut [i32]`**: هذا هو المكان الذي تظهر فيه ألوان نظام الأنواع في Rust على الفور.
      * `&mut` تشير إلى **مرجع قابل للتغيير**. هذا يعني أن دالة `quick_sort` تحصل على مرجع مستعار للمصفوفة `arr`، ويُسمح لها بتعديل محتويات تلك المصفوفة *في مكانها*.
      * `[i32]` هي **شريحة** من أعداد صحيحة من النوع `i32`. في Rust، `[T]` هو النوع الخاص بالشريحة، وهي عبارة عن عرض لتسلسل متجاور من العناصر. إنها لا تملك البيانات؛ إنها تشير فقط إلى جزء من مصفوفة أو `Vec`. هذا أمر بالغ الأهمية للكفاءة، لأنه يتجنب نسخ البيانات. أنت على دراية بالمؤشرات وأقسام المصفوفات من خلفيتك في C/C++/Java؛ فكر في هذا على أنه طريقة Rust الآمنة والصريحة لإدارة ذلك.
  * **الحالة الأساسية `if arr.len() <= 1`**: الحالة الأساسية القياسية للتكرار في Quicksort. إذا كانت الشريحة تحتوي على 0 أو 1 عنصر، فهي مرتبة بالفعل، لذا ما عليك سوى العودة.
  * **`let pivot_index = partition(arr);`**: يستدعي هذا دالة `partition` (التي سننظر إليها بعد قليل) لإعادة ترتيب الشريحة. تقوم بإرجاع الموضع النهائي لعنصر المحور.
  * **`let (left, right) = arr.split_at_mut(pivot_index);`**: هذه ميزة أساسية في Rust للتعامل الآمن مع الأسماء المستعارة القابلة للتغيير.
      * `split_at_mut` هي طريقة متاحة للشرائح القابلة للتغيير. تأخذ فهرسًا وتقسم الشريحة القابلة للتغيير إلى شريحتين قابلتين للتغيير *منفصلتين*.
      * `left` ستكون `arr[0..pivot_index]` و `right` ستكون `arr[pivot_index..len]`.
      * هذا أساسي لـ **مدقق الاقتراض** في Rust. لا يمكنك الحصول على مرجعين قابلين للتغيير *لنفس البيانات* في نفس الوقت. تضمن `split_at_mut` أن `left` و `right` يشيران إلى أجزاء منفصلة تمامًا من المصفوفة الأصلية، مما يرضي مدقق الاقتراض ويمنع حالات تنافس البيانات في سياق متعدد الخيوط (حتى لو كان هذا أحادي الخيط، فإن المبدأ ينطبق).
  * **`quick_sort(left);`**: ترتيب الشريحة الفرعية `left` بشكل متكرر.
  * **`quick_sort(&mut right[1..]);`**: ترتيب الشريحة الفرعية `right` بشكل متكرر.
      * `right[1..]` مهم: تبدأ شريحة `right` عند `pivot_index`. نظرًا لأن `arr[pivot_index]` هو الآن عنصر المحور الموضوع في مكانه الصحيح، فإننا نستبعده من الاستدعاء التكراري على الجانب الأيمن.
      * `&mut` تقوم بشكل صريح بإعادة استعارة شريحة قابلة للتغيير من `right`.

-----

### `fn partition(arr: &mut [i32]) -> usize`

```rust
fn partition(arr: &mut [i32]) -> usize {
    let len = arr.len();
    let pivot = arr[len - 1];
    let mut i = 0;
    for j in 0..len - 1 {
        if arr[j] <= pivot {
            arr.swap(i, j);
            i += 1;
        }
    }
    arr.swap(i, len - 1);
    i
}
```

تطبق هذه الدالة مخطط تقسيم Lomuto، وهو طريقة شائعة لتقسيم مصفوفة لـ Quicksort.

  * **`let len = arr.len();`**: يحصل على طول الشريحة الحالية.
  * **`let pivot = arr[len - 1];`**: يتم اختيار **العنصر الأخير** من الشريحة كمحور.
  * **`let mut i = 0;`**: يعمل `i` كمؤشر إلى "الحد الفاصل" بين العناصر الأصغر من أو المساوية للمحور والعناصر الأكبر من المحور. ستكون العناصر على يسار `i` أقل من أو تساوي المحور.
  * **`for j in 0..len - 1`**: تقوم هذه الحلقة بالتكرار خلال جميع العناصر *ما عدا* المحور (الموجود عند `len - 1`).
  * **`if arr[j] <= pivot { ... }`**: إذا كان العنصر الحالي `arr[j]` أصغر من أو يساوي المحور:
      * **`arr.swap(i, j);`**: مبادلة `arr[j]` مع `arr[i]`. هذا ينقل العنصر الأصغر إلى قسم "أصغر من أو يساوي".
      * **`i += 1;`**: زيادة `i` لتوسيع قسم "أصغر من أو يساوي".
  * **`arr.swap(i, len - 1);`**: بعد الحلقة، `i` هو الموضع الصحيح للمحور. نقوم بتبديل المحور (الذي لا يزال عند `len - 1`) إلى موضعه النهائي المرتب. الآن، جميع العناصر على يسار `i` أقل من أو تساوي `arr[i]` (المحور)، وجميع العناصر على اليمين أكبر.
  * **`i`**: ترجع الدالة `i`، وهو الفهرس النهائي لعنصر المحور.

-----

### `fn main()`

```rust
fn main() {
    let mut arr = [3, 6, 8, 10, 1, 2, 1];
    println!("Before: {:?}", arr);
    quick_sort(&mut arr);
    println!("After: {:?}", arr);
}
```

  * **`let mut arr = [3, 6, 8, 10, 1, 2, 1];`**:
      * `let mut` تعلن عن **متغير قابل للتغيير**. هذا يسمح لك بإعادة تعيين المتغير أو تعديل محتوياته (إذا كان من نوع قابل للتغيير).
      * `[3, ...]` تنشئ **مصفوفة بحجم ثابت** في stack. حجمها معروف في وقت الترجمة.
  * **`println!("Before: {:?}", arr);`**: يستخدم ماكرو `println!` للإخراج.
      * `{:?}` هو محدد تنسيق **الطباعة للتDebug**. يستخدم السمة `Debug` لطباعة تمثيل يمكن للبشر قراءته للمصفوفة.
  * **`quick_sort(&mut arr);`**: يستدعي دالة `quick_sort`، ويمرر مرجعًا قابلًا للتغيير لمصفوفة `arr`.
  * **`println!("After: {:?}", arr);`**: يطبع المصفوفة مرة أخرى بعد الترتيب.

-----

### استنتاجات خاصة بـ Rust لك

  * **الملكية والاقتراض**: هذا الكود هو مثال رئيسي على المفاهيم الأساسية لـ Rust. أنت تمرر **مراجع (`&` و `&mut`)** بدلاً من نسخ البيانات. مراجع `&mut` ضرورية لتعديل المصفوفة في مكانها، و **مدقق الاقتراض** (مفروض من خلال `split_at_mut` على سبيل المثال) يضمن ألا يكون لديك أبدًا مراجع متعددة قابلة للتغيير لنفس البيانات، مما يلغي فئة كاملة من أخطاء التزامن في وقت الترجمة. من المرجح أن هذا هو أكبر تحول في النمط الفكري من لغات مثل Java أو Python، لكنه يوفر سلامة الذاكرة بدون جامع القمامة.
  * **الشرائح `[T]`**: هذه قوية بشكل لا يصدق للعمل مع البيانات المتجاورة. توفر عرضًا آمنًا وفعالًا لأجزاء من المصفوفات أو المتجهات دون تخصيص ذاكرة جديدة.
  * **ماكروات (`println!`)**: سترى `!` بعد العديد من دوال المكتبة القياسية (مثل `println!`، `vec!`، `format!`). هذه تشير إلى أنها **ماكروات**، وليست دوال عادية. تقوم الماكروات بتوسيع الكود في وقت الترجمة، مما يوفر مرونة وقوة أكبر (مثل الوسائط المتغيرة أو توليد الكود في وقت الترجمة) مقارنة بالدوال العادية.

نظرًا لخلفيتك، من المحتمل أن تقدر خصائص الأداء وضمانات السلامة التي تقدمها Rust، حتى لو استغرق "رقصة مدقق الاقتراض" بعض الوقت للاعتياد عليها. إنها طريقة مختلفة للتفكير في إدارة الذاكرة، لكنها تؤدي إلى كود قوي وفعال للغاية.