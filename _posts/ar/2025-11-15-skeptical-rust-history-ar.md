---
audio: false
generated: true
image: false
lang: ar
layout: post
model: x-ai/grok-4-fast
title: تاريخ ريبي للغة رست
translated: true
type: note
---

### الترجمة الإنجليزية وشرح المنشور  
العنوان: "تاريخ لغة Rust كما رأيته"

هذا تأمل طويل، شخصي، وناقد إلى حد كبير كتبه مبرمج خبير (على الأرجح تايواني، وينشر باللغة الصينية) عن لقائه المبكر بلغة Rust ولماذا، رغم شعبيتها الحالية، يظل متشككًا فيها بعمق — من الناحيتين التقنية والثقافية.

#### اللقاء المبكر (2009، جامعة إنديانا)
- أثناء الدراسة في جامعة إنديانا (IU)، كان لدى الكاتب زميلان في الفصل (من تخصصات غير علوم الحاسب على مستوى البكالوريوس) واجها صعوبة كبيرة في مقرر دان فريدمان المتقدم عن لغات البرمجة.
- كان هذان الزميلان من النوع الذي "يتباهى بكلام كبير" لكنهما لم يفهما حقًا المفاهيم العميقة. ومع ذلك، كانا جيدين في بناء الشبكات والترويج لأنفسهما.
- في صيف 2009، تدرب هذان الزميلان في Mozilla Research وعملا على نسخة مبكرة من لغة Rust (كان هذا من المشروع الشخصي لـ Graydon Hoare الذي تبنته موزيلا لاحقًا؛ ربما كان الزميلان من المساهمين الأوائل جدًا أو متدربين صيفيين في المشروع).
- في نهاية الصيف، قدما محاضرة في الجامعة مقدّمين لغة Rust للجميع. كانت هذه هي المرة الأولى التي يسمع فيها الكاتب عن اللغة.

#### محاضرة 2009 (الانطباع الأول للكاتب)
- كانت المحاضرة عبارة عن تسويق محض: شعارات كبيرة، ولا شيء تقريبًا من المادة التقنية.
- عرضا شريحًا مثلثًا يحتوي على "الميزات الثلاث الكبرى لـ Rust" — إحداها كانت "الأمان"، والاثنتين الأخريين نسيهما الكاتب.
- الادعاء الرئيسي: ستُحقق Rust إدارة ذاكرة آمنة بالكامل من خلال التحليل الثابت وحده دون أي جمع للمهملات (بدون GC على الإطلاق).
- غادر الكاتب وهو يفكر: "هذا مجرد ضجيج تسويقي من موزيلا. لن يطلقوا متصفحًا مبنيًا عليها. ستموت مثل جميع مشاريعهم البحثية الأخرى." (يذكر على وجه التحديد DrServ/DrJS كمشروع بحثي آخر لموزيلا لم ينجح).

#### الشكوك حول المصمم واختيار لغة البداية (Bootstrap)
- يشكك الكاتب في عمق Graydon Hoare (المبتكر الأصلي) في نظرية لغات البرمجة.
- على وجه الخصوص، يعتقد أن اختيار OCaml كلغة التنفيذ الأولى أظهر نقصًا في الذوق أو الفهم العميق (رأي مثير للجدل ولكنه ليس نادرًا بين بعض قدماء مجتمع PL الذين لا يحبون غرابة OCaml).

#### التطورات اللاحقة
- أحد هذين الزميلين بدأ لاحقًا مشروع دكتوراه حول لغة "عامة الأغراض" لوحدات معالجة الرسوميات (GPU) ادعت أنه يمكنك بناء أشجار، ورسوم بيانية، إلخ على وحدات معالجة الرسوميات. اعتقد الكاتب أن المشروع محكوم عليه بالفشل لأن وحدات معالجة الرسوميات مصممة لأحمال العمل المتوازية في البيانات، وليس للهياكل الثقيلة بالمؤشرات بشكل تعسفي. المشروع بالفعل لم يصبح عمليًا أبدًا، لكن الزميل لا يزال حصل على الدكتوراة ويعمل الآن على مترجم Rust في شركة تقنية كبيرة.

#### رحلة الكاتب الشخصية مع إدارة الذاكرة
- كان الكاتب مفتونًا شخصيًا بفكرة تحقيق أمان ذاكرة ثابت 100% دون GC (وهو بالضبط الادعاء الأصلي لـ Rust).
- قضى الكثير من الوقت في تصميم نماذج الذاكرة وتحليلات ثابتة محاولًا تحقيق ذلك الحلم.
- في أحد الأيام أخبر مستشاره Kent Dybvig (مؤلف Chez Scheme الأسطوري) عن الفكرة. رد كينت بهدوء:  
  "إدارة الذاكرة الثابتة بالكامل — هل هذا ممكن أصلاً؟ إدارة الذاكرة هي في جوهرها عملية ديناميكية."
- هذه الجملة الواحدة حطمت أوهام الكاتب. أدرك أن جمع المهملات الدقيق هو مشكلة غير قابلة للحسم في الحالة العامة (مرتبطة بمشكلة التوقف Halting Problem).
- عندما اقترح عد المراجع (reference counting) بدلاً من ذلك، أشار كينت إلى أن عد المراجع له تكلفة عالية وغالبًا ما يكون أداؤه أسوأ من GC جيد متعدد الأجيال (generational). فترات توقف GC الجيدة ليست مشكلة حقيقية إذا كان جامع المهملات مصممًا جيدًا (Chez Scheme يثبت ذلك).

#### Chez Scheme كنموذج مضاد
- الكاتب يحترم كينت ديبفيغ و Chez Scheme بعمق:
  - ترجمة فائقة السرعة.
  - GC قابل للضبط بدرجة عالية مع فترات توقف منخفضة.
  - الفلسفة: لا تضيع الوقت في تحسين الكود الغبي؛ افترض أن المبرمج كفء؛ اختر التجريدات البسيطة الصحيحة.
- بمعنى آخر، الحكمة > التعقيد القائم على القوة الغاشمة.

#### كيف اتضح أمر Rust في الواقع
- الحلم الأصلي "لإدارة الذاكرة الثابتة البحتة، لا وجود لـ GC أبدًا" قد مات.
- Rust الحديثة لديها:
  - `Rc<T>` / `Arc<T>` (عد المراجع مع جمع الدورات عبر `Weak`)
  - كود `unsafe` (إلزامي للعديد من المكتبات الواقعية: مكدسات الشبكة، المتصفحات، نواة أنظمة التشغيل، إلخ)
  - أبحاث مستمرة تحاول جعل أجزاء من `unsafe` أكثر أمانًا (Stacked Borrows, Tree Borrows، إلخ)، لكن كل نموذج جديد يضيف قيودًا مرة أخرى.
- ومع ذلك لا يزال التسويق والمجتمع يكرران شعار "ضمانات ثابتة قوية" و "التزامن بلا خوف".
- عندما تشير إلى الفجوات، يصبح الرد الرسمي "هذه فقط فلسفة Rust" أو "أنت لا تفهم مدقق الاقتراض (borrow checker)".

#### الموقف الحالي للكاتب
- هو يفهم تمامًا فترات الحياة (lifetimes)، والاقتراض (borrowing)، إلخ، وقد قام حتى بتدريس دورات متقدمة في Rust حيث نفذ الطلاب مترجمات للغات وظيفية (functional-language) في Rust.
- لكن كلما قام بتدريس Rust أكثر، كلما زاد تقديره لـ C++:
  - المؤشرات الذكية في C++ + RAII هما أبسط وأكثر تعبيرًا للعديد من المهام.
  - عندما تحتاج حقًا إلى أقصى أداء، سيظل يختار C/C++ بدلاً من Rust.
- يجد أن رسائل الخطأ في Rust صعبة الفك بشكل سيء السمعة، والحاجة المستمرة للصراع مع مدقق الاقتراض مزعجة.
- دفاع "الفلسفة" يشعر وكأنه عذر ديني لتسويات التصميم.

#### خلاصة القول
يرى الكاتب أن نجاح Rust الحديثة هو إلى حد كبير انتصار للتسويق + زخم النظام البيئي، وليس دليلاً على أن أفكارها الأساسية كانت سليمة بشكل جوهري أكثر من إنجازات decades of prior art (أنظمة المناطق Region systems، Cyclone، الأنواع الخطية Linear types، GC عالية الأداء، إلخ). هو يعتقد أن الادعاءات العظيمة الأصلية كانت ساذجة، وأن التسويات كانت حتمية، وأن المجتمع يختبئ الآن وراء "الفلسفة" عندما يتم مواجهته بالفجوات.

إنه نقد نادر من منظور داخلي من شخص:
1. شاهد Rust حرفيًا عند ولادتها،
2. درس أمان الذاكرة بعمق بنفسه،
3. كان لديه Kent Dybvig كمرشد،
4. لا يزال يختار C/C++ في عام 2025 رغم الضجة.

سواء أكنت توافق أم لا، فهو سرد مضاد مدروس للقصة السائدة "Rust هي المستقبل الذي وصل بالفعل".