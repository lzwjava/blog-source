---
audio: false
generated: true
lang: ar
layout: post
title: لغة برمجة رست
translated: true
type: note
---

حسناً، إليك دليل شامل حول لغة البرمجة Rust، يغطي مفاهيمها الأساسية وتركيبها اللغوي وميزاتها المتقدمة. Rust هي لغة برمجة أنظمة تركز على السلامة والسرعة والتزامن.

**I. مقدمة إلى Rust**

*   **ما هي Rust؟**
    *   Rust هي لغة برمجة مترجمة، ساكنة الأنماط، متعددة النماذج مصممة للأداء والسلامة، خاصة في مجالات مثل برمجة الأنظمة، ومحركات الألعاب، و Web Assembly، والأنظمة المدمجة.
    *   تحقق السلامة للذاكرة بدون جامع قمامة من خلال نظام الملكية والاستعارة وفترات الحياة.
    *   تؤكد Rust على التجريدات عديمة التكلفة، مما يعني أنك تحصل على ميزات عالية المستوى بدون تكلفة وقت تشغيل كبيرة.
*   **الميزات ومبادئ التصميم الرئيسية:**
    *   **سلامة الذاكرة:** تمنع الأخطاء الشائعة مثل dereference مؤشرات null، وسباق البيانات، وتجاوز سعة المخزن المؤقت في وقت الترجمة.
    *   **التزامن بدون سباق البيانات:** نظام الملكية يجعل كتابة كود تزامني آمن أسهل.
    *   **الأداء:** التحكم منخفض المستوى، والتجريدات عديمة التكلفة، والترجمة الفعالة تؤدي إلى أداء ممتاز، غالباً ما يكون مشابهاً لـ C++.
    *   **نظام أنواع معبر:** استدلال أنواع قوي، أنواع عامة، سمات (مشابهة للواجهات أو فئات الأنواع)، وأنواع بيانات جبرية.
    *   **أدوات ممتازة:** Cargo (نظام بناء ومدير حزم)، rustfmt (منظم الكود)، clippy (أداة فحص الكود).
    *   **نظام بيئي نامي:** مجتمع نابض بالحياة ونشط مع عدد متزايد من المكتبات والأطر.
*   **حالات الاستخدام:**
    *   أنظمة التشغيل
    *   محركات الألعاب
    *   Web Assembly (Wasm)
    *   الأنظمة المدمجة
    *   أدوات سطر الأوامر
    *   برمجة الشبكات
    *   العملات المشفرة
    *   الحوسبة عالية الأداء

**II. إعداد بيئة Rust الخاصة بك**

*   **التثبيت:**
    *   الطريقة الموصى بها لتثبيت Rust هي استخدام `rustup`، مثبت أدوات Rust الرسمي.
    *   قم بزيارة [https://rustup.rs/](https://rustup.rs/) واتبع التعليمات لنظام التشغيل الخاص بك.
    *   في أنظمة Unix، عادةً ما تشغل أمراً مثل: `curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh`
*   **التحقق من التثبيت:**
    *   افتح طرفيتك أو موجه الأوامر وشغل:
        *   `rustc --version`: تظهر إصدار مترجم Rust.
        *   `cargo --version`: تظهر إصدار Cargo.
*   **Cargo: نظام بناء Rust ومدير الحزم:**
    *   Cargo أساسي لإدارة مشاريع Rust. فهو يتعامل مع:
        *   بناء الكود الخاص بك.
        *   إدارة التبعيات (crates).
        *   تشغيل الاختبارات.
        *   نشر المكتبات.
    *   **إنشاء مشروع جديد:** `cargo new <project_name>` (ينشئ مشروع binary). `cargo new --lib <library_name>` (ينشئ مشروع مكتبة).
    *   **هيكل المشروع:** مشروع Cargo نموذجي يحتوي على:
        *   `Cargo.toml`: ملف البيان الذي يحتوي على وصف المشروع والتبعيات.
        *   `src/main.rs`: نقطة الدخول لمشاريع binary.
        *   `src/lib.rs`: نقطة الدخول لمشاريع المكتبات.
        *   `Cargo.lock`: يسجل الإصدارات الدقيقة للتبعيات المستخدمة في المشروع.
    *   **البناء:** `cargo build` (يبني المشروع في وضع التصحيح). `cargo build --release` (يبني المشروع مع تحسينات للإصدار).
    *   **التشغيل:** `cargo run` (يبني ويشغل الـ binary).
    *   **إضافة التبعيات:** أضف أسماء وإصدارات الـ crates إلى قسم `[dependencies]` في `Cargo.toml`. سيقوم Cargo بتنزيلها وبنائها تلقائياً.
    *   **تحديث التبعيات:** `cargo update`.

**III. تركيب Rust الأساسي والمفاهيم**

*   **!Hello, World**
    ```rust
    fn main() {
        println!("Hello, world!");
    }
    ```
    *   `fn main()`: الدالة الرئيسية حيث يبدأ تنفيذ البرنامج.
    *   `println!()`: ماكرو (يشار إليه بـ `!`) يطبع نصاً إلى وحدة التحكم.
*   **المتغيرات والقابلية للتغيير:**
    *   المتغيرات تكون غير قابلة للتغيير بشكل افتراضي. لجعل المتغير قابلاً للتغيير، استخدم الكلمة المفتاحية `mut`.
    *   التصريح: `let variable_name = value;` (استدلال النوع). `let variable_name: Type = value;` (تحديد النوع صراحةً).
    *   متغير قابل للتغيير: `let mut counter = 0; counter = 1;`
    *   الثوابت: تُصرح باستخدام `const`، يجب أن يكون لها تحديد نوع، وقيمتها يجب أن تكون معروفة في وقت الترجمة. `const MAX_POINTS: u32 = 100_000;`
    *   إعادة التعريف (Shadowing): يمكنك التصريح عن متغير جديد بنفس اسم متغير سابق؛ المتغير الجديد يحجب القديم.
*   **أنواع البيانات:**
    *   **الأنواع العددية (Scalar):** تمثل قيمة واحدة.
        *   **الأعداد الصحيحة:** `i8`, `i16`, `i32`, `i64`, `i128`, `isize` (موقعة بحجم المؤشر)؛ `u8`, `u16`, `u32`, `u64`, `u128`, `usize` (غير موقعة بحجم المؤشر). يمكن أن تحتوي حرفيات الأعداد الصحيحة على لاحقات (مثلاً `10u32`).
        *   **الأعداد العشرية:** `f32` (دقة مفردة), `f64` (دقة مزدوجة).
        *   **القيم المنطقية:** `bool` (`true`, `false`).
        *   **الحروف:** `char` (قيم Unicode scalar، 4 بايت).
        *   **نوع الوحدة (Unit):** `()` (يمثل tuple فارغ أو غياب القيمة).
    *   **الأنواع المركبة:** تجمع عدة قيم.
        *   **Tuples:** سلاسل مرتبة ذات حجم ثابت من العناصر بأنواع مختلفة محتملة. `let my_tuple = (1, "hello", 3.14); let (x, y, z) = my_tuple; let first = my_tuple.0;`
        *   **المصفوفات (Arrays):** مجموعات ذات حجم ثابت من العناصر من نفس النوع. `let my_array = [1, 2, 3, 4, 5]; let months: [&str; 12] = ["...", "..."]; let first = my_array[0];`
        *   **الشرائح (Slices):** مشاهدات ذات حجم ديناميكي لتسلسل متجاور من العناصر في مصفوفة أو شريحة أخرى. `let slice = &my_array[1..3];`
    *   **أنواع مهمة أخرى:**
        *   **السلاسل النصية:**
            *   `String`: بيانات سلسلة نصية مملوكة، قابلة للنمو والتغيير. تُنشأ باستخدام `String::from("...")` أو بتحويل أنواع السلاسل النصية الأخرى.
            *   `&str`: شريحة سلسلة نصية، مشهد غير قابل للتغيير لبيانات سلسلة نصية. غالباً ما يشار إليها بـ "string literal" عندما تكون مضمنة مباشرة في الكود (مثلاً `"hello"`).
        *   **المتجهات (`Vec<T>`):** مصفوفات قابلة لتغيير الحجم يمكن أن تنمو أو تتقلص. `let mut my_vec: Vec<i32> = Vec::new(); my_vec.push(1); let another_vec = vec![1, 2, 3];`
        *   **خرائط التجزئة (`HashMap<K, V>`):** تخزن أزواج مفتاح-قيمة حيث تكون المفاتيح فريدة ومن نوع قابل للتجزئة. تتطلب `use std::collections::HashMap;`.
*   **المعاملات:**
    *   **الحسابية:** `+`, `-`, `*`, `/`, `%`.
    *   **المقارنة:** `==`, `!=`, `>`, `<`, `>=`, `<=`.
    *   **المنطقية:** `&&` (AND), `||` (OR), `!` (NOT).
    *   **البتية:** `&` (AND), `|` (OR), `^` (XOR), `!` (NOT), `<<` (إزاحة لليسار), `>>` (إزاحة لليمين).
    *   **التعيين:** `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`.
*   **تحكم التدفق:**
    *   **`if`, `else if`, `else`:** تنفيذ شرطي.
        ```rust
        let number = 7;
        if number < 5 {
            println!("condition was true");
        } else if number == 7 {
            println!("number is seven");
        } else {
            println!("condition was false");
        }
        ```
    *   **`loop`:** حلقة لا نهائية (استخدم `break` للخروج).
        ```rust
        loop {
            println!("again!");
            break;
        }
        ```
    *   **`while`:** حلقة تستمر طالما أن الشرط صحيح.
        ```rust
        let mut counter = 0;
        while counter < 5 {
            println!("counter is {}", counter);
            counter += 1;
        }
        ```
    *   **`for`:** التكرار عبر المجموعات.
        ```rust
        let a = [10, 20, 30, 40, 50];
        for element in a.iter() {
            println!("the value is: {}", element);
        }

        for number in 1..5 { // يتكرر من 1 إلى (ولكن لا يشمل) 5
            println!("{}", number);
        }
        ```
    *   **`match`:** بناء تحكم تدفق قوي يقارن قيمة بسلسلة من الأنماط.
        ```rust
        let number = 3;
        match number {
            1 => println!("one"),
            2 | 3 => println!("two or three"),
            4..=6 => println!("four, five, or six"),
            _ => println!("something else"), // النمط العام
        }
        ```
    *   **`if let`:** طريقة أكثر إيجازاً للتعامل مع التعدادات أو الخيارات حيث تهتم بمتغير واحد أو قليل فقط.
        ```rust
        let some_value = Some(5);
        if let Some(x) = some_value {
            println!("The value is: {}", x);
        }
        ```

**IV. الملكية، الاستعارة، وفترات الحياة**

هذا هو جوهر ضمانات سلامة الذاكرة في Rust.

*   **الملكية:**
    *   كل قيمة في Rust لها متغير هو *مالكها*.
    *   يمكن أن يكون هناك مالك واحد فقط للقيمة في وقت واحد.
    *   عندما يخرج المالك من النطاق، سيتم التخلص من القيمة (يتم تحرير ذاكرتها).
*   **الاستعارة:**
    *   بدلاً من نقل الملكية، يمكنك إنشاء مراجع للقيمة. هذا يسمى *استعارة*.
    *   **الاستعارة غير القابلة للتغيير (`&`):** يمكن أن يكون لديك عدة مراجع غير قابلة للتغيير للقيمة في نفس الوقت. لا تسمح الاستعارات غير القابلة للتغيير بتعديل القيمة المستعارة.
    *   **الاستعارة القابلة للتغيير (`&mut`):** يمكن أن يكون لديك مرجع قابل للتغيير واحد فقط للقيمة في وقت واحد. تسمح الاستعارات القابلة للتغيير بتعديل القيمة المستعارة.
    *   **قواعد الاستعارة:**
        1.  في أي وقت معين، يمكنك الحصول على *إما* مرجع قابل للتغيير واحد *أو* أي عدد من المراجع غير القابلة للتغيير.
        2.  يجب أن تكون المراجع صالحة دائماً.
*   **فترات الحياة:**
    *   فترات الحياة هي شروحات تصف النطاق الذي يكون فيه المرجع صالحاً. يستخدم مترجم Rust معلومات فترة الحياة لضمان أن المراجع لا تعيش أكثر من البيانات التي تشير إليها (مؤشرات متدلية).
    *   في كثير من الحالات، يمكن للمترجم استنتاج فترات الحياة تلقائياً (حذف فترة الحياة).
    *   قد تحتاج إلى شرح فترات الحياة صراحةً في تواقيع الدوال أو تعريفات الـ structs عندما تكون فترات حياة المراجع غير واضحة.
    *   مثال على شرح فترة الحياة صراحةً:
        ```rust
        fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
            if x.len() > y.len() {
                x
            } else {
                y
            }
        }
        ```
        يشير `'a` إلى أن شريحة السلسلة النصية المُرجعة ستعيش على الأقل طالما عاشت شرائح السلاسل النصية المدخلة.

**V. الـ Structs، والـ Enums، والوحدات النمطية**

*   **الـ Structs:** أنواع بيانات معرفة من قبل المستخدم تجمع معاً حقولاً مسماة.
    ```rust
    struct User {
        active: bool,
        username: String,
        email: String,
        sign_in_count: u64,
    }

    fn main() {
        let mut user1 = User {
            active: true,
            username: String::from("someusername123"),
            email: String::from("someone@example.com"),
            sign_in_count: 1,
        };

        user1.email = String::from("another@example.com");

        let user2 = User {
            email: String::from("another@example.com"),
            ..user1 // بناء تحديث الـ struct، الحقول المتبقية من user1
        };
    }
    ```
    *   tuple structs: tuples مسماة بدون حقول مسماة. `struct Color(i32, i32, i32);`
    *   unit-like structs: structs بدون حقول. `struct AlwaysEqual;`
*   **الـ Enums (التعدادات):** تعرّف نوعاً عن طريق تعداد متغيراته المحتملة.
    ```rust
    enum Message {
        Quit,
        Move { x: i32, y: i32 }, // struct مجهول
        Write(String),
        ChangeColor(i32, i32, i32), // يشبه الـ tuple
    }

    fn main() {
        let q = Message::Quit;
        let m = Message::Move { x: 10, y: 5 };
        let w = Message::Write(String::from("hello"));

        match m {
            Message::Quit => println!("Quit"),
            Message::Move { x, y } => println!("Move to x={}, y={}", x, y),
            Message::Write(text) => println!("Write: {}", text),
            Message::ChangeColor(r, g, b) => println!("Change color to r={}, g={}, b={}", r, g, b),
        }
    }
    ```
    *   يمكن أن تحمل الـ Enums البيانات مباشرة داخل متغيراتها.
*   **الوحدات النمطية:** تنظم الكود داخل الـ crates (الحزم).
    *   استخدم الكلمة المفتاحية `mod` لتعريف وحدة نمطية.
    *   يمكن أن تحتوي الوحدات النمطية على وحدات نمطية أخرى، و structs، و enums، ودوال، إلخ.
    *   تحكم في الرؤية باستخدام `pub` (عام) و private (افتراضي).
    *   الوصول إلى العناصر داخل الوحدات النمطية باستخدام مسار الوحدة النمطية (مثلاً `my_module::my_function()`).
    *   إحضار العناصر إلى النطاق الحالي باستخدام الكلمة المفتاحية `use` (مثلاً `use std::collections::HashMap;`).
    *   فصل الوحدات النمطية إلى ملفات مختلفة (الاتفاقية: وحدة نمطية باسم `my_module` تذهب إلى `src/my_module.rs` أو `src/my_module/mod.rs`).

**VI. السمات والأنواع العامة**

*   **السمات:** مشابهة للواجهات أو فئات الأنواع في اللغات الأخرى. تعرّف مجموعة من الدوال التي يجب على نوع أن ينفذها لتحقيق عقد معين.
    ```rust
    pub trait Summary {
        fn summarize(&self) -> String;
    }

    pub struct NewsArticle {
        pub headline: String,
        pub location: String,
        pub author: String,
        pub content: String,
    }

    impl Summary for NewsArticle {
        fn summarize(&self) -> String {
            format!("{}, by {} ({})", self.headline, self.author, self.location)
        }
    }

    pub struct Tweet {
        pub username: String,
        pub content: String,
        pub reply: bool,
        pub retweet: bool,
    }

    impl Summary for Tweet {
        fn summarize(&self) -> String {
            format!("{}: {}", self.username, self.content)
        }
    }

    fn main() {
        let tweet = Tweet {
            username: String::from("horse_ebooks"),
            content: String::from("of course, as you probably already know, people"),
            reply: false,
            retweet: false,
        };

        println!("New tweet available! {}", tweet.summarize());
    }
    ```
    *   يمكن أن يكون للسمات تنفيذ افتراضي للدوال.
    *   يمكن استخدام السمات كقيود للأنواع العامة.
*   **الأنواع العامة:** اكتب كوداً يمكنه العمل مع أنواع متعددة بدون معرفة الأنواع المحددة في وقت الترجمة.
    ```rust
    fn largest<T: PartialOrd + Copy>(list: &[T]) -> T {
        let mut largest = list[0];

        for &item in list.iter() {
            if item > largest {
                largest = item;
            }
        }

        largest
    }

    fn main() {
        let number_list = vec![34, 50, 25, 100, 65];
        let result = largest(&number_list);
        println!("The largest number is {}", result);

        let char_list = vec!['y', 'm', 'a', 'q'];
        let result = largest(&char_list);
        println!("The largest char is {}", result);
    }
    ```
    *   معاملات النوع تُصرح داخل الأقواس الزاوية `<T>`.
    *   قيود السمة (`T: PartialOrd + Copy`) تحدد الوظيفة التي يجب على النوع العام تنفيذها.
    *   `PartialOrd` يسمح بالمقارنة باستخدام `>`، و `Copy` تعني أنه يمكن نسخ النوع بالقيمة.

**VII. معالجة الأخطاء**

تركز Rust على معالجة الأخطاء الصريحة.

*   **تعداد `Result`:** يمثل إما النجاح (`Ok`) أو الفشل (`Err`).
    ```rust
    enum Result<T, E> {
        Ok(T),
        Err(E),
    }
    ```
    *   `T` هو نوع قيمة النجاح.
    *   `E` هو نوع قيمة الخطأ.
    *   يُستخدم عادةً للعمليات التي قد تفشل (مثلاً، إدخال/إخراج الملفات، طلبات الشبكة).
    *   معامل `?` هو سكر نحوي للتعامل مع قيم `Result`. إذا كانت `Result` هي `Ok`، فإنها تستخرج القيمة؛ إذا كانت `Err`، فإنها ترجع الخطأ مبكراً من الدالة الحالية.
*   **ماكرو `panic!`:** يتسبب في انهيار البرنامج فوراً. يُستخدم عموماً للأخطاء غير القابلة للاسترداد.
    ```rust
    fn main() {
        let v = vec![1, 2, 3];
        // v[99]; // هذا سيتسبب في panic في وقت التشغيل
        panic!("Crash and burn!");
    }
    ```
*   **تعداد `Option`:** يمثل قيمة قد تكون موجودة أو لا.
    ```rust
    enum Option<T> {
        Some(T),
        None,
    }
    ```
    *   يُستخدم لتجنب مؤشرات null.
    *   تُستخدم دوال مثل `unwrap()`, `unwrap_or()`, `map()`, و `and_then()` للعمل مع قيم `Option`.
    ```rust
    fn divide(a: i32, b: i32) -> Option<i32> {
        if b == 0 {
            None
        } else {
            Some(a / b)
        }
    }

    fn main() {
        let result1 = divide(10, 2);
        match result1 {
            Some(value) => println!("Result: {}", value),
            None => println!("Cannot divide by zero"),
        }

        let result2 = divide(5, 0);
        println!("Result 2: {:?}", result2.unwrap_or(-1)); // يرجع -1 إذا كانت None
    }
    ```

**VIII. الإغلاقات والمكررات**

*   **الإغلاقات (Closures):** دوال مجهولة يمكنها التقاط متغيرات من النطاق المحيط بها.
    ```rust
    fn main() {
        let x = 4;
        let equal_to_x = |z| z == x; // إغلاق يلتقط x

        println!("Is 5 equal to x? {}", equal_to_x(5));
    }
    ```
    *   تركيب الإغلاق: `|parameters| -> return_type { body }` (يمكن غالباً استنتاج نوع الإرجاع).
    *   يمكن للإغلاقات التقاط المتغيرات بالمرجع (`&`)، أو بالمرجع القابل للتغيير (`&mut`)، أو بالقيمة (بنقل الملكية). يستنتج Rust نوع الالتقاط. استخدم الكلمة المفتاحية `move` لإجبار نقل الملكية.
*   **المكررات (Iterators):** توفر طريقة لمعالجة تسلسل من العناصر.
    *   تُنشأ باستدعاء الدالة `iter()` على مجموعات مثل المتجهات، والمصفوفات، وخرائط التجزئة (للتكرار غير القابل للتغيير)، و `iter_mut()` للتكرار القابل للتغيير، و `into_iter()` لاستهلاك المجموعة وأخذ ملكية عناصرها.
    *   المكررات كسولة؛ تنتج القيم فقط عندما تُستهلك صراحةً.
    *   محولات المكررات الشائعة (دوال تحول المكررات): `map()`, `filter()`, `take()`, `skip()`, `zip()`, `enumerate()`، إلخ.
    *   مستهلكات المكررات الشائعة (دوال تنتج قيمة نهائية): `collect()`, `sum()`, `product()`, `fold()`, `any()`, `all()`، إلخ.
    ```rust
    fn main() {
        let v1 = vec![1, 2, 3];

        let v1_iter = v1.iter(); // ينشئ مكرراً فوق v1

        for val in v1_iter {
            println!("Got: {}", val);
        }

        let v2: Vec<_> = v1.iter().map(|x| x + 1).collect(); // تحويل وجمع
        println!("v2: {:?}", v2);

        let sum: i32 = v1.iter().sum(); // استهلاك المكرر للحصول على مجموع
        println!("Sum of v1: {}", sum);
    }
    ```

**IX. المؤشرات الذكية**

المؤشرات الذكية هي هياكل بيانات تتصرف مثل المؤشرات ولكن لديها أيضاً وصف بيانات إضافية وقدرات. تفرض مجموعات مختلفة من القواعد compared to المراجع العادية.

*   **`Box<T>`:** أبسط مؤشر ذكي. يخصص ذاكرة على الـ heap ويوفر ملكية القيمة. عندما يخرج `Box` من النطاق، يتم التخلص من القيمة على الـ heap. مفيد لـ:
    *   البيانات التي لا يكون حجمها معروفاً في وقت الترجمة.
    *   نقل ملكية كميات كبيرة من البيانات.
    *   إنشاء هياكل بيانات متكررة.
*   **`Rc<T>` (عد المراجع):** يمكن أجزاء متعددة من البرنامج من الوصول للقراءة فقط إلى نفس البيانات. يتم تنظيف البيانات فقط عندما يخرج آخر مؤشر `Rc` من النطاق. غير آمن للخيوط.
*   **`Arc<T>` (عد المراجع ذرياً):** مشابه لـ `Rc<T>` ولكنه آمن للخيوط للاستخدام في سيناريوهات التزامن. لديه بعض النفقات العامة في الأداء compared to `Rc<T>`.
*   **`Cell<T>` و `RefCell<T>` (القدرة على التغيير الداخلي):** يسمحان بتعديل البيانات حتى عندما تكون هناك مراجع غير قابلة للتغيير لها. هذا ينتهك قواعد الاستعارة المعتادة لـ Rust ويُستخدم في مواقف محدودة ومسيطر عليها.
    *   `Cell<T>`: للأنواع التي هي `Copy`. تسمح بتعيين القيمة والحصول عليها.
    *   `RefCell<T>`: للأنواع التي ليست `Copy`. يوفر فحوص استعارة في وقت التشغيل (يتسبب في panic إذا انتهكت قواعد الاستعارة في وقت التشغيل).
*   **`Mutex<T>` و `RwLock<T>` (بدائيات التزامن):** يوفران آليات للوصول المشترك القابل للتغيير الآمن عبر الخيوط.
    *   `Mutex<T>`: يسمح لخيط واحد فقط بالاحتفاظ بالقفل والوصول إلى البيانات في وقت واحد.
    *   `RwLock<T>`: يسمح لعدة قراء أو كاتب واحد بالوصول إلى البيانات.

**X. التزامن**

لدى Rust دعم مدمج ممتاز للتزامن.

*   **الخيوط:** أنشئ خيوط نظام تشغيل جديدة باستخدام `std::thread::spawn`.
    ```rust
    use std::thread;
    use std::time::Duration;

    fn main() {
        let handle = thread::spawn(|| {
            for i in 1..10 {
                println!("hi number {} from the spawned thread!", i);
                thread::sleep(Duration::from_millis(1));
            }
        });

        for i in 1..5 {
            println!("hi number {} from the main thread!", i);
            thread::sleep(Duration::from_millis(1));
        }

        handle.join().unwrap(); // انتظر حتى ينتهي الخيط المُنشأ
    }
    ```
*   **تمرير الرسائل:** استخدم القنوات (الموفرة من `std::sync::mpsc`) لإرسال البيانات بين الخيوط.
    ```rust
    use std::sync::mpsc;
    use std::thread;
    use std::time::Duration;

    fn main() {
        let (tx, rx) = mpsc::channel();

        thread::spawn(move || {
            let val = String::from("hi");
            tx.send(val).unwrap();
            // println!("val is {}", val); // خطأ: val تم نقلها
        });

        let received = rx.recv().unwrap();
        println!("Got: {}", received);
    }
    ```
*   **التزامن بحالة مشتركة:** استخدم المؤشرات الذكية مثل `Mutex<T>` و `Arc<T>` للوصول المشترك القابل للتغيير الآمن عبر خيوط متعددة.

**XI. الماكرو**

الماكرو هو شكل من أشكال البرمجة الفوقية في Rust. يسمح لك بكتابة كود يكتب كوداً آخر.

*   **الماكرو التقريري (`macro_rules!`):** يطابق الأنماط ويستبدلها بكود آخر. قوي لتقليل الكود المتكرر.
    ```rust
    macro_rules! vec {
        ( $( $x:expr ),* ) => {
            {
                let mut temp_vec = Vec::new();
                $(
                    temp_vec.push($x);
                )*
                temp_vec
            }
        };
    }

    fn main() {
        let my_vec = vec![1, 2, 3, 4];
        println!("{:?}", my_vec);
    }
    ```
*   **الماكرو الإجرائي:** أقوى وأكثر تعقيداً من الماكرو التقريري. يعمل على شجرة التركيب المجردة (AST) لكود Rust. هناك ثلاثة أنواع:
    *   **الماكرو الشبيه بالدوال:** يبدو مثل استدعاءات الدوال.
    *   **الماكرو الشبيه بالسمات:** يُستخدم مع تركيب `#[...]`.
    *   **ماكرو الاشتقاق:** يُستخدم مع `#[derive(...)]` لتنفيذ السمات تلقائياً.

**XII. الاختبار**

لدى Rust دعم مدمج لكتابة وتشغيل الاختبارات.

*   **اختبارات الوحدة:** تختبر وحدات فردية من الكود (دوال، وحدات نمطية). توضع عادة في نفس ملف الكود الذي تختبره، داخل وحدة نمطية `#[cfg(test)]`.
    ```rust
    pub fn add(left: usize, right: usize) -> usize {
        left + right
    }

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn it_works() {
            let result = add(2, 2);
            assert_eq!(result, 4);
        }
    }
    ```
*   **اختبارات التكامل:** تختبر كيف تعمل أجزاء مختلفة من مكتبتك أو binary معاً. توضع في دليل `tests` منفصل في المستوى الأعلى لمشروعك.
*   **تشغيل الاختبارات:** استخدم الأمر `cargo test`.

**XIII. Rust غير الآمن**

ضمانات السلامة في Rust يفرضها المترجم. ومع ذلك، هناك مواقف قد تحتاج فيها إلى تجاوز هذه الضمانات. يتم ذلك باستخدام الكلمة المفتاحية `unsafe`.

*   **كتلة `unsafe`:** يمكن للكود داخل كتلة `unsafe` تنفيذ عمليات لا يستطيع المترجم ضمان أنها آمنة، مثل:
    *   dereference المؤشرات الأولية (`*const T`, `*mut T`).
    *   استدعاء دوال أو طرق `unsafe`.
    *   الوصول إلى حقول `union`s.
    *   الربط بكود خارجي (غير Rust).
*   **دوال `unsafe`:** الدوال التي تحتوي على عمليات `unsafe` يتم标记ها نفسها كـ `unsafe`. استدعاء دالة `unsafe` يتطلب كتلة `unsafe`.
*   **أسباب استخدام `unsafe`:** الواجهة مع مكتبات C، برمجة الأنظمة منخفضة المستوى، كود حرج الأداء حيث يتم الحفاظ على ثوابت السلامة يدوياً.
*   **ملاحظة مهمة:** يجب استخدام `unsafe` باعتدال وبحذر شديد. إنها مسؤوليتك لضمان سلامة الذاكرة داخل كتل `unsafe`.

**XIV. النظام البيئي لـ Rust**

*   **Crates (الحزم):** مكتبات أو تنفيذيات يمكن استخدامها في مشاريع Rust. تُوجد على [https://crates.io/](https://crates.io/).
*   **Crates شائعة:**
    *   `serde`: التسلسل وإلغاء التسلسل.
    *   `tokio`, `async-std`: البرمجة غير المتزامنة.
    *   `actix-web`, `rocket`: أطر عمل الويب.
    *   `diesel`, `sea-orm`: معارض كائن-علائقي (ORMs).
    *   `clap`, `structopt`: تحليل وسيطات سطر الأوامر.
    *   `log`, `env_logger`: التسجيل.
    *   `rand`: توليد الأعداد العشوائية.
*   **مكتبة Rust القياسية (`std`):** توفر الوظائف الأساسية.

**XV. موارد التعلم**

*   **كتاب لغة البرمجة Rust:** الدليل الرسمي والشامل ([https://doc.rust-lang.org/book/](https://doc.rust-lang.org/book/)).
*   **Rust by Example:** مجموعة من الأمثلة القابلة للتشغيل توضح ميزات Rust المختلفة ([https://doc.rust-lang.org/rust-by-example/](https://doc.rust-lang.org/rust-by-example/)).
*   **دورة Rustlings:** مجموعة من التمارين الصغيرة لتعويدك على قراءة وكتابة كود Rust ([https://github.com/rust-lang/rustlings](https://github.com/rust-lang/rustlings)).
*   **توثيق Rust:** توثيق API الرسمي ([https://doc.rust-lang.org/std/](https://doc.rust-lang.org/std/)).
*   **مدونة Rust:** إعلانات وتحديثات رسمية ([https://blog.rust-lang.org/](https://blog.rust-lang.org/)).
*   **Reddit (r/rust)، Discord، ومنصات مجتمعية أخرى.**

يوفر هذا الدليل أساساً متيناً لتعلم Rust. أفضل طريقة لإتقانها هي ممارسة كتابة كود Rust، واستكشاف النظام البيئي، والتفاعل مع المجتمع. حظاً سعيداً في رحلتك مع Rust!