---
audio: false
generated: true
image: false
lang: ar
layout: post
model: x-ai/grok-4-fast
title: فرز سريع مقابل فرز دمج
translated: true
type: note
---

### لماذا يبدو فرز سريع صعبًا (بينما لا يبدو فرز الدمج كذلك)

أنت محق تمامًا — تنفيذ خوارزمية الفرز السريع من الصفر دون الرجوع إلى مراجع قد يشبه مصارعة خنزير مدهون، بينما يشبه فرز الدمج طي الملابس: منهجي ومتوقع. تدفق فرز الدمج "فرّق تسد واجمع" هو خطي وعودي بطريقة نظيفة، دون مفاجآت في خطوة الدمج. من ناحية أخرى، يعتمد الفرز السريع *في مكانه* على خدعة تقسيم ذكية تتضمن تبادل العناصر حول "المحور" (نقطة التقسيم المختارة). يبدو الأمر فوضويًا في البداية لأن المحور ليس ثابتًا — إنه أشبه بحكم يتم إعادة ترتيبه خلال المباراة. ولكن بمجرد أن تفهم الفكرة البديهية، ستجدها فعالة بأناقة (متوسط الوقت O(n log n)، وأسوأ حالة O(n²) إذا كانت اختيارات المحور سيئة).

دعني أقدم لك الفرز السريع من خلال عدسة طبيعية تشبه القصة: تخيل ترتيب كومة فوضوية من الكتب على رف حسب الطول. بدلاً من تقسيم الكومة إلى نصفين، وقياس كل شيء، ثم الدمج (هذا هو فرز الدمج)، تختار كتابًا واحدًا كـ "معيار" (المحور)، ثم تعيد ترتيب الكتب الأخرى بحيث تكون جميع الكتب الأقصر إلى يساره وجميع الكتب الأطول إلى يمينه. ينتهي الأمر بالمحور في مكانه *النهائي*، وتكرر العملية بشكل عودي فقط على الكومتين الفرعيتين اليسرى واليمنى. لا حاجة لمساحة إضافية — مجرد تبادل للأماكن على الرف. إنه يشبه حفل رفع العلم الهولندي "quicksort" (ومن هنا جاء الاسم)، حيث تقوم بتقسيم الكتب إلى ثلاث مجموعات: أقصر، معيار، أطول.

### لماذا تعمل: سحر التقسيم

يعمل الفرز السريع بسبب **استراتيجية فرّق تسد مع ضمان**: كل خطوة تقسيم تضع *عنصرًا واحدًا على الأقل* (المحور) في موقعه الصحيح النهائي، مما يقلل المشكلة بمقدار ذلك العنصر على الأقل في كل مرة. في أفضل الحالات، يقسم المحور المصفوفة بشكل متساوٍ (مثل التقسيم إلى نصفين في فرز الدمج)، مما يؤدي إلى عودية متوازنة. في أسوأ الحالات (مثل مصفوفة مرتبة مسبقًا مع اختيار محور سيء)، تتحول الخوارزمية إلى O(n²) مثل فرز الفقاعة — ولكن اختيارات المحور الجيدة تجعلها سريعة جدًا في الممارسة العملية.

الفكرة الرئيسية: **التقسيم يفرض ثوابت**. بعد عملية تقسيم واحدة:
- كل شيء يسار المحور ≤ المحور.
- كل شيء يمين المحور ≥ المحور.
- المحور أصبح مرتبًا الآن إلى الأبد — لا حاجة للمسّه مرة أخرى.

هذا يضمن التقدم: عمق شجرة العودية يكون على الأكثر log n في المتوسط، وكل مستوى يقوم بعمل إجمالي O(n) (مسح وتبادل).

### كيفية اختيار المحور (ولماذا "يتحرك" أثناء المقارنات)

المحور ليس مقدسًا — إنه مجرد أي عنصر تختاره ليكون المعيار. يمكن للاختيارات السيئة (مثل اختيار العنصر الأول دائمًا) أن تخل بالتوازن، إليك تدرج طبيعي للاستراتيجيات، من البسيطة إلى القوية:

1.  **ساذج: اختر العنصر الأول (أو الأخير).**
    - سهل البرمجة، لكنه محفوف بالمخاطر. في مصفوفة مرتبة `[1,2,3,4,5]`، محور=1 يعني أن الجانب الأيسر فارغ والجانب الأيمن به 4 عناصر — تصبح العودية غير متوازنة وعميقة.
    - "الحركة": أثناء التقسيم، تقارن كل شيء آخر بقيمة هذا المحور، لكنك تبادل العناصر *حول* موقعه. المحور نفسه يتم تبديله إلى مكانه الصحيح عندما تتقاطع الحدود عنده.

2.  **أفضل: اختر العنصر الأوسط.**
    - قم بتبديله مع النهاية مؤقتًا، واستخدمه كمحور. أكثر توازنًا بشكل بديهي (أقرب إلى الوسيط)، لكنه لا يزال معرضًا للمدخلات المرتبة أو المرتبة عكسيًا.

3.  **الأفضل في الممارسة العملية: اختر عنصرًا عشوائيًا.**
    - قم بتبديله مع النهاية، ثم قم بالتقسيم. العشوائية توازن الحالات السيئة، مما يجعل أسوأ حالة غير محتملة (باحتمالية عالية، يبقى الأداء O(n log n)). هذا ما تستخدمه معظم المكتبات.

4.  **متقدم (للمقابلات): وسيط الثلاثة.**
    - اختر الوسيط بين العناصر الأول والأوسط والأخير ليكون المحور. سريع الحساب، ويتجنب المزالق الشائعة.

في الكود، غالبًا ما "تثبت" المحور عن طريق تبديله إلى النهاية أولاً، ثم تقوم بالتقسيم حول *قيمته* (وليس موقعه)، ثم تعيد تبديله إلى المكان الذي ينتمي إليه. هذا هو السبب في أن المحور يبدو وكأنه "يتحرك" — فهو ليس ثابتًا؛ عملية التقسيم تجد موقعه ديناميكيًا من خلال مؤشرين (أيسر وأيمن) يتقدمان نحو بعضهما البعض، ويقومان بتبادل العناصر التي تنتهك القاعدة.

### مثال عملي: ترتيب [3, 7, 1, 9, 4] باستخدام العنصر الأخير كمحور

لنمر بخطوة تقسيم واحدة. المصفوفة: `[3, 7, 1, 9, 4]`. المحور = الأخير = 4. (سنقوم بتبديله حسب الحاجة.)

- ابدأ بمؤشر أيسر عند الفهرس 0 (القيمة 3)، ومؤشر أيمن عند الفهرس 3 (القيمة 9، لأن المحور عند 4).
- امسح من اليسار: 3 < 4؟ نعم، اتركه. التالي، 7 > 4؟ نعم، لكن انتظر — نبدله مع أول عنصر >4 من اليمين.
- في الواقع، تقسيم Lomuto القياسي (أسلوب المؤشر الواحد البسيط):
  1. i = -1 (حد للعناصر < المحور).
  2. من j = 0 إلى n-2 (تخطى المحور):
     - إذا كان arr[j] ≤ المحور (4)، قم بتبديل arr[++i] مع arr[j]. (وسّع الجانب الأيسر.)
  3. أخيرًا، قم بتبديل المحور مع arr[++i] لوضعه في مكانه.

خطوة بخطوة:
- j=0: 3 ≤4؟ نعم. i=0، بدّل arr[0] مع arr[0] (لا تغيير). المصفوفة: [3,7,1,9,4]
- j=1: 7 ≤4؟ لا. تخط.
- j=2: 1 ≤4؟ نعم. i=1، بدّل arr[1] (7) مع arr[2] (1). المصفوفة: [3,1,7,9,4]
- j=3: 9 ≤4؟ لا. تخط.
- النهاية: بدّل المحور (4 عند الفهرس 4) مع arr[++i=2] (7). المصفوفة: [3,1,4,9,7]

الآن: يسار 4 (الفهرس 2) هو [3,1] (كلاهما ≤4، غير مرتبين)، يمين [9,7] (كلاهما ≥4، غير مرتبين). المحور=4 *انتهى*. كرر العملية على اليسار [3,1] واليمين [9,7].

- اليسار: المحور=1، يقسم إلى [1,3].
- اليمين: المحور=7، يقسم إلى [7,9].

الترتيب الكامل: [1,3,4,7,9]. أترى؟ كل خطوة تثبت التقدم، والتبادلات "تحرك" المحور إلى مكانه.

### رسم تخطيطي للكود الزائف (لتسهيل التنفيذ)

```
quicksort(arr, low, high):
    if low < high:
        pivot_idx = partition(arr, low, high)
        quicksort(arr, low, pivot_idx-1)
        quicksort(arr, pivot_idx+1, high)

partition(arr, low, high):  # أسلوب Lomuto، المحور عند high
    pivot = arr[high]
    i = low - 1
    for j in low to high-1:
        if arr[j] <= pivot:
            i += 1
            swap arr[i], arr[j]
    swap arr[i+1], arr[high]
    return i+1
```

"الحركة" تحدث في عمليات التبديل هذه: العناصر تتبادل الأماكن حتى يستقر المحور. تدرب على الورق باستخدام 5-6 عناصر — بمجرد أن تفهم التقسيم، ستشعر أن العودية طبيعية. إذا واجهت صعوبات، حاول تصور الأمر ذهنيًا كترتيب كتب على ذلك الرف.

للتعمق أكثر:  
[تصور الفرز السريع](https://visualgo.net/en/sorting?slide=9)  
[فصل CLRS عن الفرز السريع](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-20.html#%_sec_3.3)