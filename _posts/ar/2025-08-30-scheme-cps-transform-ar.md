---
audio: false
generated: true
image: false
lang: ar
layout: post
title: تحليل كود تحويل أسلوب نقل البرمجة المتابعة
translated: true
type: note
---

إليك الكود المستخرج من لقطتك، مع إعادة تنسيقه للوضوح:

```scheme
(define cps
  (lambda (exp)
    (letrec
        ([trivial? (lambda (x) (memq x '(zero? add1 sub1)))]
         [id (lambda (v) v)]
         [ctx0 (lambda (v) `(k ,v))]   ; سياق الذيل
         [fv (let ([n -1])
               (lambda ()
                 (set! n (+ 1 n))
                 (string->symbol (string-append "v" (number->string n)))))]
         [cps1
          (lambda (exp ctx)
            (pmatch exp
              [,x (guard (not (pair? x))) (ctx x)]
              [(if ,test ,conseq ,alt)
               (cps1 test
                     (lambda (t)
                       (cond
                         [(memq ctx (list ctx0 id))
                          `(if ,t ,(cps1 conseq ctx) ,(cps1 alt ctx))]
                         [else
                          (let ([u (fv)])
                            `(let ([k (lambda (,u) ,(ctx u))])
                               (if ,t ,(cps1 conseq ctx0) ,(cps1 alt ctx0))))])))]
              [(lambda (,x) ,body)
               (ctx `(lambda (,x ,k) ,(cps1 body ctx0)))]
              [(,op ,a ,b)
               (cps1 a
                     (lambda (v1)
                       (cps1 b
                             (lambda (v2)
                               (ctx `(,op ,v1 ,v2))))))]
              [(,rator ,rand)
               (cps1 rator
                     (lambda (r)
                       (cps1 rand
                             (lambda (d)
                               (cond
                                 [(trivial? r) (ctx `(,r ,d))]
                                 [(eq? ctx ctx0) `(,r ,d ,k)] ; استدعاء ذيلي
                                 [else
                                  (let ([u (fv)])
                                    `(,r ,d (lambda (,u) ,(ctx u))))]))))))]))]
      (cps1 exp id))))
```

---

## ما يفعله هذا الكود

هذا تنفيذ لمحوّل **نمط تمرير الاستمرارية (CPS)** للغة صغيرة تشبه Scheme. نمط تمرير الاستمرارية هو طريقة لإعادة كتابة البرامج بحيث يصبح تدفق التحكم صريحًا من خلال تمرير *دوال الاستمرارية*.

### المكونات الرئيسية

1. **العمليات التافهة**

   ```scheme
   (trivial? (lambda (x) (memq x '(zero? add1 sub1))))
   ```

   يحدد بعض العوامل البدائية على أنها تافهة (لا تحتاج إلى تغليف CPS).

2. **سياقات الاستمرارية**

   ```scheme
   [id (lambda (v) v)]      ; سياق الهوية
   [ctx0 (lambda (v) `(k ,v))] ; استمرارية الذيل الافتراضية
   ```

   `id` تُرجع مُعطاها فقط، بينما `ctx0` تعني "أرجع القيمة إلى استمرارية `k`".

3. **المتغيرات الجديدة**

   ```scheme
   [fv ...] ; يولد الرموز v0, v1, v2, ...
   ```

   تُستخدم عندما تكون هناك حاجة إلى روابط جديدة.

4. **المحوّل الرئيسي**

   ```scheme
   cps1
   ```

   يحول هذا التعبيرات بشكل متكرر إلى صيغة CPS، حالة تلو الأخرى.

   * **المتغيرات والثوابت**
     إذا لم يكن `x` زوجًا (ذريًا)، فما عليك سوى تطبيق سياق الاستمرارية.

   * **الشروط**

     ```scheme
     (if test conseq alt)
     ```

     يتم تحويل الاختبار إلى CPS أولاً.
     إذا كان السياق بسيطًا (`ctx0` أو `id`)، أنتج `if` مباشر.
     وإلا، قم بتوليد استمرارية جديدة `k` وحول كلا الفرعين إلى CPS باستخدام `ctx0`.

   * **لامبدا**

     ```scheme
     (lambda (x) body)
     ```

     تتحول إلى `(lambda (x k) <CPS of body>)`، أي أن دوال لامبدا تأخذ الآن استمرارية بشكل صريح.

   * **العمليات الثنائية**

     ```scheme
     (op a b)
     ```

     يتم تحويل كلا المعاملين إلى CPS، ثم يتم دمجهما.

   * **استدعاء الدالة**

     ```scheme
     (rator rand)
     ```

     يتم تحويل العامل والمعامل إلى CPS. ثم اعتمادًا على التفاهة:

     * إذا كان العامل بدائيًا، فطبقه مباشرة.
     * إذا كان في موضع الذيل (`ctx = ctx0`)، فقط استدع `(r d k)`.
     * وإلا، فغلّفه في استمرارية جديدة.

5. **نقطة الدخول**

   ```scheme
   (cps exp)
   ```

   يستدعي `cps1` مع `id` كسياق أولي.

---

## الحدس من خلال المثال

لنفترض أنك قمت بتحويل هذا إلى CPS:

```scheme
((lambda (x) (add1 x)) 5)
```

سيحوله تحويل CPS إلى شيء مثل:

```scheme
((lambda (x k)
   (k (add1 x)))
 5
 k)
```

حيث `k` هي استمرارية النتيجة. بدلاً من إرجاع قيمة، تستدعي الدالة `k` بها.

---

## المراجعة

* **نقاط القوة**

  * ينفذ جميع قواعد تحويل CPS الأساسية: المتغيرات، والشروط، ولامبدا، والاستدعاءات.
  * يميز بشكل صحيح بين العوامل التافهة مقابل الاستدعاءات عالية الرتبة.
  * يتعامل مع الاستدعاءات الذيلية بشكل خاص (مهم لدلالات Scheme).
  * يستخدم توليد متغيرات جديدة صحية (`fv`).

* **المشكلات المحتملة**

  * بدائيات محدودة (`zero?`, `add1`, `sub1`) — ستحتاج إلى توسيع `trivial?` للغة أغنى.
  * يستخدم `pmatch` (مطابقة الأنماط) — يتطلب مكتبة ماكرو داعمة.
  * مولّد المتغيرات الجديدة (`fv`) يغير `n` العام — جيد للتجارب الصغيرة، لكنه غير آمن في الاستخدام المتزامن أو المعياري.
  * لا يتعامل مع دوال لامبدا متعددة المعاملات (أحادية فقط).
  * لا يدعم روابط let أو التسلسل beyond استدعاء الدالة.

---

✅ بشكل عام: هذا *تنفيذ تعليمي* أنيق لتحويل CPS لـ Scheme لعبة. إنه يوضح بوضوح آليات تمرير الاستمرارية: إضافة معاملات `k`، وتغليف الفروع، وجعل التحكم صريحًا.

---

هل تريد مني أن **أشرح مثالاً ملموسًا** (على سبيل المثال، إظهار تحويل CPS خطوة بخطوة لـ `(if (zero? x) (add1 y) (sub1 y))`)؟ بهذه الطريقة يمكنك أن ترى بالضبط كيف يعيد هذا الكود كتابته.