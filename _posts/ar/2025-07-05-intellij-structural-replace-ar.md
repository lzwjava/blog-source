---
audio: false
generated: true
lang: ar
layout: post
title: إتقان الاستبدال الهيكلي في IntelliJ
translated: true
type: note
---

حسنًا، دعنا نحلل ميزة الاستبدال البنيوي في IntelliJ IDEA.

الاستبدال البنيوي في IntelliJ IDEA هي ميزة قوية بشكل لا يصدق، لكنها غالبًا ما تكون غير مستخدمة بالشكل الكافي، تسمح لك بالعثور على أنماط التعليمات البرمجية واستبدالها بناءً على **هيكلها** وليس فقط محتواها النصي. هذا يتجاوز بكثير البحث والاستبدال النصي البسيط، مما يتيح إجراء إعادة الهيكلة المعقدة، وإنفاذ أسلوب كتابة التعليمات البرمجية، وإصلاح الأخطاء عبر قاعدة تعليمات برمجية كبيرة.

إليك دليلًا شاملاً:

-----

## IntelliJ IDEA Structural Replace: دليل شامل

### 1. ما هو البحث والاستبدال البنيوي (SSR)؟

في جوهره، يتعلق البحث والاستبدال البنيوي في IntelliJ IDEA بالعمل مع أشجار الصيغة المجردة (ASTs). بدلاً من البحث عن سلاسل نصية حرفية، تقوم بتحديد *نمط* يصف هيكل التعليمات البرمجية التي تريد العثور عليها (البحث البنيوي) ونمط آخر يصف كيف تريد تحويلها (الاستبدال البنيوي).

هذا يسمح لك بـ:

* **إعادة هيكلة التعليمات البرمجية:** تغيير طريقة استدعاء الأساليب، إعادة ترتيب المعاملات، تغليف الحقول، إلخ.
* **إنفاذ معايير كتابة التعليمات البرمجية:** ضمان الاستخدام المتسق لتركيبات اللغة أو استدعاءات واجهة برمجة التطبيقات (API) المحددة.
* **إصلاح الأخطاء الشائعة:** تحديد الأخطاء المنطقية المتكررة وتصحيحها.
* **ترحيل واجهات برمجة التطبيقات (API):** تحديث التعليمات البرمجية عند تغيير المكتبات أو الأطر.
* **تنظيف التعليمات البرمجية القديمة:** العثور على استخدامات واجهات برمجة التطبيقات (API) القديمة واستبدالها بأخرى جديدة.

### 2. الوصول إلى البحث والاستبدال البنيوي

يمكنك الوصول إلى حوار البحث والاستبدال البنيوي بطريقتين:

* **اذهب إلى Edit -> Find -> Search Structurally...** (للبحث)
* **اذهب إلى Edit -> Find -> Replace Structurally...** (للاستبدال مباشرة)

حوار كلاهما متشابه جدًا، مع إضافة حقل "Replace Template" في "Replace Structurally".

### 3. فهم حوار البحث البنيوي

حوار البحث البنيوي هو المكان الذي تحدد فيه نمط البحث الخاص بك.

#### 3.1. نموذج البحث (Search Template)

هذا هو الجزء الأكثر أهمية. تكتب snippet تعليمات برمجية تمثل *الهيكل* الذي تبحث عنه.

**المفاهيم الأساسية:**

* **تعليمات برمجية حرفية:** أي تعليمات برمجية تكتبها مباشرة سيتم مطابقتها حرفيًا.
* **المتغيرات:** استخدم المتغيرات لتمثيل أجزاء من التعليمات البرمجية التي يمكن أن تختلف. يتم تعريف المتغيرات باستخدام صيغة خاصة ثم تكوينها بقيود.
    * **الصيغة الشائعة للمتغيرات:** `$variableName$` (موضوعة بين علامتي الدولار).
    * **مثال:** `System.out.println($arg$);` سيجد أي استدعاء لـ `System.out.println`، حيث سيتم مطابقة `$arg$` لأي شيء داخل الأقواس.

#### 3.2. قيود السكريبت (على المتغيرات)

بعد تعريف المتغيرات في "نموذج البحث" الخاص بك، تحتاج إلى تحديد قيودها. يتم ذلك عن طريق تحديد المتغير في النموذج (أو وضع المؤشر عليه) ثم استخدام زر "Edit variables" (غالبًا ما يكون أيقونة قلم رصاص صغيرة بجوار حقل النموذج أو يمكن الوصول إليه عبر علامة التبويب "Variables").

القيود الشائعة تشمل:

* **النص (تعبير نمطي):** تعبير نمطي يجب أن يتطابق معه المحتوى النصي للمتغير.
* **النوع (تعبير نمطي):** تعبير نمطي يجب أن يتطابق معه نوع المتغير (مثل `java.lang.String`، `int[]`).
* **العدد:** يحدد عدد مرات ظهور عنصر المتغير (مثل `[0, N]`، `[1, N]`، `[1, 1]`). هذا مفيد بشكل خاص لمجموعات العبارات أو معاملات الأسلوب.
* **المرجع:** إذا كان المتغير يمثل معرفًا (مثل اسم أسلوب أو اسم متغير)، فيمكنك تقييده للإشارة إلى نوع أو تعريف محدد.
* **داخل:** يقيد المتغير ليكون ضمن نطاق أو تعريف معين.
* **Not RegExp:** يستبعد المطابقات بناءً على تعبير نمطي.
* **الشرط (سكريبت Groovy):** هذا هو أقوى قيد. يمكنك كتابة سكريبت Groovy تُرجع `true` أو `false`. لدى هذا السكريبت إمكانية الوصول إلى العنصر المطابق وخصائصه، مما يسمح بمنطق معقد جدًا.
    * **مثال على السكريبت:** للتحقق مما إذا كانت قيمة متغير عدد صحيح أكبر من 10: `_target.text.toInteger() > 10` (حيث `_target` هو العنصر المطابق للمتغير).

#### 3.3. الخيارات

أسفل النموذج، توجد خيارات متناسبة لتحسين بحثك:

* **السياق:** يحدد نطاق البحث (مثل المشروع بأكمله، الوحدة النمطية، الدليل، الملفات المحددة، نطاق مخصص).
* **نوع الملف:** يقصر البحث على أنواع ملفات محددة (Java، Kotlin، XML، إلخ).
* **مراعاة حالة الأحرف:** تبديل حساسية حالة الأحرف القياسي.
* **مطابقة حالة الأحرف/الكلمات الكاملة:** ينطبق على النص داخل النموذج.
* **مطابقة فواصل الأسطر:** مهم لأنماط متعددة الأسطر.
* **حفظ النموذج:** يحفظ نموذج البحث الحالي الخاص بك لاستخدامه في المستقبل.

### 4. فهم حوار الاستبدال البنيوي

يضيف حوار الاستبدال البنيوي حقل "Replace Template" إلى "نموذج البحث" و "المتغيرات" التي تحددها للبحث.

#### 4.1. نموذج الاستبدال (Replace Template)

هذا هو المكان الذي تحدد فيه كيف يجب تحويل هيكل التعليمات البرمجية الذي تم العثور عليه.

* **المتغيرات من نموذج البحث:** يمكنك استخدام نفس المتغيرات المعرفة في "نموذج البحث" الخاص بك داخل "نموذج الاستبدال". سيتم إدراج المحتوى المطابق بواسطة المتغير في البحث داخل نموذج الاستبدال.
* **تعليمات برمجية جديدة:** يمكنك إدخال عناصر تعليمات برمجية جديدة، أو إعادة ترتيب العناصر الموجودة، أو إزالة أجزاء.
* **مثال:**
    * **نموذج البحث:** `System.out.println($arg$);`
    * **نموذج الاستبدال:** `LOGGER.info($arg$);`
    * هذا سيغير `System.out.println("Hello");` إلى `LOGGER.info("Hello");`.

#### 4.2. تقصير الأسماء الكاملة (Shorten FQ Names)

هذا الخيار (غالبًا ما يتم تمكينه تلقائيًا) يحاول استبدال أسماء الفئات الكاملة المؤهلة (مثل `java.util.ArrayList`) بأسمائها المختصرة (مثل `ArrayList`) وإضافة عبارات الاستيراد اللازمة. هذا بالغ الأهمية للحفاظ على تعليمات برمجية مقروءة.

#### 4.3. التنسيق

عادةً ستعيد IntelliJ IDEA تنسيق التعليمات البرمجية المستبدلة وفقًا لإعدادات نمط التعليمات البرمجية لمشروعك، وهو أمر مرغوب فيه بشدة.

### 5. أمثلة عملية

دعنا نوضح ذلك ببعض السيناريوهات الشائعة.

#### المثال 1: استبدال `System.out.println` بـ Logger

**الهدف:** تغيير جميع `System.out.println("message");` إلى `LOGGER.info("message");` (بافتراض أن `LOGGER` هو حقل static final).

1.  **افتح الاستبدال البنيوي:** `Edit -> Find -> Replace Structurally...`
2.  **نموذج البحث:**
    ```java
    System.out.println($arg$);
    ```
3.  **المتغيرات:** انقر على "Edit variables" أو اذهب إلى علامة التبويب "Variables".
    * حدد `$arg$`.
    * **العدد:** `[1, 1]` (معامل واحد).
    * **النوع (تعبير نمطي):** `java.lang.String` (إذا كنت تريد فقط استبدال السلاسل النصية الحرفية، وإلا اتركه فارغًا لأي نوع).
4.  **نموذج الاستبدال:**
    ```java
    LOGGER.info($arg$);
    ```
5.  **تشغيل:** انقر على "Find" لمعاينة التغييرات، ثم "Replace All" إذا كنت راضيًا.

#### المثال 2: تبديل معاملات الأسلوب

**الهدف:** تغيير `someMethod(paramA, paramB)` إلى `someMethod(paramB, paramA)`.

1.  **نموذج البحث:**
    ```java
    someMethod($paramA$, $paramB$);
    ```
2.  **المتغيرات:**
    * `$paramA$`: `Count: [1,1]`, `Type (regexp): .*` (أي نوع)
    * `$paramB$`: `Count: [1,1]`, `Type (regexp): .*` (أي نوع)
3.  **نموذج الاستبدال:**
    ```java
    someMethod($paramB$, $paramA$);
    ```

#### المثال 3: تغليف حقل (حالة بسيطة)

**الهدف:** إذا كان لديك حقول عامة مثل `public String name;` وتريد استبدال الوصول المباشر `obj.name` بـ `obj.getName()`. (هذا مثال مبسط؛ غالبًا ما ستستخدم إعادة الهيكلة المخصصة للتغليف).

1.  **نموذج البحث:**
    ```java
    $object$.$fieldName$;
    ```
2.  **المتغيرات:**
    * `$object$`: `Count: [1,1]`, `Type (regexp): .*`
    * `$fieldName$`: `Count: [1,1]`, `Text (regexp): name` (استهدف حقل `name` محددًا).
3.  **نموذج الاستبدال:**
    ```java
    $object$.get$fieldName$();
    ```
    * **ملاحظة:** قد تحتاج إلى ضبط حالة الأحرف إذا لم يقم `get$fieldName$` تلقائيًا بتحويل `name` إلى `Name`. لهذا، يمكنك استخدام سكريبت Groovy على `$fieldName$` داخل نموذج الاستبدال، لكنه يصبح أكثر تعقيدًا. غالبًا ما يكون النهج الأبسط لهذه الحالة المحددة هو استخدام بحثين واستبدال بنيويين أو إعادة هيكلة مخصصة. بالنسبة لـ `get$fieldName$()`، عادةً ما تتعامل بيئة التطوير مع حالة الأحرف لأنماط الـ getters الشائعة.

#### المثال 4: العثور على كتل `catch` الفارغة

**الهدف:** العثور على جميع كتل `catch` الفارغة (أو التي تحتوي فقط على تعليقات/مسافات بيضاء).

1.  **نموذج البحث:**
    ```java
    try {
        $statements$;
    } catch ($exceptionType$ $exceptionVariable$) {
        $emptyBody$;
    }
    ```
2.  **المتغيرات:**
    * `$statements$`: `Count: [0, N]` (صفر أو أكثر من العبارات في كتلة try)
    * `$exceptionType$`: `Count: [1,1]`
    * `$exceptionVariable$`: `Count: [1,1]`
    * `$emptyBody$`: `Count: [0, 0]` (هذا هو المفتاح لجسم فارغ)

#### المثال 5: استخدام سكريبت Groovy للشروط المتقدمة

**الهدف:** العثور على عبارات `if` حيث الشرط هو ثابت `true`.

1.  **نموذج البحث:**
    ```java
    if ($condition$) {
        $thenBranch$;
    }
    ```
2.  **المتغيرات:**
    * `$condition$`: `Count: [1,1]`
        * **الشرط (سكريبت Groovy):** `_target.text == "true"` (هذا يتحقق من النص الحرفي للشرط).
    * `$thenBranch$`: `Count: [0, N]`

### 6. نصائح وأفضل الممارسات

* **ابدأ ببساطة:** ابدأ بأنماط أساسية وأضف التعقيد تدريجيًا.
* **استخدم `Find` أولاً:** استخدم دائمًا "Find" (البحث البنيوي) قبل "Replace" لمعاينة المطابقات والتأكد من صحة النمط الخاص بك.
* **اختبر على نطاق صغير:** قبل إجراء استبدال واسع النطاق، اختبر النمط الخاص بك على مجموعة صغيرة ومعزولة من الملفات.
* **احفظ النماذج:** احفظ النماذج المستخدمة بشكل متكرر أو المعقدة لإعادة استخدامها بسهولة.
* **استفد من النماذج الموجودة:** تأتي IntelliJ IDEA مع العديد من نماذج البحث والاستبدال البنيوي المحددة مسبقًا. يمكنك العثور عليها بالنقر على أيقونة "العدسة المكبرة مع علامة الجمع" في حوار البحث والاستبدال البنيوي وتصفح النماذج الموجودة. هذه موارد تعليمية ممتازة.
* **قوة سكريبت Groovy:** للمطابقات عالية التخصيص أو الحساسة للسياق، تعتبر سكريبتات Groovy لا تقدر بثمن. تعلم أساسيات كيفية الوصول إلى العناصر (`_target`, `_target.parent`, `_target.text`, `_target.type`, إلخ) داخل السكريبت.
* **افهم أنواع المطابقة:** كن على علم بما تتطابق معه متغيراتك (مثل عبارة، تعبير، نوع، اسم متغير). هذا يؤثر على القيود التي يمكنك تطبيقها.
* **التعبيرات النمطية:** الفهم الجيد للتعبيرات النمطية سيعزز بشكل كبير قدرتك على تحديد قيود `Text` و `Type`.
* **تصحيح الأخطاء:** إذا لم يكن النمط الخاص بك يطابق كما هو متوقع، قم بتبسيطه. أزل القيود واحدًا تلو الآخر حتى يبدأ في المطابقة، ثم أعد تقديمها لتحديد المشكلة.
* **احفظ نسخة احتياطية من تعليماتك البرمجية:** قبل أي عملية استبدال بنيوي رئيسية على قاعدة تعليمات برمجية كبيرة، تأكد من أن لديك نسخة احتياطية أو أنك تعمل ضمن نظام تحكم في الإصدارات حيث يمكنك التراجع عن التغييرات بسهولة.

### 7. القيود

* **التعقيد:** قد يكون من الصعب أو المستحيل التعبير عن عمليات الاستبدال المعقدة جدًا أو عالية السياق بحتة باستخدام البحث والاستبدال البنيوي. في بعض الأحيان، قد يكون البرنامج المساعد المخصص لـ IntelliJ IDEA أو السكريبت المخصص أكثر ملاءمة.
* **الأداء:** يمكن أن تكون الأنماط الواسعة جدًا أو المعقدة التي تعمل على قاعدة تعليمات برمجية كبيرة جدًا بطيئة.
* **الغموض:** كن حذرًا مع الأنماط العامة بشكل مفرط، لأنها قد تطابق عن غير قصد وتعدل تعليمات برمجية لم تكن تنوي تعديلها.

-----

من خلال إتقان البحث والاستبدال البنيوي في IntelliJ IDEA، تكتسب أداة قوية للحفاظ على جودة التعليمات البرمجية، وإجراء إعادة الهيكلة واسعة النطاق، وأتمتة التعديلات المملة على التعليمات البرمجية. إنها ميزة تمكن المطورين حقًا من العمل بكفاءة أكبر وبشكل متسق عبر مشاريعهم.