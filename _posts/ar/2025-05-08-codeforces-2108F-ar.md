---
audio: false
generated: true
lang: ar
layout: post
title: كودفورسيز ٢١٠٨إف
translated: true
type: note
---

دعنا نتعمق في سبب حل الكود Java المقدم لمشكلة "الأبراج المتساقطة". تتضمن المشكلة مصفوفة من أبراج \\( n \\)، كل برج بارتفاع \\( a_i \geq 0 \\). يمكنك هدم البرج في الموضع \\( i \\)، مما يزيد ارتفاعات الأبراج الـ \\( a_i \\) التالية بمقدار 1 (أو أقل إذا لم يكن هناك عدد كافٍ من الأبراج المتبقية)، ثم يضبط \\( a_i \\) إلى 0. الهدف هو هدم جميع الأبراج الـ \\( n \\) مرة واحدة بالضبط بأي ترتيب، مع ضمان أن المصفوفة النهائية غير متناقصة (أي، لأي \\( i < j \\)، الارتفاع في الموضع \\( i \\) يكون أقل من أو يساوي الارتفاع في الموضع \\( j \\)). الناتج هو أقصى قيمة MEX للمصفوفة النهائية، حيث MEX هو أصغر عدد صحيح غير سالب غير موجود في المصفوفة.

---

### تحليل المشكلة

1. **تعريف العملية**:
   - هدم البرج \\( i \\) بارتفاع \\( a_i \\):
     - يزيد ارتفاعات الأبراج في المواضع \\( i+1, i+2, \dots, i+a_i \\) بمقدار 1 (إذا كانت موجودة).
     - يضبط \\( a_i = 0 \\).
   - يجب هدم كل برج مرة واحدة بالضبط، بأي ترتيب.
   - إذا كان \\( a_i = 0 \\)، فإن هدم البرج \\( i \\) لا يؤثر على الأبراج الأخرى.

2. **المصفوفة النهائية غير المتناقصة**:
   - بعد كل العمليات، يجب أن تفي المصفوفة النهائية \\( b_1, b_2, \dots, b_n \\) بشرط \\( b_i \leq b_{i+1} \\) لكل \\( i < n \\).

3. **MEX**:
   - MEX للمصفوفة النهائية هو أصغر عدد صحيح غير سالب \\( m \\) غير موجود في \\( \{b_1, b_2, \dots, b_n\} \\).
   - بما أن المصفوفة غير متناقصة، إذا احتوت المصفوفة على القيم \\( 0, 1, 2, \dots, k-1 \\) (ربما بتكرارات) ولكن ليس \\( k \\)، فإن MEX هو \\( k \\).
   - الهدف هو تعظيم هذا MEX.

4. **تفسير MEX**:
   - لكي يكون MEX هو \\( m \\)، يجب أن تحتوي المصفوفة النهائية على جميع الأعداد الصحيحة من 0 إلى \\( m-1 \\) مرة واحدة على الأقل، ويجب ألا يظهر \\( m \\).
   - بما أن المصفوفة غير متناقصة، فإن تحقيق MEX بقيمة \\( m \\) يعني أن المصفوفة النهائية لها قيم مثل \\( 0, 0, \dots, 1, 1, \dots, m-1, m-1 \\)، مع ظهور كل عدد صحيح من 0 إلى \\( m-1 \\) مرة واحدة على الأقل، وبدون وجود قيمة \\( m \\) أو أعلى.

5. **الاستبصار الرئيسي**:
   - MEX \\( m \\) يتوافق مع وجود موضع واحد على الأقل لكل قيمة من 0 إلى \\( m-1 \\).
   - بشكل مكافئ، لـ MEX بقيمة \\( m \\)، نحتاج إلى \\( m \\) موضع على الأقل في المصفوفة النهائية بحيث يكون للموضع \\( i \\) قيمة على الأقل \\( i - (n - m) \\)، لأن:
     - المواضع الـ \\( m \\) الأخيرة (من الفهرس \\( n-m+1 \\) إلى \\( n \\)) يجب أن تغطي القيم من 0 إلى \\( m-1 \\).
     - الموضع \\( n-m+1 \\) يجب أن تكون قيمته على الأقل 0، الموضع \\( n-m+2 \\) على الأقل 1، ...، الموضع \\( n \\) على الأقل \\( m-1 \\).
   - هذا يترجم إلى اشتراط أن يكون الارتفاع النهائي في الموضع \\( i \\) على الأقل \\( \max(0, m - (n - i + 1)) = \max(0, m - n + i) \\).

---

### نهج الحل

يستخدم الكود البحث الثنائي لإيجاد أقصى قيمة MEX ممكنة \\( m \\). لكل مرشح \\( m \\)، يتحقق مما إذا كان من الممكن تحقيق مصفوفة نهائية غير متناقصة حيث يكون لكل موضع \\( i \\) ارتفاع على الأقل \\( \max(0, m - n + i) \\). هذا يضمن أن المواضع الـ \\( m \\) الأخيرة يمكنها تغطية القيم من 0 إلى \\( m-1 \\)، مما يجعل MEX على الأقل \\( m \\).

#### البحث الثنائي
- **النطاق**: MEX \\( m \\) هو على الأقل 0 (حالة المصفوفة الفارغة) وعلى الأكثر \\( n \\) (لأننا نحتاج إلى \\( m \\) موضع على الأقل للحصول على القيم من 0 إلى \\( m-1 \\)). وبالتالي، ابحث عن \\( m \\) في \\( [0, n] \\).
- **دالة التحقق**: بالنسبة لـ \\( m \\) معطى، حدد ما إذا كان هناك ترتيب لهدم الأبراج بحيث تفي المصفوفة النهائية بـ:
  - \\( b_i \geq \max(0, m - n + i) \\) لكل \\( i \\).
  - أن تكون المصفوفة غير متناقصة.

#### دالة التحقق
تحاكي دالة التحقق ما إذا كان من الممكن تحقيق الارتفاعات المطلوبة باستخدام نهج مصفوفة الفروق، بافتراض إمكانية هدم الأبراج بأي ترتيب.

1. **الارتفاعات المطلوبة**:
   - لـ MEX \\( m \\)، يحتاج الموضع \\( i \\) إلى ارتفاع نهائي \\( b_i \geq \text{need}_i \\)، حيث:
     \\[
     \text{need}_i = \max(0, m - n + i)
     \\]
   - هذا يضمن أن المواضع من \\( n-m+1 \\) إلى \\( n \\) لها ارتفاعات على الأقل 0, 1, ..., \\( m-1 \\) على التوالي.

2. **مصفوفة الفروق**:
   - يستخدم الكود مصفوفة فروق \\( d \\) لتتبع التأثير التراكمي للعمليات.
   - تهيئة \\( d[i] = 0 \\) لكل \\( i \\).
   - لكل موضع \\( i \\):
     - احسب المجموع التراكمي: \\( d[i] += d[i-1] \\) (إذا كان \\( i > 0 \\))، ممثلاً العدد الحالي للكتل الإضافية في الموضع \\( i \\).
     - تحقق مما إذا كان \\( d[i] \geq \text{need}_i \\). إذا لم يكن كذلك، فمن المستحيل تحقيق الارتفاع المطلوب، لذا ارجع \\( false \\).
     - احسب طول النطاق المتأثر بهدم البرج \\( i \\):
       \\[
       \text{len} = d[i] - \text{need}_i + a_i
       \\]
       - \\( d[i] - \text{need}_i \\): الكتل الإضافية المتاحة بعد تلبية الحد الأدنى من المتطلبات.
       - \\( a_i \\): عدد الكلت التي يساهم بها ارتفاع البرج \\( i \\).
       - هذا الـ \\( \text{len} \\) يمثل عدد المواضع إلى يمين \\( i \\) التي يمكن زيادتها عند هدم البرج \\( i \\).
     - حدّث مصفوفة الفروق:
       - زد \\( d[i+1] \\) (إذا كان \\( i+1 < n \\)) لبدء تأثير هدم البرج \\( i \\).
       - أنقص \\( d[i + \text{len} + 1] \\) (إذا كان \\( i + \text{len} + 1 < n \\)) لإنهاء التأثير بعد \\( \text{len} \\) موضع.

3. **الإمكانية**:
   - تحاكي مصفوفة الفروق تأثير هدم البرج \\( i \\) بارتفاع معدل بناءً على الحالة الحالية.
   - إذا اكتملت الحلقة دون إرجاع \\( false \\)، فمن الممكن تحقيق الارتفاعات المطلوبة لـ MEX \\( m \\).

4. **لماذا يعمل هذا**:
   - لا تحاكي دالة التحقق الترتيب الفعلي للعمليات ولكنها تتحقق مما إذا كان هناك ترتيب يلبي متطلبات الارتفاع.
   - يضمن نهج مصفوفة الفروق أن عدد الكلت المضافة إلى كل موضع يتوافق مع تسلسل عمليات صالح.
   - يتم استيفاء شرط عدم التناقص ضمنيًا لأن الارتفاعات المطلوبة \\( \text{need}_i = \max(0, m - n + i) \\) غير متناقصة (مع زيادة \\( i \\)، تزيد \\( m - n + i \\) أو تبقى 0).

#### الحلقة الرئيسية
- اقرأ عدد حالات الاختبار \\( t \\).
- لكل حالة اختبار:
  - اقرأ \\( n \\) ومصفوفة \\( a \\).
  - نفّذ بحثًا ثنائيًا على \\( m \\) من 0 إلى \\( n \\).
  - استخدم دالة التحقق لتحديد ما إذا كان MEX \\( m \\) قابلًا للتحقيق.
  - حدّث \\( lo \\) (إذا كان ممكنًا) أو \\( hi \\) (إذا لم يكن ممكنًا).
- أخرج أقصى \\( m \\) (أي \\( lo \\)) لكل حالة اختبار.

---

### لماذا يحل الكود المشكلة

1. **صحة البحث الثنائي**:
   - يجد البحث الثنائي أقصى \\( m \\) بحيث ترجع دالة التحقق \\( true \\).
   - بما أن إمكانية تحقيق MEX \\( m \\) تعني إمكانية تحقيق جميع قيم MEX الأصغر (يتطلب \\( m \\) الأصغر مواضع أقل بارتفاعات أقل)، فإن البحث الثنائي يحدد بشكل صحيح أقصى MEX ممكن.

2. **دقة دالة التحقق**:
   - تضمن دالة التحقق أن كل موضع \\( i \\) يمكن أن يكون له على الأقل \\( \max(0, m - n + i) \\) كتلة بعد كل العمليات.
   - تحاكي مصفوفة الفروق التأثير التراكمي لهدم الأبراج، مع الأخذ في الاعتبار أن كل برج يساهم بـ \\( a_i \\) كتلة في المواضع الـ \\( a_i \\) التالية.
   - من خلال معالجة المواضع من اليسار إلى اليمين وتعديل مصفوفة الفروق، تتحقق مما إذا كان يمكن إعادة توزيع الارتفاعات الأولية \\( a_i \\) لتلبية الارتفاعات المطلوبة.

3. **معالجة قيد عدم التناقص**:
   - الارتفاعات المطلوبة \\( \max(0, m - n + i) \\) غير متناقصة، مما يتوافق مع متطلبات المشكلة لمصفوفة نهائية غير متناقصة.
   - إذا نجحت دالة التحقق، فيمكن جعل المصفوفة الناتجة غير متناقصة من خلال ضمان أن كل موضع يلبي أو يتجاوز الارتفاع المطلوب.

4. **الكفاءة**:
   - **البحث الثنائي**: \\( O(\log n) \\) تكرارات (بما أن \\( m \leq n \\)).
   - **دالة التحقق**: \\( O(n) \\) لكل استدعاء، حيث تعالج كل موضع مرة واحدة وتحدّث مصفوفة الفروق في وقت ثابت لكل موضع.
   - **المجموع لكل حالة اختبار**: \\( O(n \log n) \\).
   - **المجموع لجميع حالات الاختبار**: بما أن \\( \sum n \leq 10^5 \\)، فإن التعقيد الإجمالي هو \\( O(t \cdot n \log n) \\)، والذي يتناسب مع الحد الزمني البالغ 3 ثوانٍ.

5. **الحالات الخاصة**:
   - **\\( n = 1 \\)**: إذا كان \\( a_1 = 0 \\)، MEX = 1 (تصبح المصفوفة [0]). إذا كان \\( a_1 > 0 \\)، MEX = 0 (تصبح المصفوفة [0]). يتعامل الكود مع هذا بشكل صحيح.
   - **\\( a_i \\) كبيرة**: بما أن \\( a_i \leq 10^9 \\)، ولكن فقط المواضع الـ \\( n-i \\) الأولى تتأثر، فإن الكود يحدد التأثير بشكل صحيح باستخدام حدود المصفوفة.
   - **جميع \\( a_i = 0 \\)**: المصفوفة النهائية كلها أصفار، MEX = 1. تؤكد دالة التحقق هذا.
   - **قيم مختلطة**: يتعامل البحث الثنائي ودالة التحقق مع قيم \\( a_i \geq 0 \\) اعتباطية.

---

### تفاصيل كود Java

ينقل كود Java منطق C++ باستخدام `BufferedReader` و `PrintWriter` للإدخال/الإخراج الفعال، كما هو مطلوب. الجوانب الرئيسية:

1. **معالجة الإدخال**:
   - يستخدم `BufferedReader` لقراءة الأسطر و `StringTokenizer` لتحليل الأعداد الصحيحة.
   - يقرأ \\( t \\)، ثم لكل حالة اختبار، يقرأ \\( n \\) ومصفوفة \\( a \\).

2. **فئة Checker**:
   - تغلف منطق التحقق لمحاكاة دالة Lambda في C++.
   - تستخدم مصفوفة \\( d \\) لمحاكاة نهج مصفوفة الفروق.

3. **الإخراج**:
   - يستخدم `PrintWriter` لإخراج النتيجة لكل حالة اختبار، مع `out.flush()` لضمان كتابة كل المخرجات.

4. **الأداء**:
   - يحافظ كود Java على نفس التعقيد \\( O(n \log n) \\) لكل حالة اختبار.
   - يضمن `BufferedReader` و `PrintWriter` أن الإدخال/الإخراج سريع بما يكفي لـ \\( \sum n \leq 10^5 \\).

---

### الخاتمة

يحل الكود مشكلة "الأبراج المتساقطة" عن طريق:
- استخدام البحث الثنائي لإيجاد أقصى MEX \\( m \\).
- استخدام دالة تحقق قائمة على مصفوفة الفروق للتحقق مما إذا كان يمكن إعادة توزيع ارتفاعات الأبراج الأولية لتحقيق مصفوفة غير متناقصة بالارتفاعات المطلوبة.
- ضمان الصحة من خلال الطبيعة غير المتناقصة للارتفاعات المطلوبة وإمكانية تسلسلات العمليات.
- التعامل مع جميع الحالات الخاصة والتناسب ضمن قيود الزمن والذاكرة.

ينفذ كود Java منطق C++ بأمانة، باستخدام إدخال/إخراج فعال لتلبية متطلبات المشكلة.