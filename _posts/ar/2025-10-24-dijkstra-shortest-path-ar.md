---
audio: false
generated: true
image: false
lang: ar
layout: post
model: x-ai/grok-4-fast
title: فهم خوارزمية ديكسترا لإيجاد أقصر مسار
translated: true
type: note
---

### فهم خوارزمية ديجكسترا لإيجاد أقصر مسار

خوارزمية ديجكسترا هي طريقة أساسية لإيجاد أقصر مسار بين العقد في رسم بياني حيث تحتوي الحواف على أوزان غير سالبة (مثل المسافات أو التكاليف). سُميت على اسم إدخر ديجكسترا وتُستخدم على نطاق واسع في ملاحة GPS، وتوجيه الشبكات، وغير ذلك. الفكرة الأساسية: تستكشف الخوارزمية الرسم البياني بطريقة جشعة، دائمًا تختار أقرب عقدة غير مزارة وتحدد المسارات منها، مثل تأثير التموج من نقطة البداية.

#### متطلبات سريعة
- **أساسيات الرسم البياني**: فكر في الرسم البياني كخريطة لمدن (عقد) متصلة بطُرق (حواف) ذات أطوال (أوزان). نفترض أن الأوزان موجبة—لا توجد مسافات سالبة!
- **موجه مقابل غير موجه**: تعمل في كلا النوعين، ولكن الأمثلة هنا تستخدم غير الموجه للتبسيط.
- **أقصر مسار**: المسار ذو الوزن الإجمالي الأدنى من المصدر إلى الهدف.

إذا كانت الرسوم البيانية جديدة عليك، تخيل شبكة اجتماعية: أشخاص (عقد)، صداقات بدرجات "قوة" (أوزان).

#### كيف تعمل: خطوة بخطوة بشكل بديهي
تبني خوارزمية ديجكسترا أقصر مسار بشكل تدريجي، باستخدام **طابور أولوية** (مثل قائمة مهام مرتبة حسب الاستعجال—هنا، حسب أقصر مسافة معروفة حاليًا). إنها لا تعيد زيارة العقد بمجرد تسويتها، مما يجعلها فعالة.

1. **التهيئة**:
   - اختر عقدة بداية (المصدر). عيّن مسافتها إلى 0.
   - عيّن مسافات جميع العقد الأخرى إلى اللانهاية (∞).
   - تتبع "المسار إلى" كل عقدة (في البداية لا شيء).

2. **بينما توجد عقد غير مزارة**:
   - اختر العقدة غير المزارة ذات المسافة الحالية الأصغر (من طابور الأولوية).
   - "سوّها": ضع علامة عليها كمُزارة. هذه المسافة نهائية—بفضل الأوزان غير السالبة، لا يمكن إيجاد مسار أقصر لاحقًا.
   - لكل جار لهذه العقدة:
     - احسب المسافة الجديدة المحتملة: (مسافة العقدة المسوّاة) + (وزن الحافة إلى الجار).
     - إذا كانت هذه أقصر من المسافة الحالية للجار، قم بتحديثها ولاحظ أن المسار جاء عبر العقدة المسوّاة.
   - كرر حتى يتم زيارة جميع العقد أو يتم تسوية العقدة الهدف.

تتوقف الخوارزمية مبكرًا إذا كنت تهتم فقط بعقدة هدف واحدة.

**لماذا تعمل**: إنها مثل البحث بعرض الأولوية ولكن مُوزون—دائمًا تُوسع الحد الأرخص أولاً. يعتمد الإثبات على حقيقة أنه بمجرد تسوية عقدة، لا يمكن تحسين مسافتها (خاصية الاختيار الجشع).

#### مثال بسيط
تخيل رسمًا بيانيًا به 4 مدن: A (البداية)، B، C، D. الحواف والأوزان:

- A → B: 4
- A → C: 2
- B → C: 1
- B → D: 5
- C → D: 8

تصوير ASCII:
```
   4
A ----- B
 \     / \
  2   1   5
  \   /     |
   C ------- D
     8
```

شغّل ديجكسترا من A:

- **البداية**: dist[A]=0, dist[B]=∞, dist[C]=∞, dist[D]=∞. الطابور: A.
- **تسوية A** (dist=0).
  - تحديث B: 0+4=4
  - تحديث C: 0+2=2
  - الطابور: C(2), B(4)
- **تسوية C** (dist=2).
  - تحديث D: 2+8=10
  - الطابور: B(4), D(10)
- **تسوية B** (dist=4).
  - تحديث C: 4+1=5 (ولكن 2<5، لا تغيير)
  - تحديث D: 4+5=9 (9<10، تحديث إلى 9)
  - الطابور: D(9)
- **تسوية D** (dist=9).

المسافات النهائية: A=0, B=4, C=2, D=9.  
المسار إلى D: A → B → D (الإجمالي 9، أقصر من A → C → D=10).

يمكنك تتبع المسارات للخلف باستخدام مصفوفة "العقدة السابقة".

#### شبه كود
هذا مخطط تنفيذ بسيط (شبيه بـ Python):

```python
import heapq  # For priority queue

def dijkstra(graph, start):
    distances = {node: float('inf') for node in graph}
    distances[start] = 0
    previous = {node: None for node in graph}
    pq = [(0, start)]  # (distance, node)
    
    while pq:
        current_dist, current = heapq.heappop(pq)
        if current_dist > distances[current]:
            continue  # Outdated entry
        
        for neighbor, weight in graph[current].items():
            distance = current_dist + weight
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                previous[neighbor] = current
                heapq.heappush(pq, (distance, neighbor))
    
    # Reconstruct path to target (e.g., 'D')
    path = []
    node = 'D'
    while node is not None:
        path.append(node)
        node = previous[node]
    return path[::-1], distances['D']  # Reverse to get start-to-end
```

- `graph`: قاموس من القواميس، مثال: `{'A': {'B':4, 'C':2}, ...}`
- التعقيد الزمني: O((V+E) log V) مع كومة ثنائية (V=رؤوس، E=حواف). رائع للرسوم البيانية المتفرقة.

#### نصائح لفهمها بشكل أعمق
- **تصور**: ارسم رسمك البياني على الورق، وحاكي الخطوات بجدول للمسافات/المزارة.
- **الأخطاء الشائعة**: تفشل مع الأوزان السالبة (استخدم Bellman-Ford بدلاً من ذلك). تفترض رسمًا بيانيًا متصلًا.
- **الممارسة**: جربها على رسوم بيانية صغيرة، ثم ابرمجها لمجموعة بيانات خريطة.
- **المتغيرات**: تضيف A* الاستدلالات للبحث الأسرع (مثلًا في الألعاب).

يجب أن تفهمها—ابدأ بالمثال، وشغّلها ذهنيًا عدة مرات!

[ويكيبيديا: خوارزمية ديجكسترا](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)  
[GeeksforGeeks: شرح مرئي](https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/)