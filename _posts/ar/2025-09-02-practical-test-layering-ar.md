---
audio: false
generated: true
image: false
lang: ar
layout: post
title: دليل التقسيم الطبقي للاختبارات العملية
translated: true
type: note
---

سؤال رائع. استراتيجية الاختبار السليمة تدور بشكل أساسي حول **المخاطر وسرعة التغذية الراجعة**. إليك طريقة عملية لتحديد **ما يجب اختباره وأي طبقة**—بدون جداول، فقط قواعد وأمثلة واضحة.

---

# المبادئ الأساسية

* **اختبر السلوك، وليس التنفيذ.** فضّل واجهات برمجة التطبيقات (APIs) العامة على التفاصيل الخاصة.
* **ارفع معظم الفحوصات إلى أسرع طبقة** يمكنها اكتشاف الخطأ.
* **استخدم التبعات الحقيقية فقط عندما تستدعي المخاطر ذلك** (قاعدة البيانات، قوائم الانتظار، المتصفح).
* **غطِ المسارات الحرجة من البداية إلى النهاية، ولكن باعتدال.** اختبارات واجهة المستخدم هي الأكثر هشاشة وبطئًا؛ احتفظ بها لما يهم حقًا.

---

# ما الذي يوضع أين (إرشادات سريعة)

## ١) اختبارات الوحدة (سريعة، معزولة)

**استخدم عندما:** يمكن اختبار المنطق النقي/المجال دون مدخلات/مخرجات (قاعدة البيانات، HTTP، نظام الملفات).

* قواعد العمل، حسابات التسعير/الرسوم، المدققات، أدوات التعيين، الأدوات المساعدة.
* طرق الخدمة مع استبدال المستودعات/العملاء **بمحاكاة (Mocking)**.
* الهدف: العديد من الاختبارات الصغيرة؛ الفشل في أجزاء من الثانية.

**مثال Java/Spring**

```java
@ExtendWith(MockitoExtension.class)
class FeeServiceTest {
  @Mock AccountRepo repo;
  @InjectMocks FeeService svc;

  @Test void vipGetsDiscount() {
    when(repo.tier("u1")).thenReturn("VIP");
    assertEquals(Money.of(90), svc.charge("u1", Money.of(100)));
    verify(repo).tier("u1");
  }
}
```

## ٢) اختبارات التكامل / المكونات (ربط حقيقي، حد أدنى من المحاكاة)

**استخدم عندما:** تحتاج إلى التحقق من ربط Spring، التسلسل، المرشحات، استعلامات قاعدة البيانات، المعاملات.

* **طبقة HTTP بدون شبكة**: `@WebMvcTest` (وحدات التحكم + json)، أو `@SpringBootTest(webEnvironment=RANDOM_PORT)` للمكدس الكامل.
* **صحة قاعدة البيانات**: استخدم **Testcontainers** لتشغيل قاعدة بيانات حقيقية؛ تحقق من SQL، الفهارس، عمليات الترحيل.
* **المراسلة**: اختبر المستهلكين/المنتجين مع وسيط حقيقي في حاوية (Kafka/RabbitMQ).

**مثال شريحة HTTP**

```java
@WebMvcTest(controllers = OrderController.class)
class OrderControllerTest {
  @Autowired MockMvc mvc;
  @MockBean OrderService svc;

  @Test void createsOrder() throws Exception {
    when(svc.create(any())).thenReturn(new Order("id1", 100));
    mvc.perform(post("/orders").contentType("application/json")
        .content("{\"amount\":100}"))
      .andExpect(status().isCreated())
      .andExpect(jsonPath("$.id").value("id1"));
  }
}
```

**قاعدة البيانات مع Testcontainers**

```java
@Testcontainers
@SpringBootTest
class RepoIT {
  @Container static PostgreSQLContainer<?> db = new PostgreSQLContainer<>("postgres:16");
  @Autowired OrderRepo repo;

  @Test void persistsAndQueries() {
    var saved = repo.save(new OrderEntity(null, 100));
    assertTrue(repo.findById(saved.getId()).isPresent());
  }
}
```

## ٣) اختبارات عقد واجهة برمجة التطبيقات (API) والاختبارات الشاملة لواجهة برمجة التطبيقات

**استخدم عندما:** يجب عليك ضمان **عقود متوافقة مع الإصدارات السابقة** أو سير عمل النظام الكامل.

* **اختبارات العقد** (مثل، التحقق من مخطط OpenAPI أو Pact) تكتشف التغييرات غير المتوافقة دون واجهة المستخدم.
* **مسارات شاملة لواجهة برمجة التطبيقات**: شغّل التطبيق مع قاعدة بيانات حقيقية واختبره عبر HTTP (RestAssured). ركز على المسارات السعيدة + بعض حالات الحافة الحرجة.

**مثال API شاملة**

```java
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class ApiFlowIT {
  @LocalServerPort int port;
  @Test void happyPath() {
    given().port(port).contentType("application/json")
      .body("{\"amount\":100}")
      .when().post("/orders")
      .then().statusCode(201)
      .body("amount", equalTo(100));
  }
}
```

## ٤) الاختبارات الشاملة لواجهة المستخدم (المتصفح)

**استخدم عندما:** يجب إثنة **عدد قليل** فقط من رحلات المستخدم الحرجة في متصفح حقيقي:

* المصادقة + الدفع؛ تحركات الأموال؛ مسارات المعلومات الشخصية (PII)؛ رفع الملفات.
* حافظ على **من ٣ إلى ١٠ سيناريوهات رئيسية**. كل شيء آخر: غطّه في طبقات الوحدة/التكامل/واجهة برمجة التطبيقات.

**Selenium مقابل Playwright/Cypress؟**

* **فضّل Playwright** (أو Cypress) لتطبيقات Angular الحديثة: الانتظار التلقائي، محددات أسهل، التوازي، عارض التتبع المدمج، تشغيل مستقر بدون واجهة عبر Chromium/Firefox/WebKit.
* **استخدم Selenium** إذا كنت بحاجة إلى تشغيل **متصفحات بائعين حقيقية في شبكة مخصصة**، أو التفاعل مع إعدادات **قديمة/للشركات**، أو إذا كان لديك بالفعل بنية تحتية ناضجة لـ Selenium. إنها تتطلب المزيد من الإعداد؛ ستحتاج إلى أوقات انتظار صريحة وشبكة للسرعة.

**مثال Playwright (TypeScript)**

```ts
import { test, expect } from '@playwright/test';

test('checkout happy path', async ({ page }) => {
  await page.goto('http://localhost:4200');
  await page.getByRole('button', { name: 'Sign in' }).click();
  await page.getByLabel('Email').fill('u@example.com');
  await page.getByLabel('Password').fill('secret');
  await page.getByRole('button', { name: 'Login' }).click();

  await page.getByText('Add to cart', { exact: true }).first().click();
  await page.getByRole('button', { name: 'Checkout' }).click();
  await expect(page.getByText('Order confirmed')).toBeVisible();
});
```

**إذا كان يجب عليك استخدام Selenium (Java)**

```java
WebDriver d = new ChromeDriver();
d.get("http://localhost:4200");
new WebDriverWait(d, Duration.ofSeconds(10))
  .until(ExpectedConditions.elementToBeClickable(By.id("loginBtn"))).click();
```

---

# اتخاذ القرار طبقة تلو أخرى (مسار سريع)

١. **هل يمكن اختباره دون مدخلات/مخرجات؟**
   → نعم: **اختبره كوحدة**.

٢. **هل يعتمد على ربط/تسلسل إطار العمل أو استعلامات قاعدة البيانات؟**
   → نعم: اختبر **التكامل/المكونات** (شرائح Spring، Testcontainers).

٣. **هل هو عقد عبر الخدمات/واجهة برمجة تطبيقات عامة؟**
   → نعم: **اختبارات العقد** (مخطط/Pact) + بضع مسارات **شاملة لواجهة برمجة التطبيقات**.

٤. **هل القيمة مرئية فقط في واجهة المستخدم أو هي تجربة مستخدم حرجة؟**
   → نعم: **شاملة لواجهة المستخدم**، ولكن فقط للرحلات الأساسية.

---

# النسب المئوية المعقولة والميزانيات

* استهدف تقريبًا **٧٠–٨٠٪ وحدة**، **١٥–٢٥٪ تكامل/واجهة برمجة تطبيقات**، **٥–١٠٪ واجهة مستخدم شاملة**.
* حافظ على سرعة التكامل المستمر (CI) لكل commit: الوحدة في <٢–٣ دقائق، التكامل بشكل متوازٍ؛ شغّل **فحصًا صغيرًا لواجهة المستخدم** على طلبات السحب (PRs)، و **حزمة واجهة مستخدم أوسع ليلاً**.

---

# ما يجب إعطاؤه الأولوية (قائمة مرجعية قائمة على المخاطر)

* تحركات الأموال، المصادقة، الصلاحيات، الامتثال → **واجهة برمجة التطبيقات ومسار سعيد لواجهة المستخدم**.
* الحسابات المعقدة، قواعد التسعير → **وحدة** (العديد من الحالات) + **بضعة تكامل** مع تقريب/توقيت قاعدة البيانات الحقيقية.
* منطق الثبات، عمليات الترحيل، عمليات الربط المعقدة → **اختبارات المستودع مع Testcontainers**.
* العقود بين الفرق → **اختبارات العقد** في التكامل المستمر (CI) لمنع التغييرات غير المتوافقة.
* إمكانية الوصول، التدويل → **اختبارات المكونات** لـ ARIA/اللغة + **فحص دوري لواجهة المستخدم** (axe) على الصفحات الرئيسية.

---

# شكل خط أنابيب التكامل المستمر (عملي)

* **عند كل دفع:** وحدة + اختبارات الشرائح؛ حفنة من الشاملة لواجهة برمجة التطبيقات؛ فحص سطحي صغير لواجهة المستخدم (١–٣).
* **ليلاً:** شاملة كاملة لواجهة برمجة التطبيقات، حزمة واجهة مستخدم أوسع، فحص أداء سطحي (k6)، فحص أمان أساسي (ZAP).
* **اعزل الاختبارات غير المستقرة** بسرعة؛ أصلحها أو احذفها—لا تتجاهلها.

---

# نصائح حول بيانات الاختبار وعدم الاستقرار

* استخدم **طرق التصنيع/البنائين**؛ تجنب التركيبات القابلة للتعديل المشتركة.
* **قم بتهيئة Testcontainers** بـ SQL/البيانات عند بدء التشغيل؛ حافظ على الاختبارات **ثابتة النتائج (Idempotent)**.
* في واجهة المستخدم، فضّل **محددات الدور/التسمية** عن CSS/XPath؛ تجنب أوقات الانتظار (sleeps)، استخدم الانتظار المرتبط بالحالات المرئية للمستخدم.
* **سجّل التتبع** (تتبع Playwright، سجلات Selenium) لتصحيح أخطاء فشل التكامل المستمر (CI).

---

# ملخص سريع: قواعد عامة

* إذا كان من الممكن اكتشاف الخطأ بواسطة طبقة **أسرع**، **انقل الاختبار لأسفل**.
* احتفظ فقط **بعدد قليل، حرج** من رحلات واجهة المستخدم.
* استخدم **Testcontainers** لجعل التكامل ذا معنى.
* فضّل **Playwright** ما لم يكن Selenium مطلبًا صارمًا.

إذا أردت، أخبرني بـ **أهم ٣–٥ مسارات حرجة للأعمال** وسأرسم لك قائمة الاختبارات الدقيقة لكل طبقة (مع خيارات الأدوات وبوابات التكامل المستمر).