---
audio: false
generated: true
image: false
lang: ar
layout: post
title: دليل Git Diff-Tree
translated: true
type: note
---

إليك دليل عملي وشامل لـ `git diff-tree` — ما هو، ومتى تستخدمه، والخيارات التي ستلجأ إليها فعليًا في العمل الحقيقي. سأتجنب الجداول الكبيرة وألتزم بالشرح المركز مع أمثلة قابلة للنسخ واللصق.

# ما يفعله `git diff-tree` فعليًا

* يقارن **كائنات الشجرة (tree objects)**. في الاستخدام اليومي، هذا يعني عادة: "أرني ما الذي تغير في **commit** مقارنة بالـ parent(s) الخاص به."
* إنه **أمر Plumbing** (ملائم للبرامج النصية)، على عكس `git show`/`git log` اللذين يعتبران من أوامر Porcelain (موجهة للبشر).
* لا ينظر أبدًا إلى دليل العمل الخاص بك؛ إنه يقارن فقط الأشجار المخزنة في المستودع (commits، أو علامات تشير إلى commits، أو معرفات الأشجار الخام).

# الأشكال الأساسية التي ستستخدمها

١. قارن commit بالـ parent الخاص به

```bash
git diff-tree -p <commit>
```

إذا كان للـ `<commit>` parent واحد، سترى رقعة (patch) عادية. إذا كان commit دمج (merge)، فلن ترى أي شيء إلا إذا طلبت عرض عمليات الدمج (انظر أدناه).

٢. قارن شجرتين/commitين بشكل صريح

```bash
git diff-tree -p <old-tree-or-commit> <new-tree-or-commit>
```

رائع عندما تريد مقارنة أي نقطتين، وليس فقط "commit مقابل parent".

٣. اعرض أسماء الملفات فقط (بدون رقعة)

```bash
git diff-tree --name-only -r <commit>
```

أضف `-r` للتنقل بشكل متكرر في الأدلة الفرعية حتى تحصل على قائمة مسطحة.

٤. اعرض الأسماء مع نوع التغيير

```bash
git diff-tree --name-status -r <commit>
# يخرج أسطرًا مثل:
# A path/to/newfile
# M path/to/modified
# D path/to/deleted
```

٥. اعرض رقعة (diff كامل)

```bash
git diff-tree -p <commit>            # unified diff مثل `git show`
git diff-tree -U1 -p <commit>        # سياق أقل (سطر واحد)
```

# الخيارات التي يجب معرفتها (مع السبب/متى)

* `-r` — التنقل بشكل متكرر في الأشجار الفرعية حتى ترى جميع المسارات المتداخلة. بدونه، قد يظهر الدليل الذي تغير كسطر واحد.
* `--no-commit-id` — قمع رأس "commit <sha>" عندما تكتب برنامجًا نصيًا للمخرجات لكل commit.
* `--root` — عندما لا يكون للـ commit **أي parent** (الـ commit الأولي)، لا يزال يعرض تغييراته مقابل الشجرة الفارغة.
* `-m` — بالنسبة لـ commits الدمج، اعرض الـ diffs **ضد كل parent** (ينتج multiple diffs).
* `-c` / `--cc` — Combined merge diff. `--cc` هو عرض منقح (ما يستخدمه `git show` للعمليات الدمج).
* `--name-only` / `--name-status` / `--stat` / `--numstat` — أنماط ملخص مختلفة. `--numstat` ملائم للبرامج النصية (أعداد الأسطر المضافة/المحذوفة).
* `--diff-filter=<set>` — رِشِّح حسب أنواع التغيير، على سبيل المثال `--diff-filter=AM` (فقط المضافة أو المعدلة)؛ الحروف الشائعة: `A` (مضافة)، `M` (معدلة)، `D` (محذوفة)، `R` (معدلة الاسم)، `C` (منسوخة)، `T` (النوع تغير).
* `-M` / `-C` — اكتشف التغييرات في الأسماء والنسخ. أضف عتبة تشابه اختيارية، مثل `-M90%`.
* `--relative[=<path>]` — اقتصر المخرجات على دليل فرعي؛ بدون وسيط، يستخدم دليل العمل الحالي.
* `-z` — **NUL-terminate** للمسارات للتحليل الآلي غير المبهم (يتعامل مع أسطر جديدة أو علامات تبويب في أسماء الملفات).
* `--stdin` — اقرأ قائمة من commits (أو أزواج) من الإدخال القياسي. هذا هو السر للعمليات المجمعة السريعة.

# أنماط البرمجة النصية الأساسية

### ١) اذكر الملفات التي تغيرت لـ commit واحد

```bash
git diff-tree --no-commit-id --name-status -r <commit>
```

### ٢) معالجة مجمعة للعديد من commits (سريع!)

```bash
git rev-list main --since="2025-08-01" |
  git diff-tree --stdin -r --no-commit-id --name-status
```

`--stdin` يتجنب تشغيل `git` لكل commit وهو أسرع بكثير للنطاقات الكبيرة.

### ٣) فقط الإضافات والتعديلات في دليل

```bash
git diff-tree -r --no-commit-id --name-status \
  --diff-filter=AM <commit> -- src/backend/
```

### ٤) عد الأسطر المضافة/المحذوفة لكل ملف (ملائم للبرامج النصية)

```bash
git diff-tree -r --no-commit-id --numstat <commit>
# المخرجات: "<added>\t<deleted>\t<path>"
```

### ٥) اكتشف واعرض التغييرات في الأسماء في commit

```bash
git diff-tree -r --no-commit-id -M --name-status <commit>
# أسطر مثل: "R100 old/name.txt\tnew/name.txt"
```

### ٦) رقعة لـ commit دمج

```bash
git diff-tree -m -p <merge-commit>     # رقع لكل parent
git diff-tree --cc <merge-commit>      # عرض مجمع (رقعة واحدة)
```

### ٧) الـ commit الأولي (لا يوجد parent)

```bash
git diff-tree --root -p <initial-commit>
```

# فهم تنسيق السجل الخام (إذا كنت تقوم بالتحليل يدويًا)

استخدم `--raw` (يُستخدم ضمنيًا في بعض الأنماط) للحصول على سجلات دنيا مستقرة:

```
:100644 100644 <oldsha> <newsha> M<TAB>path
```

* الأرقام هي أوضاع الملف: `100644` ملف عادي، `100755` قابل للتنفيذ، `120000` رابط رمزي، `160000` gitlink (وحدة فرعية).
* الحالة هي حرف واحد (`A`، `M`، `D`، إلخ)، possibly مع درجة (على سبيل المثال، `R100`).
* بالنسبة لإعادة التسمية/النسخ، سترى مسارين. مع `-z`، الحقول مفصولة بـ NUL؛ بدون `-z`، تكون مفصولة بعلامات Tab.

**نصيحة:** إذا كنت تبني أدوات موثوقة، مرر دائمًا `-z` واقسم على NUL. توجد أسماء ملفات بها أسطر جديدة.

# مقارنة `git diff-tree` بالأوامر ذات الصلة (حتى تختار الصحيح)

* `git diff`: يقارن **index/شجرة العمل** مقابل HEAD أو أي commitين/شجرتين؛ التطوير التفاعلي.
* `git show <commit>`: غلاف جميل لـ "diff مقابل parent + بيانات وصفية". رائع للبشر.
* `git log -p`: السجل بالإضافة إلى الرقع. بالنسبة للنطاقات، غالبًا ما يكون أكثر ملاءمة من التكرار اليدوي لـ `diff-tree`.
* `git diff-tree`: Plumbing من أجل **diffs قابلة للبرمجة النصية بدقة لكل commit**، قابلة للمعالجة المجمعة مع `--stdin`.

# أمثلة من العالم الحقيقي

### "ما الذي تغير في commit دمج طلب السحب هذا؟"

```bash
git diff-tree --cc <merge-commit> | less
```

إذا كنت بحاجة إلى تفاصيل حسب الـ parent:

```bash
git diff-tree -m -p <merge-commit> | less
```

### "قم بتغذية خطوة CI بقائمة نظيفة للملفات المعدلة بواسطة أحدث commit"

```bash
git diff-tree --no-commit-id --name-only -r HEAD > changed.txt
```

### "ملفات Java فقط المضافة أو المعدلة في آخر 20 commit"

```bash
git rev-list -n 20 HEAD |
  git diff-tree --stdin -r --no-commit-id --name-only --diff-filter=AM |
  grep -E '\.java$'
```

### "لخص التغيير (الأسطر المضافة/المحذوفة) لإصدار tag"

```bash
git diff-tree -r --no-commit-id --numstat v1.2.0..v1.3.0
```

### "تعامل مع أسماء الملفات الغريبة بأمان"

```bash
git diff-tree -z -r --no-commit-id --name-status <commit> |
  awk -v RS='\0' 'NR%2{status=$0; next}{printf "%s %s\n", status, $0}'
```

# ملاحظات الأداء

* فضّل `--stdin` مع `git rev-list` للنطاقات الكبيرة؛ فهو يتجنب إرهاق العملية.
* تخطى الرقع (`--name-only`/`--name-status`) عندما لا تحتاج إلى تغييرات الأسطر.
* تجنب اكتشاف إعادة التسمية (`-M`، `-C`) إذا كنت تهتم بالسرعة على الدقة.

# المشاكل والحالات الطارئة

* **لا يوجد إخراج لعمليات الدمج افتراضيًا.** يجب أن تمرر `-m` (لكل parent) أو `--cc`/`-c` (مجمعة).
* **الـ commit الأولي هو "شجرة فارغة مقابل شجرة".** استخدم `--root` لإجبار الـ diff.
* **الوحدات الفرعية** تظهر الوضع `160000` و SHA (gitlink). لن ترى diffs داخلية إلا إذا قمت بالـ diff داخل مستودع الوحدة الفرعية.
* **Pathspecs تكون بعد `--`.** إذا قمت بالتصفية حسب المسارات، ضعها بعد `--` لتجنب الغموض.
* **أسماء الملفات التي تحتوي على مسافات بيضاء/أسطر جديدة.** أضف دائمًا `-z` إذا كنت تقوم بالتحليل.

# "مقتطفات الغش" السريعة التي ستستخدمها مرة أخرى

```bash
# الملفات التي تغيرت (قائمة مسطحة)
git diff-tree --no-commit-id --name-only -r <commit>
```