---
audio: false
generated: true
lang: ar
layout: post
title: API تدفق في جافا
translated: true
---

لاستخدام `java.util.stream` في Java، يمكنك الاستفادة من واجهة Stream التي تم تقديمها في Java 8 لتعالجة مجموعات البيانات بطريقة وظيفية ووضحية. تسمح السيلات لك بإجراء عمليات مثل التصفية، والتحويل، والتقليل على تسلسلات العناصر (مثل القوائم أو المصفوفات) بشكل فعال ووضوح. أدناه، سأشرح كيفية استخدام `java.util.stream` من خلال مراجعة مثال محدد: العثور على المتوسط للأعداد الزوجية الأكبر من 10 من قائمة من الأعداد الصحيحة. هذا سيوضح العمليات الرئيسية للسيلات والمفاهيم.

---

### **نظرة عامة على `java.util.stream`**
يوفر حزمة `java.util.stream` واجهة `Stream` وطبائع ذات صلة (مثل `IntStream`, `DoubleStream` إلخ) لمعالجة البيانات. السيل هو تسلسل من العناصر يدعم العمليات التي يتم تنفيذها في أنبوب. هذه العمليات هي:
- **العمليات المتوسطة**: تحويل أو تصفية السيل (مثل `filter`, `map`)، وإرجاع سيل جديد. هذه العمليات بطيئة ولا يتم تنفيذها إلا عند استدعاء عملية نهائية.
- **العمليات النهائية**: إنتاج نتيجة أو تأثير جانبي (مثل `average`, `collect`)، مما يثير أنبوب المعالجة للبيانات.

لاستخدام السيلات، عادةً ما:
1. إنشاء سيل من مصدر البيانات (مثل قائمة).
2. تطبيق العمليات المتوسطة لتحويل أو تصفية البيانات.
3. استخدام عملية نهائية لإنتاج نتيجة.

---

### **مثال على المشكلة**
دعونا نحل هذه المشكلة: مع قائمة `List<Integer>`, حسب متوسط جميع الأعداد الزوجية الأكبر من 10. إذا لم يكن هناك أي أرقام مثل هذه، ارجع 0.0. إليك كيفية القيام بذلك باستخدام `java.util.stream`.

#### **حل خطوة بخطوة**
1. **إنشاء سيل**
   - ابدأ مع `List<Integer>` (مثل `List.of(1, 2, 12, 15, 20, 25, 30)`).
   - استخدم طريقة `stream()` لإنشاء `Stream<Integer>`:
     ```java
     list.stream()
     ```

2. **تصفية السيل**
   - استخدم طريقة `filter` لحفظ فقط الأعداد التي هي زوجية وأكبر من 10.
   - تأخذ طريقة `filter` `Predicate` (دالة ترجع قيمة منطقية) كعبارة لامدا:
     ```java
     .filter(number -> number % 2 == 0 && number > 10)
     ```
     - `number % 2 == 0` يحدد إذا كانت الأرقام زوجية.
     - `number > 10` يضمن أن الرقم أكبر من 10.
     - بالنسبة للقائمة المثالية `[1, 2, 12, 15, 20, 25, 30]`, هذا يحتفظ بـ `[12, 20, 30]`.

3. **تحويل إلى `IntStream`**
   - نظرًا لأن `average()` متاحة على السيلات الأولية مثل `IntStream` (ليس `Stream<Integer>`)، قم بتحويل `Stream<Integer>` إلى `IntStream` باستخدام `mapToInt`:
     ```java
     .mapToInt(i -> i)
     ```
     - `i -> i` يفتح كل `Integer` إلى `int`. يمكنك أيضًا استخدام `Integer::intValue`.
     - هذا يعطي `IntStream` من `[12, 20, 30]`.

4. **حساب المتوسط**
   - استخدم طريقة `average()` على `IntStream`، والتي ترجع `OptionalDouble` (لأن السيل قد يكون فارغًا):
     ```java
     .average()
     ```
     - بالنسبة لـ `[12, 20, 30]`, هذا يحسب `(12 + 20 + 30) / 3 = 20.666...`.
     - إذا كان السيل فارغًا، فإنه يرجع `OptionalDouble` فارغًا.

5. **معالجة الحالة الفارغة**
   - استخدم `orElse(0.0)` على `OptionalDouble` لإرجاع 0.0 إذا لم يكن هناك أرقام تفي بالتصفية:
     ```java
     .orElse(0.0)
     ```
     - بالنسبة لـ `[12, 20, 30]`, هذا يرجع `20.666...`.
     - بالنسبة للقائمة مثل `[1, 3, 5]` (لا يوجد أرقام زوجية > 10), يرجع `0.0`.

#### **الكود الكامل**
هنا هو الحل الكامل كطريقة:
```java
import java.util.List;

public class Main {
    public static double averageOfEvenGreaterThanTen(List<Integer> list) {
        return list.stream()
                   .filter(number -> number % 2 == 0 && number > 10)
                   .mapToInt(i -> i)
                   .average()
                   .orElse(0.0);
    }

    public static void main(String[] args) {
        // حالات الاختبار
        System.out.println(averageOfEvenGreaterThanTen(List.of(1, 2, 12, 15, 20, 25, 30)));  // ~20.666
        System.out.println(averageOfEvenGreaterThanTen(List.of(1, 3, 5)));                    // 0.0
        System.out.println(averageOfEvenGreaterThanTen(List.of(12)));                         // 12.0
        System.out.println(averageOfEvenGreaterThanTen(List.of()));                           // 0.0
        System.out.println(averageOfEvenGreaterThanTen(List.of(10, 8, 6)));                   // 0.0
        System.out.println(averageOfEvenGreaterThanTen(List.of(11, 13, 14, 16)));             // 15.0
    }
}
```

---

### **الميزات الرئيسية لـ `java.util.stream` التي تم توضيحها**
- **التسلسل**: يتم تسلسل العمليات في نمط مريح (مثل `.filter().mapToInt().average()`).
- **البطء**: العمليات المتوسطة (مثل `filter` و `mapToInt`) لا يتم تنفيذها إلا عند استدعاء العملية النهائية (`average`).
- **السيلات الأولية**: `IntStream` يوفر طرقًا مثل `average()` مخصصة لعمليات العددية، مما يوفر تجنب تكلفة التعبئة.
- **معالجة الاختيار**: `OptionalDouble` يعالج الحالات التي لا يوجد فيها نتيجة، مع `orElse` يوفر قيمة افتراضية.

---

### **الطريقة البديلة**
يمكنك أيضًا استخدام طائفة `Collectors`:
```java
import java.util.stream.Collectors;

double average = list.stream()
                     .filter(number -> number % 2 == 0 && number > 10)
                     .collect(Collectors.averagingInt(i -> i));
```
- هذا يرجع `Double` مباشرة ويرجع `0.0` للسيل الفارغ. ومع ذلك، `mapToInt().average()` أكثر مباشرة لهذا المثال البسيط ويوافق على استخدام السيلات الأولية.

---

### **متى استخدام السيلات**
- استخدم `java.util.stream` للكود الواضح والمفهم عند معالجة المجموعات.
- بالنسبة للبيانات الكبيرة، اعتبر استخدام `parallelStream()` بدلاً من `stream()` للاستفادة من التوازي، على الرغم من أن هذا هو أكثر من اللازم للقوائم الصغيرة بسبب التكلفة.

---

يوضح هذا المثال كيفية استخدام `java.util.stream` لحل مشكلة عملية. يمكنك تعديل هذه الخطوات - إنشاء سيل، تصفية، تحويل، وتقليل - إلى حالات أخرى حسب الحاجة!