---
audio: false
generated: true
image: false
lang: ar
layout: post
model: x-ai/grok-4-fast:free
title: مواقع مصدر وفئات JavaCC
translated: true
type: note
---

### نظرة عامة على JavaCC
JavaCC (مُصرِّف مُصرِّف جافا) هو أداة تُنشئ شفرة مصدرية بلغة جافا (مثل فئات المحلِّل) من ملفات مواصفات القواعد النحوية (ملفات `.jj`). إنها **لا** تُصرِّف الشفرة مباشرةً إلى bytecode (ملفات `.class`) — فهذه المهمة ت handled بواسطة مُصرِّف جافا قياسي مثل `javac`. إذا كنت تستخدم JavaCC برمجيًا (مثلًا في بيئة تطوير متكاملة IDE أو بيئة وقت التشغيل) لتوليد وتجميع شفرة ديناميكية، فإن مواقع الإخراج تعتمد على كيفية تكوينك لها. سأشرح هذا خطوة بخطوة، بناءً على السلوك القياسي لـ JavaCC وأنماط الاستخدام الشائعة.

### أين يُولِّد JavaCC ملفات المصدر
- **موقع الإخراج الافتراضي**: يُخرج JavaCC ملفات `.java` المُنشأة إلى **دليل العمل الحالي** (أو دليل فرعي يسمى "output" إذا لم يتم تحديده). يمكنك تجاوز هذا باستخدام خيارات سطر الأوامر مثل `-OUTPUT_DIRECTORY=<مسار>` أو برمجيًا عبر فئة `JavaCCOptions` إذا كنت تستدعيها في الشفرة.
- **مثال على استخدام سطر الأوامر**:
  ```
  javacc -OUTPUT_DIRECTORY=/path/to/generated MyGrammar.jj
  ```
  هذا من شأنه إنشاء ملفات `.java` (مثل `Token\` 0, `Parser`, `ParseException`) في `/path/to/generated`.
- **الاستخدام البرمجي**: إذا كنت تستدعي JavaCC من داخل تطبيق جافا الخاص بك (مثلًا باستخدام `org.javacc.JavaCC.main()` أو واجهات برمجة تطبيقات APIs مماثلة)، يمكنك تعيين الخيارات لتحديد مسار الإخراج. ملفات المصدر هي مجرد ملفات `.java` عادية تحتاج إلى مزيد من التجميع.

هذا يتوافق مع التوثيق الرسمي لـ JavaCC (مثلًا من مشروع JavaCC القديم على SourceForge أو التوزيعات القائمة على Maven)، الذي ينص على أن الفئات المُنشأة تُخرج إلى الدليل المحدد كشفرة مصدرية، وليس bytecode.

### أين تُخزَّن الفئات المُصرَّفة إذا قمت بتجميع الشفرة المُنشأة
إن JavaCC بذاتها لا تُصرِّف إلى ملفات `.class` — يجب عليك القيام بذلك يدويًا أو أتمتة ذلك في شفرتك. إليك ما يحدث بعد ذلك:

- **التجميع اليدوي**: استخدم `javac` على ملفات `.java` المُنشأة:
  ```
  javac -d /path/to/classes MyGeneratedParser.java
  ```
  - تحدد علامة `-d` دليل الإخراج لملفات `.class`، غالبًا مجلد `classes/` أو هدف بناء مشروعك (مثل `target/classes/` في Maven/Gradle).
  - المواقع الشائعة: `bin/`, `build/classes/`, أو `target/classes/` اعتمادًا على نظام البناء الخاص بك (مثل Ant, Maven).

- **التجميع الديناميكي في الشفرة**: إذا كنت تستخدم JavaCC أثناء وقت التشغيل runtime لتوليد محلِّلين لشفرة ديناميكية (مثلًا لتفسير النصوص البرمجية scripts أو التحليل على الطاير on-the-fly parsing)، فعادةً ما ستقوم بـ:
  1. توليد ملفات `.java` برمجيًا (مثلًا، الكتابة إلى دليل مؤقت مثل `System.getProperty("java.io.tmpdir")`).
  2. تجميعها باستخدام Java Compiler API (javax.tools.JavaCompiler) أو مكتبة مثل Janino.
     - مثال: عيّن إخراج التجميع إلى دليل مخصص، مثل `new File("generated/classes")`.
     - تُخزَّن ملفات `.class` المُصرَّفة في ذلك الدليل. أثناء وقت التشغيل، استخدم ClassLoader مخصصًا لتحميلها من هناك أو من مخازن مؤقتة في الذاكرة.
  - **الافتراضي في JVM**: بدون مسارات مخصصة، قد تذهب الفئات إلى `target/classes` الافتراضي إذا كنت تستخدم أدوات بناء، أو إلى أي دليل تحدده في مهمة التجميع.

- **السيناريوهات الديناميكية الشائعة**:
  - **التجميع في الذاكرة**: تسمح مكتبات مثل Compiler API بالتجميع دون الكتابة على القرص، وتخزين bytecode في الذاكرة عبر `ClassLoader.defineClass()`. لا يحدث تخزين مادي.
  - **التخزين المؤقت**: إذا تم تجميع الشفرة المُنشأة واستمرارها، فغالبًا ما تذهب إلى `/tmp/` في أنظمة شبيهة يونكس أو المجلدات المؤقتة. بالنسبة للتطبيقات الإنتاجية، استخدم دليل `generated/` أو `cache/` مخصص في نظام ملفات مشروعك.
  - **الأطر Frameworks**: قد تُؤتمت أدوات مثل ANTLR (بديل لـ JavaCC) أو العدّادات المخصصة runners هذا، مخزنة الفئات في ذاكرة الوصول العشوائي RAM أو مجلد في classpath (مثل إدخالات `CLASSPATH`).

### الاعتبارات الرئيسية وأفضل الممارسات
- **سلامة وقت التشغيل**: يحمل تجميع الشفرة ديناميكيًا مخاطر (مثل مشاكل الأمان). تأكد من أن القواعد النحوية المُولَّدة من قبل المستخدم معزولة في بيئة آمنة sandboxed.
- **تكامل أدوات البناء**: إذا كنت تستخدم Maven أو Gradle، فإن إضافات JavaCC plugins (مثل `javacc-maven-plugin`) تُخرج إلى `target/generated-sources/javacc/` للمصادر وإلى `target/classes/` للفئات المُصرَّفة، ويمكن تكوينها في ملف `pom.xml` أو `build.gradle` الخاص بك.
- **تصحيح الأخطاء**: إذا فشل التجميع، فتحقق من إخراج خطأ JavaCC أو السجلات logs. عادةً ما تُخزَّن الملفات المُنشأة حيث يعمل تطبيقك، وليس بشكل عام.
- **الأدلة من التوثيق**: وفقًا للدليل الرسمي لـ JavaCC (javacc.github.io أو التوثيق القديم)، فإن الإخراج قائم على الدليل ويتم التعامل مع ما بعد التجميع بواسطة المستخدم. تُظهر الأمثلة الواقعية في مستودعات GitHub (مثلًا، ابحث عن استخدام JavaCC) أدلة إخراج مخصصة مثل `src/main/generated/`.

إذا كان هذا لا يتطابق مع إعدادك (مثل إطار عمل framework أو بيئة تطوير متكاملة IDE معينة)، فقدم المزيد من التفاصيل مثل مقتطف الشفرة أو البيئة الخاصة بك، ويمكنني تحسين الإجابة!