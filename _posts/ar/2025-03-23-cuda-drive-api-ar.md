---
audio: false
generated: true
lang: ar
layout: post
title: واجهة برمجة تطبيقات مشغل CUDA
translated: true
type: note
---

رأس `<cuda.h>` هو جزء من **واجهة برمجة تطبيقات برنامج تشغيل CUDA**، وهي واجهة برمجة تطبيقات منخفضة المستوى مقارنة بواجهة وقت تشغيل CUDA عالية المستوى (مثل `cudaMalloc`، `cudaMemcpy`). توفر واجهة برمجة تطبيقات برنامج التشغيل تحكمًا أدق في موارد وحدة معالجة الرسومات (مثل السياقات، الوحدات، التدفقات) وغالبًا ما تُستخدم في سيناريوهات متقدمة مثل البرمجة متعددة وحدات معالجة الرسومات، أو تحميل النواة ديناميكيًا، أو التحسينات منخفضة المستوى.

### دوال شائعة في واجهة برمجة تطبيقات برنامج تشغيل CUDA
إليك بعض الدوال الرئيسية وأغراضها:

| الدالة                          | الوصف                                                                                   |
|----------------------------------|-----------------------------------------------------------------------------------------------|
| **`cuInit(unsigned int flags)`** | يقوم بتهيئة برنامج تشغيل CUDA. يجب استدعاؤه قبل أي دالة أخرى في واجهة برمجة تطبيقات برنامج التشغيل. |
| **`cuDeviceGet(CUdevice *dev, int ordinal)`** | يحصل على مقبض لجهاز وحدة معالجة الرسومات ذي الترتيب المحدد (مثل `0` لأول وحدة معالجة رسومات).     |
| **`cuCtxCreate(CUcontext *ctx, unsigned int flags, CUdevice dev)`** | ينشئ سياق CUDA على الجهاز المحدد.                                                             |
| **`cuModuleLoad(CUmodule *mod, const char *fname)`** | يقوم بتحميل ملف PTX أو cubin في السياق الحالي كوحدة.                                |
| **`cuModuleGetFunction(CUfunction *func, CUmodule mod, const char *name)`** | يسترجع دالة نواة من وحدة محملة.                                                              |
| **`cuMemAlloc(CUdeviceptr *dptr, size_t bytesize)`** | يخصص ذاكرة على وحدة معالجة الرسومات.                                                                  |
| **`cuMemcpyHtoD(CUdeviceptr dst, const void *src, size_t bytes)`** | ينقل البيانات من المضيف (وحدة المعالجة المركزية) إلى الجهاز (وحدة معالجة الرسومات).                                                  |
| **`cuMemcpyDtoH(void *dst, CUdeviceptr src, size_t bytes)`** | ينقل البيانات من الجهاز (وحدة معالجة الرسومات) إلى المضيف (وحدة المعالجة المركزية).                                                  |
| **`cuLaunchKernel(CUfunction f, ...)`** | يُطلق دالة نواة بأبعاد شبكة/كتلة ومعلمات محددة.                                                |

---

### مثال على سير العمل
فيما يلي مثال مبسط باستخدام واجهة برمجة تطبيقات برنامج تشغيل CUDA لـ:
1. تهيئة برنامج التشغيل.
2. تخصيص ذاكرة وحدة معالجة الرسومات.
3. نسخ البيانات من/إلى وحدة معالجة الرسومات.
4. تحميل نواة من ملف PTX وتنفيذها.

```cpp
#include <cuda.h>
#include <stdio.h>

int main() {
    CUdevice dev;
    CUcontext ctx;
    CUmodule mod;
    CUfunction kernel;
    CUresult err;

    // 1. تهيئة برنامج تشغيل CUDA
    cuInit(0);

    // 2. الحصول على مقبز لجهاز 0 (أول وحدة معالجة رسومات)
    cuDeviceGet(&dev, 0);

    // 3. إنشاء سياق على الجهاز
    cuCtxCreate(&ctx, 0, dev);

    // 4. تحميل وحدة PTX (مثال: مُنشأة من ملف .cu)
    cuModuleLoad(&mod, "my_kernel.ptx");

    // 5. الحصول على دالة النواة من الوحدة
    cuModuleGetFunction(&kernel, mod, "my_kernel");

    // 6. تخصيص ذاكرة وحدة معالجة الرسومات
    size_t N = 1024;
    CUdeviceptr d_data;
    cuMemAlloc(&d_data, N * sizeof(float));

    // 7. نسخ البيانات من المضيف إلى الجهاز
    float h_data[N] = {1.0f};
    cuMemcpyHtoD(d_data, h_data, N * sizeof(float));

    // 8. تكوين معلمات النواة
    void *args[] = { &d_data, &N };
    int blockSize = 256;
    int gridSize = (N + blockSize - 1) / blockSize;

    // 9. إطلاق النواة
    cuLaunchKernel(
        kernel,
        gridSize, 1, 1,    // أبعاد الشبكة
        blockSize, 1, 1,   // أبعاد الكتلة
        0, NULL,           // الذاكرة المشتركة والتدفق
        args, NULL         // معلمات النواة
    );

    // 10. نسخ النتائج مرة أخرى إلى المضيف
    cuMemcpyDtoH(h_data, d_data, N * sizeof(float));

    // 11. التنظيف
    cuMemFree(d_data);
    cuModuleUnload(mod);
    cuCtxDestroy(ctx);

    return 0;
}
```

---

### ملاحظات رئيسية
1. **معالجة الأخطاء**: تحقق دائمًا من قيمة الإرجاع (مثال: `CUresult err = cuSomeFunction(...);`). استخدم `cuGetErrorString(err)` لفك رموز الأخطاء.
2. **معلمات النواة**: بالنسبة لـ `cuLaunchKernel`، يتم تمرير المعلمات كمصفوفة من المؤشرات إلى الوسائط. تأكد من أن الترتيب يتطابق مع المعلمات المتوقعة للنواة.
3. **ملفات PTX**: يجب تجميع النواة إلى PTX (مثال: `nvcc --ptx my_kernel.cu -o my_kernel.ptx`).
4. **إدارة السياق**: السياقات مماثلة لعمليات وحدة المعالجة المركزية - فهي تدير الموارد لوحدة معالجة الرسومات. استخدم `cuCtxPushCurrent`/`cuCtxPopCurrent` للبرمجة متعددة الخيوط.

---

### متى تستخدم واجهة برمجة تطبيقات برنامج التشغيل؟
- **تحميل النواة ديناميكيًا**: تحميل PTX في وقت التشغيل.
- **التحكم متعدد وحدات معالجة الرسومات**: إدارة وحدات معالجة رسومات متعددة بشكل صريح.
- **التحسينات منخفضة المستوى**: تحكم دقيق في السياقات، أو التدفقات، أو الذاكرة.

في معظم التطبيقات، تكون **واجهة وقت التشغيل** عالية المستوى (مثل `cudaMalloc`، `cudaMemcpy`) كافية وأبسط. استخدم واجهة برمجة تطبيقات برنامج التشغيل عندما تحتاج إلى ميزاتها المتقدمة.