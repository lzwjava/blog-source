---
audio: false
generated: true
image: false
lang: ar
layout: post
model: x-ai/grok-4-fast
title: دليل الجبر الخطي في نومبي الجيب
translated: true
type: note
---

باعتباري مدرسًا يركز على الهندسة، يبني هذا الدليل على الصيغ الصريحة للمؤشرات السابقة من خلال دمج عروض NumPy العملية عبر `import numpy as np` و `np.linalg`. تظل جميع الرياضيات قابلة للتحقق باستخدام المؤشرات (مثل \\( A = [a_{ij}]_{i=1}^2, j=1^2 \\)); يستخدم الكود مصفوفات صريحة للوضوح. المخرجات من تنفيذات تم التحقق منها (مثل \\( A = \begin{pmatrix} a_{11}=1 & a_{12}=2 \\ a_{21}=3 & a_{22}=4 \end{pmatrix} \\)، \\( B = \begin{pmatrix} 5 & 6 \\ 7 & 8 \end{pmatrix} \\)). استخدم هذه للعمليات الحسابية السريعة في التحضير للامتحانات—ركز على تفسير المخرجات مقابل الصيغ.

## 1. عمليات المصفوفات
الرياضيات كما كانت من قبل: \\( (AB)_{ij} = \sum_{k=1}^2 a_{ik} b_{kj} \\)، إلخ.

**عرض NumPy**:
```python
import numpy as np
A = np.array([[1, 2], [3, 4]], dtype=float)
B = np.array([[5, 6], [7, 8]], dtype=float)
```
- الجمع: `A + B` ينتج \\( \begin{pmatrix} 6 & 8 \\ 10 & 12 \end{pmatrix} \\) (حسب الإدخال \\( a_{ij} + b_{ij} \\)).
- العدد القياسي: `2 * A` ينتج \\( \begin{pmatrix} 2 & 4 \\ 6 & 8 \end{pmatrix} \\) (\\( c a_{ij} \\)).
- الضرب: `A @ B` (أو `np.dot(A, B)`) ينتج \\( \begin{pmatrix} 19 & 22 \\ 43 & 50 \end{pmatrix} \\) (تحقق: مجموع الصف1-عمود1 \\( 1\cdot5 + 2\cdot7 = 19 \\)). لاحظ عدم الإبدال: `np.allclose(A @ B, B @ A)` هو `False`.
- منقول المصفوفة: `A.T` ينتج \\( \begin{pmatrix} 1 & 3 \\ 2 & 4 \end{pmatrix} \\) (\\( (A^T)_{ij} = a_{ji} \\)).
- المعكوس: `np.linalg.inv(A)` ينتج \\( \begin{pmatrix} -2 & 1 \\ 1.5 & -0.5 \end{pmatrix} \\) (تحقق: `A @ inv_A` ≈ \\( I = \begin{pmatrix} 1 & 0 \\ 0 & 1 \end{pmatrix} \\)، مع أخطاء صغيرة في الفاصلة العائمة ~1e-16).

## 2. المحددات
الرياضيات: \\( \det A = \sum_{j=1}^2 a_{1j} C_{1j} \\)، \\( C_{1j} = (-1)^{1+j} \det(M_{1j}) \\) (مثال: \\( M_{11} = [4] \\)، لذا \\( C_{11} = 4 \\); بالكامل \\( \det A = 1\cdot4 - 2\cdot3 = -2 \\)).

**عرض NumPy** (متابعة ما سبق):
- `np.linalg.det(A)`: -2.0 (يطابق الصيغة؛ دقة الفاصلة العائمة -2.0000000000000004).
- الضرب: `np.linalg.det(A @ B)` = 4.0; `det_A * np.linalg.det(B)` ≈ 4.0 (يُتحقق من \\( \det(AB) = \det A \cdot \det B \\)).
- المنقول: `np.linalg.det(A.T)` = -2.0 (يُتحقق من \\( \det(A^T) = \det A \\)).

للربط بين المرافق الحاشدة/المعكوس: يستخدم المعكوس المحدد في المقام، كما في الصيغة \\( A^{-1} = \frac{1}{\det A} \adj A \\).

## 3. الأنظمة الخطية والحذف الغاوسي
الرياضيات: زيادة \\( [A | b] \\) مع \\( b = [b_i]_{i=1}^2 = [5, 11]^T \\); الحل عن طريق الإرجاع بعد REF.

**عرض NumPy**:
- `np.linalg.solve(A, b)` ينتج [1. 2.] (بالضبط: \\( x_1 = \frac{\det A_1}{\det A} \\)، حيث \\( A_1 \\) تبادل العمود1 مع b، محدد= -2 نفسه؛ يُتحقق من كرامر).
- التحقق: `A @ x` = [5. 11.] (الباقي 0).
- الرتبة: `np.linalg.matrix_rank(A)` = 2 (كاملة؛ للمفردة، رتبة < 2 تعني عدد لا نهائي/لا يوجد حلول).

دالة `solve` في NumPy تؤدي تحليل LU داخليًا (لا حاجة لكود غاوسي صريح؛ للمخصص، استخدم `scipy.linalg.lu` ولكن التزم بـ np.linalg هنا).

## 4. الفضاءات المتجهة
الرياضيات: رتبة A = # المحاور = بُعد Col(A); الباطنية = 2 - رتبة A.

**عرض NumPy**:
- الرتبة كما سبق: 2.
- تقدير الباطنية عبر SVD: `U, S, Vt = np.linalg.svd(A)`; عد القيم المفردة > 1e-10: 2، لذا الباطنية = 2 - 2 = 0 (Nul(A) = {0}). للأساس، متجهات فضاء العدم من صفوف Vt ذات S الصغيرة.

## 5. التحويلات الخطية
الرياضيات: T(x)_i = \\( \sum_j a_{ij} x_j \\); التمثيل المصفوفي هو A.

**الربط مع NumPy**: نفس عمليات المصفوفة؛ مثال: `T_x = A @ x` يطبق التحويل (بشكل متجه).

## 6. القيم الذاتية
الرياضيات: حل det(A - λ I) = 0، (A - λ I)_{ij} = a_{ij} - λ δ_{ij}; ثم (A - λ I) v = 0 من أجل v_j.

**عرض NumPy**:
- `eigvals, eigvecs = np.linalg.eig(A)`: eigvals ≈ [-0.372, 5.372] (جذور λ² - tr(A)λ + det A = λ² - 5λ -2 =0).
- أعمدة المتجهات الذاتية: مثال: col0 ≈ [-0.825, 0.566]^T لـ λ≈-0.372.
- التحقق: `A @ eigvecs[:,0]` ≈ λ eigvecs[:,0] (تحقق معياري: `A @ eigvecs[:,0] / eigvals[0]` يطابق eigvecs[:,0]).

للقياسية: متجهات ذاتية كاملة الرتبة (det ≠0).

## 7. الضرب الداخلي والتعامد
الرياضيات: <u,v> = \\( \sum_i u_i v_i \\); الإسقاط = (<v,w>/<w,w>) w (ضرب قياسي على w_i).

**عرض NumPy** (u=[1,2], v=[3,4]):
- `np.dot(u, v)` = 11 (أو `u @ v`).
- `np.linalg.norm(u)` ≈ 2.236 (√<u,u>).

غرام-شميدت: استخدم `np.linalg.qr(V)` للمصفوفة V (الأعمدة كمتجهات أساسية); Q = متعامدة مقيسة.
- مثال V = \\( \begin{pmatrix} 3 & 0 & 0 \\ 1 & 2 & 0 \\ 0 & 0 & 3 \end{pmatrix} \\) (الأعمدة v^{(1)}=[3,1,0]^T، إلخ.).
- `ortho = np.linalg.qr(V)[0]` ينتج ≈ \\( \begin{pmatrix} -0.949 & -0.316 & 0 \\ -0.316 & 0.949 & 0 \\ 0 & 0 & 1 \end{pmatrix} \\) (قلب الإشارة مقبول).
- التحقق: `np.allclose(ortho.T @ ortho, np.eye(3))` = True (δ_{ij}).

الصيغة التربيعية: `u @ A @ u` = 27.0 (x^T A x مع x_i = u_i; للتأكد الإيجابي، كل القيم الذاتية >0—هنا إشارات مختلطة).

**نصيحة التحقق السريع**: دائماً استخدم `np.allclose` للفاصلة العائمة; اختزل الصفوف يدويًا لـ n صغيرة، ثم طابق `solve` أو `eig`. تدرب: استبدل بمصفوفات 3×3 الخاصة بك.

[NumPy linalg Documentation](https://numpy.org/doc/stable/reference/routines.linalg.html)  
[Linear Algebra in NumPy - SciPy Lecture Notes](https://scipy-lectures.org/intro/numpy/auto_examples/plot_linear_algebra.html)