---
audio: false
generated: true
lang: ar
layout: post
title: مهندس خلفية Java مقابلة
translated: true
---

**Java Core (20 نقاط)**

1. فهم مبادئ البرمجة الموجهة للobjects: التغطية، الوراثة، متعدد الأشكال، التعمية.

2. الجينيريك في جاوا: استخدام المعلمات النوعية، الأنواع المحددة، والجينيريك الواسع.

3. المتعدد التسلسل في جاوا: إنشاء الخيوط، دورة حياة الخيط، والتواصل بين الخيوط.

4. إدارة ذاكرة JVM: الكومة، الكومة، مساحة PermGen/Survivor، خوارزميات جمع النفايات.

5. معالجة الاستثناءات: الاستثناءات المحكومة وغير المحكومة، كتلة try-catch، في النهاية، ومتعدد الاستثناءات.

6. التسلسل في جاوا: واجهة التسلسل، التسلسل المخصص مع writeObject و readObject.

7. إطار عمل المجموعات في جاوا: واجهات قائمة، مجموعة، خريطة، طابور و تنفيذاتها.

8. التعبيرات اللامبدا و واجهات الوظائف: استخدام المتنبئين، المستهلكين، الموردين، والوظائف.

9. API التدفق: العمليات المتوسطة والنهائية، التدفقات المتوازية، و تدفق الأنابيب.

10. API المرآة: الوصول إلى الفئات، الطرق، والمتغيرات في وقت التشغيل، معالجة التعليقات.

11. جاوا IO مقابل NIO: الاختلافات في معالجة الملفات، إدخال / إخراج القناة، و إدخال / إخراج غير الموقوف.

12. API تاريخ و وقت جاوا: العمل مع LocalDate، LocalDateTime، و Duration.

13. شبكات جاوا: برمجة الجوازات، اتصالات URL، و عملاء HTTP.

14. أمان جاوا: التشفير، التوقيعات الرقمية، و الممارسات الآمنة للكتابة.

15. وحدات جاوا: فهم JPMS (نظام وحدات منصة جاوا) و التجزئة.

16. التعدادات في جاوا: استخدام التعدادات، القيم العرفي، و الطرق المخصصة في التعدادات.

17. التعليقات في جاوا: التعليقات المدمجة، التعليقات المخصصة، و معالجة التعليقات.

18. أدوات التزامن في جاوا: CountDownLatch، CyclicBarrier، Semaphore، و Exchanger.

19. تسرب الذاكرة في جاوا: الأسباب، الكشف، و استراتيجيات الوقاية.

20. تحسين أداء جاوا: خيارات JVM، أدوات التصفية، و استراتيجيات تحسين الذاكرة.

**مجموعة Spring (20 نقاط)**

21. حاوية Spring IoC: حقن الاعتماد، دورة حياة الفئة، و النطاق.

22. التكوين التلقائي في Spring Boot: كيفية تكوين Spring Boot الفئات تلقائيًا.

23. Spring Data JPA: نماذج المستودع، عمليات CRUD، و طرق الاستعلام.

24. Spring Security: التحقق من الهوية، الصلاحيات، و حماية APIs REST.

25. Spring MVC: طرق التحكم، خريطة الطلب، و حلول العرض.

26. Spring Cloud: اكتشاف الخدمة مع Eureka، توازن الحمل مع Ribbon.

27. Spring AOP: برمجة التوجه إلى الجانب، المعالجات المتقاطعة، و أنواع النصائح.

28. Spring Boot Actuator: نقاط النهاية للمراقبة، فحص الصحة، و جمع البيانات.

29. ملفات Spring: التكوين الخاص بالبيئة و تفعيل الملفات.

30. Spring Boot Starter Dependencies: استخدام البدء لتسهيل إدارة الاعتماد.

31. Spring Integration: دمج الأنظمة المختلفة، الرسائل، و الوصلات.

32. Spring Batch: معالجة الحزم، جدول العمل، و تنفيذ الخطوات.

33. Spring Cache: استراتيجيات التخزين المؤقت، التعليقات، و مدير التخزين المؤقت.

34. Spring WebFlux: البرمجة التفاعلية، إدخال / إخراج غير الموقوف، و إطار WebFlux.

35. Spring Cloud Config: إدارة التكوين المركزي للميكروسيرفيس.

36. Spring Cloud Gateway: نماذج البوابة API، التوجيه، و التصفية.

37. اختبار Spring Boot: استخدام @SpringBootTest، MockMvc، و TestRestClient.

38. Spring Data REST: عرض المستودعات كخدمات RESTful.

39. Spring Cloud Stream: دمج مع وسيط الرسائل مثل RabbitMQ و Kafka.

40. Spring Cloud Sleuth: تتبع و تسجيل موزع في الميكروسيرفيس.

**معمارية الميكروسيرفيس (20 نقاط)**

41. اكتشاف الخدمة: كيفية عمل Eureka، Consul، و Zookeeper.

42. بوابة API: نماذج، التوجيه، و الأمان في بوابات API.

43. محول الدائرة: تنفيذ المقاومة مع Hystrix، Resilience4j.

44. معمارية التوجيه بالحدث: مصدر الحدث، وسيط الرسائل، و معالجات الحدث.

45. تصميم API RESTful: HATEOAS، التصميم بدون حالة، و قيود REST.

46. GraphQL: تنفيذ APIs GraphQL، تعريفات الشكل، و المحللين.

47. تواصل الميكروسيرفيس: التواصل المتزامن مقابل غير المتزامن.

48. نمط الساغا: إدارة المعاملات الموزعة عبر الخدمات.

49. فحص الصحة: تنفيذ فحص الحياة و جاهزية.

50. تطوير أولًا بالاتفاق: استخدام Swagger للاتفاقيات API.

51. إصدارات API: استراتيجيات إصدار APIs RESTful.

52. الحد من معدل: تنفيذ حدود معدل لمنع الاستغلال.

53. نماذج محول الدائرة: تنفيذ الاسترجاع و إعادة المحاولة.

54. نشر الميكروسيرفيس: استخدام Docker، Kubernetes، و منصات السحاب.

55. شبكة الخدمات: فهم Istio، Linkerd، و فوائدها.

56. التعاون بالحدث: نمط الساغا مقابل نمط التسلسل.

57. أمان الميكروسيرفيس: OAuth2، JWT، و بوابات API.

58. المراقبة والتتبع: أدوات مثل Prometheus، Grafana، و Jaeger.

59. اختبار الميكروسيرفيس: اختبار التكامل، اختبار العقد، و اختبار النهاية إلى النهاية.

60. قاعدة بيانات لكل خدمة: إدارة البيانات و الاستقرار في الميكروسيرفيس.

**قواعد البيانات والتخزين المؤقت (20 نقاط)**

61. انضمامات SQL: داخلي، خارجي، يسار، يمين، و انضمام متقاطع.

62. خصائص ACID: الوحدة، الاستقرار، العزل، الديمومة في المعاملات.

63. قواعد البيانات NoSQL: مخازن الوثائق، مخازن القيم، و قواعد البيانات الرسومية.

64. Redis Caching: مخزن البيانات في الذاكرة، بنية البيانات، و خيارات الديمومة.

65. Memcached مقابل Redis: مقارنة حلول التخزين المؤقت.

66. تقسيم قاعدة البيانات: تقسيم أفقي، و توازن الحمل.

67. إطار عمل ORM: Hibernate، MyBatis، و مواصفات JPA.

68. تجميع اتصال JDBC: تنفيذ DataSource و دورة حياة الاتصال.

69. البحث الكامل: تنفيذ البحث في قواعد البيانات مثل Elasticsearch.

70. قواعد البيانات الزمنية: InfluxDB، OpenTSDB للبيانات الزمنية.

71. مستويات عزل المعاملات: غير مرفق، مرفق، قابل للقراءة، متكرر، متسلسل.

72. استراتيجيات الفهرسة: B-tree، فهرس هاش، و فهرس مركب.

73. تكرار قاعدة البيانات: رئيس-غلام، رئيس-رئيس.

74. نسخ احتياطي و استعادة قاعدة البيانات: استراتيجيات حماية البيانات.

75. تحليل قاعدة البيانات: أدوات مثل SQL Profiler، سجلات الاستعلام البطيئة.

76. نماذج استقرار NoSQL: الاستقرار النهائي، نظرية CAP.

77. هجرة قاعدة البيانات: استخدام Flyway، Liquibase لتغييرات الهيكل.

78. استراتيجيات التخزين المؤقت: تخزين جانبي، قراءة عبر، كتابة عبر.

79. إلغاء تخزين المؤقت: إدارة انتهاء صلاحية و إلغاء التخزين المؤقت.

80. تجميع اتصال قاعدة البيانات: HikariCP، تكوينات Tomcat JDBC.

**التزامن والتسلسل المتعدد (20 نقاط)**

81. دورة حياة الخيط: جديد، قابل للتنفيذ، يجري، محظور، في انتظار، منتهي.

82. آليات التزامن: القفل، كتلة المتزامن، و القفل الداخلي.

83. قفل إعادة الدخول: فوائد على كتلة المتزامن، العدل، و الأوقات.

84. إطار العمل التنفيذي: ThreadPoolExecutor، ExecutorService، و تكوينات مجموعة الخيوط.

85. Callable مقابل Runnable: الاختلافات و حالات الاستخدام.

86. نموذج الذاكرة في جاوا: الرؤية، العلاقات التي تحدث قبل، و استقرار الذاكرة.

87. كلمة مفتاحية متغيرة: ضمان رؤية تغييرات المتغيرات عبر الخيوط.

88. منع التوقف: تجنب و كشف التوقف.

89. البرمجة غير المتزامن: استخدام CompletableFuture للعمليات غير الموقوفة.

90. ScheduledExecutorService: جدول العمليات مع معدلات ثابتة و تأخير.

91. مجموعات الخيوط: ثابتة، مخزنة، و مخطط.

92. قفل الشريط: تقليل التنافس على القفل مع القفل المشرط.

93. قفل القراءة والكتابة: السماح لعدد من القراء أو كاتب واحد.

94. آليات الانتظار و الإشعار: التواصل بين الخيوط باستخدام wait/notify.

95. إيقاف الخيط: معالجة الإيقاف و تصميم المهام القابلة للإيقاف.

96. فئات آمنة للخيط: تنفيذ نمط Singleton الآمن للخيط.

97. أدوات التزامن: CountDownLatch، CyclicBarrier، Semaphore.

98. ميزات التزامن في جاوا 8+: التدفقات المتوازية، إطار العمل fork-join.

99. برمجة متعددة النواة: تحديات و حلول للعمليات المتوازية.

100. رصد الخيوط و تحليلها: تحديد المشاكل مع رصد الخيوط.

**خادم الويب و توازن الحمل (20 نقاط)**

101. تكوين Apache Tomcat: إعداد الوصلات، context.xml، و server.xml.

102. Nginx كوكيل عكسي: تكوين proxy_pass، خادم upstream، و توازن الحمل.

103. HAProxy للاحتياط: إعداد الفشل، و استمرارية الجلسة.

104. أمان خادم الويب: تكوينات SSL/TLS، رؤوس الأمان، و قواعد الحائط الناري.

105. خوارزميات توازن الحمل: دورية، أقل اتصال، هاش IP.

106. تخزين المؤقت على جانب الخادم: استخدام Varnish، Redis، أو التخزين المؤقت في الذاكرة.

107. أدوات المراقبة: استخدام Prometheus، Grafana، و New Relic لمراقبة الخادم.

108. تسجيل في الإنتاج: تسجيل مركزي مع ELK stack أو Graylog.

109. توسيع أفقي مقابل عمودي: فهم التضحيات و حالات الاستخدام.

110. تحسين أداء خادم الويب: تعديل خيوط العمال، أوقات انتظار الاتصال، و الحاويات.

111. تخزين المؤقت للكوكيل العكسي: تكوين رؤوس التخزين المؤقت و انتهاء صلاحيته.

112. اختبار أداء خادم الويب: أدوات مثل Apache JMeter، Gatling.

113. نقل SSL: معالجة انتهاء SSL/TLS في توازن الحمل.

114. تقوية خادم الويب: أفضل الممارسات الأمنية و تقييمات العيوب.

115. تقديم المحتوى الديناميكي مقابل الثابت: تحسين تكوينات الخادم.

116. تجميع خادم الويب: إعداد مجموعات للاحتياط العالي.

117. تصديق خادم الويب: تنفيذ تصديق أساسي، هضمي، و OAuth.

118. صيغ تسجيل خادم الويب: صيغ تسجيل الشائعة و أدوات التحليل.

119. حدود الموارد في خادم الويب: تكوينات حدود على الاتصالات، الطلبات، و عرض النطاق.

120. نسخ احتياطي و استعادة خادم الويب: استراتيجيات استعادة من الكوارث.

**CI/CD و DevOps (20 نقاط)**

121. Jenkins Pipeline as Code: كتابة Jenkinsfiles لخطوط الأنابيب CI/CD.

122. حاويات Docker: إنشاء Dockerfile، بناء متعدد المراحل، و ترتيب الحاويات.

123. ترتيب Kubernetes: التوزيعات، الخدمات، الوحدات، و استراتيجيات التوسيع.

124. مبادئ GitOps: استخدام Git لإدارة البنية التحتية والتكوين.

125. أدوات بناء Maven و Gradle: إدارة الاعتماد، الإضافات، و دورة الحياة.

126. اختبار الوحدة و التكامل: كتابة الاختبارات مع JUnit، Mockito، و TestNG.

127. أدوات تغطية الكود: استخدام Jacoco لقياس تغطية الكود.

128. تحليل الكود الثابت: أدوات مثل SonarQube لفحص جودة الكود.

129. البنية التحتية ككود (IaC): استخدام Terraform، CloudFormation لإدارة البنية التحتية.

121. نشر أزرق/أخضر: تقليل الوقت المفقود أثناء النشر.

122. نشر الكناري: نشر تدريجي للميزات الجديدة.

123. اختبار الآلي في خطوط الأنابيب CI: دمج الاختبارات مع مراحل البناء.

124. إدارة البيئة: استخدام Ansible، Chef، أو Puppet لإدارة التكوين.

125. أفضل الممارسات CI/CD: التكامل المستمر، النشر المستمر، و التوصيل المستمر.

126. استراتيجيات التراجع: تنفيذ التراجع الآلي عند فشل النشر.

127. فحص الأمان: دمج فحص الأمان مثل SAST، DAST في الخطوط الأنابيب.

128. خطوط الأنابيب CI/CD للميكروسيرفيس: إدارة الخطوط الأنابيب لمختلف الخدمات.

129. مراقبة خطوط الأنابيب CI/CD: تنبيه على فشل الخطوط الأنابيب و مشاكل الأداء.

130. بيئة أدوات DevOps: فهم الأدوات مثل Docker، Kubernetes، Jenkins، Ansible.

131. CI/CD للتطبيقات الأصلية للسحاب: نشر التطبيقات على منصات السحاب.

**نماذج التصميم و أفضل الممارسات (20 نقاط)**

132. نمط Singleton: تنفيذ Singleton الآمن للخيط.

133. نمط Factory: إنشاء الكائنات دون تحديد الفئة الدقيقة.

134. نمط Strategy: تضمين الخوارزميات و التبديل بينها.

135. مبادئ SOLID: فهم و تطبيق مبدأ المسؤولية الواحدة، المفتوح/المغلق، استبدال Liskov، فصل الواجهات، و عكس الاعتماد.

136. حقن الاعتماد: تقليل الارتباط و زيادة قابلية الصيانة للكود.

137. نمط Event Sourcing: تخزين الأحداث لإعادة بناء حالة التطبيق.

138. معمارية CQRS: فصل مسؤوليات الأمر والاستعلام.

139. تصميم للتمدد: استخدام توسيع أفقي، تقسيم، و توازن الحمل.

140. تقنيات إعادة كتابة الكود: استخراج الطرق، إعادة تسمية المتغيرات، و تبسيط الشرطيات.

141. ممارسات الكود النظيف: كتابة كود قابل للقراءة، الصيانة، و التوثيق الذاتي.

142. تطوير مدفوع بالاختبار (TDD): كتابة الاختبارات قبل التنفيذ.

143. إصدارات الكود: استخدام استراتيجيات الفرع في Git مثل GitFlow، تطوير جذع.

144. تصميم للصيانة: استخدام التصميم الموديولي، فصل المسؤوليات.

145. نماذج عكسية: فئات الله، كود المكرونة، و الارتباط القوي.

146. تصميم للأمان: تنفيذ الأقل امتياز، الدفاع العميق.

147. تصميم للأداء: تحسين الخوارزميات، تقليل عمليات الإدخال / الإخراج.

148. تصميم للثقة: تنفيذ التكرار، التسامح مع الأخطاء، و معالجة الأخطاء.

149. تصميم للتمدد: استخدام الإضافات، التوسعات، و واجهات مفتوحة.

150. تصميم للسهولة: التأكد من أن واجهات برمجة التطبيقات (APIs) واضحة و مستندة جيدًا.

151. تصميم للاختبار: كتابة كود يمكن اختباره و تقمصه بسهولة.

**الأمان (20 نقاط)**

152. OAuth2 و JWT: تنفيذ تصديق الماركات.

153. التحكم بالصلاحيات بناءً على الدور (RBAC): تعيين الأدوار و الصلاحيات للمستخدمين.

154. رؤوس الأمان: تنفيذ سياسات أمان المحتوى، X-Frame-Options.

155. منع اختراق SQL: استخدام الاستعلامات المهيئة و الاستعلامات المحدد.

156. حماية من XSS: تنظيف المدخلات والمخرجات.

157. التشفير و فك التشفير: استخدام AES، RSA لحماية البيانات.

158. ممارسات كتابة الكود الآمنة: تجنب العيوب الشائعة مثل تجاوز الحافز.

159. تنفيذ سجلات المراقبة: تسجيل أفعال المستخدم و أحداث النظام.

160. معالجة البيانات الحساسة: تخزين كلمات المرور بشكل آمن باستخدام خوارزميات الهاش.

161. الالتزام بالقوانين: GDPR، PCI-DSS، و قوانين حماية البيانات.

162. تنفيذ التحقق من الهوية ثنائي (2FA): إضافة طبقة أمان إضافية.

163. اختبار الأمان: اختبار اختراق، تقييم العيوب.

164. بروتوكولات الاتصال الآمنة: تنفيذ SSL/TLS لتشفير البيانات.

165. إدارة جلسات آمنة: إدارة رموز الجلسة و الأوقات.

166. تنفيذ حواجز الحماية للويب (WAF): حماية من الهجمات الشائعة.

167. مراقبة الأمان و التنبيه: استخدام أدوات مثل SIEM للكشف عن التهديدات.

168. أفضل الممارسات الأمنية في الميكروسيرفيس: حماية تواصل الخدمة إلى الخدمة.

169. تنفيذ CAPTCHA لحماية من الروبوتات: منع الهجمات الآلية.

170. الأمان في خطوط الأنابيب CI/CD: فحص العيوب أثناء البناء.

171. تنفيذ الأمان من خلال التصميم: دمج الأمان من بداية عملية التطوير.

**تحسين الأداء و تحسينه (20 نقاط)**

172. تحليل أداء تطبيقات جاوا: استخدام أدوات مثل JProfiler، VisualVM.

173. تحسين جمع النفايات: تعديل معلمات GC لأداء.

174. تحسين استعلام قاعدة البيانات: الفهرسة، إعادة كتابة الاستعلام، و استخدام خطط التفسير.

175. استراتيجيات التخزين المؤقت: استخدام التخزين المؤقت الموزع، آليات إلغاء التخزين المؤقت.

176. اختبار الحمل و اختبار الضغط: تحديد عوائق الأداء.

177. تحسين APIs RESTful: تقليل أوقات الاستجابة، تقليل نقل البيانات.

178. تقليل تأخير الشبكة: استخدام CDNs، تحسين استدعاءات API.

179. تجميع حجم الاتصال: تحديد حجمات التجميع المثلى للاتصالات و قاعدة البيانات.

180. إعدادات المراقبة و التنبيه: استخدام Prometheus، Grafana لمراقبة الوقت الحقيقي.

181. تحديد و حل العوائق: تحليل استخدام وحدة المعالجة المركزية، الذاكرة، و الإدخال / الإخراج.

182. تحسين إعدادات الكومة في جاوا: تعيين أحجام الكومة المناسبة للبيئات المختلفة.

183. تقليل توقف جمع النفايات: استخدام G1GC، ZGC للتطبيقات منخفضة التأخير.

184. تحسين الإدخال / الإخراج على القرص: استخدام SSDs، RAID، و تحسينات نظام الملفات.

185. تخزين المؤقت مقابل تخزين: تحديد متى تخزين البيانات مقابل تخزينها في قاعدة البيانات.

186. تحسين تسجيل: تقليل تكلفة تسجيل و إدارة حجم السجلات.

187. تحسين الوصول المتزامن: استخدام القفل بشكل فعال و تقليل التنافس.

188. تحليل استخدام الذاكرة: تحديد تسرب الذاكرة و تحسين تخصيص الكائنات.

189. تحسين حجم مجموعة الخيوط: التوازن بين القليل من الخيوط و الكثير.

190. تحسين بنية البيانات: اختيار البنية المناسبة للبيانات حسب حالة الاستخدام.

191. مؤشرات الأداء و KPIs: تعريف و تتبع المؤشرات الرئيسية لأداء التطبيقات.