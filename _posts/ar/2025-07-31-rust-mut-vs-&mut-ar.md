---
audio: false
generated: true
image: false
lang: ar
layout: post
title: شرح mut و &mut في لغة رست
translated: true
type: note
---

في Rust، تخدم الكلمات المفتاحية `mut` و `&mut` أغراضًا متشابهة ولكنها متميزة، وهي لا تعادل مباشرة مفاهيم النسخ العميق/السطحي في Java أو المؤشرات في C—على الرغم من أنه يمكننا رسم بعض المقارنات للتوضيح. سأقوم بشرح هذا خطوة بخطوة، وأوضح الفروق، وأتناول أسئلتك حول تمرير القيمة مقابل تمرير المرجع، والقابلية للتغيير، وكيف تؤثر التغييرات على البيانات الأصلية. سأستخدم أمثلة مبنية على الكود الذي قدمته للتوضيح.

### 1. **فهم `mut` في تعريف المتغيرات**
   - عندما تُعرِّف متغيرًا باستخدام `let mut`، فإنك تجعل *الربط* (اسم المتغير) قابلاً للتغيير. هذا يعني أنه يمكنك إعادة تعيين المتغير أو تعديل محتوياته مباشرة، ولكن فقط ضمن النطاق الذي تم تعريفه فيه.
   - مثال من الكود الخاص بك:
     ```rust
     let mut arr = [3, 6, 8, 10, 1, 2, 1];
     ```
     هنا، `arr` قابل للتغيير، لذا يمكنك القيام بـ `arr[0] = 99;` أو حتى إعادة تعيين `arr = [1, 2, 3];` لاحقًا إذا أردت. بدون `mut`، ستعترض Rust على محاولة تعديل متغير غير قابل للتغيير (تفترض Rust عدم القابلية للتغيير افتراضيًا من أجل السلامة).
   - هذه الـ `mut` تخص المتغير نفسه، وليس كيفية تمريره إلى الدوال. لا تعني النسخ أو الإشارة—إنها مجرد إذن لتغيير المتغير في مكانه.

### 2. **فهم `&mut` في معاملات الدوال والمراجع**
   - `&mut` تنشئ *مرجعًا قابلًا للتغيير* (يُسمى أيضًا استعارة قابلة للتغيير). هذا يشبه المؤشر في C الذي يسمح بالقراءة *والكتابة* إلى البيانات التي يشير إليها، ولكن مع وجود مدقق الاقتراض الصارم في Rust لضمان السلامة (لا وجود لسباق البيانات، ولا وجود لمؤشرات متدلية).
   - في الكود الخاص بك:
     ```rust
     fn quick_sort(arr: &mut [i32]) { ... }
     ```
     - المعامل `arr` هو مرجع قابل للتغيير إلى شريحة من `i32` (`&mut [i32]`). الشرائح في Rust هي مشاهدات إلى المصفوفات أو المتجهات (مثل مؤشر + طول)، ويتم تمريرها دائمًا تقريبًا كمراجع لأن الشرائح هي أنواع "غير محددة الحجم" (حجمها غير معروف في وقت الترجمة).
     - عندما تستدعي `quick_sort(&mut arr);`، فإنك تمرر مرجعًا قابلًا للتغيير إلى `arr` الأصلي. هذا يسمح للدالة بتعديل عناصر المصفوفة الأصلية من خلال المرجع (على سبيل المثال، عبر التبديلات في `partition`).
     - داخل الدالة، عمليات مثل `arr.swap(i, j);` تؤثر مباشرة على البيانات الأصلية لأن `arr` هو مرجع يشير إليها.
   - بدون `&`، لا يمكنك تمرير شريحة مثل `[i32]` مباشرة كمعامل بهذه الطريقة—تتطلب Rust المراجع للأنواع غير محددة الحجم. ولكن بشكل عام، `&mut` يمكّن تمرير المرجع مع حقوق التعديل.

### 3. **تمرير القيمة مقابل تمرير المرجع في Rust**
   - تستخدم Rust *الملكية* كنموذج أساسي لها، وهو يختلف عن Java (التي تعتمد في الغالب على المرجع مع جامع القمامة) أو C (المؤشرات اليدوية).
     - **تمرير القيمة (نقل الملكية)**: عندما تمرر قيمة بدون `&` (مثال: `fn foo(x: i32)` أو `fn bar(mut v: Vec<i32>)`)، تنتقل ملكية البيانات إلى الدالة. يمكن للدالة تعديلها محليًا، لكن التغييرات لا تؤثر على الأصل لدى المستدعي (لأن المستدعي لم يعد يملكها). إذا كان النوع ينفذ `Copy` (مثل الأنواع البدائية مثل `i32`)، يتم نسخه تلقائيًا بدلاً من نقله—لا يتم نسخه بعمق إلا إذا استنسخته صراحةً.
       - مثال:
         ```rust
         fn foo(mut x: i32) {
             x += 1;  // يعدل x المحلي، لكن أصل المتغير لدى المستدعي لم يتغير (أو نُقل/نُسخ).
             println!("Inside: {}", x);
         }

         let y = 5;
         foo(y);  // يمرر بالقيمة (نسخ، لأن i32 هو Copy).
         println!("After: {}", y);  // يبقى 5.
         ```
       - هذا يشبه "تمرير القيمة" في اللغات الأخرى: يتم نسخ الأنواع البدائية، بينما تُنقل الأنواع الأكبر (مثل المصفوفات/المتجهات) (بكفاءة، دون نسخ ما لم يتم استنساخها).
     - **تمرير المرجع (الاقتراض)**: استخدام `&` (مرجع غير قابل للتغيير) أو `&mut` (مرجع قابل للتغيير) "يقترض" البيانات دون نقل الملكية. تحصل الدالة على مشاهدة مؤقتة (مثل مؤشر)، ويحتفظ المالك الأصلي بالسيطرة.
       - `&`: اقتراض للقراءة فقط. لا يمكن تعديل الأصل.
       - `&mut`: اقتراض للقراءة والكتابة. *يستطيع* تعديل الأصل، مثل تمرير المرجع في C++ أو مؤشر قابل للتغيير في C.
       - مثال:
         ```rust
         fn bar(x: &mut i32) {
             *x += 1;  // إلغاء المرجع وتعديل الأصل.
         }

         let mut y = 5;
         bar(&mut y);  // تمرير مرجع قابل للتغيير.
         println!("After: {}", y);  // أصبح 6، الأصل تغير.
         ```
       - في كود الفرز السريع الخاص بك، يتم تمرير المرجع باستخدام `&mut`، لذا تغير التبديلات المصفوفة الأصلية. إذا كان مجرد `& [i32]`، لما أمكنك تعديلها (اقتراض غير قابل للتغيير).

   - بالنسبة لنقطتك: نعم، `&mut` يسمح بتغيير القيم الأصلية (تمرير المرجع مع التعديل)، بينما التمرير بدون `&` (تمرير القيمة) إما ينقل الملكية أو ينسخ البيانات، لذا تكون التعديلات محلية ولا تؤثر على الأصل. لكن:
     - ليست كل الأنواع تُنسخ تلقائيًا—فقط تلك التي تنفذ `Copy` (مثال: `i32`، وليس المصفوفات أو المتجهات). بالنسبة للأنواع غير `Copy` مثل مصفوفتك، فإن التمرير بالقيمة *ينقل* الملكية، وستحتاج إلى إعادتها "لإرجاعها" إلى المستدعي.
     - تتجنّع Rust النسخ غير الضرورية للكفاءة. مصفوفتك لا تُنسخ عند تمريرها كـ `&mut [i32]`—إنها مجرد مرجع (سطحي، مثل مؤشر).

### 4. **المقارنة مع Java و C**
   - **Java**: كل شيء غير بدائي يتم تمريره بالمرجع (سطحي—يتم مشاركة الكائنات، لكن إعادة تعيين المعامل لا تؤثر على المستدعي). يتم تمرير الأنواع البدائية بالقيمة (نسخ). لا يوجد مكافئ مباشر لـ `mut` أو `&mut`؛ يتم التحكم في القابلية للتغيير عبر تصميم الفئة (مثل الحقول النهائية). لا تملك Java ملكية Rust، لذا فهي أكثر عرضة لمشاكل حالة التغيير المشتركة. يتطلب النسخ العميق استنساخًا يدويًا.
   - **C**: `&mut` يشبه تمرير مؤشر (`int*`) حيث يمكنك إلغاء المرجع والتعديل (`*ptr = 10;`). `mut` العادية (في التصريحات) تشبه المتغيرات غير الثابتة. لكن لا يوجد في C مدقق اقتراض، لذا تدير الأعمار الافتراضية يدويًا (عرضة للأخطاء). التمرير بالقيمة في C ينسخ البيانات (سطحي للهياكل ما لم تُنسخ بعمق).
   - الفرق الرئيسي: تفرض Rust "مرجع قابل للتغيير واحد في كل مرة" (أو عدة مراجع غير قابلة للتغيير)، مما يمنع الأخطاء. لا توجد قيم فارغة، ولا توجد مؤشرات برية.

### 5. **لماذا `mut` أحيانًا و `&mut` أحيانًا أخرى في الكود الخاص بك؟**
   - `mut` وحدها: تُستخدم للمتغيرات المحلية التي تحتاج إلى أن تكون قابلة للتغيير، مثل `let mut arr` (حتى تتمكن من تمرير `&mut arr` لاحقًا أو تعديلها مباشرة).
   - `&mut`: تُستخدم في المعاملات عندما تحتاج الدالة إلى اقتراض وتعديل بيانات المستدعي دون أخذ الملكية. في `quick_sort` و `partition`، `&mut [i32]` يسمحان لهما بفرز المصفوفة في مكانها دون نقلها/نسخها.
   - إذا حاولت `fn quick_sort(mut arr: [i32])`، فلن يتم تجميعها—لا يمكن تمرير الشرائح بالقيمة بهذه الطريقة. ستحتاج إلى مصفوفة بحجم ثابت (مثال: `[i32; 7]`) وسينقل ذلك الملكية.
   - في `partition`، الحلقة تستخدم `mut i` داخليًا—هذا متغير محلي قابل للتغيير، لا علاقة له بالتمرير.

### 6. **هل يغير القيم الأصلية؟**
   - نعم لـ `&mut`: التغييرات تنتقل إلى الأصل (تمرير المرجع).
   - لا لتمرير القيمة (بدون `&`): التغييرات محلية فقط (ما لم تُرجع القيمة المعدلة).
   - في `quick_sort_interact()` الخاصة بك، `println!("After: {:?}", arr);` ستعرض المصفوفة المرتبة لأنه تم استخدام `&mut`.

إذا قمت بتشغيل الكود الخاص بك، يجب أن يخرج الناتج:
```
Before: [3, 6, 8, 10, 1, 2, 1]
After: [1, 1, 2, 3, 6, 8, 10]
```
(يبدو أن `mod simple;` و `simple::run_simple();` غير مرتبطين—ربما مكان محجوز؟ إذا كان هناك خطأ هناك، فقد يكون لأن `simple` غير معرّف.)

إذا لم يكن هذا واضحًا أو كان لديك جزء محدد من الكود لتعديله/اختباره، فأعلمني!