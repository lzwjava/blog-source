---
audio: false
generated: true
lang: ar
layout: post
title: فِيغما تستخدم ويب أسيمبلي
translated: true
type: note
---

تستفيد Figma من WebAssembly (Wasm) لتعزيز أدائها بشكل كبير، مما يجعلها مثالاً بارزاً على كيفية قدرة هذه التقنية على تحويل التطبيقات القائمة على الويب. في جوهرها، Figma هي أداة تصميم تعاونية تعمل أساساً في المتصفح، وتستخدم WebAssembly لتنفيذ المهام الحرجة كثيفة الاستهلاك للأداء بسرعات شبه أصلية. إليك كيف تعمل:

تم بناء محرك Figma بلغة C++، وهي لغة معروفة بسرعتها وكفاءتها ولكنها غير مدعومة أصلاً في المتصفحات. لسد هذه الفجوة، تقوم Figma بتحويل قاعدة كود C++ الخاصة بها إلى WebAssembly باستخدام Emscripten، وهي سلسلة أدوات تحول C/C++ إلى ملفات Wasm الثنائية. ثم يتم تحميل ملفات `.wasm` هذه في المتصفح، حيث تتولى handling المهام الشاقة—مثل عرض الرسوميات المتجهة المعقدة، وإدارة مستندات التصميم الكبيرة، ومعالجة التحديثات الفورية عبر عدة مستخدمين.

من الفوائد الكبيرة لهذا النهج **وقت التحميل**. أفادت Figma أن التحول إلى WebAssembly قلل وقت التحميل بأكثر من 3 مرات مقارنة باستخدامها السابق لـ asm.js (مجموعة فرعية من JavaScript لتشغيل كود C++). تنسيق WebAssembly الثنائي أكثر إحكاما وأسرع في التحليل من JavaScript، وبمجرد التحميل، يقوم المتصفح بتخزين كود الآلة المترجم مؤقتاً، لذا تكون عمليات التحميل اللاحقة أسرع. هذا أمر بالغ الأهمية لـ Figma، حيث يتعامل المستخدمون غالباً مع ملفات ضخمة ويتوقعون استجابة فورية.

**محرك العرض** هو مجال رئيسي آخر تتألق فيه WebAssembly. تستخدم Figma WebGL للرسوميات المعززة بوحدة معالجة الرسومات، ولكن المنطق الذي يقود هذا—فكر في عرض المنحنيات، والإخفاء، والتشويش، و أوضاع المزج—يتم إدارته بواسطة كود C++ المحول إلى Wasm. هذا الإعداد يتجاوز خط عرض HTML الخاص بالمتصفح، مما يمنح Figma تحكماً دقيقاً في الأداء والاتساق عبر المنصات. هذا هو السبب وراء أن التكبير والتصغير والتمرير في Figma تبدو سلسة للغاية، حتى مع وجود آلاف الطبقات.

**التعاون في الوقت الفعلي** يستفيد أيضاً. تعتمد ميزات اللعب الجماعي في Figma على Conflict-Free Replicated Data Types (CRDTs) لمزامنة التغييرات فوراً بين المستخدمين. بينما قد لا يعمل منطق CRDT نفسه بالكامل في Wasm، فإن المحرك المدعوم بـ C++ يتعامل مع حالة المستند والتحديثات بكفاءة، مما يضمن أن التعديلات التعاونية لا تثقل النظام. تساعد سرعة WebAssembly في الحفاظ على هذا السلاسة، حتى مع وجود العشرات من المتعاونين.

هناك بنية هجينة تعمل هنا: المحرك الأساسي (C++/Wasm) يدير المستند واللوحة، بينما يتم بناء واجهة المستخدم المحيطة—مثل شريط الأدوات والقوائم—باستخدام JavaScript (الآن TypeScript + React). الاثنان يتواصلان عبر جسر، حيث يصدر Wasm وظائف يمكن لـ JavaScript استدعاؤها، والعكس صحيح. هذا التقسيم يسمح لـ Figma بتحسين الأداء حيث يكون أكثر أهمية مع الحفاظ على مرونة JavaScript الأصلية للويب للمهام الأقل استهلاكاً للحساب.

هناك تحذير واحد: لا تستخدم Figma WebAssembly بشكل موحد عبر جميع المتصفحات. تاريخياً، اعتمدت على Wasm أكثر في Firefox بسبب بعض الأخطاء المبكرة في Chrome (على سبيل المثال، عدم وجود تخزين مؤقت لكود Wasm المترجم)، على الرغم من أن التطبيقات الحديثة قد ساهمت على الأرجح في معالجة هذا. ومع ذلك، فإن خط التحويل من C++ إلى Wasm يظل أساسياً في بنيتها المعمارية.

باختصار، تستخدم Figma WebAssembly لتقديم أداء بمستوى تطبيقات سطح المكتب إلى المتصفح، وذلك عن طريق تحويل نواتها المكتوبة بلغة C++ إلى ملفات ثنائية فعالة تتولى handling العرض، وإدارة المستندات، والمزامنة في الوقت الفعلي. إنها حالة نموذجية لتمكين Wasm لتطبيق ويب من تجاوز حدود قدرات JavaScript بكثير. هل تريد التعمق أكثر في التفاصيل التقنية أو معرفة كيف يقارن هذا بالأدوات الأخرى؟