---
audio: false
generated: true
image: false
lang: ar
layout: post
model: openai/gpt-5
title: أساسيات ومقارنات قلاب دي
translated: true
type: note
---

الإجابة: D flip-flop

لماذا هو الخيار الصحيح
- الوظيفة: يقوم D flip-flop بتخزين بت واحد بالضبط. عند الحافة النشطة للساعة (الصاعدة أو الهابطة، اعتمادًا على التصميم)، يأخذ عينة من الإدخال D ويقوم بتحديث Q لتلك القيمة. بين حافات الساعة، يحتفظ Q بقيمته السابقة.
- القاعدة السلوكية: Q_next = D عند حافة الساعة؛ وإلا يبقى Q دون تغيير. هذه السلوكية "أخذ العينة والاحتفاظ" هي بالضبط ما تريده للسجلات وخطوط الأنابيب.

كيف يختلف عن الآخرين
- RS flip-flop: يحتوي على مدخلات Set و Reset منفصلة وحالة غير صالحة (S=R=1). ليس مثاليًا للتخزين العام للبيانات في التصميمات المتزامنة.
- JK flip-flop: يعمم RS؛ J=K=1 يتسبب في التبديل. أكثر مرونة ولكنه أكثر تعقيدًا ونادرًا ما يستخدم للسجلات القياسية للبيانات.
- T flip-flop: يتبدّل عندما T=1 عند حافة الساعة، ويحتفظ عندما T=0. رائع لعدادات القسمة على 2، وليس لتخزين البيانات الاعتباطي.

تفاصيل رئيسية حول D flip-flops
- يحفّز بالحافة مقابل Latch: D flip-flop يحفّز بالحافة (يتحديث فقط عند حافة الساعة). D latch حساس للمستوى (شفاف بينما enable مفعل). عندما يقول الناس "ينقل الإدخال مباشرة إلى المخرج عند التفعيل بالساعة"، فإنهم يقصدون عادة أن D flip-flop يلتقط D عند حافة الساعة.
- متطلبات التوقيت: التشغيل الصحيح يتطلب الوفاء بوقت الإعداد (D مستقر قبل الحافة) ووقت الاستبقاء (D مستقر بعد الحافة). انتهاك هذه الأوقات يمكن أن يسبب عدم استقرار.
- المتغيرات: غالبًا ما تتضمن دبابيس Preset غير متزامنة و Clear لإعداد Q القيمة الابتدائية.
- الاستخدامات الشائعة: بناء سجلات n-bit (n DFF بالتوازي)، مراحل خطوط الأنابيب، سجلات الحالة، سجلات الإزاحة (غالبًا مع MUX للتحميل التسلسلي/المتوازي)، المزامنات (في أزواج) لعبور نطاقات الساعة.

قاعدة عامة
- إذا كنت تحتاج إلى عنصر تخزين "يخزن فقط البت الذي تقدمه عند الساعة"، فاستخدم D flip-flop.