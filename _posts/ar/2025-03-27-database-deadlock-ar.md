---
audio: false
generated: true
lang: ar
layout: post
title: تعطل قاعدة البيانات
translated: true
type: note
---

يحدث **انحباس قاعدة البيانات** عندما تنتظر معاملتان أو أكثر بعضهما البعض لإطلاق أقفال على الموارد، مما يخلق تبعية دائرية تمنع أي منها من المتابعة. عادةً ما يكتشف نظام إدارة قواعد البيانات (DBMS) هذا الموقف ويحله من خلال التراجع عن إحدى المعاملات. فيما يلي مثال مفصل لسيناريو الانحباس:

---

### مثال: انحباس بين معاملتين
*   **السيناريو**:
    *   المعاملة T1 تقوم بتحديد صف في جدول `Orders` ثم تحتاج إلى تحديث صف في جدول `Customers`.
    *   المعاملة T2 تقوم بتحديث صف في جدول `Customers` ثم تحتاج إلى تحديث صف في جدول `Orders`.
    *   تقوم كلتا المعاملتين بقفل الموارد بترتيب مختلف، مما يؤدي إلى انحباس.

*   **خطوة بخطوة**:
    1.  T1 تقفل صفًا في `Orders`.
    2.  T2 تقفل صفًا في `Customers`.
    3.  T1 تحاول قفل الصف في `Customers` (مقيدة بواسطة T2).
    4.  T2 تحاول قفل الصف في `Orders` (مقيدة بواسطة T1).
    *   النتيجة: لا يمكن لأي من المعاملتين المتابعة، مما يخلق انحباسًا.

*   **مثال SQL**:
    ```sql
    -- المعاملة T1
    BEGIN TRANSACTION;
    UPDATE Orders SET Status = 'Shipped' WHERE OrderID = 100;  -- تقفل OrderID 100
    -- (بعض التأخير أو المعالجة)
    UPDATE Customers SET LastOrderDate = '2025-03-27' WHERE CustomerID = 1;  -- مقيدة بواسطة T2

    -- المعاملة T2
    BEGIN TRANSACTION;
    UPDATE Customers SET Balance = Balance - 50 WHERE CustomerID = 1;  -- تقفل CustomerID 1
    -- (بعض التأخير أو المعالجة)
    UPDATE Orders SET PaymentStatus = 'Paid' WHERE OrderID = 100;  -- مقيدة بواسطة T1
    ```

*   **ما الذي يحدث**:
    *   T1 تمتلك قفلًا حصريًا على `OrderID = 100` وتنتظر `CustomerID = 1`.
    *   T2 تمتلك قفلًا حصريًا على `CustomerID = 1` وتنتظر `OrderID = 100`.
    *   حالة الانتظار الدائرية هذه هي انحباس.
    *   يكتشف نظام إدارة قواعد البيانات هذا (على سبيل المثال، عبر انتهاء مهلة أو خوارزمية كشف الانحباس) ويرجع إحدى المعاملات (على سبيل المثال، T2)، مما يسمح لـ T1 بالإكمال.

---

### التمثيل المرئي للانحباس
```
T1: تقفل Orders(100) --> تريد Customers(1)
   |                        ↑
   |                        |
T2: تريد Orders(100)  <-- تقفل Customers(1)
```

*   **الحل**: قد يخرج نظام إدارة قواعد البيانات خطأ مثل:
    ```
    Transaction T2 was deadlocked on lock resources with another process and has been chosen as the deadlock victim. Rerun the transaction.
    ```

---

### لماذا يحدث هذا
*   **ترتيب القفل**: T1 و T2 تكتسبان الأقفال بترتيب مختلف (T1: Orders → Customers; T2: Customers → Orders).
*   **التزامن**: كلا المعاملتين تعملان في وقت واحد وتحتاجان إلى موارد متداخلة.
*   **أقفال حصرية**: عمليات التحديث تتطلب أقفالًا حصرية، مما يمنع المعاملات الأخرى من الوصول إلى نفس البيانات.

---

### كيفية تجنب الانحباس
1.  **ترتيب قفل متسق**: تأكد من أن جميع المعاملات تكتسب الأقفال بنفس الترتيب (على سبيل المثال، قم دائمًا بقفل `Orders` قبل `Customers`).
    ```sql
    -- يجب على كل من T1 و T2 قفل Orders أولاً، ثم Customers
    ```
2.  **تقليل وقت المعاملة**: قلل التأخير داخل المعاملات لتقليل فرصة التداخل.
3.  **استخدام مستويات عزل أقل**: إذا كان ذلك مناسبًا، استخدم مستوى عزل أقل صرامة (مثل Read Committed) لتقليل مدة القفل.
4.  **انتهاء المهلة**: حدد أوقات انتهاء أقصر للأقفال للفشل بسرعة وإعادة المحاولة.

---

أعلمني إذا كنت تريد مثالاً أكثر تحديدًا (مثلًا مع نظام إدارة قواعد بيانات معين مثل PostgreSQL أو SQL Server) أو توضيحًا إضافيًا!