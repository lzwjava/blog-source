---
audio: false
generated: false
image: true
lang: ar
layout: post
title: مقدمة في التعلم الآلي - بايتورش
translated: true
---

```markdown
---
هذا المنشور كتب أصلا باللغة الصينية. تم ترجمته إلى الإنجليزية لتسهيل ترجمته إلى لغات أخرى.

---

## بايتورش (PyTorch)

فلنثبته. هذا يدعم إصدار بايثون `3.9`.

```shell
$ pip install torch torchvision
Collecting torch
  Downloading torch-1.8.0-cp39-none-macosx_10_9_x86_64.whl (120.6 MB)
     |████████████████████████████████| 120.6 MB 224 kB/s
Collecting torchvision
  Downloading torchvision-0.9.0-cp39-cp39-macosx_10_9_x86_64.whl (13.1 MB)
     |████████████████████████████████| 13.1 MB 549 kB/s
Requirement already satisfied: numpy in /usr/local/lib/python3.9/site-packages (from torch) (1.20.1)
Collecting typing-extensions
  Downloading typing_extensions-3.7.4.3-py3-none-any.whl (22 kB)
Requirement already satisfied: pillow>=4.1.1 in /usr/local/lib/python3.9/site-packages (from torchvision) (8.0.1)
Installing collected packages: typing-extensions, torch, torchvision
Successfully installed torch-1.8.0 torchvision-0.9.0 typing-extensions-3.7.4.3
```

فلنتحقق منه.

```python
import torch
x = torch.rand(5, 3)
print(x)
```

حدث خطأ.

```shell
Traceback (most recent call last):
  File "torch.py", line 1, in <module>
    import torch
  File "torch.py", line 2, in <module>
    x = torch.rand(5, 3)
AttributeError: partially initialized module 'torch' has no attribute 'rand' (most likely due to a circular import)
```

بعد البحث عن رسالة الخطأ هذه على جوجل، اتضح أن ملفنا كان اسمه `torch` أيضا، مما تسبب في تعارض في الأسماء. بعد إعادة تسميته، يعمل بشكل صحيح.

```shell
tensor([[0.5520, 0.9446, 0.5543],
        [0.6192, 0.0908, 0.8726],
        [0.0223, 0.7685, 0.9814],
        [0.4019, 0.5406, 0.3861],
        [0.5485, 0.6040, 0.2387]])
```

فلنبحث عن مثال.

```python
# -*- coding: utf-8 -*-

import torch
import math
dtype = torch.float
device = torch.device("cpu")
# device = torch.device("cuda:0") # قم بإلغاء التعليق لتشغيله على وحدة معالجة الرسومات

# إنشاء بيانات إدخال وإخراج عشوائية
x = torch.linspace(-math.pi, math.pi, 2000, device=device, dtype=dtype)
y = torch.sin(x)

# تهئية أوزان عشوائية
a = torch.randn((), device=device, dtype=dtype)
b = torch.randn((), device=device, dtype=dtype)
c = torch.randn((), device=device, dtype=dtype)
d = torch.randn((), device=device, dtype=dtype)

learning_rate = 1e-6
for t in range(2000):
    # تمرير إلى الأمام: حساب ي المتوقع
    y_pred = a + b * x + c * x ** 2 + d * x ** 3

    # حساب وطبع الخسارة
    loss = (y_pred - y).pow(2).sum().item()
    if t % 100 == 99:
        print(t, loss)

    # الانتشار العكسي لحساب تدرجات أ، ب، ج، د بالنسبة للخسارة
    grad_y_pred = 2.0 * (y_pred - y)
    grad_a = grad_y_pred.sum()
    grad_b = (grad_y_pred * x).sum()
    grad_c = (grad_y_pred * x ** 2).sum()
    grad_d = (grad_y_pred * x ** 3).sum()

    # تحديث الأوزان باستخدام الهبوط التدرجي
    a -= learning_rate * grad_a
    b -= learning_rate * grad_b
    c -= learning_rate * grad_c
    d -= learning_rate * grad_d
print(f'النتيجة: y = {a.item()} + {b.item()} x + {c.item()} x^2 + {d.item()} x^3')
```

فلنشغله.

```shell
99 1273.537353515625
199 849.24853515625
299 567.4786987304688
399 380.30291748046875
499 255.92752075195312
599 173.2559814453125
699 118.2861328125
799 81.72274780273438
899 57.39331817626953
999 41.198158264160156
1099 30.41307830810547
1199 23.227672576904297
1299 18.438262939453125
1399 15.244369506835938
1499 13.113286972045898
1599 11.690631866455078
1699 10.740333557128906
1799 10.105220794677734
1899 9.6804780960083
1999 9.39621353149414
النتيجة: y = -0.011828352697193623 + 0.8360244631767273 x + 0.002040589228272438 x^2 + -0.09038365632295609 x^3
```

فلننظر إلى مثال باستخدام مكتبة `numpy` فقط.

```python
# -*- coding: utf-8 -*-
import numpy as np
import math

# إنشاء بيانات إدخال وإخراج عشوائية
x = np.linspace(-math.pi, math.pi, 2000)
y = np.sin(x)

# تهئية أوزان عشوائية
a = np.random.randn()
b = np.random.randn()
c = np.random.randn()
d = np.random.randn()

learning_rate = 1e-6
for t in range(2000):
    # تمرير إلى الأمام: حساب ي المتوقع
    # y = a + b x + c x^2 + d x^3
    y_pred = a + b * x + c * x ** 2 + d * x ** 3

    # حساب وطبع الخسارة
    loss = np.square(y_pred - y).sum()
    if t % 100 == 99:
        print(t, loss)

    # الانتشار العكسي لحساب تدرجات أ، ب، ج، د بالنسبة للخسارة
    grad_y_pred = 2.0 * (y_pred - y)
    grad_a = grad_y_pred.sum()
    grad_b = (grad_y_pred * x).sum()
    grad_c = (grad_y_pred * x ** 2).sum()
    grad_d = (grad_y_pred * x ** 3).sum()

    # تحديث الأوزان
    a -= learning_rate * grad_a
    b -= learning_rate * grad_b
    c -= learning_rate * grad_c
    d -= learning_rate * grad_d

print(f'النتيجة: y = {a} + {b} x + {c} x^2 + {d} x^3')
```

لاحظ أن هناك طريقتين مختلفتين لأداء الحسابات.

في هذه الأمثلة، يتم أولاً توليد مجموعة من قيم x و y. ثم يتم افتراض أنها معادلة تكعيبية. بعد ذلك، يتم استخدام بعض الطرق لحساب المعاملات بشكل تكراري. ما هي هذه الخوارزميات؟ لاحظ أنها تتكرر `2000` مرة، لتصبح أكثر دقة في كل تكرار. لن ندخل في التفاصيل هنا.

## أخيراً

حالياً، لا نفهم كيف تعمل حسابات التعلم الآلي خلف الكواليس. ومع ذلك، هذا ليس مهمًا الآن. باستخدام المعرفة أعلاه، يمكننا بالفعل القيام بالكثير من الأشياء. يمكن أيضًا استخدام التعلم الآلي لمعالجة النصوص والصوت والمزيد. بعد استكشاف عشرات الأمثلة، لن يكون متأخرًا لتعلم النظرية.

## تمارين

* يجب على الطلاب الاستكشاف كما هو موضح أعلاه.
```