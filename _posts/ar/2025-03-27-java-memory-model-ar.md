---
audio: false
generated: true
lang: ar
layout: post
title: نموذج ذاكرة جافا
translated: true
type: note
---

دعونا نتعمق في نموذج ذاكرة جافا (JMM)! هذا مفهوم أساسي لفهم كيفية تصرف برامج جافا متعددة الخيوط، خاصة عند التعامل مع البيانات المشتركة.

**ما هو نموذج ذاكرة جافا (JMM)؟**

نموذج ذاكرة جافا هو وصف مجرد لكيفية تفاعل الخيوط في برنامج جافا مع الذاكرة. فهو يحدد القواعد التي تحكم كيف ومتى تكون التغييرات التي يجريها خيط واحد على المتغيرات المشتركة مرئية للخيوط الأخرى. إنه ليس بنية ذاكرة فعلية، بل هو مجموعة من القواعد التي يجب على JVM اتباعها لضمان سلوك متسق وقابل للتنبؤ للبرامج المتزامنة عبر منصات الأجهزة المختلفة.

**لماذا نحتاج إلى نموذج ذاكرة جافا؟**

في بيئة متعددة الخيوط، يمكن لخيوط متعددة الوصول إلى المتغيرات المشتركة وتعديلها. بدون نموذج ذاكرة محدد جيدًا، يمكن أن تنشأ عدة مشكلات:

*   **مشكلات الرؤية:** قد لا تكون التغييرات التي يجريها خيط واحد على متغير مشترك مرئية على الفور للخيوط الأخرى. يمكن أن يحدث هذا بسبب تحسينات مثل التخزين المؤقت، حيث قد يكون لكل خيط نسخته المحلية الخاصة من المتغير.
*   **مشكلات الترتيب:** قد لا يكون الترتيب الذي تظهر به العمليات في الكود المصدري هو نفسه الترتيب الذي يتم تنفيذها به فعليًا بواسطة المعالج. يمكن للمترجمين والمعالجات إعادة ترتيب التعليمات لتحسين الأداء. بينما يكون هذا آمنًا بشكل عام في البرامج أحادية الخيط، يمكن أن يؤدي إلى سلوك غير متوقع في البرامج متعددة الخيوط إذا لم تتم إدارته بشكل صحيح.
*   **مشكلات الذرية:** بعض العمليات التي تظهر كعمليات مفردة في الكود المصدري قد يتم تقسيمها إلى خطوات أصغر متعددة على مستوى المعالج. في بيئة متعددة الخيوط، قد تتداخل هذه الخطوات مع عمليات من خيوط أخرى، مما يؤدي إلى نتائج غير متسقة.

يوفر JMM إطار عمل لمعالجة هذه المشكلات ويضمن أن البرامج المتزامنة تتصرف بشكل صحيح بغض النظر عن بنية الجهاز الأساسي.

**الهيكل المجرد لـ JMM:**

يحدد JMM علاقة مجردة بين الخيوط والذاكرة الرئيسية:

1.  **الذاكرة الرئيسية:** هذا هو المكان الذي توجد فيه جميع المتغيرات المشتركة. إنه مثل التخزين المركزي لجميع البيانات التي يمكن لخيوط متعددة الوصول إليها.
2.  **ذاكرة العمل (التخزين المؤقت المحلي):** لكل خيط ذاكرة العمل الخاصة به (مشابهة من الناحية المفاهيمية للتخزين المؤقت لوحدة المعالجة المركزية). عندما يحتاج الخيط إلى الوصول إلى متغير مشترك، فإنه يقوم أولاً بنسخ المتغير من الذاكرة الرئيسية إلى ذاكرة العمل الخاصة به. عندما يقوم الخيط بتعديل المتغير، فإنه يفعل ذلك عادةً في ذاكرة العمل الخاصة به، ويتم كتابة التغيير في النهاية مرة أخرى إلى الذاكرة الرئيسية.

**التحديات الرئيسية التي يعالجها JMM:**

*   **الرؤية:** يحدد JMM قواعد حول متى وكيف يتم جعل تغييرات الخيط على متغير مشترك في ذاكرة العمل الخاصة به مرئية للخيوط الأخرى (أي، كتابتها مرة أخرى إلى الذاكرة الرئيسية ثم قراءتها بعد ذلك بواسطة خيوط أخرى).
*   **الترتيب:** يحدد JMM قيودًا على كيفية قدرة المترجم والمعالج على إعادة ترتيب التعليمات لضمان وجود علاقة "يحدث-قبل" متسقة بين عمليات معينة في خيوط مختلفة.

**علاقة "يحدث-قبل":**

علاقة "يحدث-قبل" هي المفهوم الأساسي الأكثر أهمية في JMM. فهي تحدد ترتيبًا جزئيًا للعمليات في البرنامج. إذا كانت العملية الأولى "تحدث-قبل" العملية الثانية، فإن تأثيرات العملية الأولى (مثل الكتابة إلى متغير) مضمونة لتكون مرئية للعملية الثانية.

فيما يلي بعض قواعد "يحدث-قبل" الرئيسية التي يحددها JMM:

1.  **قاعدة ترتيب البرنامج:** داخل خيط واحد، يحدث كل إجراء في البرنامج قبل كل إجراء يأتي لاحقًا في ترتيب البرنامج.

2.  **قاعدة قفل المراقب:** عملية فتح قفل على مراقب (القفل المرتبط بكتل أو طرق `synchronized`) تحدث قبل كل عملية قفل لاحقة على نفس المراقب. يضمن هذا أنه عندما يقوم خيط بتحرير قفل، فإن أي تغييرات أجراها داخل الكتلة المتزامنة تكون مرئية للخيط التالي الذي يحصل على نفس القفل.

3.  **قاعدة المتغيرات المتقلبة:** عملية الكتابة لمتغير `volatile` تحدث قبل كل عملية قراءة لاحقة لنفس المتغير. يضمن هذا أنه عندما يكتب خيط في متغير `volatile`، يتم كتابة القيمة على الفور في الذاكرة الرئيسية، وأي خيط آخر يقرأ هذا المتغير سيحصل على أحدث قيمة.

4.  **قاعدة بدء الخيط:** طريقة `start()` لكائن `Thread` تحدث قبل أي إجراء في الخيط الذي تم بدؤه حديثًا.

5.  **قاعدة إنهاء الخيط:** جميع الإجراءات في خيط، بما في ذلك عمليات الكتابة للمتغيرات المشتركة، تحدث قبل الإرجاع الناجح من طريقة `join()` لهذا الخيط أو قبل أن يكتشف خيط آخر أن الخيط قد انتهى (على سبيل المثال، عن طريق التحقق من `isAlive()`).

6.  **العدولية:** إذا كانت العملية A تحدث قبل العملية B، والعملية B تحدث قبل العملية C، فإن العملية A تحدث قبل العملية C.

7.  **قاعدة إنشاء الكائن:** اكمال منشئ الكائن يحدث قبل بدء أي عملية أخرى تستخدم ذلك الكائن.

**التركيبات اللغوية الرئيسية و JMM:**

*   **كلمة `volatile` المفتاحية:** الإعلان عن متغير كـ `volatile` له تأثيران رئيسيان مرتبطان بـ JMM:
    *   **الرؤية:** يضمن أن جميع عمليات الكتابة لهذا المتغير سيتم كتابتها على الفور في الذاكرة الرئيسية، وأن جميع عمليات القراءة ستحصل على أحدث قيمة من الذاكرة الرئيسية. هذا يمنع الخيوط من استخدام القيم المخزنة مؤقتًا القديمة.
    *   **يمنع إعادة ترتيب التعليمات (إلى حد ما):** يمنع أنواعًا معينة من إعادة ترتيب التعليمات التي يمكن أن تؤدي إلى سلوك غير صحيح في البرامج متعددة الخيوط. على وجه التحديد، لا يمكن إعادة ترتيب العمليات قبل الكتابة إلى متغير `volatile` بعد الكتابة، ولا يمكن إعادة ترتيب العمليات بعد القراءة من متغير `volatile` قبل القراءة.

*   **كلمة `synchronized` المفتاحية:** عندما يدخل خيط كتلة أو طريقة `synchronized`، فإنه يكتسب قفلًا على المراقب المرتبط. يضمن JMM:
    *   **الاستبعاد المتبادل (الذرية):** خيط واحد فقط يمكنه الاحتفاظ بالقفل لمراقب معين في أي وقت معين، مما يضمن تنفيذ الكود داخل الكتلة المتزامنة بشكل ذري فيما يتعلق بالخيوط الأخرى التي تتم مزامنتها على نفس المراقب.
    *   **الرؤية:** عندما يقوم خيط بتحرير القفل (عن طريق الخروج من كتلة أو طريقة `synchronized`)، فإنه يقوم بشكل فعال بمسح أي تغييرات أجراها على المتغيرات المشتركة داخل تلك الكتلة مرة أخرى إلى الذاكرة الرئيسية. عندما يكتسب خيط آخر نفس القفل، فإنه سيعيد قراءة المتغيرات المشتركة من الذاكرة الرئيسية، مما يضمن أن يرى أحدث التحديثات.

*   **الحقول `final`:** يوفر JMM ضمانات حول رؤية الحقول `final`. بمجرد تهيئة حقل `final` بشكل صحيح في منشئ الكائن، ستكون قيمته مرئية لجميع الخيوط الأخرى دون الحاجة إلى مزامنة صريحة. هذا لأن الكتابة إلى حقل `final` في المنشئ تحدث قبل أن يتمكن أي خيط آخر من الوصول إلى الكائن.

**الآثار المترتبة على البرمجة المتزامنة:**

يعد فهم JMM أمرًا بالغ الأهمية لكتابة برامج متزامنة صحيحة وفعالة في جافا. من خلال الالتزام بالقواعد التي يحددها JMM واستخدام آليات المزامنة المناسبة (`volatile`، `synchronized`، الأقفال من حزمة `java.util.concurrent`)، يمكن للمطورين ضمان الوصول إلى البيانات المشتركة وتعديلها بأمان بواسطة خيوط متعددة.

**المزالق الشائعة وكيف يساعد JMM:**

*   **حالات السباق:** تحدث عندما تعتمد نتيجة البرنامج على الترتيب غير المتوقع الذي تصل به خيوط متعددة إلى الموارد المشتركة. يساعد JMM، جنبًا إلى جنب مع المزامنة المناسبة، في منع حالات السباق من خلال ضمان تنسيق الوصول إلى المتغيرات المشتركة بشكل صحيح.
*   **سباقات البيانات:** تحدث عندما تصل خيوط متعددة إلى نفس المتغير المشترك في وقت واحد، ويكون واحد على الأقل من عمليات الوصول هو عملية كتابة، دون أي مزامنة. يحدد JMM أنه إذا كان للبرنامج سباق بيانات، فإن السلوك غير محدد. يساعد استخدام `volatile` أو `synchronized` في منع سباقات البيانات.
*   **مشكلات التنفيذ خارج الترتيب:** بدون ضمانات JMM، قد يعيد المترجم أو المعالج ترتيب العمليات بطريقة تعطل المنطق المقصود للبرنامج متعدد الخيوط. يفرض JMM قيودًا على إعادة الترتيب، خاصة حول المتغيرات `volatile` والكتل المتزامنة، لمنع مثل هذه المشكلات.

**باختصار:**

نموذج ذاكرة جافا هو مجموعة من القواعد التي تحكم كيفية تفاعل الخيوط مع الذاكرة في جافا. يعالج التحديات المتعلقة بالرؤية والترتيب والذرية في البرامج متعددة الخيوط. تشمل المفاهيم الرئيسية الذاكرة الرئيسية وذاكرة العمل وعلاقة "يحدث-قبل". توفر التركيبات اللغوية مثل `volatile` و `synchronized` آليات لضمان السلوك الصحيح والقابل للتنبؤ في تطبيقات جافا المتزامنة من خلال الالتزام بالمواصفات التي يحددها JMM. يعد فهم JMM أمرًا ضروريًا لكتابة كود جافا متعدد الخيوط قوي وفعال.