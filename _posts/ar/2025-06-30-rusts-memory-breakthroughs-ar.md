---
audio: false
generated: true
lang: ar
layout: post
title: إنجازات لغة رست في إدارة الذاكرة
translated: true
type: note
---

نقدك لإدارة الذاكرة في رست يلامس نقاطًا مؤلمة صحيحة لكنه يتجاهل **اكتشافاتها الأساسية**. دعنا نحلّل هذا بموضوعية:

### ١. **سوء الفهم "استحالة الإدارة الساكنة للذاكرة"**
   - رست **لا تزيل التخصيص الديناميكي**؛ بل تتحقق ساكنًا من انتقالات الملكية. الابتكار ليس في توقع أنماط التخصيص—بل في ضمان السلامة *بدون فحوصات وقت التشغيل*.
   - **تشبيه**: كما تمنع الأنواع الساكنة أخطاء الأنواع في وقت التشغيل، تمنع الملكية/فترات الحياة أخطاء الذاكرة في وقت الترجمة. إنه *ممكن* لأنه نظام قيود، وليس نبوءة.

### ٢. **فترات الحياة: ليست سحرًا، بل مثبتة**
   - `'a`/`'b` **ليست كيانات وقت التشغيل**—بل هي عقود يُفرضها المترجم لضمان ألا تعيش المراجع أكثر من بياناتها. التكرار ليس عيبًا:
     ```rust
     fn factorial<'a>(n: u32, acc: &'a mut u32) -> &'a u32 {
         if n == 0 { acc } else { factorial(n-1, &mut (*acc * n)) }
     }
     ```
     فترات الحياة تتناول التكرار لأنها تتعقب *عمق النطاق*، وليس المسارات الخطية.

### ٣. **مقايضات التعقيد**
   - **احتكاك مدقق الاقتراض**: نعم، محاربته تحدث عند نمذجة البيانات الدورية (مثل، الرسوم البيانية). لكن هذا يكشف عن أخطار متأصلة في الاختلاس/التحوير—*ليست من اختراع رست*. توجد حلول:
     - `Rc<RefCell<T>>` لإتاحة التحوير المشترك (يُفحص في وقت التشغيل)
     - الساحات أو الفهارس للرسوم البيانية المعقدة
   - **الحمل الإدراكي**: مرتفع في البداية، لكنه ينقل تكاليف سلامة الذاكرة من تصحيح الأخطاء (C/C++) أو توقفات وقت التشغيل (GC) إلى وقت التصميم. لبرمجة الأنظمة، هذا تحويلي.

### ٤. **لماذا الـ GC/RC لا "يكفيان"**
   - **الحتمية**: توقفات الـ GC تدمر الأنظمة في الزمن الحقيقي (الألعاب، نواة أنظمة التشغيل).
   - **النفقات العامة**: دورات الـ RC تسبب تسريبات؛ الـ GC يستهلك ١٠-٢٠٪ من المعالج بشكل غير متوقع.
   - **السلامة**: *كلاها لا يزال يسمح بـ use-after-free في سياقات متعددة الخيوط*. ملكية رست تمنع هذا ساكنًا.

### ٥. **تجربتك مع المترجم: صحيحة لكن غير مكتملة**
   - **الألم ≠ عيب**: المعاناة مع فترات الحياة عند كتابة مترجم تعكس منحنى التعلم في رست، وليس فشلًا. بمجرد إتقانها:
     - المطابقة مع الأنماط + التعدادات تتناول شجرة التركيب المجردة بنظافة.
     - `Box` + `Rc` تدير هياكل الأشجار بكفاءة.
   - **برهان من العالم الحقيقي**: [swc](https://github.com/swc-project/swc) (بديل Babel مبني برست) يعالج ملايين أسطر الشفرة بدون أخطاء ذاكرة.

### ٦. **"أخطاء في التصميم"؟ الأدلة تقول غير ذلك**
   - **الاعتماد**: نواة لينكس، مشغّلات ويندوز، AWS Firecracker—كلها تستخدم رست لأغراض حرجة في سلامة الذاكرة.
   - **البيانات**: [الدراسات](https://arxiv.org/abs/2003.03296) تظهر أن ~٧٠٪ من ثغرات CVE هي مشاكل ذاكرة—*يمكن منعها* بنموذج رست.
   - **لا يوجد "خلل أساسي"**: لو أن التكرار أو التزامن كسر فترات الحياة، لما كان لمشاريع مثل Tokio (بيئة تشغيل غير متزامنة) أن توجد.

### الخلاصة: تحول نمطي، وليس دواءً شاملاً
رست ليست "GC أفضل"—بل هي **نظام عقد في وقت الترجمة** يقوم بما يلي:
- **تنجح** حيث يفشل الـ GC/RC: الأداء الحتمي، تجريدات بدون تكلفة، لا نفقات تشغيل إضافية.
- **تفشل** عندما: تكون النمذجة السريعة أهم من السلامة، أو للبيانات دورية العمق التي تحتاج الـ GC.

إحباطك مشروع—رست *تتطلب* دقة في التصميم مسبقًا. لكن تجاهلها باعتبارها "ثوب إمبراطور جديد" يتجاهل تأثيرها المثبت: **إزالة فئات كاملة من الثغرات** مع تمكين التزامن بدون خوف. إنها ليست لكل مشكلة، لكن للأنظمة التي يكون فيها التعطل/الاختراق غير مقبول؟ ثورية.