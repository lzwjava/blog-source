---
audio: false
generated: true
lang: ar
layout: post
title: تعزيز أداء رست في ديسكورد
translated: true
type: note
---

دفعت مشاكل الأداء في خدمة "حالات القراءة" القائمة على لغة Go في Discord إلى اعتماد Rust. تتعقب هذه الخدمة قراءات المستخدمين للرسائل عبر القنوات. حقق التحول إلى Rust تحسينات كبيرة في زمن الوصول، وأزال ذروات جمع القمامة، وعرض نقاط قوة Rust في إدارة الذاكرة والتزامن. إليك تفصيل دقيق:

---

### **لماذا انتقل Discord إلى Rust**
1. **مشاكل جمع القمامة (GC) في Go**  
   - عانت خدمة Go في Discord من ذروات في زمن الوصول كل دقيقتين تقريبًا بسبب آلية GC المحافظة وغير المولدة في Go، والتي *كان عليها فحص ذاكرة التخزين المؤقت LRU بالكامل* (التي تحتوي على ملايين الكائنات) حتى مع إنتاج الحد الأدنى من القمامة.  
   - فشل ضبط GC في Go (مثل ضبط حجم ذاكرة التخزين المؤقت) في حل الذروات أو أدى إلى تفاقم زمن الوصل في المئين 99.  

2. **إدارة الذاكرة في Rust**  
   - نموذج الملكية في Rust *يحرر الذاكرة فورًا* عند الإزالة من ذاكرة التخزين المؤقت LRU، متجنبًا التوقفات الناتجة عن GC. هذا النهج الحتمي أزال ذروات زمن الوصول.  
   - عدم وجود حمل تشغيلي لـ GC يعني أداءً متسقًا تحت الحمل العالي (مئات الآلاف من التحديثات في الثانية).  

3. **تحسين الأداء**  
   - حتى التنفيذ الأولي البسيط لـ Rust حقق أداءً مماثلاً لأداء Go. أدت التحسينات الإضافية (مثل استخدام `BTreeMap` بدلاً من `HashMap`، وتقليل نسخ الذاكرة) *إلى خفض استخدام وحدة المعالجة المركزية بنسبة 70%* وقطع أوقات الاستجابة المتوسطة إلى ميكروثوانٍ.  

4. **النظام البيئي ودعم Async**  
   - تبنى Discord ميزات async الليلة في Rust مبكرًا (التي استقرت لاحقًا)، مما مكّن من تشغيل الخدمات الشبكية بكفاءة دون مقايضات GC.  

---

### **نتائج التحول**  
- **زمن الوصول**: تم إزالة ذروات GC الدورية كل دقيقتين، وتحقيق أوقات استجابة أقل من جزء من الألف من الثانية.  
- **كفاءة الموارد**: انخفاض استخدام وحدة المعالجة المركزية والذاكرة، مما سمح بسعة ذاكرة تخزين مؤقت تصل إلى 8 ملايين حالة قراءة دون تدهور في الأداء.  
- **الموثوقية**: عدد أقل من الأخطاء أثناء التشغيل بفضل فحوصات السلامة في وقت الترجمة في Rust.  

---

### **مزايا Rust لـ Discord**  
1. **الأداء**  
   - زمن وصول منخفض يمكن التنبؤ به، مثالي للخدمات في الوقت الفعلي.  
   - التحكم الدقيق في الذاكرة يتفوق على اللغات المعتمدة على GC.  

2. **السلامة**  
   - يمنع نموذج الملكية تسريبات الذاكرة، والمؤشرات الخالية، وسباقات البيانات.  
   - سلامة التزامن دون مزامنة يدوية.  

3. **الأدوات الحديثة**  
   - قلل Cargo (مدير الحزم) والعاملات الغنية من التكرار مقارنة بـ Go.  

4. **نمو النظام البيئي**  
   - قدمت التحديثات (مثل وقت تشغيل Tokio غير المتزامن) مكاسب أداء مجانية.  

---

### **العيوب والتحديات**  
1. **منحنى التعلم**  
   - يتطلب نموذج الملكية وفترات الحياة في Rust استثمارًا مسبقًا.  

2. **قيود Async المبكرة**  
   - شكل الاعتماد الأولي على الميزات الليلية غير المستقرة مخاطر صيانة.  

3. **نظام بيئي أصغر**  
   - عدد أقل من المكتبات مقارنة بـ Go أو ++C، لكنه ينمو بسرعة.  

---

### **الاستنتاجات الرئيسية**  
يُبرز نجاح Discord مع Rust ملاءمته للخدمات *الحساسة لزمن الوصل وعالية النطاق* حيث تكون توقفات GC غير مقبولة. بينما تطلب الانتقال التغلب على منحنى التعلم الحاد لـ Rust، فإن العائد شمل **أداءً أسرع، واستخدامًا أقل للموارد، وأخطاءً أقل أثناء التشغيل**. بالنسبة للفرق التي تُعطي أولوية للقابلية طويلة الأمد للصيانة والأداء، تقدم Rust مزايا مقنعة مقارنة باللغات المعتمدة على GC مثل Go.  

للحصول على رؤى تقنية أعمق، راجع [المدونة الأصلية لـ Discord](https://discord.com/blog/why-discord-is-switching-from-go-to-rust).