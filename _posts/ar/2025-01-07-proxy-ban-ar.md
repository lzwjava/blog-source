---
audio: true
lang: ar
layout: post
title: تحليل حظر خادم الوكيل
translated: true
---

## هل يمكن لواجهات برمجة التطبيقات (APIs) في خوادم الوكيل تجنب حظر جدار الحماية العظيم (GFW)؟

أقوم بتشغيل خادم بسيط على مثيل Shadowsocks الخاص بي باستخدام الكود التالي:

```python
from flask import Flask, jsonify
from flask_cors import CORS
import subprocess
```

```python
app = Flask(__name__)
CORS(app)  # تمكين CORS لجميع المسارات
```

```python
@app.route('/bandwidth', methods=['GET'])
def get_bandwidth():
    # تشغيل أمر vnstat للحصول على إحصائيات حركة المرور لفترات 5 دقائق لـ eth0
    result = subprocess.run(['vnstat', '-i', 'eth0', '-5', '--json'], capture_output=True, text=True)
    data = result.stdout
```

    # إرجاع البيانات الملتقطة كاستجابة JSON
    return jsonify(data)

```python
if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
```

وأستخدم nginx لتقديم المنفذ 443 كما هو موضح أدناه:

```bash
server {
    listen 443 ssl;
    server_name www.some-domain.xyz;
```

    ssl_certificate /etc/letsencrypt/live/www.some-domain.xyz/fullchain.pem; # مُدار بواسطة 
    # ...
    location / {

```nginx
        proxy_pass http://127.0.0.1:5000/;
        # ...
    }
}
```

يوفر برنامج الخادم هذا بيانات الشبكة، وأستخدم الخادم كخادم وكيل خاص بي، مما يسمح لي بعرض حالة الاتصال بالإنترنت على مدونتي باستخدام بيانات الشبكة.

المثير للاهتمام هو أن الخادم لم يتم حظره من قبل الجدار الناري العظيم (GFW) أو أي أنظمة تحكم شبكية أخرى منذ عدة أيام حتى الآن. في العادة، الخادم الوكيل الذي أقوم بإعداده يتم حظره خلال يوم أو يومين. الخادم يعمل ببرنامج Shadowsocks على منفذ مثل 51939، لذا فهو يعمل بمرور Shadowsocks مختلطًا مع مرور API العادي. يبدو أن هذا المزيج يقود GFW إلى الاعتقاد بأن الخادم ليس خادمًا وكيلًا مخصصًا، بل خادمًا عاديًا، مما يمنع حظر عنوان IP.

هذه الملاحظة مثيرة للاهتمام. يبدو أن الجدار الناري العظيم (GFW) يستخدم منطقًا محددًا للتمييز بين حركة المرور عبر الوكيل وحركة المرور العادية. في حين أن العديد من المواقع مثل تويتر ويوتيوب محجوبة في الصين، إلا أن العديد من المواقع الأجنبية—مثل مواقع الجامعات والشركات الدولية—تبقى قابلة للوصول.

يشير هذا إلى أن الجدار الناري العظيم (GFW) يعمل على الأرجح بناءً على قواعد تميز بين حركة مرور HTTP/HTTPS العادية وحركة المرور المتعلقة بالبروكسي. يبدو أن الخوادم التي تتعامل مع كلا النوعين من حركة المرور تتجنب الحظر، في حين أن الخوادم التي تتعامل فقط مع حركة المرور المتعلقة بالبروكسي تكون أكثر عرضة للحجب.

سؤال واحد هو النطاق الزمني الذي يستخدمه الجدار الناري العظيم (GFW) لتجميع البيانات لحظر الخوادم—سواء كان ذلك يومًا واحدًا أو ساعة واحدة. خلال هذا النطاق الزمني، يكتشف الجدار الناري ما إذا كانت حركة المرور تأتي حصريًا من خلال بروكسي. إذا كان الأمر كذلك، يتم حظر عنوان IP الخادم.

غالبًا ما أزور مدونتي لمراجعة ما كتبته، ولكن في الأسابيع القادمة، سينصب تركيزي على مهام أخرى بدلًا من كتابة منشورات المدونة. هذا سيقلل من وصولي إلى واجهة برمجة التطبيقات `bandwidth` عبر المنفذ 443. إذا اكتشفت أنني تم حظري مرة أخرى، يجب أن أكتب برنامجًا للوصول إلى هذه الواجهة بشكل منتظم لخداع جدار الحماية العظيم (GFW).

إليك النسخة المحسنة من نصك مع تحسين في الهيكل والوضوح:

## كيف يعمل الجدار الناري العظيم (GFW).

### الخطوة 1: تسجيل الطلبات

```python
import time
```

# قاعدة بيانات لتخزين بيانات الطلبات
request_log = []

# دالة لتسجيل الطلبات
```python
def log_request(source_ip, target_ip, target_port, body):
    request_log.append({
        'source_ip': source_ip,
        'target_ip': target_ip,
        'target_port': target_port,
        'body': body,
        'timestamp': time.time()
    })
```

تقوم دالة `log_request` بتسجيل الطلبات الواردة مع المعلومات الأساسية مثل عنوان IP المصدر، عنوان IP الهدف، منفذ الهدف، نص الطلب، والطابع الزمني.

### الخطوة 2: التحقق من عناوين IP وحظرها

```python
# دالة للتحقق من الطلبات وحظر عناوين IP
def check_and_ban_ips():
    banned_ips = set()
```

```python
    # التكرار عبر جميع الطلبات المسجلة
    for request in request_log:
        if is_illegal(request):
            banned_ips.add(request['target_ip'])
        else:
            banned_ips.discard(request['target_ip'])
```

    # تطبيق الحظر على جميع عناوين IP المحددة
    ban_ips(banned_ips)
```

تقوم الدالة `check_and_ban_ips` بالمرور عبر جميع الطلبات المسجلة، وتحديد وعنونة عناوين IP المرتبطة بأنشطة غير قانونية.

### الخطوة 3: تحديد ما يجعل الطلب غير قانوني

```python
# دالة لمحاكاة التحقق مما إذا كان الطلب غير قانوني
def is_illegal(request):
    # مكان لحفظ منطق التحقق الفعلي من الطلب غير القانوني
    # على سبيل المثال، التحقق من جسم الطلب أو الهدف
    return "illegal" in request['body']
```

هنا، `is_illegal` تتحقق مما إذا كان نص الطلب يحتوي على كلمة "illegal". يمكن توسيع هذا المنطق ليشمل قواعد أكثر تعقيدًا اعتمادًا على ما يعتبر نشاطًا غير قانوني.

### الخطوة 4: حظر عناوين IP المحددة

```python
# دالة لحظر قائمة من عناوين IP
def ban_ips(ip_set):
    for ip in ip_set:
        print(f"جارٍ حظر عنوان IP: {ip}")
```

بمجرد تحديد عناوين IP غير القانونية، تقوم دالة `ban_ips` بحظرها عن طريق طباعة عناوين IP الخاصة بها (أو، في نظام حقيقي، يمكن أن تقوم بحظرها).

### الخطوة 5: طريقة بديلة للتحقق من عناوين IP وحظرها بناءً على 80% من الطلبات غير القانونية

```python
# دالة للتحقق من الطلبات وحظر عناوين IP بناءً على 80% من الطلبات غير القانونية
def check_and_ban_ips():
    banned_ips = set()
    illegal_count = 0
    total_requests = 0
```

```python
# التكرار على جميع الطلبات المسجلة
for request in request_log:
    total_requests += 1
    if is_illegal(request):
        illegal_count += 1
```

    # إذا كانت 80% أو أكثر من الطلبات غير قانونية، قم بحظر عناوين IP تلك
    if total_requests > 0 and (illegal_count / total_requests) >= 0.8:
        for request in request_log:
            if is_illegal(request):
                banned_ips.add(request['target_ip'])

    # تطبيق الحظر على جميع عناوين IP المحددة
    ban_ips(banned_ips)
```

هذه الطريقة البديلة تقيّم ما إذا كان ينبغي حظر عنوان IP بناءً على نسبة الطلبات غير القانونية. إذا كانت 80% أو أكثر من الطلبات القادمة من عنوان IP غير قانونية، يتم حظره.

### الخطوة 6: تحسين فحص الطلبات غير القانونية (مثل اكتشاف بروتوكولات Shadowsocks وTrojan)

```python
def is_illegal(request):
    # التحقق مما إذا كان الطلب يستخدم بروتوكول Shadowsocks (الجسم يحتوي على بيانات تشبه الثنائية)
    if request['target_port'] == 443:
        if is_trojan(request):
            return True
    elif is_shadowsocks(request):
        return True
    return False
```

دالة `is_illegal` الآن تتحقق أيضًا من بروتوكولات محددة مثل Shadowsocks و Trojan:
- **Shadowsocks**: قد نتحقق من وجود بيانات مشفرة أو تشبه البيانات الثنائية في جسم الطلب.
- **Trojan**: إذا جاء الطلب عبر المنفذ 443 (HTTPS) وطابق أنماطًا محددة (مثل خصائص حركة مرور Trojan)، يتم تصنيفه على أنه غير قانوني.

### الخطوة 7: مثال على الطلبات القانونية

على سبيل المثال، الطلبات مثل `GET https://some-domain.xyz/bandwidth` هي بالتأكيد طلبات قانونية ولن تؤدي إلى تفعيل آلية الحظر.

### الخطوة 8: خصائص حركة مرور خادم الوكيل

خوادم الوكيل (Proxy servers) تتمتع بخصائص حركة مرور مختلفة تمامًا مقارنة بخوادم الويب أو واجهات برمجة التطبيقات (API) العادية. يحتاج الجدار الناري العظيم (GFW) إلى التمييز بين حركة مرور خادم الويب العادي وحركة مرور خادم الوكيل، والتي يمكن أن تبدو مختلفة تمامًا.

### الخطوة 9: نماذج التعلم الآلي والذكاء الاصطناعي للكشف الذكي

نظرًا للنطاق الواسع من الطلبات والاستجابات التي تمر عبر الإنترنت، يمكن أن تستخدم جدار الحماية العظيم (GFW) الذكاء الاصطناعي ونماذج التعلم الآلي لتحليل أنماط حركة المرور والكشف بذكاء عن السلوكيات غير القانونية. من خلال تدريب النظام على مجموعة متنوعة من أنواع حركة المرور واستخدام تقنيات متقدمة، يمكن أن يحظر أو يرشح حركة المرور بشكل أكثر فعالية بناءً على الأنماط الملاحظة.

