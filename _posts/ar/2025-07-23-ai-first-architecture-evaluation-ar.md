---
audio: false
generated: true
lang: ar
layout: post
title: العمارة المعتمدة على الذكاء الاصطناعي للتطوير الحديث
translated: true
type: note
---

تمت كتابة هذا المنشور بمساعدة Grok، لكن الأفكار أصلية.

---

### تقييم نقاطك

سأقوم بتحليل نقاطك بشكل فردي، مقيمًا إياها في ضوء اتجاهات هندسة البرمجيات الحالية، ودمج الذكاء الاصطناعي/نماذج اللغة الكبيرة (مثل أدوات مثل GitHub Copilot أو Cursor أو وكلاء نماذج لغة كبيرة مخصصة)، والآثار العملية. أنت تلامس فكرة حاسمة: مع أصبح الذكاء الاصطناعي جزءًا لا يتجزأ من سير عمل التطوير، يجب أن تعطي الهياكل الأولوية لملاءمة الذكاء الاصطناعي إلى جانب التصاميم المتمركزة حول الإنسان. ومع ذلك، ليست جميع الأفكار قابلة للتطبيق عالميًا — السياق مهم، والتوازن بين البساطة والقابلية للتوسع ضروري. سأوضح نقاط الاتفاق والخلاف والفروق الدقيقة الرئيسية.

#### 1. لهندسة البنوك التقليدية مزايا، لكن ركز على تحسين الذكاء الاصطناعي/نماذج اللغة الكبيرة للمشاريع الجديدة: ركز على هندسة السياق، والفصل الواضح، والتصميم الموجه بالذكاء الاصطناعي
أنت محق من الناحية النظرية. تتميز الهياكل التقليدية، مثل تلك المستخدمة في القطاع المصرفي (بافتراض الإشارة إلى الأنظمة الأحادية أو ذات الطبقات للمؤسسات)، بالموثوقية والأمن وسهولة الصيانة البشرية. ومع ذلك، مع قيام وكلاء الذكاء الاصطناعي/نماذج اللغة الكبيرة بتوليد الكود وتصحيح الأخطاء وإعادة الهيكلة، فإن عقلية "الذكاء الاصطناعي أولاً" أصبحت ذات صلة متزايدة. يتضمن ذلك التصميم وفقًا لقدرات نماذج اللغة الكبيرة، مثل نافذة السياق المحدودة (مثل 128 ألف رمز في GPT-4o)، من خلال تصميم الكود بشكل وحدوي لضمان ملاءمة التفاصيل الحرجة ضمن تلك الحدود.

*   **نقاط القوة**: الفصل الواضح للمسؤوليات (على سبيل المثال، تدفقات البيانات المميزة، أو الأوامر النصية، أو حدود واجهات برمجة التطبيقات) يمكن الذكاء الاصطناعي من التفكير بفعالية أكبر. على سبيل المثال، تزدهر أدوات الذكاء الاصطناعي مثل LangChain أو الوكلاء المخصصين مع سياقات معزولة ومحددة بوضوح بدلاً من المنطق المتشابك.
*   **الفروق الدقيقة**: يظل التصميم المتمركز حول الإنسان حيويًا — لا يزال الذكاء الاصطناعي يتطلب الإشراف البشري في المجالات المعقدة مثل التمويل، حيث تكون الامتثال التنظيمي والأمان أمرًا بالغ الأهمية. قد يكون النموذج الهجين هو الأمثل: مُحسّن للذكاء الاصطناعي للمهام المتكررة، ومُحسّن للبشر للمنطق الحرج.
*   **بشكل عام**: أوافق إلى حد كبير؛ هذا الاتجاه واضح في هياكل الخدمات المصغرة والهياكل عديمة الخادم المدعومة بالذكاء الاصطناعي.

#### 2. يقدم Spring تجريدات قوية، لكنه يشكل تحديات لفهم الذكاء الاصطناعي/نماذج اللغة الكبيرة
أنت محق هنا. يُعد Spring (وأطر عمل Java المشابهة مثل Micronaut) مثاليًا للبيئات المؤسسية بميزاته مثل حقن التبعيات والبرمجة الموجهة للجوانب والتجريدات ذات الطبقات (مثل المتحكمات -> الخدمات -> المستودعات). بينما هي ممتازة للفرق الكبيرة التي يديرها البشر، إلا أنها يمكن أن تطغى على نماذج اللغة الكبيرة بسبب عدم المباشرة والكود النمطي.

*   **نقاط القوة**: غالبًا ما تواجه نماذج اللغة الكبيرة صعوبة في التعامل مع مكدسات الاستدعاء العميقة أو السلوكيات الضمنية (مثل شرح @Autowired)، مما يؤدي إلى استنتاجات خاطئة أو تحليلات غير مكتملة. يشير البحث حول توليد الكود بالذكاء الاصطناعي إلى ارتفاع معدلات الخطأ في قواعد التعليمات البرمجية المجردة بشكل مفرط.
*   **الفروق الدقيقة**: ليست جميع التجريدات ضارة — واجهات البرمجة، على سبيل المثال، تعزز قابلية الاختبار، مما يساعد الذكاء الاصطناعي بشكل غير مباشر في مهام مثل إنشاء المحاكاة. ومع ذلك، فإن التقسيم الطبقي المفرط يزيد من حجم السياق، مما يعقد تتبع المنطق لنماذج اللغة الكبيرة.
*   **بشكل عام**: أوافق بشدة؛ هناك تحول نحو أطر عمل أخف (مثل Quarkus) أو نهج تقليل الاعتماد على الأطر لتحسين التوافق مع الذكاء الاصطناعي.

#### 3. فضل الهياكل الأكثر تسطيحًا، على غرار المنظمات المسطحة: اقتصر على مستويين، حيث يستدعي المستوى الأول المستوى الثاني، وتجنب المكدسات العميقة ذات 50 مستوى
هذه فكرة مقنعة من أجل البساطة، though ليست مثالية عالميًا. تقلل الهياكل المسطحة (مثل منسق رئيسي يستدعي دوال صغيرة متعددة) من التداخل، مما يساعد نماذج اللغة الكبيرة على تجنب أخطاء التفكير في مكدسات الاستدعاء المعقدة. هذا يعكس تسلسل الدوال البسيط الذي يُشاهد غالبًا في نصوص Python.

*   **نقاط القوة**: يخفض الكود المسطح العبء الإدراكي على الذكاء الاصطناعي — حيث يؤدي نماذج اللغة الكبيرة أداءً أفضل مع التفكير الخطي أو المتوازي مقارنة بالتعميق العودي. تشبيه "المؤسسة المسطحة" صحيح: مثل الشركات الناشئة، الكود المسطح أكثر قابلية للتكيف مع التعديلات التي يجريها الذكاء الاصطناعي.
*   **الفروق الدقيقة**: استدعاء العديد من الوظائف من نقطة واحدة يعرض لخطر تحول الكود إلى "سباغيتي" بدون تنظيم منضبط (مثل التسمية الواضحة أو التوزيع الوحدوي). في الأنظمة الأكبر، يمنع التسلسل الهرمي الأدنى (3-4 مستويات) الفوضى. بينما تتعامل وكلاء الذكاء الاصطناعي مثل Devin مع الهياكل المسطحة بشكل جيد، قد تظهر مشاكل في الأداء بدون تنسيق مناسب.
*   **بشكل عام**: أوافق جزئيًا؛ التسطح مفيد حيثما كان ذلك ممكنًا، ولكن يجب اختبار قابلية التوسع. يتماشى هذا مع اتجاهات البرمجة الوظيفية في التطوير المدعوم بالذكاء الاصطناعي.

#### 4. يواجه الذكاء الاصطناعي/نماذج اللغة الكبيرة صعوبة مع الهياكل المتداخلة المعقدة، ويتفوق في الدوال الصغيرة (100-200 سطر); نظام الاستدعاء والاستيراد في Python يدعم هذا
أنت محق تمامًا فيما يتعلق بقدرات نماذج اللغة الكبيرة. النماذج الحالية (مثل Claude 3.5 أو GPT-4) تتقن المهام المركزة والمحددة لكنها تتعثر مع التعقيد — ترتفع معدلات الخطأ بعد حوالي 500 سطر من السياق بسبب حدود الرموز وتشتت الانتباه.

*   **نقاط القوة**: الدوال الصغيرة (100-200 سطر) هي الأمثل للذكاء الاصطناعي: يسهل إعطاء أوامر نصية لها، أو توليدها، أو إعادة هيكلتها. نظام الاستيراد في Python (مثل `from module import func`) يعزز النمطية، مما يجعله أكثر ملاءمة للذكاء الاصطناعي من الهيكل القائم على الفئات في Java.
*   **الفروق الدقيقة**: بينما تتقدم نماذج اللغة الكبيرة (مثلًا مع التوجيه المتسلسل للفكر)، يظل المنطق المتداخل تحديًا. تساعد مرونة Python، لكن الكتابة الثابتة (مثل في TypeScript) يمكن أن تساعد الذكاء الاصطناعي أيضًا من خلال توفير إشارات صريحة.
*   **بشمل عام**: أوافق بشدة؛ هذا يفسر سبب تبني أنظمة التعلم الآلي/الذكاء الاصطناعي (مثل مكتبات Hugging Face) غالبًا للنمط الوحدوي في Python.

#### 5. قم بتقسيم ملفات Java الكبيرة إلى ملفات أصغر تحتوي على دوال أكثر لتسهيل الاختبار/التحقق; يجب أن تحاكي مشاريع Java هيكل Python
هذا اتجاه عملي. فئات Java الكبيرة الأحادية (مثل 1000+ سطر) تشكل تحديًا لكل من البشر والذكاء الاصطناعي، بينما يؤدي التقسيم إلى ملفات/دوال أصغر إلى تحسين التجزئة.

*   **نقاط القوة**: تبسط الوحدات الأصغر الاختبارات الوحدوية (مثلًا باستخدام JUnit) والتحقق (يمكن للذكاء الاصطناعي التركيز على دالة واحدة في كل مرة)، مما يعكس نهج Python لوحدة نمطية لكل ميزة. أدوات البناء مثل Maven/Gradle تستوعب هذا بسلاسة.
*   **الفروق الدقيقة**: نظام الحزم في Java يدعم هذا بالفعل، لكن التحول الثقافي من التطبيقات الأحادية للبرمجة كائنية التوجه ضروري. ليس من الضروري أن تحاكي جميع مشاريع Java لغة Python — قد تستفيد التطبيقات الحساسة للأداء من بعض الدمج.
*   **بشكل عام**: أوافق؛ Java الحديثة (مثلًا مع السجلات والفئات المختومة في Java 21+) تتجه في هذا الاتجاه.

#### 6. قد تتفوق البرمجة الإجرائية على البرمجة كائنية التوجه في عصر الذكاء الاصطناعي/نماذج اللغة الكبيرة
هذا منظور جريء لكنه صحيح في سياقه. تتماشى النهج الإجرائية (أو الوظيفية)، مع تركيزها على التدفقات المباشرة والدوال الخالصة، مع نقاط قوة نماذج اللغة الكبيرة — حيث أن توليد الكود الخطي أبسط من التعامل مع حالة البرمجة كائنية التوجه وتوريثها وتعدد أشكالها.

*   **نقاط القوة**: غالبًا ما تربك تجريدات البرمجة كائنية التوجه مثل التوريث العميق نماذج اللغة الكبيرة، مما يؤدي إلى أخطاء في الكود المُولد. الكود الإجرائي أكثر قابلية للتنبؤ ويناسب طبيعة الذكاء الاصطناعي في مطابقة الأنماط. تعكس لغات مثل Rust (بسماتها الإجرائية) و Go (التي تؤكد على البساطة) هذا الاتجاه.
*   **الفروق الدقيقة**: البرمجة كائنية التوجه ليست بالية — فهي فعالة في نمذجة المجالات المعقدة (مثل الكيانات المالية). قد يكون النهج الهجين (نواة إجرائية مع أغلفة برمجة كائنية التوجه) هو الأمثل. باستخدام أوامر نصية مخصصة، يمكن لنماذج اللغة الكبيرة إدارة البرمجة كائنية التوجه، رغم أن الإجرائية تقلل الاحتكاك.
*   **بشكل عام**: أوافق جزئيًا؛ أساليب البرمجة الإجرائية/الوظيفية تكتسب زخمًا في سير عمل الذكاء الاصطناعي، لكن البرمجة كائنية التوجه تحتفظ بقيمتها للحفاظ على قابلية الصيانة على المدى الطويل في الأنظمة الكبيرة.

#### 7. يجب أن تقدم بيئات التطوير المتكاملة مثل VSCode أو IntelliJ IDEA اختصارات للتحرير المدعوم بالذكاء الاصطناعي للدوال/الطرق
أنت محق في أن هذا من شأنه أن يبسط سير العمل. بينما تقدم بيئات التطوير المتكاملة الحالية دعمًا جزئيًا (مثل "الانتقال إلى التعريف" في VSCode أو الاقتراحات المضمنة في Copilot)، فإن الاختصارات المخصصة للتحرير بالذكاء الاصطناعي أصبحت أكثر شيوعًا.

*   **نقاط القوة**: اختيار دالة/طريقة وإعطاء أمر للذكاء الاصطناعي (مثل "أعد هيكلة هذا") من شأنه تعزيز الكفاءة. أدوات مثل Cursor (المبني على VSCode) تمكن بالفعل من التعديلات الخاصة بالمنطقة باستخدام الذكاء الاصطناعي.
*   **الفروق الدقيقة**: تقدم IntelliJ IDEA ميزة "استخراج طريقة" ومساعدي ذكاء اصطناعي (عبر JetBrains AI)، بينما تدعم إضافات VSCode مثل GitHub Copilot Chat الاستعلامات القائمة على التحديد. ومع ذلك، فإن اختصار أصلي مثل "قم بتحرير هذه الدالة بالذكاء الاصطناعي" سيكون إضافة قيمة — ومن المرجح أن يظهر في التحديثات المستقبلية.
*   **بشكل عام**: أوافق؛ يتماشى هذا مع الاتجاه المتزايد لأدوات العمل الموجهة للذكاء الاصطناعي أولاً.

### ملخص
رؤاك دقيقة في الغالب: إن تبني الهياكل المُحسنة للذكاء الاصطناعي (المسطحة، الوحدوية، ذات الوحدات الصغيرة) يعالج قيودًا حقيقية في نماذج اللغة الكبيرة ويمكن أن يسرع التطوير. ومع ذلك، فإن التطرف في التصاميم الإجرائية بالكامل أو المسطحة بشكل مفرط قد يضر بقابلية الصيانة على المدى الطويل — التوازن أمر بالغ الأهمية. في مجالات مثل التمويل، قد تستلزم اعتبارات الأمان والامتثال بعض التجريدات. يتوافق منظورك مع أفضل الممارسات الناشئة في البرمجة بمساعدة الذكاء الاصطناعي، حيث تفيد البساطة كلًا من البشر والآلات.

إذا كان لديك أمثلة كود محددة أو ترغب في استكشاف إعادة تصميم موجهة بالذكاء الاصطناعي أولاً، لا تتردد في السؤال