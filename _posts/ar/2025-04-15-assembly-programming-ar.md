---
audio: false
generated: true
lang: ar
layout: post
title: برمجة لغة التجميع
translated: true
type: note
---

فيما يلي برنامج تعليمي شامل **للجزء الثاني: برمجة لغة التجميع**، يغطي المواضيع المحددة: *مجموعة تعليمات 8086 (تعليمات نقل البيانات، الحسابية، المنطقية، وتحكم التدفق)، برمجة لغة التجميع (هياكل التسلسل، الفروع، والحلقات)، وبرامج خدمة المقاطعة*. تم تصميم هذا البرنامج التعليمي ليكون شاملاً وسهل الووعلي وعملياً، مبنيًا على أساسيات الحواسيب الصغيرة (مثل بنية 8086/8088). يفترض معرفة أساسية بسجلات المعالج وطرق عنونة الذاكرة.

---

## الجزء الثاني: برمجة لغة التجميع

لغة التجميع هي لغة برمجة منخفضة المستوى تتحكم مباشرة في عمليات المعالج الدقيق. بالنسبة لمعالجات Intel 8086/8088، تتيح لغة التجميع للمبرمجين كتابة تعليمات تتوافق بشكل وثيق مع شفرة الآلة، مما يوفر تحكمًا دقيقًا في موارد العتاد مثل السجلات والذاكرة وأجهزة الإدخال والإخراج.

### 1. مجموعة تعليمات 8086

مجموعة تعليمات 8086 هي مجموعة من الأوامر التي يفهمها المعالج، مصنفة حسب وظيفتها: **نقل البيانات**، **الحسابية**، **المنطقية**، و**تحكم التدفق**. تعمل كل تعليمة على السجلات أو الذاكرة أو القيم الفورية، باستخدام طرق العنونة الخاصة بـ 8086 (مثل السجل، المباشر، غير المباشر).

#### أ. تعليمات نقل البيانات
تنقل هذه التعليمات البيانات بين السجلات والذاكرة والقيم الفورية.

- **MOV (نقل)**:
  - الصيغة: `MOV الوجهة, المصدر`
  - الوظيفة: تنسخ البيانات من المصدر إلى الوجهة.
  - مثال: `MOV AX, BX` (انسخ BX إلى AX)؛ `MOV AX, [1234h]` (انسخ البيانات من عنوان الذاكرة DS:1234h إلى AX).
  - ملاحظات: لا تؤثر على الأعلام؛ يجب أن يكون المصدر والوجهة بنفس الحجم (8-بت أو 16-بت).
- **XCHG (تبادل)**:
  - الصيغة: `XCHG الوجهة, المصدر`
  - الوظيفة: يبدل محتويات المصدر والوجهة.
  - مثال: `XCHG AX, BX` (تبادل AX و BX).
- **PUSH (دفع إلى المكدس)**:
  - الصيغة: `PUSH المصدر`
  - الوظيفة: يدفع بيانات 16-بت إلى المكدس، وينقص SP بمقدار 2.
  - مثال: `PUSH AX` (احفظ AX على المكدس).
- **POP (سحب من المكدس)**:
  - الصيغة: `POP الوجهة`
  - الوظيفة: يسحب بيانات 16-بت من المكدس إلى الوجهة، ويزيد SP بمقدار 2.
  - مثال: `POP BX` (استرجع BX من المكدس).
- **LEA (تحميل العنوان الفعال)**:
  - الصيغة: `LEA الوجهة, المصدر`
  - الوظيفة: تحمل عنوان معامل الذاكرة في سجل.
  - مثال: `LEA BX, [SI+4]` (تحميل عنوان DS:SI+4 في BX).
- **IN/OUT**:
  - الصيغة: `IN الوجهة, المنفذ`؛ `OUT المنفذ, المصدر`
  - الوظيفة: تنقل البيانات من/إلى منافذ الإدخال والإخراج.
  - مثال: `IN AL, 60h` (قراءة منفذ لوحة المفاتيح)؛ `OUT 61h, AL` (الكتابة إلى منفذ السماعة).

#### ب. التعليمات الحسابية
تقوم هذه التعليمات بعمليات رياضية، وتحدث الأعلام (مثل ZF, CF, SF, OF) بناءً على النتائج.

- **ADD (جمع)**:
  - الصيغة: `ADD الوجهة, المصدر`
  - الوظيفة: تجمع المصدر مع الوجهة، وتخزن النتيجة في الوجهة.
  - مثال: `ADD AX, BX` (AX = AX + BX).
- **SUB (طرح)**:
  - الصيغة: `SUB الوجهة, المصدر`
  - الوظيفة: تطرح المصدر من الوجهة.
  - مثال: `SUB CX, 10` (CX = CX - 10).
- **INC (زيادة)**:
  - الصيغة: `INC الوجهة`
  - الوظيفة: تزيد الوجهة بمقدار 1.
  - مثال: `INC BX` (BX = BX + 1).
- **DEC (إنقاص)**:
  - الصيغة: `DEC الوجهة`
  - الوظيفة: تنقص الوجهة بمقدار 1.
  - مثال: `DEC CX` (CX = CX - 1).
- **MUL (ضرب، بدون إشارة)**:
  - الصيغة: `MUL المصدر`
  - الوظيفة: تضرب AL (8-بت) أو AX (16-بت) في المصدر، وتخزن النتيجة في AX أو DX:AX.
  - مثال: `MUL BX` (DX:AX = AX * BX).
- **DIV (قسمة، بدون إشارة)**:
  - الصيغة: `DIV المصدر`
  - الوظيفة: تقسم AX (8-بت) أو DX:AX (16-بت) على المصدر، وتخزن ناتج القسمة في AL/AX، والباقي في AH/DX.
  - مثال: `DIV BX` (AX = DX:AX / BX, DX = الباقي).
- **ADC (جمع مع حمل)** و **SBB (طرح مع استلاف)**:
  - الوظيفة: تتعامل مع الحساب متعدد الكلمات باستخدام علم الحمل.
  - مثال: `ADC AX, BX` (AX = AX + BX + CF).

#### ج. التعليمات المنطقية
تقوم هذه التعليمات بعمليات bitwise وتتعامل مع البيانات الثنائية.

- **AND (AND منطقية)**:
  - الصيغة: `AND الوجهة, المصدر`
  - الوظيفة: تنفذ عملية AND منطقية، وتخزن النتيجة في الوجهة.
  - مثال: `AND AX, 0FFh` (مسح البايت العلوي لـ AX).
- **OR (OR منطقية)**:
  - الصيغة: `OR الوجهة, المصدر`
  - الوظيفة: تنفذ عملية OR منطقية.
  - مثال: `OR BX, 1000h` (تعيين البت 12 في BX).
- **XOR (XOR منطقية)**:
  - الصيغة: `XOR الوجهة, المصدر`
  - الوظيفة: تنفذ عملية XOR منطقية.
  - مثال: `XOR AX, AX` (مسح AX إلى 0).
- **NOT (NOT منطقية)**:
  - الصيغة: `NOT الوجهة`
  - الوظيفة: تعكس كل البتات في الوجهة.
  - مثال: `NOT BX` (BX = ~BX).
- **SHL/SHR (إزاحة لليسار/لليمين)**:
  - الصيغة: `SHL الوجهة, العدد`؛ `SHR الوجهة, العدد`
  - الوظيفة: تزاح البتات لليسار/لليمين، تملأ بـ 0 (SHR) أو بت الإشارة (SAL/SAR).
  - مثال: `SHL AX, 1` (AX = AX * 2).
- **ROL/ROR (دوران لليسار/لليمين)**:
  - الوظيفة: تدور البتات، مع الالتفاف حول علم الحمل.
  - مثال: `ROL BX, 1` (دوران BX لليسار بمقدار 1 بت).

#### د. تعليمات تحكم التدفق
تغير هذه التعليمات تسلسل تنفيذ البرنامج، مما يتيح القفزات والحلقات والبرامج الفرعية.

- **JMP (قفز)**:
  - الصيغة: `JMP التسمية`
  - الوظيفة: يقفز بشكل غير شرطي إلى تسمية.
  - مثال: `JMP start` (اذهب إلى التسمية `start`).
  - المتغيرات:
    - قفز قصير (±127 بايت).
    - قفز قريب (داخل القطعة).
    - قفز بعيد (قطعة مختلفة).
- **القفزات الشرطية**:
  - الصيغة: `Jcc التسمية` (مثل JZ, JNZ, JC, JNC)
  - الوظيفة: تقفز بناءً على حالة الأعلام.
  - أمثلة:
    - `JZ loop_end` (اقفز إذا كان علم الصفر مضبوطًا).
    - `JC error` (اقفز إذا كان علم الحمل مضبوطًا).
    - الشروط الشائعة: JZ (صفر), JNZ (ليس صفر), JS (إشارة), JO (تجاوز).
- **LOOP (حلقة)**:
  - الصيغة: `LOOP التسمية`
  - الوظيفة: تنقص CX، وتقفز إلى التسمية إذا كان CX ≠ 0.
  - مثال: `LOOP process` (كرر حتى CX = 0).
  - المتغيرات:
    - `LOOPE/LOOPZ`: حلقة إذا كان CX ≠ 0 و ZF = 1.
    - `LOOPNE/LOOPNZ`: حلقة إذا كان CX ≠ 0 و ZF = 0.
- **CALL (استدعاء برنامج فرعي)**:
  - الصيغة: `CALL التسمية`
  - الوظيفة: تدفع عنوان العودة إلى المكدس، وتقفز إلى البرنامج الفرعي.
  - مثال: `CALL compute_sum` (استدعاء برنامج فرعي).
- **RET (عودة)**:
  - الصيغة: `RET`
  - الوظيفة: تسحب عنوان العودة من المكدس، وتستأنف التنفيذ.
  - مثال: `RET` (العودة من البرنامج الفرعي).
- **INT (مقاطعة)**:
  - الصيغة: `INT الرقم`
  - الوظيفة: تطلق مقاطعة برمجية، مستدعية برنامج خدمة المقاطعة (ISR).
  - مثال: `INT 21h` (استدعاء نظام DOS).
- **IRET (عودة من المقاطعة)**:
  - الوظيفة: تعود من ISR، مستعادة الأعلام وعنوان العودة.

---

### 2. برمجة لغة التجميع

تكتب برامج لغة التجميع كتعليمات مقروءة يمكن تجميعها إلى شفرة الآلة. يستخدم 8086 **نموذج ذاكرة مجزأ**، مع تعريف قطاعات الكود والبيانات والمكدس بشكل صريح.

#### أ. هيكل البرنامج
يتضمن برنامج التجميع النموذجي لـ 8086:
- **التوجيهات**: تعليمات للمجمع (مثل NASM, MASM).
  - `SEGMENT`: يحدد قطاعات الكود أو البيانات أو المكدس.
  - `ORG`: يحدد عنوان البداية.
  - `DB/DW`: يحدد بيانات البايت/الكلمة.
- **التعليمات**: عمليات المعالج (مثل MOV, ADD).
- **التسميات**: تحدد مواقع للقفزات أو البيانات.
- **التعليقات**: تشرح الكود (مثل `; تعليق`).

**مثال على هيكل البرنامج (بناء جملة MASM)**:
```asm
.model small
.stack 100h
.data
    message db 'Hello, World!$'
.code
main proc
    mov ax, @data    ; تهيئة DS
    mov ds, ax
    mov dx, offset message ; تحميل عنوان الرسالة
    mov ah, 09h      ; وظيفة طباعة سلسلة في DOS
    int 21h          ; استدعاء مقاطعة DOS
    mov ah, 4Ch      ; إنهاء البرنامج
    int 21h
main endp
end main
```

#### ب. هياكل التسلسل
ينفذ الكود التسلسلي التعليمات بالترتيب، بدون قفزات أو حلقات.

**مثال: جمع عددين**
```asm
mov ax, 5        ; AX = 5
mov bx, 10       ; BX = 10
add ax, bx       ; AX = AX + BX (15)
mov [result], ax ; تخزين النتيجة في الذاكرة
```
- تنفذ التعليمات واحدة تلو الأخرى.
- شائع في الحسابات البسيطة أو تهيئة البيانات.

#### ج. هياكل الفروع
يستخدم التفرع قفزات شرطية/غير شرطية لتغيير تدفق البرنامج بناءً على الشروط.

**مثال: مقارنة وتفرع**
```asm
mov ax, 10       ; AX = 10
cmp ax, 15       ; قارن AX مع 15
je equal         ; اقفز إذا كان AX == 15
mov bx, 1        ; وإلا، BX = 1
jmp done
equal:
    mov bx, 0    ; BX = 0 إذا تساوى
done:
    ; تابع البرنامج
```
- **CMP**: يضبط الأعلام بناءً على الطرح (AX - 15).
- **JE**: يقفز إذا كان ZF = 1 (متساوي).
- مفيد لمنطق if-then-else.

#### د. هياكل الحلقات
تكرر الحلقات التعليمات حتى يتحقق شرط، غالبًا باستخدام `LOOP` أو قفزات شرطية.

**مثال: جمع الأعداد من 1 إلى 10**
```asm
mov cx, 10       ; عداد الحلقة = 10
mov ax, 0        ; المجموع = 0
sum_loop:
    add ax, cx   ; أضف CX إلى المجموع
    loop sum_loop ; انقص CX، كرر إذا كان CX ≠ 0
    ; AX = 55 (1 + 2 + ... + 10)
```
- `LOOP` يبسط التكرار القائم على العداد.
- بديل: استخدم `CMP` و `JNZ` للشروط المخصصة.

**مثال بحلقة شرطية**
```asm
mov ax, 0        ; عداد
mov bx, 100      ; حد
count_up:
    inc ax       ; AX++
    cmp ax, bx   ; قارن مع 100
    jle count_up ; اقفز إذا كان AX <= 100
```
- مرن للحلقات غير القائمة على العداد.

#### هـ. البرامج الفرعية
تقسم البرامج الفرعية الكود إلى وحدات، مما يسمح بإعادة الاستخدام عبر `CALL` و `RET`.

**مثال: تربيع عدد**
```asm
main:
    mov ax, 4    ; الإدخال
    call square  ; استدعاء البرنامج الفرعي
    ; AX = 16
    jmp exit
square:
    push bx      ; احفظ BX
    mov bx, ax   ; انسخ AX
    mul bx       ; AX = AX * BX
    pop bx       ; استرجع BX
    ret          ; عودة
exit:
    ; نهاية البرنامج
```
- **PUSH/POP**: احفظ/استرجع السجلات لتجنب الآثار الجانبية.
- يدير المكدس عناوين العودة تلقائيًا.

---

### 3. برامج خدمة المقاطعة (ISRs)

تسمح المقاطعات للمعالج بالاستجابة للأحداث الخارجية أو الداخلية (مثل إدخال لوحة المفاتيح، نبضات المؤقت) عن طريق إيقاف البرنامج الحالي مؤقتًا وتنفيذ ISR.

#### آلية المقاطعة
- **جدول متجهات المقاطعة (IVT)**:
  - موجود في الذاكرة 0000:0000h–0000:03FFh.
  - يخزن عناوين ISRs لـ 256 نوع مقاطعة (0–255).
  - كل مدخل: القطعة:الإزاحة (4 بايت).
- **الأنواع**:
  - **مقاطعات العتاد**: تطلقها الأجهزة (مثل IRQ).
  - **مقاطعات البرمجيات**: تطلقها تعليمة `INT` (مثل INT 21h لـ DOS).
  - **الاستثناءات**: أخطاء المعالج (مثل القسمة على صفر).
- **العملية**:
  1. تحدث المقاطعة.
  2. يحفظ المعالج الأعلام و CS و IP على المكدس.
  3. يقفز إلى ISR عبر IVT.
  4. ينفذ ISR، وينتهي بـ `IRET` لاستعادة الحالة.

#### كتابة ISR
يجب على ISRs أن:
- تحافظ على السجلات (PUSH/POP).
- تتعامل مع المقاطعة بسرعة.
- تنتهي بـ `IRET`.

**مثال: ISR مخصص للمؤقت**
```asm
.data
old_vec dw 2 dup(0) ; تخزين متجه المقاطعة القديم
.code
install_isr:
    cli             ; عطل المقاطعات
    mov ax, 0
    mov es, ax      ; ES = 0 (قطعة IVT)
    mov bx, 1Ch*4   ; مقاطعة المؤقت (1Ch)
    mov ax, es:[bx] ; احفظ المتجه القديم
    mov old_vec, ax
    mov ax, es:[bx+2]
    mov old_vec+2, ax
    mov ax, offset my_isr ; عين المتجه الجديد
    mov es:[bx], ax
    mov ax, cs
    mov es:[bx+2], ax
    sti             ; مكن المقاطعات
    ret
my_isr:
    push ax
    inc word ptr [counter] ; زيادة العداد
    pop ax
    iret            ; عودة من المقاطعة
```
- يربط مقاطعة المؤقت (1Ch، ~18.2 هرتز).
- يزيد متغير عداد.
- يحافظ على السجلات ويستخدم `IRET`.

**مثال: مقاطعة DOS (INT 21h)**
```asm
mov ah, 09h      ; وظيفة طباعة سلسلة
mov dx, offset msg ; عنوان السلسلة المنتهية بـ '$'
int 21h          ; استدعاء DOS
```
- يوفر INT 21h خدمات نظام التشغيل (مثل الإدخال/الإخراج، التعامل مع الملفات).
- يحدد AH رمز الوظيفة.

#### ملاحظات عملية
- **حفظ الحالة**: يجب على ISRs الحفاظ على جميع السجلات لتجنب إتلاف البرنامج الرئيسي.
- **الأولوية**: قد تسبق المقاطعات العتادية الأخرى (تدار بواسطة PIC).
- **التصحيح**: استخدم أدوات مثل DEBUG.COM أو المحاكيات الحديثة (مثل DOSBox, Bochs).

---

### برنامج مثال: حساب المضروب
يحسب هذا البرنامج مضروب عدد (مثل 5! = 120) باستخدام حلقة وبرنامج فرعي.

```asm
.model small
.stack 100h
.data
    num dw 5        ; العدد المدخل
    result dw ?     ; تخزين النتيجة
.code
main proc
    mov ax, @data
    mov ds, ax      ; تهيئة DS
    mov ax, num     ; تحميل العدد
    call factorial  ; حساب المضروب
    mov result, ax  ; تخزين النتيجة
    mov ah, 4Ch     ; خروج
    int 21h
main endp
factorial proc
    push bx
    mov bx, ax      ; BX = n
    mov ax, 1       ; AX = النتيجة
fact_loop:
    cmp bx, 1
    jle done        ; إذا كان BX <= 1، اخرج
    mul bx          ; AX = AX * BX
    dec bx          ; BX--
    jmp fact_loop
done:
    pop bx
    ret
factorial endp
end main
```
- **المنطق**:
  - الإدخال: num = 5.
  - الحلقة: AX = AX * BX, BX-- حتى BX = 1.
  - النتيجة: AX = 5 * 4 * 3 * 2 * 1 = 120.
- **الميزات**:
  - برنامج فرعي للتعديلية.
  - مكدس للحفاظ على السجلات.
  - هياكل تسلسلية وحلقية.

---

### أفضل الممارسات
1. **علق على الكود**: لغة التجميع غامضة؛ اشرح كل خطوة.
2. **قلل استخدام السجلات**: تجنب الكتابة فوقها بدون داع.
3. **اختبر تدريجيًا**: استخدم المصححات لتتبع التنفيذ.
4. **تعامل مع الحالات الطارئة**: تحقق من التجاوز أو الصفر أو المدخلات السالبة.
5. **حسن الأداء**: قلل عدد التعليمات (مثل استخدم XOR AX, AX بدلاً من MOV AX, 0).

---

### الملخص
- **مجموعة تعليمات 8086**:
  - **نقل البيانات**: MOV, PUSH, POP لنقل البيانات.
  - **الحسابية**: ADD, SUB, MUL للحسابات.
  - **المنطقية**: AND, OR, XOR للتلاعب بالبتات.
  - **تحكم التدفق**: JMP, LOOP, CALL لتحكم تدفق البرنامج.
- **هياكل البرمجة**:
  - **التسلسلية**: تنفيذ خطي للمهام البسيطة.
  - **الفروع**: قفزات شرطية لاتخاذ القرارات.
  - **الحلقات**: LOOP أو Jcc للتكرار.
  - **البرامج الفرعية**: CALL/RET للكود المعياري.
- **المقاطعات**:
  - تتعامل ISRs مع الأحداث عبر IVT.
  - تحافظ على الحالة، تنتهي بـ IRET.
  - تستخدم لمقاطعات العتاد (مثل المؤقت) والبرمجيات (مثل DOS).

---

### أسئلة التدريب
1. اكتب برنامجًا لعكس سلسلة في الذاكرة.
2. نفذ برنامجًا فرعيًا للتحقق مما إذا كان الرقم أوليًا.
3. أنشئ ISR لمقاطعة لوحة المفاتيح (INT 09h) لحساب عدد ضغطات المفاتيح.
4. اشرح الفرق بين `JMP` و `CALL`.
5. حسن هذا الكود: `MOV AX, 0; MOV BX, AX; ADD BX, 5`.

---

يغطي هذا البرنامج التعليمي أساسيات برمجة التجميع لـ 8086، مع أمثلة وشروحات لبناء مهارات عملية. إذا كنت ترغب في استكشاف تعليمات محددة، أو تقنيات متقدمة (مثل عمليات السلسلة)، أو أدوات المحاكاة، دعني أعرف!