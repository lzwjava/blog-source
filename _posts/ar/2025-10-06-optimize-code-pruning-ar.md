---
audio: false
generated: true
image: false
lang: ar
layout: post
model: x-ai/grok-4-fast
title: تحسين الكود بإزالة الأكواد غير الضرورية
translated: true
type: note
---

تماماً صحيح—لنبني على سجل الوكيل ذلك كنقطة انطلاقنا. إنه كنز حقيقي لعقلية "التحسين": البرنامج النصي لا يتفقد 53 وكيلاً بعنف مثل المطرقة؛ بل يركز بشكل حاد على الهدف (أسرع خوادم في سنغافورة/تايوان لأدوات الذكاء الاصطناعي مثل ChatGPT، وتجنب الحظر في هونغ كونغ) من خلال التصفية أولاً إلى 14 وكيلاً، واختبار زمن الوصول على دفعات، والفرز لتتويج الأسرع بـ 294 مللي ثانية. هذا ليس مجرد كفاءة—إنه تقليم بلا رحمة: استبعد ما لا يخدم الهدف النهائي، أعِد ترتيب العمليات (تصفية > اختبار > اختيار)، وتشكك في كل خطوة ("هل أحتاج لاختبار ذلك الوكيل المخصص للصين فقط؟ لا.").

هذا قابل للتطبيق على *أي* كود حيث تتفاقم الحلقات، أو الاستعلامات، أو العمليات الحسابية. إليك كيفية توسيع الفكرة مع أمثلة من العالم الحقيقي، مع العودة دائماً إلى تلك الأسئلة الأساسية: *هل يمكننا التحسين؟ ما هو الهدف الحقيقي؟ ماذا نستبعد؟ ترتيب مختلف؟*

### 1. **استعلامات قاعدة البيانات: صفِّ قبل الجلب (اقطع الدهون مبكراً)**
   تخيل الاستعلام من قاعدة بيانات المستخدمين عن "المشتركين النشطين في أوروبا الذين اشتروا الباقة المميزة الشهر الماضي". الكود الساذج: `SELECT * FROM users WHERE active=1 AND region='EU' AND purchase_date > '2024-09-01' ORDER BY signup_date`. ينفذ—فيجلب *كل* الأعمدة لملايين الصفوف، ثم يقوم بالتصفية في الذاكرة. إهدار إذا كنت تحتاج فقط `email` و `last_login`.

   **عدسة التحسين:**
   - **الهدف؟** ليس "جلب كل المستخدمين"، بل "قائمة بريد إلكتروني لحملة مستهدفة."
   - **ماذا نستبعد؟** SELECT فقط `email` (وربما `id` للتتبع). أضف `LIMIT 1000` إذا كنت تستخدم التقسيم إلى صفحات.
   - **ترتيب مختلف؟** ادفع عوامل التصفية إلى لغة SQL (عبارات WHERE) قبل أي منطق معالجة في التطبيق. فهرس على `region` و `purchase_date` لتقليل وقت المسح الضوئي.
   
   النتيجة: من استعلام 10 ثوانٍ إلى 50 مللي ثانية. مثل تصفية الوكيل: لماذا تحمل 53 عندما 14 تكفي؟ في الكود:
   ```python:disable-run
   # سيء: اجلب الكل، صفِّف لاحقاً
   all_users = db.query("SELECT * FROM users")
   eu_premium = [u for u in all_users if u.region == 'EU' and u.is_premium]
   
   # محسّن: صفِّف من المصدر
   eu_premium = db.query("SELECT email FROM users WHERE region='EU' AND is_premium=1 LIMIT 1000")
   ```

### 2. **معدل الحد للواجهات البرمجية: الدفعات والذاكرة المخبأة (أعِد الترتيب للفوز بالتوازي)**
   لنقل أنك تقوم بجمع 100 سعر منتج من واجهة برمجية للتجارة الإلكترونية بمعدل حد 10/ثانية. حلقة مباشرة: `for item in items: price = api.get(item.id); total += price`. تستغرق 10 ثوانٍ، ولكن ماذا لو كان نصف العناصر هي نفسها (SKUs متطابقة)؟ استدعاءات مكررة.

   **عدسة التحسين:**
   - **الهدف؟** تجميع الأسعار، وليس الضربات الفردية لكل عنصر.
   - **ماذا نستبعد؟** احذف تكرار المعرفات أولاً (`unique_items = set(item.id for item in items)`—يتخلص من 50% فوراً).
   - **ترتيب مختلف؟** اطلب على دفعات (إذا كانت الواجهة البرمجية تدعم `/batch?ids=1,2,3`) أو نفذ بالتوازي بشكل غير متزامن باستخدام `asyncio.gather([api.get(id) for id in unique_items])`. أضف طبقة من الذاكرة المخبأة Redis: "هل رأيت هذا المعرف في آخر ساعة؟ تخطَّه."
   
   التوازي في الوكيل: تلك السجلات المتزامنة لـ TCP؟ نفس الفكرة—اختبر عدة أوقات وصول في وقت واحد بدلاً من التسلسل. يختصر الثواني إلى ميلي ثوانٍ. مقتطف كود:
   ```python
   import asyncio
   
   async def fetch_prices(ids):
       return await asyncio.gather(*[api.get(id) for id in set(ids)])  # إزالة التكرار + التوازي
   
   totals = sum(await fetch_prices(items))  # دفعة واحدة، انتهى.
   ```

### 3. **خط معالجة الصور: الخروج المبكر عند الفشل (تشكك في الهدف أثناء التنفيذ)**
   تبني محرر صور: تغيير الحجم، إضافة علامة مائية، ضغط 1000 ملف مرفوع. الحلقة: لكل صورة، حمِّل > غيِّر الحجم > أضف نصاً > احفظ كـ JPEG. ولكن 20% منها تالفة—موارد معالجة مركزية مهدرة على أشباح.

   **عدسة التحسين:**
   - **الهدف؟** تقديم صور محررة صالحة، وليس معالجة خردة.
   - **ماذا نستبعد؟** فحص سريع للصلاحية (مثلاً، `PIL.Image.open` مع `try/except`—انسحب إذا فشل).
   - **ترتيب مختلف؟** تحقق من الصلاحية أولاً، ثم مرر فقط الملفات الصالحة عبر الخط. قم بالتحليل: 80% من الوقت في تغيير الحجم؟ قلل دقة الصور المصغرة بشكل غير متزامن للعروض التقديمية.
   
   يذكرنا بتحذير انتهاء وقت الوكيل: خطأ 504 ذلك؟ البرنامج النصي حدده بسرعة، لم يسمح له بتعطيل ترتيب أفضل 20. عملياً:
   ```python
   def process_image(path):
       try:
           img = Image.open(path)  # قطع مبكر: فشل هنا، سجِّل وتخطَّ
           img = img.resize((800, 600))
           # علامة مائية، ضغط...
           img.save(f"{path}_edited.jpg")
       except Exception:
           logging.warning(f"Skipped corrupt: {path}")
   
   [process_image(p) for p in valid_paths]  # قائمة مُصفاة مسبقاً
   ```

### القاعدة الشاملة: حلِّل بلا رحمة، كرِّر بتشكك
اربطها بالخلفية: ابدأ كل إعادة هيكلة بـ "ما هو عنق الزجاجة؟" (أدوات مثل `cProfile` في Python أو أدوات المطور في المتصفح). سجِّل مثل برنامجك النصي للوكيل—الطوابع الزمنية تكشف البطء. ثم راجع: *هل هناك محاذاة مع الهدف؟* (مثلاً، "زمن وصول <300 مللي ثانية للوصول إلى الذكاء الاصطناعي"). *استبعادات؟* (كود ميت، متغيرات غير مستخدمة—أدوات مثل `black` أو `pylint` تشير إليها). *إعادة ترتيب؟* (التقييم الكسول: احسب عند الطلب، ليس مقدماً).

هذا ليس تحسيناً دقيقاً قبل الأوان—إنه تشكك استراتيجي. في عالم الوكيل، هذا يعني نعيم SG/TW دون صداع HK؛ في عالمك، هذا يعني كوداً *يشعر* بأنه أسرع. هل لديك حلقة أو خوارزمية محددة تنوي تطبيق هذا العلاج عليها؟ دعنا نحللها.