---
audio: false
generated: true
lang: ar
layout: post
title: استخدام epoll في لينكس
translated: true
---

# كيفية استخدام `epoll` في لينكس

`epoll` هو مكالمة نظام لينكس مصممة لتتبع الفعاليات المتعددة على الوصفات الملفات، مثل عندما تكون البيانات جاهزة للقراءة أو عندما يكون المرفق جاهز للكتابة. إنه مفيد بشكل خاص في برمجة الشبكة، حيث قد يحتاج الخادم إلى معالجة العديد من الإتصالات بشكل متزامن. مقارنة بأدوات قديمة مثل `select` أو `poll`، فإن `epoll` يتسق بشكل أفضل مع عدد كبير من الوصفات الملفات لأنه يتجنب فحص جميع الوصفات بشكل متكرر للاستعداد.

هنا دليل خطوة بخطوة لاستخدام `epoll` في لينكس، متبوعًا بامثلة بسيطة لخادم يقبل الإتصالات ويعيد البيانات.

---

## خطوات لاستخدام `epoll`

### 1. **إنشاء مثيل `epoll`**
لبدء استخدام `epoll`، تحتاج إلى إنشاء مثيل `epoll`، والذي يمثله وصف ملف. استخدم مكالمة النظام `epoll_create1`:

```c
int epoll_fd = epoll_create1(0);
```
- **المعلمة**: قم بإرسال `0` للاستخدام الأساسي (لا توجد علامات خاصة). يمكن استخدام علامات مثل `EPOLL_CLOEXEC` لأغراض متقدمة.
- **القيمة العائدة**: يعيد وصف ملف (`epoll_fd`) عند النجاح، أو `-1` في حالة الخطأ (تحقق من `errno` للحصول على التفاصيل).

دالة `epoll_create` القديمة مشابهة ولكن تأخذ نصيحة الحجم (تغفل الآن)، لذا `epoll_create1` هي المفضلة.

### 2. **إضافة الوصفات الملفات للمراقبة**
استخدم `epoll_ctl` لتسجيل الوصفات الملفات (مثل المرفقات) مع مثيل `epoll` وتحديد الفعاليات التي تريد مراقبتها:

```c
struct epoll_event ev;
ev.events = EPOLLIN;  // مراقب للقراءة
ev.data.fd = some_fd; // وصف الملف المراقب
epoll_ctl(epoll_fd, EPOLL_CTL_ADD, some_fd, &ev);
```
- **المعلمات**:
  - `epoll_fd`: وصف ملف مثيل `epoll`.
  - `EPOLL_CTL_ADD`: عملية لإضافة وصف ملف.
  - `some_fd`: وصف الملف المراقب (مثل مرفق).
  - `&ev`: مؤشر إلى `struct epoll_event` يحدد الفعاليات والبيانات الاختيارية للمستخدم.
- **الفعاليات الشائعة**:
  - `EPOLLIN`: البيانات جاهزة للقراءة.
  - `EPOLLOUT`: جاهز للكتابة.
  - `EPOLLERR`: حدث خطأ.
  - `EPOLLHUP`: قطع الاتصال (مثل إغلاق الإتصال).
- **بيانات المستخدم**: يمكن أن تخزن الحقل `data` في `struct epoll_event` وصف ملف (كما هو موضح) أو بيانات أخرى (مثل مؤشر) لتحديد المصدر عند حدوث الفعاليات.

### 3. **انتظار الفعاليات**
استخدم `epoll_wait` لتوقف و انتظار الفعاليات على الوصفات الملفات المراقبة:

```c
struct epoll_event events[MAX_EVENTS];
int nfds = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);
```
- **المعلمات**:
  - `epoll_fd`: مثيل `epoll`.
  - `events`: مصفوفة لتخزين الفعاليات المحرضة.
  - `MAX_EVENTS`: عدد الفعاليات الأقصى للعودة (حجم المصفوفة).
  - `-1`: وقت الانتظار بالمللي ثانية (`-1` يعني انتظار بلا نهاية؛ `0` يعود فورًا).
- **القيمة العائدة**: عدد الوصفات الملفات مع الفعاليات (`nfds`), أو `-1` في حالة الخطأ.

### 4. **معالجة الفعاليات**
عبر على الفعاليات التي عادت بها `epoll_wait` و معالجتها:

```c
for (int i = 0; i < nfds; i++) {
    if (events[i].events & EPOLLIN) {
        // وصف الملف `events[i].data.fd` قابل للقراءة
    }
}
```
- تحقق من الحقل `events` باستخدام العمليات المنطقية (مثل `events[i].events & EPOLLIN`) لتحديد نوع الفعالية.
- استخدم `events[i].data.fd` لتحديد أي وصف ملف حدد الفعالية.

### 5. **إدارة الوصفات الملفات (اختياري)**
- **إزالة**: استخدم `epoll_ctl` مع `EPOLL_CTL_DEL` لإيقاف مراقب وصف ملف:
  ```c
  epoll_ctl(epoll_fd, EPOLL_CTL_DEL, some_fd, NULL);
  ```
- **تعديل**: قم بتعديل الفعاليات مع `EPOLL_CTL_MOD`:
  ```c
  ev.events = EPOLLOUT; // تغيير إلى مراقب للكتابة
  epoll_ctl(epoll_fd, EPOLL_CTL_MOD, some_fd, &ev);
  ```

---

## مفاهيم رئيسية

### **مراقب المستوى مقابل مراقب الحافة**
- **مراقب المستوى (الافتراضي)**: `epoll` يبلغ بشكل متكرر طالما استمر الوضع (مثل البيانات غير المقروءة). أسهل في معظم الحالات.
- **مراقب الحافة (`EPOLLET`)**: يبلغ فقط مرة واحدة عندما يتغير الوضع (مثل وصول بيانات جديدة). يتطلب قراءة/كتابة جميع البيانات حتى `EAGAIN` لمنع فقدان الفعاليات؛ أكثر كفاءة ولكن أكثر تعقيدًا.
- قم بإعداد `EPOLLET` في `ev.events` (مثل `EPOLLIN | EPOLLET`) إذا كنت تستخدم وضع المراقب الحافة.

### **إدخال/إخراج غير متزامن**
`epoll` غالبًا ما يُستخدم مع الوصفات الملفات غير المتزامن لمنع التوقف على عمليات الإدخال/الإخراج. قم بإعداد مرفق إلى وضع غير متزامن باستخدام:

```c
fcntl(fd, F_SETFL, fcntl(fd, F_GETFL) | O_NONBLOCK);
```

---

## مثال: خادم إيكو بسيط

هنا مثال أساسي لخادم يستخدم `epoll` لقبول الإتصالات وإعادة البيانات إلى العملاء. يستخدم وضع المراقب المستوى للسهولة.

```c
#include <sys/epoll.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>

#define MAX_EVENTS 10
#define PORT 8080

int main() {
    // إنشاء مرفق الاستماع
    int listen_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (listen_fd == -1) { perror("socket"); exit(1); }

    struct sockaddr_in addr = { .sin_family = AF_INET, .sin_addr.s_addr = INADDR_ANY, .sin_port = htons(PORT) };
    if (bind(listen_fd, (struct sockaddr*)&addr, sizeof(addr)) == -1) { perror("bind"); exit(1); }
    if (listen(listen_fd, 5) == -1) { perror("listen"); exit(1); }

    // تعيين مرفق الاستماع إلى وضع غير متزامن
    fcntl(listen_fd, F_SETFL, fcntl(listen_fd, F_GETFL) | O_NONBLOCK);

    // إنشاء مثيل `epoll`
    int epoll_fd = epoll_create1(0);
    if (epoll_fd == -1) { perror("epoll_create1"); exit(1); }

    // إضافة مرفق الاستماع إلى `epoll`
    struct epoll_event ev, events[MAX_EVENTS];
    ev.events = EPOLLIN; // مراقب المستوى
    ev.data.fd = listen_fd;
    if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, listen_fd, &ev) == -1) { perror("epoll_ctl"); exit(1); }

    // حلقة الفعاليات
    while (1) {
        int nfds = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);
        if (nfds == -1) { perror("epoll_wait"); exit(1); }

        for (int i = 0; i < nfds; i++) {
            int fd = events[i].data.fd;

            if (fd == listen_fd) {
                // قبول إتصال جديد
                int client_fd = accept(listen_fd, NULL, NULL);
                if (client_fd == -1) { perror("accept"); continue; }

                // تعيين مرفق العميل إلى وضع غير متزامن
                fcntl(client_fd, F_SETFL, fcntl(client_fd, F_GETFL) | O_NONBLOCK);

                // إضافة مرفق العميل إلى `epoll`
                ev.events = EPOLLIN;
                ev.data.fd = client_fd;
                if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, client_fd, &ev) == -1) {
                    perror("epoll_ctl: client_fd");
                    close(client_fd);
                }
            } else {
                // معالجة بيانات العميل
                char buf[1024];
                ssize_t n = read(fd, buf, sizeof(buf));
                if (n <= 0) {
                    // خطأ أو EOF: اغلق و إزال من `epoll`
                    if (n == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) continue;
                    close(fd);
                    epoll_ctl(epoll_fd, EPOLL_CTL_DEL, fd, NULL);
                } else {
                    // إعادة البيانات
                    write(fd, buf, n); // ملاحظة: في التطبيقات الحقيقية، قم بمعالجة الكتابة الجزئية
                }
            }
        }
    }

    close(epoll_fd);
    close(listen_fd);
    return 0;
}
```

### ملاحظات على المثال
- **مرفق الاستماع**: يراقب `EPOLLIN` لتحديد الإتصالات الجديدة.
- **مرفقات العملاء**: يراقب أيضًا `EPOLLIN` لتحديد البيانات الواردة.
- **تسوية**: يفترض أن `write` يكتمل بالكامل. في الإنتاج، قم بتمرير البيانات و استخدم `EPOLLOUT` للكتابة الجزئية.
- **معالجة الأخطاء**: يغلق المرفقات عند الأخطاء أو EOF ويزيلها من `epoll`.

---

## ملخص
`epoll` يوفر طريقة فعالة لتعامل مع الوصفات الملفات المتعددة في لينكس:
1. إنشاء مثيل باستخدام `epoll_create1`.
2. تسجيل الوصفات الملفات والفعاليات باستخدام `epoll_ctl`.
3. انتظار الفعاليات باستخدام `epoll_wait`.
4. معالجة الفعاليات في حلقة، تعديل الفعاليات المراقبة أو إزالة الوصفات حسب الحاجة.

للتطبيقات البسيطة، يُوصى باستخدام وضع المراقب المستوى. للاحتياجات عالية الأداء، اعتبر وضع المراقب الحافة مع معالجة جميع البيانات المتاحة بعناية. دائمًا قم بإزالة `epoll` مع الإدخال/الإخراج غير المتزامن للحصول على أفضل النتائج.