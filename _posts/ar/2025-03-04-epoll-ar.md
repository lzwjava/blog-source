---
audio: false
generated: true
lang: ar
layout: post
title: استخدام epoll في لينكس
translated: true
---

`epoll` هو مكالمة نظام لينكس مصممة لتتبع الفعاليات بشكل فعال على عدة معالم ملفات، مثل عندما تكون البيانات جاهزة للقراءة أو عندما يكون المرفق جاهز للكتابة. فهو مفيد بشكل خاص في برمجة الشبكة، حيث قد يحتاج الخادم إلى معالجة العديد من الإتصالات بشكل متزامن. مقارنةً بأجهزة قديمة مثل `select` أو `poll`، فإن `epoll` يتسق بشكل أفضل مع عدد كبير من معالم الملفات لأنه يتجنب فحص جميع المعالم بشكل متكرر للاستعداد.

هنا دليل خطوة بخطوة لاستخدام `epoll` في لينكس، متبوعًا بامثلة بسيطة لخدمة تقبل الإتصالات وتعيد البيانات.

---

## خطوات لاستخدام `epoll`

### 1. **إنشاء مثيل `epoll`**
لبدء استخدام `epoll`، تحتاج إلى إنشاء مثيل `epoll`، والذي يمثله معلم ملف. استخدم مكالمة النظام `epoll_create1`:

```c
int epoll_fd = epoll_create1(0);
```
- **المعلمة**: قم بتقديم `0` للاستخدام الأساسي (بدون علامات خاصة). يمكن استخدام علامات مثل `EPOLL_CLOEXEC` لأغراض متقدمة.
- **القيمة التي تعود**: ترجع معلم ملف (`epoll_fd`) عند النجاح، أو `-1` عند الخطأ (تحقق من `errno` للحصول على التفاصيل).

المكالمة القديمة `epoll_create` مشابهة ولكن تأخذ نصيحة الحجم (تجاهل الآن)، لذا فإن `epoll_create1` هو المفضل.

### 2. **إضافة معالم ملفات للتابع**
استخدم `epoll_ctl` لتسجيل معالم الملفات (مثل المرفقات) مع مثيل `epoll` وتحديد الفعاليات التي تريد تتبعها:

```c
struct epoll_event ev;
ev.events = EPOLLIN;  // تتبع القابلية للقراءة
ev.data.fd = some_fd; // معلم الملف الذي سيتم تتبعه
epoll_ctl(epoll_fd, EPOLL_CTL_ADD, some_fd, &ev);
```
- **المعلمات**:
  - `epoll_fd`: معلم مثيل `epoll`.
  - `EPOLL_CTL_ADD`: عملية لإضافة معلم ملف.
  - `some_fd`: معلم الملف الذي سيتم تتبعه (مثل مرفق).
  - `&ev`: مؤشر إلى `struct epoll_event` يحدد الفعاليات والمعلومات الإضافية للمستخدم.
- **الفعاليات الشائعة**:
  - `EPOLLIN`: البيانات جاهزة للقراءة.
  - `EPOLLOUT`: جاهز للكتابة.
  - `EPOLLERR`: حدث خطأ.
  - `EPOLLHUP`: قطع الاتصال (مثل إغلاق الإتصال).
- **بيانات المستخدم**: يمكن أن تخزن حقل `data` في `struct epoll_event` معلم ملف (كما هو موضح) أو بيانات أخرى (مثل مؤشر) لتحديد المصدر عند حدوث الفعاليات.

### 3. **انتظار الفعاليات**
استخدم `epoll_wait` لتوقف وانتظار الفعاليات على معالم الملفات التي يتم تتبعها:

```c
struct epoll_event events[MAX_EVENTS];
int nfds = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);
```
- **المعلمات**:
  - `epoll_fd`: مثيل `epoll`.
  - `events`: مصفوفة لتخزين الفعاليات المفعلة.
  - `MAX_EVENTS`: عدد الفعاليات القصوى التي سيتم إرجاعها (حجم المصفوفة).
  - `-1`: وقت الانتظار بالمللي ثانية (`-1` يعني انتظار بلا نهاية؛ `0` يعود فورًا).
- **القيمة التي تعود**: عدد معالم الملفات التي تحتوي على الفعاليات (`nfds`)، أو `-1` عند الخطأ.

### 4. **معالجة الفعاليات**
عبر على الفعاليات التي تم إرجاعها بواسطة `epoll_wait` وعمليتها:

```c
for (int i = 0; i < nfds; i++) {
    if (events[i].events & EPOLLIN) {
        // معلم الملف `events[i].data.fd` قابل للقراءة
    }
}
```
- تحقق من حقل `events` باستخدام العمليات المنطقية (مثل `events[i].events & EPOLLIN`) لتحديد نوع الفعالية.
- استخدم `events[i].data.fd` لتحديد معلم الملف الذي تسبب في الفعالية.

### 5. **إدارة معالم الملفات (اختياري)**
- **إزالة**: استخدم `epoll_ctl` مع `EPOLL_CTL_DEL` لإيقاف تتبع معلم ملف:
  ```c
  epoll_ctl(epoll_fd, EPOLL_CTL_DEL, some_fd, NULL);
  ```
- **تعديل**: تعديل الفعاليات مع `EPOLL_CTL_MOD`:
  ```c
  ev.events = EPOLLOUT; // تغيير إلى تتبع القابلية للكتابة
  epoll_ctl(epoll_fd, EPOLL_CTL_MOD, some_fd, &ev);
  ```

---

## مفاهيم رئيسية

### **التتبع على مستوى مقابل تتبع على حافة**
- **التتبع على مستوى (الافتراضي)**: يبلغ `epoll` بشكل متكرر طالما استمر الوضع (مثل البيانات غير المقروءة). أسهل في معظم الحالات.
- **التتبع على حافة (`EPOLLET`)**: يبلغ فقط مرة واحدة عندما يتغير الوضع (مثل وصول بيانات جديدة). يتطلب قراءة/كتابة جميع البيانات حتى `EAGAIN` لمنع فقدان الفعاليات؛ أكثر كفاءة ولكن أكثر تعقيدًا.
- قم بتحديد `EPOLLET` في `ev.events` (مثل `EPOLLIN | EPOLLET`) إذا كنت تستخدم وضع تتبع الحافة.

### **إدخال/إخراج غير متزامن**
يستخدم `epoll` غالبًا مع معالم ملفات غير متزامن لمنع التوقف على عمليات الإدخال/الإخراج. قم بتحديد مرفق إلى وضع غير متزامن باستخدام:

```c
fcntl(fd, F_SETFL, fcntl(fd, F_GETFL) | O_NONBLOCK);
```

---

## مثال: خادم إكو بسيط

هنا مثال أساسي لخدمة تستخدم `epoll` لتقبيل الإتصالات وإعادة البيانات إلى العملاء. يستخدم وضع تتبع المستوى من أجل السهولة.

```c
#include <sys/epoll.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>

#define MAX_EVENTS 10
#define PORT 8080

int main() {
    // إنشاء مرفق الاستماع
    int listen_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (listen_fd == -1) { perror("socket"); exit(1); }

    struct sockaddr_in addr = { .sin_family = AF_INET, .sin_addr.s_addr = INADDR_ANY, .sin_port = htons(PORT) };
    if (bind(listen_fd, (struct sockaddr*)&addr, sizeof(addr)) == -1) { perror("bind"); exit(1); }
    if (listen(listen_fd, 5) == -1) { perror("listen"); exit(1); }

    // تعيين مرفق الاستماع إلى وضع غير متزامن
    fcntl(listen_fd, F_SETFL, fcntl(listen_fd, F_GETFL) | O_NONBLOCK);

    // إنشاء مثيل `epoll`
    int epoll_fd = epoll_create1(0);
    if (epoll_fd == -1) { perror("epoll_create1"); exit(1); }

    // إضافة مرفق الاستماع إلى `epoll`
    struct epoll_event ev, events[MAX_EVENTS];
    ev.events = EPOLLIN; // تتبع المستوى
    ev.data.fd = listen_fd;
    if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, listen_fd, &ev) == -1) { perror("epoll_ctl"); exit(1); }

    // حلقة الفعاليات
    while (1) {
        int nfds = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);
        if (nfds == -1) { perror("epoll_wait"); exit(1); }

        for (int i = 0; i < nfds; i++) {
            int fd = events[i].data.fd;

            if (fd == listen_fd) {
                // قبول إتصال جديد
                int client_fd = accept(listen_fd, NULL, NULL);
                if (client_fd == -1) { perror("accept"); continue; }

                // تعيين مرفق العميل إلى وضع غير متزامن
                fcntl(client_fd, F_SETFL, fcntl(client_fd, F_GETFL) | O_NONBLOCK);

                // إضافة مرفق العميل إلى `epoll`
                ev.events = EPOLLIN;
                ev.data.fd = client_fd;
                if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, client_fd, &ev) == -1) {
                    perror("epoll_ctl: client_fd");
                    close(client_fd);
                }
            } else {
                // معالجة بيانات العميل
                char buf[1024];
                ssize_t n = read(fd, buf, sizeof(buf));
                if (n <= 0) {
                    // خطأ أو نهاية الملف: أغلق وإزالة من `epoll`
                    if (n == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) continue;
                    close(fd);
                    epoll_ctl(epoll_fd, EPOLL_CTL_DEL, fd, NULL);
                } else {
                    // إعادة البيانات
                    write(fd, buf, n); // ملاحظة: في التطبيقات الحقيقية، قم بمعالجة الكتابة الجزئية
                }
            }
        }
    }

    close(epoll_fd);
    close(listen_fd);
    return 0;
}
```

### ملاحظات على المثال
- **مرفق الاستماع**: يتبع `EPOLLIN` لتحديد الإتصالات الجديدة.
- **مرفقات العملاء**: تتبع أيضًا `EPOLLIN` لتحديد البيانات الواردة.
- **تسوية**: يفترض أن `write` يكتمل بالكامل. في الإنتاج، قم بتخزين البيانات في الحافظة واستخدم `EPOLLOUT` للكتابة الجزئية.
- **معالجة الأخطاء**: يغلق المرفقات عند الأخطاء أو نهاية الملف وإزالةها من `epoll`.

---

## ملخص
يوفر `epoll` طريقة فعالة لتعامل مع عدة معالم ملفات في لينكس:
1. إنشاء مثيل باستخدام `epoll_create1`.
2. تسجيل معالم الملفات والفعاليات باستخدام `epoll_ctl`.
3. انتظار الفعاليات باستخدام `epoll_wait`.
4. معالجة الفعاليات في حلقة، تعديل الفعاليات التي يتم تتبعها أو إزالة المعالم حسب الحاجة.

للتطبيقات البسيطة، يُوصى باستخدام وضع تتبع المستوى. بالنسبة للاحتياجات عالية الأداء، فكر في استخدام وضع تتبع الحافة مع معالجة جميع البيانات المتاحة بعناية. دائمًا استخدم `epoll` مع إدخال/إخراج غير متزامن للحصول على أفضل النتائج.