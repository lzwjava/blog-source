---
audio: false
generated: true
lang: ar
layout: post
title: استخدام إيبول في لينكس
translated: true
type: note
---

`epoll` هو استدعاء نظام في Linux مصمم لمراقبة عدة واصفات ملفات بكفاءة للأحداث، مثل عندما تكون البيانات متاحة للقراءة أو عندما يكون المقبس جاهزًا للكتابة. وهو مفيد بشكل خاص في برمجة الشبكات، حيث قد يحتاج الخادم إلى التعامل مع العديد من الاتصالات في وقت واحد. مقارنة بآليات أقدم مثل `select` أو `poll`، فإن `epoll` يتوسع بشكل أفضل مع عدد كبير من واصفات الملفات لأنه يتجنب فحص جميع الواصفات بشكل متكرر لمعرفة جاهزيتها.

إليك دليلًا خطوة بخطوة لاستخدام `epoll` في Linux، يليه مثال بسيط لخادم يقبل الاتصالات ويرد البيانات مرة أخرى.

---

## خطوات استخدام `epoll`

### 1. **إنشاء مثيل Epoll**
للبدء في استخدام `epoll`، تحتاج إلى إنشاء مثيل epoll، والذي يتم تمثيله بواسطة واصف ملف. استخدم استدعاء النظام `epoll_create1`:

```c
int epoll_fd = epoll_create1(0);
```
- **المعامل**: مرّر `0` للاستخدام الأساسي (بدون أعلام خاصة). يمكن استخدام أعلام مثل `EPOLL_CLOEXEC` في السيناريوهات المتقدمة.
- **قيمة الإرجاع**: تُرجع واصف ملف (`epoll_fd`) في حالة النجاح، أو `-1` في حالة الخطأ (تحقق من `errno` للتفاصيل).

دالة `epoll_create` الأقدم مشابهة ولكنها تأخذ تلميحًا للحجم (يتم تجاهله الآن)، لذا يُفضل استخدام `epoll_create1`.

### 2. **إضافة واصفات الملفات للمراقبة**
استخدم `epoll_ctl` لتسجيل واصفات الملفات (مثل المقابس) مع مثيل epoll وتحديد الأحداث التي تريد مراقبتها:

```c
struct epoll_event ev;
ev.events = EPOLLIN;  // مراقبة إمكانية القراءة
ev.data.fd = some_fd; // واصف الملف للمراقبة
epoll_ctl(epoll_fd, EPOLL_CTL_ADD, some_fd, &ev);
```
- **المعاملات**:
  - `epoll_fd`: واصف الملف لمثيل epoll.
  - `EPOLL_CTL_ADD`: العملية لإضافة واصف ملف.
  - `some_fd`: واصف الملف المراد مراقبته (مثل مقبس).
  - `&ev`: مؤشر إلى `struct epoll_event` يحدد الأحداث وبيانات المستخدم الاختيارية.
- **الأحداث الشائعة**:
  - `EPOLLIN`: البيانات متاحة للقراءة.
  - `EPOLLOUT`: جاهز للكتابة.
  - `EPOLLERR`: حدث خطأ.
  - `EPOLLHUP`: انقطاع (مثل إغلاق الاتصال).
- **بيانات المستخدم**: يمكن لحقل `data` في `struct epoll_event` تخزين واصف ملف (كما هو موضح) أو بيانات أخرى (مثل مؤشر) لتحديد المصدر عند حدوث الأحداث.

### 3. **الانتظار للأحداث**
استخدم `epoll_wait` لحظر التنفيذ والانتظار لحدوث الأحداث على واصفات الملفات التي تتم مراقبتها:

```c
struct epoll_event events[MAX_EVENTS];
int nfds = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);
```
- **المعاملات**:
  - `epoll_fd`: مثيل epoll.
  - `events`: مصفوفة لتخزين الأحداث التي تم تشغيلها.
  - `MAX_EVENTS`: الحد الأقصى لعدد الأحداث المراد إرجاعها (حجم المصفوفة).
  - `-1`: المهلة بالمللي ثانية (`-1` تعني الانتظار إلى أجل غير مسمى؛ `0` ترجع فورًا).
- **قيمة الإرجاع**: عدد واصفات الملفات التي بها أحداث (`nfds`)، أو `-1` في حالة الخطأ.

### 4. **معالجة الأحداث**
كرر عبر الأحداث التي أرجعت بواسطة `epoll_wait` وقم بمعالجتها:

```c
for (int i = 0; i < nfds; i++) {
    if (events[i].events & EPOLLIN) {
        // واصف الملف events[i].data.fd قابل للقراءة
    }
}
```
- تحقق من الحقل `events` باستخدام العمليات البتية (مثل `events[i].events & EPOLLIN`) لتحديد نوع الحدث.
- استخدم `events[i].data.fd` لتحديد واصف الملف الذي أطلق الحدث.

### 5. **إدارة واصفات الملفات (اختياري)**
- **الإزالة**: استخدم `epoll_ctl` مع `EPOLL_CTL_DEL` لإيقاف مراقبة واصف ملف:
  ```c
  epoll_ctl(epoll_fd, EPOLL_CTL_DEL, some_fd, NULL);
  ```
- **التعديل**: اضبط الأحداث باستخدام `EPOLL_CTL_MOD`:
  ```c
  ev.events = EPOLLOUT; // التغيير لمراقبة إمكانية الكتابة
  epoll_ctl(epoll_fd, EPOLL_CTL_MOD, some_fd, &ev);
  ```

---

## المفاهيم الأساسية

### **المستوى المشغّل مقابل الحافة المشغّلة**
- **المستوى المشغّل (الافتراضي)**: يُعلم `epoll` بشكل متكرر طالما استمرت الحالة (مثل بقاء البيانات غير مقروءة). أبسط لمعظم الحالات.
- **الحافة المشغّلة (`EPOLLET`)**: يُعلم مرة واحدة فقط عندما تتغير الحالة (مثل وصول بيانات جديدة). يتطلب قراءة/كتابة جميع البيانات حتى `EAGAIN` لتجنب فقدان الأحداث؛ أكثر كفاءة ولكنه أكثر تعقيدًا.
- عيّن `EPOLLET` في `ev.events` (مثل `EPOLLIN | EPOLLET`) إذا كنت تستخدم وضع الحافة المشغّلة.

### **الإدخال/الإخراج غير الحاجز**
غالبًا ما يتم إقران `epoll` مع واصفات ملفات غير حاجزة لمنع حظر عمليات الإدخال/الإخراج. اضبط وضع المقبس ليكون غير حاجز باستخدام:

```c
fcntl(fd, F_SETFL, fcntl(fd, F_GETFL) | O_NONBLOCK);
```

---

## مثال: خادم صدى بسيط

أدناه مثال أساسي لخادم يستخدم `epoll` لقبول الاتصالات ورد البيانات مرة أخرى إلى العملاء. يستخدم وضع المستوى المشغّل للتبسيط.

```c
#include <sys/epoll.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>

#define MAX_EVENTS 10
#define PORT 8080

int main() {
    // إنشاء مقبس استماع
    int listen_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (listen_fd == -1) { perror("socket"); exit(1); }

    struct sockaddr_in addr = { .sin_family = AF_INET, .sin_addr.s_addr = INADDR_ANY, .sin_port = htons(PORT) };
    if (bind(listen_fd, (struct sockaddr*)&addr, sizeof(addr)) == -1) { perror("bind"); exit(1); }
    if (listen(listen_fd, 5) == -1) { perror("listen"); exit(1); }

    // ضبط مقبس الاستماع ليكون غير حاجز
    fcntl(listen_fd, F_SETFL, fcntl(listen_fd, F_GETFL) | O_NONBLOCK);

    // إنشاء مثيل epoll
    int epoll_fd = epoll_create1(0);
    if (epoll_fd == -1) { perror("epoll_create1"); exit(1); }

    // إضافة مقبس الاستماع إلى epoll
    struct epoll_event ev, events[MAX_EVENTS];
    ev.events = EPOLLIN; // مستوى مشغّل
    ev.data.fd = listen_fd;
    if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, listen_fd, &ev) == -1) { perror("epoll_ctl"); exit(1); }

    // حلقة الأحداث
    while (1) {
        int nfds = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);
        if (nfds == -1) { perror("epoll_wait"); exit(1); }

        for (int i = 0; i < nfds; i++) {
            int fd = events[i].data.fd;

            if (fd == listen_fd) {
                // قبول اتصال جديد
                int client_fd = accept(listen_fd, NULL, NULL);
                if (client_fd == -1) { perror("accept"); continue; }

                // ضبط مقبس العميل ليكون غير حاجز
                fcntl(client_fd, F_SETFL, fcntl(client_fd, F_GETFL) | O_NONBLOCK);

                // إضافة مقبس العميل إلى epoll
                ev.events = EPOLLIN;
                ev.data.fd = client_fd;
                if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, client_fd, &ev) == -1) {
                    perror("epoll_ctl: client_fd");
                    close(client_fd);
                }
            } else {
                // معالجة بيانات العميل
                char buf[1024];
                ssize_t n = read(fd, buf, sizeof(buf));
                if (n <= 0) {
                    // خطأ أو نهاية الملف: أغلق وأزل من epoll
                    if (n == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) continue;
                    close(fd);
                    epoll_ctl(epoll_fd, EPOLL_CTL_DEL, fd, NULL);
                } else {
                    // رد البيانات مرة أخرى
                    write(fd, buf, n); // ملاحظة: في التطبيقات الحقيقية، تعامل مع الكتابات الجزئية
                }
            }
        }
    }

    close(epoll_fd);
    close(listen_fd);
    return 0;
}
```

### ملاحظات على المثال
- **مقبس الاستماع**: يراقب `EPOLLIN` للكشف عن الاتصالات الجديدة.
- **مقابس العملاء**: تراقب أيضًا `EPOLLIN` للكشف عن البيانات الواردة.
- **التبسيط**: يفترض اكتمال `write` بالكامل. في الإنتاج، يجب تخزين البيانات مؤقتًا واستخدام `EPOLLOUT` للكتابات الجزئية.
- **معالجة الأخطاء**: يُغلق المقابس عند الأخطاء أو نهاية الملف ويزيلها من epoll.

---

## الملخص
يوفر `epoll` طريقة فعالة للتعامل مع عدة واصفات ملفات في Linux:
1. إنشاء مثيل باستخدام `epoll_create1`.
2. تسجيل واصفات الملفات والأحداث باستخدام `epoll_ctl`.
3. الانتظار للأحداث باستخدام `epoll_wait`.
4. معالجة الأحداث في حلقة، مع تعديل الأحداث التي تتم مراقبتها أو إزالة الواصفات حسب الحاجة.

للتطبيقات البسيطة، يُوصى بوضع المستوى المشغّل. للاحتياجات عالية الأداء، فكر في وضع الحافة المشغّلة مع التعامل الحذر مع جميع البيانات المتاحة. دائمًا قم بإقران `epoll` مع الإدخال/الإخراج غير الحاجز للحصول على أفضل النتائج.