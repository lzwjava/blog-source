---
audio: false
lang: ar
layout: post
title: لماذا Redis سريع
translated: true
---

### النقاط الرئيسية
- يبدو أن الفيديو "System Design: Why is single-threaded Redis so fast?" من ByteByteGo يشرح سرعة Redis بسبب التخزين في الذاكرة، و IO multiplexing، و الهياكل البيانات الفعالة.
- تشير الأبحاث إلى أن هذه العوامل تسمح لRedis بمعالجة حتى 100,000 استعلام في الثانية، على الرغم من أن معالجة الطلبات تكون متسلسلة.
- تشير الأدلة إلى أن أحدث إصدارات Redis قد أضافت التسلسلي للمهام المحددة، ولكن النواة تبقى متسلسلة.

---

### المقدمة
يستند هذا المقال إلى الفيديو "System Design: Why is single-threaded Redis so fast?" من ByteByteGo، وهو جزء من سلسلة تصميم النظام. Redis، المعروف بفعاليته العالية، يمكن أن يعالج حتى 100,000 استعلام في الثانية على جهاز واحد، وهو أمر مدهش بالنسبة لنظام متسلسلة. دعونا نكشف لماذا هذا ممكن وما يجعل Redis سريعًا.

### أسباب سرعة Redis
يمكن أن تُنسب سرعة Redis إلى عدة عوامل رئيسية، ربما تغطيها الفيديو:

- **التخزين في الذاكرة**: Redis يخزن البيانات في الذاكرة العشوائية، والتي أسرع بكثير من التخزين على القرص. وهذا يقلل من التأخير ويزيد من معدل المعالجة، حيث أن أوقات الوصول إلى الذاكرة في النانو ثانية مقارنة بالملي ثانية للوصول إلى القرص.

- **IO Multiplexing و التنفيذ المتسلسلة**: IO multiplexing، باستخدام آليات مثل epoll على Linux، يسمح لخط واحد بمعالجة عدة اتصالات عميل بشكل فعال. وهذا يبعد عن تكلفة تبديل السياق، ويجعل الحلقة المتسلسلة عملية بسيطة من خلال إزالة مشاكل التنسيق.

- **هياكل البيانات الفعالة**: Redis يستخدم هياكل بيانات مخصصة مثل الجداول الهاش (O(1) البحث)، القوائم المروحة، والقوائم المتسلسلة، والتي تزيد من الأداء من خلال تقليل استخدام الذاكرة وتسريع العمليات.

### التوسع والتطور
لزيادة التزامن، يمكن توسيع Redis أفقيًا باستخدام عدة نسخ أو تجمعات. تفاصيل غير متوقعة هي أن بينما تبقى معالجة الطلبات الأساسية متسلسلة، فقد أضافت أحدث الإصدارات (منذ 4.0) التسلسلي لمهام مثل حذف الكائنات في الخلفية، مما يزيد من الأداء دون تغيير النموذج الأساسي.

---

### ملاحظة الاستطلاع: تحليل شامل لسرعة Redis المتسلسلة

يقدم هذا القسم تحليلًا شاملًا لسرعة Redis المتسلسلة بناءً على الفيديو "System Design: Why is single-threaded Redis so fast?" من ByteByteGo و البحوث ذات الصلة. تم نشر الفيديو في 13 أغسطس 2022، وهو جزء من سلسلة موجهة إلى تصميم النظام، من قبل مصنعي كتب "System Design Interview" الأكثر مبيعًا. نظرًا لتركيز القناة، فمن المحتمل أن يوفر الفيديو رؤى مفصلة مناسبة للمقابلات الفنية و مناقشات تصميم النظام.

#### الخلفية والسياق
Redis، مخزن المفتاح القيمة المفتوح المصدر في الذاكرة، يستخدم على نطاق واسع كخادم، وسيط الرسائل، ومحرك التدفق. يدعم هياكل البيانات مثل الأسلاف، القوائم، المجموعات، الجداول الهاش، المجموعات المصفوفة، والبنية الاحتمالية مثل Bloom Filter و HyperLogLog. يشير عنوان الفيديو إلى استكشاف لماذا Redis يحافظ على الأداء العالي على الرغم من معالجة الطلبات المتسلسلة، وهو مركز في تصميمه.

من المقالات ذات الصلة، يمكن لRedis معالجة حتى 100,000 استعلام في الثانية (QPS) على جهاز واحد، وهو رقم يُذكر في قياسات الأداء. هذه السرعة مفاجئة بالنسبة للنموذج المتسلسلة، ولكن تشير البحوث إلى أن ذلك بسبب عدة خيارات معمارية.

#### العوامل الرئيسية التي تساهم في سرعة Redis

1. **التخزين في الذاكرة**
   Redis يخزن البيانات في الذاكرة العشوائية، والتي أسرع بحوالي 1000 مرة من الوصول العشوائي إلى القرص. وهذا يبعد عن تأخير I/O القرص، حيث أن أوقات الوصول إلى الذاكرة حوالي 100-120 نانوثانية مقارنة بـ 50-150 ميكرو ثانية لـ SSDs و 1-10 ميكرو ثانية لـ HDDs. من المحتمل أن يركز الفيديو على هذا باعتباره سببًا رئيسيًا، حيث يتوافق مع تركيز القناة على أساسيات تصميم النظام.

   | الجوانب               | التفاصيل                                      |
   |----------------------|----------------------------------------------|
   | وسائط التخزين       | RAM (في الذاكرة)                              |
   | وقت الوصول          | ~100-120 نانوثانية                        |
   | مقارنة بالقرص   | أسرع بـ 1000 مرة من الوصول العشوائي إلى القرص        |
   | تأثير على الأداء| يقلل من التأخير، يزيد من معدل المعالجة        |

2. **IO Multiplexing و الحلقة المتسلسلة التنفيذية**
   IO multiplexing يسمح لخط واحد بمراقبة عدة تدفقات I/O بشكل متزامن باستخدام مكالمة النظام مثل `select`، `poll`، `epoll` (Linux)، `kqueue` (Mac OS)، أو `evport` (Solaris). هذا هو مهم لمعالجة عدة اتصالات عميل دون حظر، نقطة من المحتمل أن يشرحها الفيديو. الحلقة المتسلسلة التنفيذية تبعد عن تكلفة تبديل السياق وتكلفة التنسيق، مما يجعل التطوير والتشخيص أسهل.

   | الآلية            | الوصف                                  |
   |----------------------|----------------------------------------------|
   | epoll/kqueue         | فعال للتوازي العالي، غير متوقف |
   | select/poll          | أقدم، أقل قابلية للتوسيع، O(n) تعقيد        |
   | التأثير               | يقلل من تكلفة الاتصال، يتيح التسلسل |

   ومع ذلك، يمكن أن تأخر الأوامر المتسلسلة مثل `BLPOP` أو `BRPOP` حركة المرور، وهو عيب محتمل يُذكر في المقالات ذات الصلة. من المحتمل أن يشرح الفيديو كيف يوازن هذا الاختيار التصميم بين البساطة والفعالية.

3. **هياكل البيانات الفعالة في المستوى الأدنى**
   Redis يستفيد من هياكل البيانات مثل الجداول الهاش للبحث O(1) عن المفتاح، القوائم المروحة للقوائم، والقوائم المتسلسلة للمجموعات المصفوفة. هذه هي مخصصة للعمليات في الذاكرة، تقليل استخدام الذاكرة وزيادة السرعة. من المحتمل أن يتضمن الفيديو رسومات أو أمثلة، مثل كيفية أن الجداول الهاش تتيح عمليات المفتاح القيمة السريعة، موضوع شائع في مقابلات تصميم النظام.

   | هيكل البيانات       | حالة الاستخدام                                     | تعقيد الوقت |
   |----------------------|----------------------------------------------|-----------------|
   | جدول هاش           | تخزين المفتاح القيمة                           | O(1) متوسط    |
   | قائمة مرتبة          | القوائم، فعالة في النهاية                    | O(1) للأطراف   |
   | قائمة متسلسلة            | المجموعات المصفوفة، التخزين المصفوف                | O(log n)        |

   هذه التخصيص هي حاسمة، حيث أن معظم عمليات Redis هي في الذاكرة، مع عوائق في الذاكرة أو الشبكة، وليس في وحدة المعالجة المركزية.

#### استعراضات إضافية والتطور
بينما تبقى معالجة الطلبات الأساسية متسلسلة، فقد أضافت أحدث إصدارات Redis التسلسلي لمهام محددة. منذ Redis 4.0، تم تنفيذ تحرير الذاكرة الآسي (lazy-free)، ومنذ 6.0، تم إضافة التسلسلي لتحليل البروتوكول تحت التزامن العالي. هذه التغييرات، من المحتمل أن يشرحها الفيديو، تزيد من الأداء دون تغيير النموذج المتسلسلة للعمليات الرئيسية.

لزيادة التزامن على جهاز واحد، يدعم Redis التجمعات وتشغيل عدة نسخ، استراتيجية من المحتمل أن يشرحها الفيديو لمعالجة احتياجات التزامن العالي. هذا هو جانب مهم لتصميم النظام، يتوافق مع تركيز القناة على الأنظمة الكبيرة.

#### عوائق محتملة والمقارنة
يحتوي النموذج المتسلسلة على مزايا مثل عدم وجود تنافس على القفل و تشخيص أسهل، ولكن يمكن أن يواجه تحديات مع العمليات المتسلسلة و عوائق الذاكرة/الشبكة تحت الحمل العالي. تشير المقالات ذات الصلة إلى أن للمهام التي تستهلك وحدة المعالجة المركزية، قد تكون قواعد البيانات المتسلسلة أكثر فعالية، ولكن بالنسبة لمهام Redis النموذجية، فإن التصميم المتسلسلة هو الأفضل.

#### الخاتمة
من المحتمل أن يغطي الفيديو "System Design: Why is single-threaded Redis so fast?" من ByteByteGo التخزين في الذاكرة، IO multiplexing، و الهياكل البيانات الفعالة كأسباب رئيسية لسرعة Redis. هذه العوامل تسمح له بمعالجة QPS العالي، مع أحدث الإصدارات التي تضيف التسلسلي لمهام تحسينات معينة. يوفر هذا التحليل فهمًا شاملًا، مناسبًا للطلاب الفنيين والمهنيين في تصميم النظام.

---

### الإشارات الرئيسية
- [Why is redis so fast blog post](https://blog.bytebytego.com/p/why-is-redis-so-fast)
- [Why is Redis So Fast Despite Being Single-Threaded article](https://medium.com/@aditimishra_541/why-is-redis-so-fast-despite-being-single-threaded-dc06ba33fc75)
- [Interview on Redis thread model article](https://medium.com/javarevisited/interview-why-is-redis-so-fast-even-though-it-is-single-threaded-bfe663dabe08)
- [Why is single threaded Redis so fast article](https://www.pixelstech.net/article/1677580861-Why-is-single-threaded-Redis-so-fast)