---
audio: false
generated: true
lang: ar
layout: post
title: لماذا ريديس سريع
translated: true
type: note
---

### النقاط الرئيسية
- يبدو من المحتمل أن مقطع فيديو اليوتيوب "System Design: Why is single-threaded Redis so fast?" من قناة ByteByteGo يوضح أن سرعة Redis تعود إلى التخزين في الذاكرة، وتعدد إدخال/إخراج (IO multiplexing)، وهياكل البيانات الفعالة.
- تشير الأبحاث إلى أن هذه العوامل تسمح لـ Redis بمعالجة ما يصل إلى 100,000 استعلام في الثانية، على الرغم من كونه أحادي الخيط لمعالجة الطلبات.
- تميل الأدلة إلى أن الإصدارات الحديثة من Redis أضافت تعدد الخيوط لمهام محددة، لكن النواة الأساسية تظل أحادية الخيط.

---

### المقدمة
هذه المدونة تستند إلى مقطع فيديو اليوتيوب "System Design: Why is single-threaded Redis so fast?" من قناة ByteByteGo، وهو جزء من سلسلة تصميم الأنظمة الخاصة بهم. يشتهر Redis بأدائه العالي، حيث يمكنه معالجة ما يصل إلى 100,000 استعلام في الثانية على جهاز واحد، وهو أمر مذهل لنظام أحادي الخيط. دعنا نستكشف سبب إمكانية ذلك وما الذي يجعل Redis سريعًا إلى هذا الحد.

### أسباب سرعة Redis
يمكن إرجاع سرعة Redis إلى عدة عوامل رئيسية، من المحتمل أن يغطيها الفيديو:

- **التخزين في الذاكرة (In-Memory Storage)**: يخزن Redis البيانات في ذاكرة الوصول العشوائي (RAM)، وهي أسرع بكثير من التخزين على القرص. هذا يقلل من زمن الوصول ويزيد من الإنتاجية، حيث أن أوقات الوصول إلى الذاكرة تقاس بالنانوثانية مقارنة بالمللي ثانية للوصول إلى القرص.

- **تعدد إدخال/إخراج (IO Multiplexing) والتنفيذ أحادي الخيط**: يسمح تعدد إدخال/إخراج، باستخدام آليات مثل epoll على لينكس، لخيط واحد بإدارة اتصالات متعددة من العملاء بكفاءة. هذا يتجنب عبء تبديل السياق (context switching)، كما أن الحلقة أحادية الخيط تبسط العمليات من خلال إزالة مشاكل المزامنة (synchronization).

- **هياكل البيانات الفعالة (Efficient Data Structures)**: يستخدم Redis هياكل بيانات مُحسنة مثل جداول التجزئة (O(1) للبحث)، والقوائم المرتبطة، والقوائم القافزة (skip lists)، مما يعزز الأداء عن طريق تقليل استخدام الذاكرة وتسريع العمليات.

### التوسع والتطور
للتعامل مع الازدحام العالي (high concurrency)، يمكن توسيع نطاق Redis أفقيًا باستخدام عدة نسخ أو عن طريق التجميع (clustering). من التفاصيل غير المتوقعة أنه بينما تظل معالجة الطلبات الأساسية أحادية الخيط، فإن الإصدارات الحديثة (منذ الإصدار 4.0) أدخلت تعدد الخيوط لمهام مثل حذف الكائنات في الخلفية، مما يحسن الأداء further دون تغيير النموذج الأساسي.

---

### ملاحظة استقصائية: تحليل مفصل لأداء Redis أحادي الخيط

يقدم هذا القسم تحليلاً شاملاً لسبب كون Redis أحادي الخيط سريعًا جدًا، بناءً على مقطع فيديو اليوتيوب "System Design: Why is single-threaded Redis so fast?" من قناة ByteByteGo والأبحاث ذات الصلة. الفيديو، الذي نُشر في 13 أغسطس 2022، هو جزء من سلسلة تركز على تصميم الأنظمة، من تأليف مبتكري كتب System Design Interview الأكثر مبيعًا. نظرًا لتركيز القناة، من المحتمل أن يقدم الفيديو رؤى مفصلة مناسبة للمقابلات التقنية ومناقشات تصميم الأنظمة.

#### الخلفية والسياق
Redis، وهو مخزن مفتوح المصدر من نوع مفتاح-قيمة في الذاكرة، يُستخدم على نطاق واسع كذاكرة تخزين مؤقت (cache)، ووسيط رسائل (message broker)، ومحرك بث (streaming engine). وهو يدعم هياكل البيانات مثل السلاسل النصية (strings)، والقوائم (lists)، والمجموعات (sets)، والتجزئات (hashes)، والمجموعات المرتبة (sorted sets)، وهياكل احتمالية مثل مرشح بلوم (Bloom Filter) و HyperLogLog. يشير عنوان الفيديو إلى استكشاف سبب الحفاظ على Redis لأداء عالٍ على الرغم من معالجة الطلبات أحادية الخيط، وهو أمر أساسي في تصميمه.

من المقالات ذات الصلة، يمكن لـ Redis معالجة ما يصل إلى 100,000 استعلام في الثانية (QPS) على جهاز واحد، وهو رقم غالبًا ما يُستشهد به في معايير قياس الأداء. هذه السرعة مفاجئة بالنظر إلى النموذج أحادي الخيط، لكن الأبحاث تشير إلى أنها ناتجة عن عدة خيارات معمارية.

#### العوامل الرئيسية المساهمة في سرعة Redis

1. **التخزين في الذاكرة (In-Memory Storage)**
   يخزن Redis البيانات في ذاكرة الوصول العشوائي (RAM)، وهي أسرع ب 1000 مرة على الأقل من الوصول العشوائي إلى القرص. هذا يلغي زمن الوصول لعمليات إدخال/إخراج القرص (disk I/O)، حيث تصل أوقات الوصول إلى ذاكرة RAM إلى حوالي 100-120 نانوثانية مقارنة بـ 50-150 ميكروثانية لأقراص الحالة الثابتة (SSDs) و 1-10 مللي ثانية لأقراص الحالة الصلبة (HDDs). من المحتمل أن يركز الفيديو على هذا كسبب رئيسي، حيث أنه يتوافق مع تركيز القناة على أساسيات تصميم الأنظمة.

   | الجانب                | التفاصيل                                     |
   |----------------------|----------------------------------------------|
   | وسيط التخزين         | ذاكرة الوصول العشوائي (RAM)                  |
   | زمن الوصول           | ~100-120 نانوثانية                          |
   | المقارنة مع القرص    | أسرع ب 1000 مرة من الوصول العشوائي للقرص     |
   | التأثير على الأداء   | يقلل زمن الوصول، يزيد الإنتاجية              |

2. **تعدد إدخال/إخراج (IO Multiplexing) وحلقة التنفيذ أحادية الخيط**
   يسمح تعدد إدخال/إخراج لخيط واحد بمراقبة تدفقات متعددة للإدخال/الإخراج في وقت واحد باستخدام استدعاءات نظام مثل `select`، `poll`، `epoll` (لينكس)، `kqueue` (ماك أو إس)، أو `evport` (سولاريس). هذا أمر بالغ الأهمية لإدارة اتصالات متعددة من العملاء دون حظر (blocking)، وهي نقطة من المحتمل أن يتم تفصيلها في الفيديو. تتجنب حلقة التنفيذ أحادية الخيط عبء تبديل السياق (context switching) والمزامنة (synchronization)، مما يبسط عملية التطوير والتصحيح.

   | الآلية                | الوصف                                       |
   |----------------------|----------------------------------------------|
   | epoll/kqueue         | فعال في حالات الازدحام العالي، غير محظور (non-blocking) |
   | select/poll          | أقدم، قابلية توسع أقل، تعقيد O(n)           |
   | التأثير              | يقلل من عبء الاتصال، يمكّن من pipelining     |

   ومع ذلك، يمكن للأوامر التي تحظر العميل (client-blocking commands) مثل `BLPOP` أو `BRPOP` أن تؤخر حركة المرور، وهو عيب محتمل ذُكر في المقالات ذات الصلة. قد يناقش الفيديو كيف يوازن هذا الخيار التصميمي بين البساطة والأداء.

3. **هياكل البيانات الفعالة على المستوى الأدنى (Efficient Lower-Level Data Structures)**
   يستفيد Redis من هياكل البيانات مثل جداول التجزئة (hash tables) للبحث عن المفاتيح بسرعة O(1)، والقوائم المرتبطة (linked lists) للقوائم، والقوائم القافزة (skip lists) للمجموعات المرتبة (sorted sets). هذه الهياكل مُحسنة للعمليات في الذاكرة، مما يقلل من استخدام الذاكرة ويعظم السرعة. من المحتمل أن يتضمن الفيديو مخططات أو أمثلة، مثل كيف تمكن جداول التجزئة عمليات المفتاح-قيمة السريعة، وهو موضوع شائع في مقابلات تصميم الأنظمة.

   | هيكل البيانات        | حالة الاستخدام                                | التعقيد الزمني |
   |----------------------|----------------------------------------------|-----------------|
   | جدول التجزئة (Hash Table) | تخزين مفتاح-قيمة                            | O(1) متوسط      |
   | القائمة المرتبطة (Linked List) | القوائم، فعالة عند الأطراف               | O(1) للأطراف    |
   | القائمة القافزة (Skip List) | المجموعات المرتبة، التخزين المرتب           | O(log n)        |

   هذا التحسين أمر بالغ الأهمية، حيث أن معظم عمليات Redis تعتمد على الذاكرة، وعنق الزجاجة يكون عادةً في الذاكرة أو الشبكة، وليس في وحدة المعالجة المركزية (CPU).

#### اعتبارات إضافية والتطور
بينما تظل معالجة الطلبات الأساسية أحادية الخيط، فإن الإصدارات الحديثة من Redis قد أدخلت تعدد الخيوط لمهام محددة. منذ Redis 4.0، تم تنفيذ تحرير الذاكرة غير المتزامن (lazy-free)، ومنذ الإصدار 6.0، تمت إضافة تعدد الخيوط لتحليل البروتوكول (protocol parsing) تحت الازدحام العالي. هذه التغييرات، التي من المحتمل أن يُشار إليها في الفيديو، تعزز الأداء دون تغيير النموذج أحادي الخيط للعمليات الرئيسية.

للتوسع beyond نسخة واحدة، يدعم Redis التجميع (clustering) وتشغيل عدة نسخ، وهي إستراتيجية قد يتم مناقشتها لمعالجة احتياجات الازدحام العالي. هذا جانب مهم لتصميم الأنظمة، يتوافق مع تركيز القناة على الأنظمة واسعة النطاق.

#### العيوب المحتملة والمقارنات
يتمتع النموذج أحادي الخيط بمزايا مثل عدم وجود تنافس على القفل (lock contention) وتصحيح الأخطاء الأبسط، ولكنه قد يواجه تحديات مع العمليات الحاجبة (blocking operations) واختناقات الذاكرة/الشبكة تحت الحمل العالي. تقترح المقالات ذات الصلة أنه بالنسبة للمهام المكثفة لوحدة المعالجة المركزية (CPU-intensive)، قد تؤدي قواعد البيانات متعددة الخيوط أداءً أفضل، ولكن لحالات الاستخدام النموذجية لـ Redis، فإن التصميم أحادي الخيط هو الأمثل.

#### الخلاصة
من المحتمل أن يغطي الفيديو "System Design: Why is single-threaded Redis so fast?" من قناة ByteByteGo التخزين في الذاكرة، وتعدد إدخال/إخراج، وهياكل البيانات الفعالة كأسباب رئيسية لسرعة Redis. هذه العوامل تمكنه من التعامل مع معدل استعلامات في الثانية مرتفع (QPS)، مع إضافة الإصدارات الحديثة تعدد الخيوط لتحسينات محددة. يوفر هذا التحليل فهمًا شاملاً، مناسبًا لكل من المتعلمين التقنيين ومحترفي تصميم الأنظمة.

---

### الاقتباسات الرئيسية
- [Why is redis so fast blog post](https://blog.bytebytego.com/p/why-is-redis-so-fast)
- [Why is Redis So Fast Despite Being Single-Threaded article](https://medium.com/@aditimishra_541/why-is-redis-so-fast-despite-being-single-threaded-dc06ba33fc75)
- [Interview on Redis thread model article](https://medium.com/javarevisited/interview-why-is-redis-so-fast-even-though-it-is-single-threaded-bfe663dabe08)
- [Why is single threaded Redis so fast article](https://www.pixelstech.net/article/1677580861-Why-is-single-threaded-Redis-so-fast)