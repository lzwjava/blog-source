---
audio: false
generated: true
lang: ar
layout: post
title: أوامر جيت المتقدمة
translated: true
type: note
---

Git يشبه سكين الجيش السويسري للمطورين - متعدد الاستخدامات، قوي، ومربك أحيانًا إذا كنت لا تعرف أي أداة تستخدم. اليوم، سنتعمق في بعض ميزات Git وسير العمل الأكثر براعة: انتقاء التغييرات بشكل انتقائي، الدمج بأساليب مختلفة، إعادة الأساس للحصول على تاريخ أنظف، حذف تلك الملفات الكبيرة المزعجة التي قمت بإضافتها عن طريق الخطأ، وتراجع عن commit عندما تدرك أنك ارتكبت خطأ. دعونا نشرحها.

#### الانتقال الانتقائي (Cherry-Picking): أخذ ما تحتاجه فقط
تخيل أن لديك فرع ميزة (feature branch) به عشرات الـ commits، ولكن هناك commit واحد لامع تريد انتزاعه وتطبيقه على فرعك الرئيسي (main) - دون جلب البقية. هذا هو المكان الذي يأتي فيه `git cherry-pick` للعبور.

الأمر بسيط للغاية: ابحث عن الـ commit hash (يمكنك الحصول عليه من `git log`)، انتقل إلى الفرع الذي تريد إضافته إليه، وقم بتشغيل:
```
git cherry-pick <commit-hash>
```
هاهو! أصبح هذا الـ commit الآن جزءًا من فرعك الحالي. إذا كان هناك تعارض، سيتوقف Git ويسمح لك بحله، تمامًا مثل الدمج. بمجرد أن تكون راضيًا، قم بعمل commit للتغييرات، وستكون جاهزًا.

أستخدم هذا دائمًا عندما يتسلل إصلاح خطأ إلى فرع ميزة فوضوي، وأحتاجه في فرع `main` في أسرع وقت ممكن. فقط كن حذرًا - يؤدي Cherry-pick إلى تكرار الـ commit، لذا يحصل على hash جديد. لا تتوقع أن يعمل بشكل جيد إذا قمت بدمج الفرع الأصلي لاحقًا دون بعض التنظيف.

#### خيارات الدمج: أكثر من مجرد "دمج"
الدمج هو أساس Git، ولكن هل تعلم أنه يأتي بنكهات؟ الإعداد الافتراضي `git merge` يقوم بـ "fast-forward" إذا أمكن (لتصحيح التاريخ) أو ينشئ commit دمج إذا تباعدت الفروع. ولكن لديك خيارات:

- **`--no-ff` (بدون تقدم سريع)**: يجبر على إنشاء commit دمج حتى لو كان التقدم السريع ممكنًا. أحب هذا للحفاظ على سجل واضح لموعد دمج فرع ميزة في `main`. قم بتشغيله كالتالي:
  ```
  git merge --no-ff feature-branch
  ```
- **`--squash`**: يسحب جميع التغييرات من الفرع إلى commit واحد في فرعك الحالي. لا يوجد commit دمج، مجرد حزمة واحدة مرتبة. مثالي لضغط فرع فوضوي في شيء يمكن تقديمه:
  ```
  git merge --squash feature-branch
  ```
  بعد هذا، ستحتاج إلى عمل commit يدويًا لإتمام الصفقة.

كل خيار له مكانه. أميل نحو `--no-ff` للفروع طويلة الأمد و `--squash` عندما يكون لدي فرع مليء بـ commits "تحت العمل" أود نسيانها.

#### إعادة الأساس (Rebasing): إعادة كتابة التاريخ مثل المحترفين
إذا كان الدمج يبدو مليئًا بالفوضى، فقد يكون `git rebase` هو الخيار المناسب لك. يأخذ commits الخاصة بك ويعيد تشغيلها على فرع آخر، مما يمنحك تاريخًا خطيًا يبدو وكأنك خططت لكل شيء بشكل مثالي من البداية.

انتقل إلى فرع الميزة الخاص بك وقم بتشغيل:
```
git rebase main
```
سيرفع Git commits الخاصة بك، ويقوم بتحديث الفرع ليطابق `main`، ثم يعيد تطبيق تغييراتك في الأعلى. إذا ظهرت تعارضات، قم بحلها، ثم `git rebase --continue` حتى الانتهاء.

الإيجابيات؟ خط زمني نظيف. السلبيات؟ إذا كنت قد دفعت (push) ذلك الفرع بالفعل ويعمل عليه الآخرون، فإن إعادة الأساس تعيد كتابة التاريخ - ما يسبب رسائل غاضبة من زملاء الفريق. ألتزم بإعادة الأساس للفروع المحلية أو المشاريع الفردية. للأشياء المشتركة، الدمج أكثر أمانًا.

#### حذف الملفات الكبيرة من التاريخ: لقد أضفت ملف فيديو 2 جيجابايت عن طريق الخطأ
كلنا مررنا بذلك: قمت بإضافة ملف ضخم عن طريق الخطأ، ثم دفعت التغييرات، والآن أصبح مستودعك منتفخًا. Git لا ينسى بسهولة، ولكن يمكنك مسح هذا الملف من التاريخ ببعض الجهد.

الأداة الأساسية هنا هي `git filter-branch` أو الأحدث `git filter-repo` (أوصي بالأخيرة - إنها أسرع وأقل عرضة للأخطاء). لنقل أنك أضفت `bigfile.zip` وتحتاج إلى إزالته:
1. قم بتثبيت `git-filter-repo` (تحقق من وثائقه للإعداد).
2. قم بتشغيل:
   ```
   git filter-repo --path bigfile.zip --invert-paths
   ```
   هذا يزيل `bigfile.zip` من كل commit في التاريخ.
3. قم بدفع التاريخ المعاد كتابته قسرًا:
   ```
   git push --force
   ```

تنبيه: هذا يعيد كتابة التاريخ، لذا قم بالتنسيق مع فريقك. وإذا كان موجودًا في طلب دمج (pull request) في مكان ما، قد تحتاج إلى تنظيف المراجع (refs) أيضًا. بمجرد إزالته، سينكمش مستودعك بعد عملية جمع البيانات المهملة (`git gc`).

#### التراجع عن الـ Commit: إعادة ضبط الوقت
قمت بعمل commit وندمت على الفور؟ Git يدعمك. هناك طريقتان للتراجع عنه، اعتمادًا على المدى الذي وصلت إليه:

- **إذا لم تقم بدفع التغييرات بعد**: استخدم `git reset`. للتراجع عن آخر commit ولكن مع الاحتفاظ بالتغييرات في دليل العمل الخاص بك:
  ```
  git reset HEAD^ --soft
  ```
  هل تريد التخلي عن التغييرات تمامًا؟
  ```
  git reset HEAD^ --hard
  ```
- **إذا كنت قد دفعت التغييرات بالفعل**: ستحتاج إلى إعادة كتابة التاريخ. قم بالتراجع محليًا باستخدام `git reset HEAD^`، ثم قم بالدفع القسري:
  ```
  git push --force
  ```
  مرة أخرى، هذا يتلاعب بالتاريخ المشترك، لذا تحرك بحذر.

لقد أنقذت نفسي باستخدام `git reset --soft` مرات لا يمكن عدها - مثالية عندما أقوم بعمل commit مبكرًا جدًا وأحتاج إلى تعديل شيء ما.

#### ختاماً

مرونة Git هي ما تجعله قويًا جدًا، ولكن من السهل أن تتشابك إذا كنت لا تعرف خياراتك. استخدم Cherry-pick للدقة الجراحية، وعدل عمليات الدمج لتناسب سير العمل الخاص بك، واستخدم rebase للحصول على تاريخ مصقول، ولا تفزع عندما تحتاج إلى محو خطأ - سواء كان ملفًا ضخمًا أو commit متسرع. جرب هذه الأشياء على مستودع اختبار إذا كنت متوترًا، وسرعان ما ستصبح طبيعة ثانية.

ما هي حيلة Git المفضلة لديك؟ دعني أعرف - أنا دائمًا مستعد لتعلم شيء جديد!