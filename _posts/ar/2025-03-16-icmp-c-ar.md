---
audio: false
generated: true
lang: ar
layout: post
title: برنامج الإرسال المتتابع لبروتوكول رسائل التحكم في الإنترنت بلغة سي
translated: true
type: note
---

بروتوكول ICMP (Internet Control Message Protocol) هو بروتوكول في طبقة الشبكة يُستخدم لأغراض التشخيص والإبلاغ عن الأخطاء في شبكات IP. يشتهر استخدامه بشكل كبير في أداة `ping` لاختبار الاتصال بين المضيفين. يتم تجميع رسائل ICMP مباشرة في حزم IP (بدون طبقة TCP أو UDP) وتتكون من نوع ورمز ومجموع تحقق وحمولة. بالنسبة لـ `ping`، تعتبر رسائل "طلب الصدى" (النوع 8) و"رد الصدى" (النوع 0) هي الأساس.

إليك كيفية عمل ICMP على مستوى عالٍ:
1. يرسل المرسل (مثل جهازك) طلب صدى ICMP إلى عنوان IP الهدف.
2. الهدف، إذا كان يمكن الوصول إليه ومُهيأ للرد، يرسل رد صدى ICMP مرة أخرى.
3. يقيس المرسل زمن الذهاب والإياب (RTT) بناءً على وقت وصول الرد.

لتنفيذ برنامج يشبه `ping` بلغة C دون استخدام مكتبات مثل `libpcap` أو `libnet`، سنستخدم المقابس الأولية (`SOCK_RAW`) لإنشاء وإرسال حزم ICMP مباشرة. هذا يتطلب صلاحيات الجذر (مثل `sudo`) لأن المقابس الأولية تتجاوز التجريدات عالية المستوى.

فيما يلي برنامج C مبسط يرسل طلبات صدى ICMP وينصت لردود الصدى، محاكياً الوظيفة الأساسية لـ `ping`.

---

### برنامج Ping باستخدام ICMP بلغة C

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>
#include <time.h>
#include <errno.h>

// حساب مجموع التحقق لـ ICMP
unsigned short checksum(void *b, int len) {
    unsigned short *buf = b;
    unsigned int sum = 0;
    unsigned short result;

    for (sum = 0; len > 1; len -= 2) {
        sum += *buf++;
    }
    if (len == 1) {
        sum += *(unsigned char *)buf;
    }
    sum = (sum >> 16) + (sum & 0xFFFF);
    sum += (sum >> 16);
    result = ~sum;
    return result;
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: %s <destination_ip>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    int sock_fd;
    struct sockaddr_in dest_addr;
    char packet[64];  // رأس ICMP + بعض البيانات
    struct icmphdr *icmp;
    char recv_buffer[1024];
    struct timespec start, end;

    // إنشاء مقبس أولي لـ ICMP
    sock_fd = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);
    if (sock_fd < 0) {
        perror("فشل إنشاء المقبس (قم بالتشغيل كجذر؟)");
        exit(EXIT_FAILURE);
    }

    // إعداد عنوان الوجهة
    dest_addr.sin_family = AF_INET;
    if (inet_pton(AF_INET, argv[1], &dest_addr.sin_addr) <= 0) {
        perror("عنوان IP غير صالح");
        close(sock_fd);
        exit(EXIT_FAILURE);
    }

    // تحضير حزمة طلب صدى ICMP
    memset(packet, 0, sizeof(packet));
    icmp = (struct icmphdr *)packet;
    icmp->type = ICMP_ECHO;        // النوع 8: طلب صدى
    icmp->code = 0;
    icmp->un.echo.id = getpid();   // استخدام معرّف العملية كمعرف
    icmp->un.echo.sequence = 1;    // رقم التسلسل
    for (int i = sizeof(*icmp); i < 64; i++) {
        packet[i] = i;             // ملء الحمولة ببيانات وهمية
    }
    icmp->checksum = 0;            // حساب مجموع التحقق بعد ملء الحزمة
    icmp->checksum = checksum(packet, 64);

    printf("جاري إرسال طلبات ping إلى %s...\n", argv[1]);

    for (int i = 0; i < 4; i++) { // إرسال 4 طلبات ping
        // تسجيل وقت الإرسال
        clock_gettime(CLOCK_MONOTONIC, &start);

        // إرسال طلب صدى ICMP
        if (sendto(sock_fd, packet, 64, 0, (struct sockaddr *)&dest_addr, sizeof(dest_addr)) < 0) {
            perror("فشل الإرسال");
            close(sock_fd);
            exit(EXIT_FAILURE);
        }

        // استقبال رد صدى ICMP
        struct sockaddr_in from_addr;
        socklen_t from_len = sizeof(from_addr);
        int bytes_received = recvfrom(sock_fd, recv_buffer, sizeof(recv_buffer), 0,
                                      (struct sockaddr *)&from_addr, &from_len);
        if (bytes_received < 0) {
            perror("فشل الاستقبال");
            continue;
        }

        // تسجيل وقت الاستقبال
        clock_gettime(CLOCK_MONOTONIC, &end);

        // تحليل رؤوس IP و ICMP المستلمة
        struct iphdr *ip = (struct iphdr *)recv_buffer;
        struct icmphdr *icmp_reply = (struct icmphdr *)(recv_buffer + (ip->ihl * 4));
        if (icmp_reply->type == ICMP_ECHOREPLY && icmp_reply->un.echo.id == getpid()) {
            double rtt = (end.tv_sec - start.tv_sec) * 1000.0 +
                         (end.tv_nsec - start.tv_nsec) / 1000000.0;
            printf("%d bytes من %s: seq=%d time=%.2f ms\n",
                   bytes_received - (ip->ihl * 4), argv[1], icmp_reply->un.echo.sequence, rtt);
        } else {
            printf("استجابة ICMP غير متوقعة: type=%d\n", icmp_reply->type);
        }

        sleep(1); // الانتظار ثانية واحدة بين طلبات ping
        icmp->un.echo.sequence++; // زيادة رقم التسلسل
        icmp->checksum = 0;
        icmp->checksum = checksum(packet, 64); // إعادة حساب مجموع التحقق
    }

    close(sock_fd);
    return 0;
}
```

---

### آلية العمل

1. **إنشاء المقبس**:
   - `socket(AF_INET, SOCK_RAW, IPPROTO_ICMP)` ينشئ مقبساً أولياً لـ ICMP. هذا يسمح لنا بإنشاء حزم ICMP يدوياً.

2. **بناء حزمة ICMP**:
   - يتم ملء رأس ICMP (`struct icmphdr`) بـ:
     - `type = ICMP_ECHO` (8) لطلب الصدى.
     - `code = 0`.
     - `id` تم تعيينه إلى معرّف العملية لتحديد طلبات ping الخاصة بنا.
     - `sequence` لتتبع الطلبات الفردية.
   - تتم إضافة حمولة (بيانات وهمية)، ثم يتم حساب مجموع التحقق للحزمة بأكملها.

3. **الإرسال**:
   - `sendto()` يرسل الحزمة إلى عنوان IP الوجهة. لا حاجة لمنفذ (port) لأن ICMP يعمل أسفل طبقة النقل.

4. **الاستقبال**:
   - `recvfrom()` يلتقط حزمة IP الأولية التي تحتوي على رد صدى ICMP.
   - نتخطى رأس IP (`ihl * 4` بايت) للوصول إلى رأس ICMP.
   - نتحقق مما إذا كان رد صدى (النوع 0) ومطابقاً لـ `id` الخاص بنا.

5. **توقيت**:
   - `clock_gettime()` يقيس زمن الذهاب والإياب (RTT) بالمللي ثانية.

6. **مجموع التحقق**:
   - دالة `checksum()` تحسب المجموع المكمل إلى واحد (one's complement) بعرض 16 بت، كما هو مطلوب في ICMP.

---

### الترجمة والاستخدام
- الترجمة: `gcc ping.c -o ping`
- التشغيل (كجذر): `sudo ./ping 8.8.8.8`
- مثال على الناتج:
  ```
  جاري إرسال طلبات ping إلى 8.8.8.8...
  64 bytes من 8.8.8.8: seq=1 time=12.34 ms
  64 bytes من 8.8.8.8: seq=2 time=11.89 ms
  ...
  ```

---

### ملاحظات
- **صلاحيات الجذر**: المقابس الأولية تتطلب `sudo` لأنها تتعامل مع حزم الشبكة مباشرة.
- **جدار الحماية**: يجب أن يستجيب الهدف لطلبات صدى ICMP (بعض المضيفين يحظرها).
- **تبسيط**: هذه النسخة لا تتعامل مع جميع الحالات الطرفية (مثل انتهاء المهلة، فقدان الحزمة بالكامل، أو خيارات IP).

هذا هو أدنى مستوى يمكنك الوصول إليه في فضاء المستخدم مع ICMP. دون هذا، ستحتاج إلى كود على مستوى النواة للتفاعل مع مكدس IP مباشرة. دعني أعلم إذا كنت تريد تعديله أكثر!