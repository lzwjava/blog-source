---
audio: false
generated: true
lang: ar
layout: post
title: سطر أوامر رست مع ربط الشل
translated: true
type: note
---

أنت تتطرق إلى رغبة شائعة لدى المطورين ذوي الخبرة القادمين من لغات مثل Python أو Ruby أو JavaScript، حيث غالبًا ما يكون لديك أمر واحد لتنفيذ النص البرمجي مباشرة. لغة Rust، كونها لغة مُترجمة (compiled)، لديها سير عمل مختلف قليلاً بشكل افتراضي.

ومع ذلك، يمكنك بالتأكيد تحقيق شعور "السطر الواحد"، خاصة للنصوص البرمجية البسيطة أو التمارين، من خلال ربط الأوامر في طرفيتك (shell).

### طريقة "السطر الواحد" المباشرة (ربط أوامر الطرفية)

أنت تملك بالفعل المكونات: `rustc` للترجمة و `./` للتنفيذ. يمكنك دمجهما باستخدام مشغلات الطرفية:

```bash
rustc scripts/rust/example.rs -o test/example && ./test/example
```

**الشرح:**

*   `rustc scripts/rust/example.rs -o test/example`: يترجم هذا الأمر ملف Rust الخاص بك ويضع الملف التنفيذي في `test/example`.
*   `&&`: هذا هو **فاصل أمر شرطي** في bash (ومعظم أوامر الطرفية الشبيهة بـ Unix). الأمر الذي يلي `&&` سينفذ *فقط* إذا اكتمل الأمر الذي يسبق `&&` بنجاح (أي يعيد رمز خروج 0).
    *   إذا قام `rustc` بالترجمة دون أخطاء، سيعيد القيمة 0، وبعدها سينفذ `./test/example`.
    *   إذا واجه `rustc` خطأ في الترجمة، سيعيد رمز خروج غير صفري، ولن *يتم* تنفيذ `./test/example`. هذا تصرف جيد\!

### للحصول على تجربة أكثر "شبهاً بالنص البرمجي" (Cargo)

بينما تعمل طريقة `&&` المذكورة أعلاه بشكل جيد للاختبارات السريعة، فإن استخدام أداة `cargo` في Rust هو الطريقة الموصى بها لأي شيء يتجاوز النصوص البرمجية ذات الملف الواحد البسيطة، وهي توفر *فعلاً* أمرًا واحدًا يشبه Python لتشغيل الكود داخل مشروع:

1.  **تهيئة مشروع Cargo (إذا لم تقم بذلك بالفعل):**
    إذا كان `scripts/rust/example.rs` مجرد ملف منفرد، فعادةً ما تبدأ بإنشاء مشروع Cargo في الدليل الأصلي له (أو في دليل جديد مخصص).

    ```bash
    # انتقل إلى الدليل حيث تريد مشروعك (مثلًا، scripts/rust)
    cd scripts/rust

    # قم بتهيئة مشروع Cargo ثنائي جديد
    cargo init --bin .
    ```

    سيؤدي هذا إلى إنشاء `Cargo.toml` ونقل `example.rs` الخاص بك (إذا كان `main.rs`) أو ضبط `Cargo.toml` للإشارة إليه (إذا قمت بإعادة تسمية `example.rs` إلى `main.rs` داخل `src/`).

2.  **التشغيل باستخدام Cargo:**
    بمجرد إعداد مشروع Cargo، يمكنك الترجمة والتشغيل بأمر واحد:

    ```bash
    # من جذر مشروعك (مثلًا، scripts/rust إذا قمت بتشغيل cargo init هناك)
    cargo run
    ```

    سيقوم `cargo run` بما يلي:

    * ترجمة الكود الخاص بك (إذا لم يكن قد تمت ترجمته أو إذا أجريت تغييرات عليه).
    * ثم، تنفيذ الملف الثنائي الناتج.
    * بشكل افتراضي، يتم وضع الملف الثنائي في `target/debug/` داخل مشروعك، لكنك لست مضطرًا للقلق بشأن مساره المحدد.

**لماذا يُفضل استخدام Cargo:**

*   **إدارة التبعيات:** إذا احتاج كودك إلى مكتبات خارجية (crates)، فإن Cargo يتعامل مع جلبها وترجمتها وربطها تلقائيًا. يمكنك تحديدها في `Cargo.toml`.
*   **هيكل المشروع القياسي:** يشجع على تخطيط متناسق (`src/main.rs`، `Cargo.toml`)، مما يجعل كودك أسهل للفهم من قبل الآخرين (ومنك أنت في المستقبل).
*   **الاختبار:** `cargo test` يشغّل اختبارات الوحدة والاختبارات التكاملية.
*   **بناء إصدار التوزيع:** `cargo run --release` (أو `cargo build --release`) يترجم مع تحسينات الأداء لبيئة الإنتاج.
*   **لا حاجة للتنظيف اليدوي:** لا يتعين عليك حذف الملفات الثنائية المترجمة يدويًا. `cargo clean` يتكفل بذلك.

### ماذا عن نهج "البرمجة النصية" الحقيقي مثل `python script.py` في Python؟

لم يتم تصميم Rust كلغة برمجة نصية مفسرة (interpreted scripting language). إنها لغة أنظمة مُترجمة. لذلك، لن تحصل على أمر مباشر مثل `rust script.rs` يقوم بالترجمة والتشغيل دون خطوة ترجمة صريحة.

ومع ذلك، هناك أدوات مجتمعية تحاول سد هذه الفجوة للنصوص البرمجية "السريعة" ذات الملف الواحد في Rust (على الرغم من أنها لا تزال تترجم في الخلفية):

*   **`cargo-script`**: أمر فرعي لـ Cargo يسمح لك بتشغيل ملفات `.rs` منفردة، مع التعامل مع التبعيات إذا تم تحديدها عبر التعليقات. يمكنك تثبيته عادةً باستخدام `cargo install cargo-script`. ثم يمكنك تشغيل `cargo script scripts/rust/example.rs`.
*   **`rust-script`**: أداة أخرى شائعة لتشغيل ملفات Rust مباشرة مثل النصوص البرمجية. قم بتثبيتها عبر `cargo install rust-script`. بعد ذلك، يمكنك غالبًا جعل ملف `.rs` قابلاً للتنفيذ (`chmod +x example.rs`) وتشغيله: `./example.rs`. حيث يتعامل مع الترجمة والتنفيذ في الخلفية.

لحالة استخدامك في اختبار `example.rs` بسرعة، فإن أمر `rustc ... && ./...` المكون من سطر واحد مناسب تمامًا ويجيب مباشرة على سؤالك حول ربط الأمرين. لأي تطوير غير بسيط، فإن اعتماد Cargo سيكون تجربة أكثر إنتاجية وتتوافق مع أسلوب Rust.