---
audio: false
generated: true
image: false
lang: ar
layout: post
model: x-ai/grok-4-fast
title: 'تواصل الخدمات المصغرة: متزامن مقابل مدفوع بالأحداث'
translated: true
type: note
---

### التواصل المتزامن مقابل التواصل القائم على الأحداث في هندسة الخدمات المصغرة

في هندسة الخدمات المصغرة، يمكن أن يحدث التواصل بين الخدمات بطريقتين رئيسيتين: **متزامن** (مكالمات مباشرة ونشطة مثل واجهات برمجة تطبيقات HTTP/REST) أو **غير متزامن/قائم على الأحداث** (باستخدام أدوات مثل Kafka لنشر واستهلاك الأحداث). يسلط سؤالك الضوء على مقايضة شائعة: لماذا لا يتم فقط تركيز المنطق في خدمة واحدة (الـ "caller") وجعلها تستدعي الخدمات اللاحقة ("callees") بشكل نشط، أو حتى تعديل الـ caller لتوزيع المكالمات إلى عدة خدمات لاحقة؟ بدلاً من ذلك، لماذا نستخدم شيئًا مثل Kafka لفصلهم عبر الأحداث؟

الإجابة المختصرة: تعزز البنى القائمة على الأحداث باستخدام Kafka **الفصل المرن، القابلية للتوسع، والمرونة**، مما يجعل الأنظمة أسهل في البناء والصيانة والتوسع—خاصة مع زيادة التعقيد. تعمل المكالمات المباشرة بشكل جيد في الإعدادات البسيطة ولكنها تفشل في البيئات الموزعة عالية الحمولة. دعونا نشرح ذلك.

#### لماذا لا نكتفي باستدعاء الخدمات بشكل نشط من مكان واحد (أو تعديل الـ Caller)؟
هذا النهج—وجود خدمة "موجه" مركزية (أو الـ caller الأصلي) تستدعي الخدمات اللاحقة مباشرة عبر واجهات برمجة التطبيقات—يكون واضحًا ومباشرًا في البداية. يمكنك حتى تحديث الـ caller "لإضافة خدمات لاحقة" حسب الحاجة (مثال، التوزيع إلى عدة خدمات بالتسلسل أو بالتوازي). ولكن إليك سبب قصوره:

- **الاقتران الشديد (Tight Coupling)**: يجب على الـ caller معرفة المواقع الدقيقة (عناوين URL / نقاط النهاية)، والمخططات، وتوفر كل خدمة لاحقة. إذا قامت خدمة لاحقة بتغيير واجهة برمجة التطبيقات الخاصة بها، أو توقفت عن العمل، أو تم تغيير اسمها، يجب عليك تحديث *كل* caller. هذا يخلق شبكة من التبعيات يصعب إعادة هيكلتها.

- **الكتلة المتزامنة (Synchronous Blocking)**: المكالمات تكون محظورة—caller الخاص بك ينتظر الردود. إذا كانت إحدى الخدمات اللاحقة بطيئة أو فشلت، فإن السلسلة بأكملها تتوقف (فشل متتالي). في سيناريو التوزيع (caller يستدعي عدة خدمات لاحقة)، يمكن لانتهاء مهلة واحدة أن يؤخر كل شيء.

- **حدود القابلية للتوسع**: حركة المرور العالية تعني أن الـ caller يصبح عنق زجاجة. عليه أن يتعامل مع كل التنسيق، وإعادة المحاولة، ومعالجة الأخطاء. إضافة المزيد من الخدمات اللاحقة؟ أنت تثقل الـ caller بالمنطق، مما ينتهك مبادئ المسؤولية الفردية.

- **مشاكل الموثوقية**: لا توجد آليات قائمة لإدارة قوائم الانتظار أو إعادة المحاولة. تنتشر الأعطال على الفور، وتفقد الأحداث/البيانات إذا تعطلت خدمة في منتصف المكالمة.

في الجوهر، الأمر يشبه شجرة هاتفية حيث يتصل الجميع مباشرة: فعال لـ 3-4 أشخاص، فوضوي لـ 100.

#### لماذا البنية القائمة على الأحداث مع Kafka؟ (دع الخدمات اللاحقة تستهلك الأحداث)
Kafka هي منصة تدفق أحداث موزعة تعمل كسجل دائم ومرتب للأحداث. تقوم المنتجات (الخدمات المصدرة) بنشر الأحداث إلى مواضيع (مثال، "user-registered")، وتقوم المستهلكات (الخدمات اللاحقة) بالاشتراك ومعالجتها بشكل مستقل. هذا يحول النموذج من "تنسيق الدفع/السحب" إلى "النشر/الاشتراك" (pub/sub).

الفوائد الرئيسية التي تجعل التحول يستحق العناء:

1.  **الفصل المرن والمرونة**:
    *   لا تحتاج الخدمات إلى معرفة بعضها البعض. المنتج ينشر حدثًا بالبيانات ذات الصلة (مثال، `{userId: 123, action: "registered"}`). يمكن لأي عدد من المستهلكين الاشتراك في ذلك الموضوع دون أن يهتم المنتج.
    *   تريد إضافة خدمة لاحقة جديدة (مثال، إشعار البريد الإلكتروني، تحديث التحليلات)? فقط اجعلها تستهلك الحدث—لا حاجة لتغييرات على المنتج أو الكود الحالي. إزالة واحدة? قم بإلغاء اشتراكها. هذا أمر ضخم بالنسبة للأنظمة المتطورة.

2.  **غير متزامن وغير محظور**:
    *   المنتجات تطلق الحدث وتنساه: انشر الحدث وامضِ قدمًا على الفور. لا انتظار للمعالجة اللاحقة.
    *   يحسن استجابة النظام بشكل عام—خدمتك الموجهة للمستخدم لا تتعطل بسبب المهام الخلفية مثل التسجيل أو الإشعارات.

3.  **القابلية للتوسع والإنتاجية**:
    *   Kafka تتعامل مع نطاق هائل: ملايين الأحداث/الثانية عبر الأقسام (partitions). يمكن لعدة مستهلكين معالجة *نفس* الحدث بالتوازي (مثال، واحد للتخزين المؤقت، واحد لفهرسة البحث).
    *   التوسع الأفقي سهل—أضف المزيد من نسخ المستهلك دون المساس بالمنتجين.

4.  **المرونة والمتانة**:
    *   يتم حفظ الأحداث في سجل Kafka لأيام/أسابيع. إذا تعطل مستهلك أو تأخر، فإنه يعيد تشغيل الأحداث من آخر نقطة حفظ له (offset).
    *   دلالات مرة واحدة بالضبط (مع التكوين المناسب) تمنع التكرار. آليات إعادة المحاولة المدمجة، وطابور الرسائل الميتة، وتحمل الأعطال تتغلب على الكود المخصص في الـ caller.

5.  **إسناد الأحداث وإمكانية التدقيق (Event Sourcing and Auditability)**:
    *   تعامل البيانات كتدفق من الأحداث غير القابلة للتغيير، مما يتيح إعادة التشغيل لتصحيح الأخطاء، أو الامتثال، أو إعادة بناء الحالة (مثال، "أعد تشغيل جميع أحداث المستخدم لإصلاح خطأ").
    *   رائع للتحليلات في الوقت الفعلي، خطوات أنابيب التعلم الآلي، أو أنماط CQRS (فصل مسؤولية استعلام الأوامر).

#### متى يبرز هذا النهج؟ (المقايضات)
*   **الأفضل ل**: الأنظمة الموزعة عالية الحمولة (مثال، معالجة طلبات التجارة الإلكترونية، تدفقات بيانات IoT، خلاصات نشاط المستخدم). إذا كان تطبيقك يحتوي على 10+ خدمات أو أحمال غير متوقعة، فإن Kafka تمنع تحول النظام إلى "كرة طينية كبيرة من الفوضى".
*   **العيوب**: يضيف تعقيدًا (تعلم Kafka، إدارة المواضيع/الأقسام، الاتساق النهائي). يمكن أن يكون تصحيح تدفقات الأحداث أصعب من المكالمات المباشرة. ابدأ بالمزامنة للنماذج الأولية، ثم انتقل إلى الأحداث مع التوسع.
*   **بدائل Kafka**: RabbitMQ (لطابور الانتظار الأبسط)، AWS SNS/SQS (المدارة)، أو Pulsar (إذا كنت تحتاج إلى إيجار متعدد). لكن مزيج Kafka من التدفق + طابور الانتظار يجعله الخيار الأمثل.

#### مثال بالكود (كود زائف)
**الـ Caller المتزامن (هش)**:
```python
def process_user_registration(user_data):
    # الـ caller يستدعي عدة خدمات مباشرة
    email_service.send_welcome(user_data)  # يتعطل إذا كانت بطيئة
    analytics_service.log_event(user_data)  # فشلت؟ كل شيء يفشل
    cache_service.invalidate(user_data)     # إضافة المزيد؟ قم بالتحديث هنا
```

**البنية القائمة على الأحداث مع Kafka (مرن)**:
```python
# المنتج (upstream)
from kafka import KafkaProducer
producer = KafkaProducer(bootstrap_servers='localhost:9092')
producer.send('user-events', value={'userId': 123, 'action': 'registered'})

# المستهلك 1 (خدمة البريد الإلكتروني، مستقل)
from kafka import KafkaConsumer
consumer = KafkaConsumer('user-events', bootstrap_servers='localhost:9092')
for msg in consumer:
    if msg.value['action'] == 'registered':
        send_welcome(msg.value)  # يمكن توسيع نطاقها/إعادة محاولتها بشكل مستقل

# المستهلك 2 (التحليلات، يشترك في نفس الموضوع—لا حاجة لتغيير المنتج)
# ... مشابه، لكن يسجل في قاعدة البيانات
```

باختصار، تعديل الـ caller "لإضافة خدمات لاحقة" هو حل سريع لا يتوسع بشكل جبل ويقترن بكل شيء. البنية القائمة على الأحداث مع Kafka تتيح للخدمات التطور بشكل مستقل، محولة نظامك شبه الموحد إلى نظام معياري حقًا. إذا كنت تبني شيئًا محددًا، شارك المزيد من التفاصيل للحصول على نصيحة مخصصة!

**المراجع**:
*   [Kafka Documentation: Introduction](https://kafka.apache.org/intro)
*   [Martin Fowler: Event-Driven Architecture](https://martinfowler.com/articles/201701-event-driven.html)
*   [ThoughtWorks: Microservices Patterns (Ch. 11: Event Collaboration)](https://www.oreilly.com/library/view/microservices-patterns/9781492034018/ch11.html)