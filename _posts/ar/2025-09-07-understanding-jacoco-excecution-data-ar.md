---
audio: false
date: 2025-09-07
generated: true
image: false
lang: ar
layout: post
title: فهم ملفات بيانات تنفيذ جاكوكو
translated: true
type: note
---

إليك دليل عملي شامل لكل ما تحتاج معرفته.

# ما هو `jacoco-it.exec`؟

* إنه **ملف بيانات تنفيذ JaCoCo** يُنتج أثناء **اختبارات التكامل**.
* اللاحقة "`-it`" هي مجرد **اصطلاح** (من هدف *report-integration* في إضافة `jacoco-maven-plugin` ومرحلة Failsafe). غالبًا ما تُسجل اختبارات الوحدة في `jacoco.exec`، بينما تُسجل اختبارات التكامل في `jacoco-it.exec`.
* يمكنك الحصول على عدة ملفات `.exec` (لكل وحدة، لكل مرحلة، لكل تشغيل) و **دمجها** لاحقًا لإنتاج تقرير تغطية واحد.

إعداد Maven النموذجي:

```xml
<plugin>
  <groupId>org.jacoco</groupId>
  <artifactId>jacoco-maven-plugin</artifactId>
  <version>0.8.12</version>
  <executions>
    <!-- لاختبارات الوحدة -->
    <execution>
      <id>prepare-agent</id>
      <goals><goal>prepare-agent</goal></goals>
    </execution>
    <!-- لاختبارات التكامل -->
    <execution>
      <id>prepare-agent-integration</id>
      <goals><goal>prepare-agent-integration</goal></goals>
    </execution>
    <execution>
      <id>report</id>
      <phase>verify</phase>
      <goals><goal>report</goal></goals>
    </execution>
    <execution>
      <id>report-it</id>
      <phase>verify</phase>
      <goals><goal>report-integration</goal></goals>
    </execution>
  </executions>
</plugin>
```

يكتب هذا عادةً `target/jacoco.exec` (لاختبارات الوحدة) و `target/jacoco-it.exec` (لاختبارات التكامل).

# ما الموجود داخل ملف `.exec`؟

* **بيانات الضربات للمجسات فقط**، مُرتبة حسب الفئة.
* بشكل ملموس: لكل فئة مُحمَّلة، يحسب JaCoCo **معرفًا** (مبنيًا على البايت كود) ويخزن **مصفوفة منطقية للمجسات** (أي التعليمات/الفروع تم تنفيذها).
* كما يخزن **معرف الجلسة** وطوابع زمنية.
* **لا يحتوي على البايت كود للفئات، أو أسماء الأساليب، أو أرقام الأسطر، أو الكود المصدري**. تأتي تلك المعلومات الهيكلية لاحقًا من **ملفات الفئات** و **المصادر** الخاصة بك عند تشغيل `jacoco:report` لإنشاء HTML/XML.

الآثار المترتبة:

* إذا تغيرت فئاتك بعد إنتاج ملف `.exec`، فقد لا يتطابق الملف بعد الآن (لن تتطابق المعرفات). دائمًا قم بإنشاء التقرير مقابل **نفس بناء ملفات الفئات بالضبط** الذي أنتج ملف exec.

# هل يحتوي على معلومات هيكل الفئة؟

* **لا**. لا توجد أساليب، ولا أرقام أسطر، ولا كود مصدري.
* إنه **خريطة ضربات** ثنائية مضغوطة لكل فئة. تقوم خطوة التقرير بقراءة **فئاتك المترجمة** (والمصادر اختياريًا) لتعيين تلك الضربات إلى الحزم، والفئات، والأساليب، والأسطر، والفروع.

# هل سيتم تحديثه عند الإرفاق عبر `-javaagent`؟

إجابة قصيرة: **نعم**، مع تفاصيل:

* عند بدء تشغيل JVM مع الوكيل، فإنه يُجهز الفئات **على الطاير** ويسجل ضربات المجسات **في الذاكرة**.
* يكتب الوكيل إلى `destfile`:

  * **عند خروج JVM** (لـ `output=file`، الافتراضي)، أو
  * عندما تقوم **بتفريغ** البيانات بشكل صريح (عبر TCP/JMX/API)، أو
  * عند تعيين `append=true`، سيقوم **بالإلحاق/الدمج** إلى ملف موجود بدلاً من الكتابة فوقه.

خيارات الوكيل الشائعة:

```bash
-javaagent:/path/to/org.jacoco.agent.jar=\
destfile=/path/to/jacoco-it.exec,\
append=true,\
output=file
```

أوضاع أخرى مفيدة:

* `output=tcpserver` (الاستماع على منفذ؛ يمكنك الاتصال وتشغيل تفريغ)
* `output=tcpclient` (دفع البيانات إلى خادم)
* `jmx=true` (كشف MBean عبر JMX للتفريغ/إعادة التعيين)
* برمجيًا: `org.jacoco.agent.rt.RT.getAgent().dump(/*reset*/ true|false)`

ملاحظات على "محدث":

* مع `output=file` **و** `append=true`، يقوم **كل تفريغ** بدمج مصفوفات المجسات في الملف الحالي (OR منطقي للضربات).
* بدون `append=true`، فإن الكتابة التالية **تكتب فوق** الملف عند التفريغ/الخروج.
* إذا كان لديك **عدة JVMs** (خدمات صغيرة، اختبارات منفصلة)، فوجّه كل منها إلى **ملفات مختلفة**، أو استخدم TCP/JMX لجمعها مركزياً، ثم ادمجها.

# سير العمل النموذجية

**مرحلة اختبار التكامل (Failsafe):**

* يرفق Maven الوكيل بـ JVM لاختبار التكامل مع `destfile=target/jacoco-it.exec`.
* في النهاية، يشغل `jacoco:report-integration` الذي يقرأ:

  * `target/jacoco-it.exec` (الضربات)
  * `target/classes` (الهيكل)
  * `src/main/java` (اختياري لأسطر الكود المصدري)
* المخرجات: تغطية HTML/XML/CSV *لاختبارات التكامل فقط*.

**دمج عمليات التشغيل المتعددة:**

```bash
# عبر Maven
mvn jacoco:merge -Djacoco.destFile=target/merged.exec \
  -Djacoco.dataFileList="target/jacoco.exec,target/jacoco-it.exec,other.exec"
# ثم
mvn jacoco:report -Djacoco.dataFile=target/merged.exec
```

# مشاكل شائعة عملية ونصائح

* **طابق البناء**: أنشئ التقارير مقابل **نفس فئات البناء المترجمة** التي أنتجت ملف `.exec`.
* **الفروع المتوازية**: عند تشغيل الاختبارات بشكل متوازٍ أو في عدة JVMs، تجنب وجود عدة كُتّاب لنفس الملف إلا إذا كان `append=true` مضبوطًا وأنت موافق على الإلحاق المتزامن (الأكثر أمانًا هو استخدام ملف لكل JVM ثم الدمج).
* **الخدمات طويلة الأمد**: فعّل **TCP/JMX** أو استدع runtime API ل **تفريغ البيانات دوريًا**؛ لا تنتظر حتى انتهاء العملية.
* **عزل محمّل الفئات**: تقوم بعض خوادم التطبيقات بتحميل نفس الفئة مرتين؛ يقوم JaCoCo بإزالة التكرارات حسب معرف الفئة، لكن كن على علم بذلك في الحاويات المعقدة.
* **التجهيز دون اتصال** موجود، لكن نهج **javaagent** عادةً ما يكون أبسط وأكثر متانة.

---

## إجابات مباشرة على أسئلتك

* **"ما هو `jacoco-it.exec`؟"**
  ملف بيانات التنفيذ (ضربات المجسات) الذي تم التقاطه أثناء **اختبارات التكامل**. إنه مجرد اصطلاح تسمية؛ وظيفيًا هو نفس تنسيق `jacoco.exec`.

* **"هل يحتوي على معلومات هيكل الفئة؟"**
  **لا**. يخزن فقط **مصفوفات ضربات المجسات** لكل فئة وبيانات وصفية للجلسة. تأتي معلومات الفئة/الأسلوب/الأسطر من فئاتك/مصادرك المترجمة أثناء خطوة التقرير.

* **"هل سيتم تحديثه عند الإرفاق عبر `-javaagent`؟"**
  **نعم**. مع `output=file`، يكتب الوكيل عند **خروج JVM** أو **حسب الطلب** (TCP/JMX/API). مع `append=true`، فإنه **يدمج** مع أي ملف موجود؛ بدونه، فإنه **يكتب فوقه**. للتشغيل متعدد JVMs، استخدم ملفات منفصلة أو تفريغًا عن بُعد ثم **ادمج** لاحقًا.