---
audio: false
generated: true
image: false
lang: ar
layout: post
model: x-ai/grok-4-fast
title: مقدمة في خوارزمية الاتحاد والبحث
translated: true
type: note
---

### مقدمة إلى خوارزمية الاتحاد والبحث (مجموعة الاتحاد المنفصلة)

خوارزمية **الاتحاد والبحث** (تُسمى أيضًا **مجموعة الاتحاد المنفصلة** أو **DSU**) هي بنية بيانات ومجموعة من العمليات تُستخدم لإدارة مجموعة من المجموعات المنفصلة (مجموعات من العناصر التي لا تتداخل). إنها فعالة للمشكلات التي تتضمن التجميع أو الدمج أو التحقق من الاتصال، كما في خوارزميات الرسوم البيانية أو التجميع.

العمليات الرئيسية:
- **البحث**: يحدد المجموعة التي ينتمي إليها العنصر (غالبًا عن طريق إيجاد "الجذر" أو الممثل للمجموعة).
- **الاتحاد**: يدمج مجموعتين في مجموعة واحدة.

تتميز الخوارزمية بسبب التحسينات مثل **ضغط المسار** (تسطيح بنية الشجرة أثناء عمليات البحث) و **الاتحاد حسب الرتبة/الحجم** (دمج الأشجار الأصغر في الأشجار الأكبر للحفاظ على توازن البنية). هذا يجعل الوقت المُقدر لكل عملية شبه O(1) — سريع جدًا لمجموعات البيانات الكبيرة.

#### البنية الأساسية للبيانات
- مصفوفة `p[]` (مصفوفة الوالد): `p[i]` تشير إلى والد العنصر `i`. في البداية، كل عنصر هو والد نفسه (`p[i] = i`).
- اختياري: مصفوفة `rank[]` للاتحاد حسب الرتبة لموازنة عمليات الدمج.

#### عملية البحث (مع ضغط المسار)
دالة `find` تتتبع العنصر إلى جذره. السطر الذي ذكرته—`if (p[i] != -1) i = p[i]`—هو خطوة تكرارية أو تعاودية في هذه العملية. إنه يتبع مؤشرات الوالد حتى الوصول إلى الجذر (حيث `p[root] == root` أو `p[root] == -1` للعلامة الفارغة).

إليك تنفيذًا تكرارياً بسيطًا في الكود الزائف:

```
function find(i):
    if p[i] != -1:  # ليس الجذر (أو العلامة الفارغة)
        i = p[i]     # الانتقال إلى الوالد (هذا هو سطرك!)
        return find(i)  # تعاودي: الاستمرار حتى الجذر
    else:
        return i     # تم العثور على الجذر
```

**مع ضغط المسار الكامل** (لتحسين عمليات البحث المستقبلية)، نقوم بتسطيح المسار عن طريق تعيين جميع العقد مباشرة إلى الجذر:

```
function find(i):
    if p[i] != i:  # ليس الجذر
        p[i] = find(p[i])  # الضغط: تعيين الوالد إلى الجذر الذي تم العثور عليه
    return p[i]
```

- `-1` غالبًا ما تُستخدم كعلامة فارغة للجذور (بدلاً من `i` للوالد الذاتي)، خاصة في بعض التنفيذيات للتمييز بين العقد غير المهيأة أو غير الصالحة.
- بدون الضغط، يمكن أن تجعل عمليات البحث المتكررة البنية سلسلة طويلة (O(n) في أسوأ الحالات). الضغط يجعلها شبه مسطحة.

#### عملية الاتحاد
لدمج مجموعتي `x` و `y`:
1. إيجاد الجذور: `rootX = find(x)`, `rootY = find(y)`.
2. إذا كان `rootX != rootY`، ربط أحدهما بالآخر (مثلاً، حسب الرتبة: إرفاق الرتبة الأصغر إلى الأكبر).

الكود الزائف:
```
function union(x, y):
    rootX = find(x)
    rootY = find(y)
    if rootX != rootY:
        if rank[rootX] > rank[rootY]:
            p[rootY] = rootX
        elif rank[rootX] < rank[rootY]:
            p[rootX] = rootY
        else:
            p[rootY] = rootX
            rank[rootX] += 1  # زيادة الرتبة للوالد الجديد
```

#### كيفية استخدام الخوارزمية
الاتحاد-البحث مثالي لمشكلات الاتصال الديناميكي. إليك دليلًا خطوة بخطوة مع الأمثلة:

1. **التهيئة**:
   - إنشاء `p[]` بحجم `n` (عدد العناصر): `for i in 0 to n-1: p[i] = -1` (أو `i` للوالد الذاتي).
   - اختياري: `rank[]` جميعها مضبوطة على 0 أو 1.

2. **مسار الاستخدام الأساسي**:
   - للتحقق مما إذا كان عنصران في نفس المجموعة: `if find(a) == find(b)`.
   - للدمج: `union(a, b)`.
   - معالجة الاستعلامات/الدمج بأي ترتيب — إنها ديناميكية!

3. **مثال: اكتشاف المكونات المتصلة في رسم بياني**
   تخيل رسمًا بيانيًا به 5 عقد (0-4) وحواف مثل (0-1), (1-2), (3-4).
   ```
   // التهيئة
   p = [-1, -1, -1, -1, -1]
   rank = [0, 0, 0, 0, 0]

   // دمج الحواف
   union(0, 1)  // يدمج 0 و 1، لنقل p[0]=-1, p[1]=0
   union(1, 2)  // يدمج 2 في {0,1}, p[2]=0
   union(3, 4)  // يدمج {3,4}، لنقل p[3]=-1, p[4]=3

   // استعلام: هل 0 و 2 متصلان؟ find(0)=0, find(2)=0 → نعم
   // هل 2 و 3 متصلان؟ find(2)=0, find(3)=-1 → لا
   ```

4. **التطبيقات في العالم الحقيقي**:
   - **شجرة الامتداد الدنيا لكراسكال**: ترتيب الحواف حسب الوزن، دمج الحواف التي لا تشكل دورة (تخطي إذا كان `find(u) == find(v)`).
   - **أصدقاء شبكة التواصل الاجتماعي**: دمج الأصدقاء، إيجاد الاتصالات المشتركة.
   - **تجزئة الصورة**: دمج البكسلات المجاورة ذات اللون المماثل.
   - **اكتشاف الدورة في الرسوم البيانية غير الموجهة**: دمج نقاط النهاية؛ إذا كانت في نفس المجموعة بالفعل، توجد دورة.

#### تنفيذ بسيط بلغة Python
```python
class UnionFind:
    def __init__(self, n):
        self.p = [-1] * n
        self.rank = [0] * n
    
    def find(self, i):
        if self.p[i] != -1 and self.p[i] != i:  # يتعامل مع العلامة الفارغة + الوالد الذاتي
            self.p[i] = self.find(self.p[i])  # ضغط المسار
        return self.p[i] if self.p[i] != -1 else i
    
    def union(self, x, y):
        px, py = self.find(x), self.find(y)
        if px != py:
            if self.rank[px] > self.rank[py]:
                self.p[py] = px
            elif self.rank[px] < self.rank[py]:
                self.p[px] = py
            else:
                self.p[py] = px
                self.rank[px] += 1

# الاستخدام
uf = UnionFind(5)
uf.union(0, 1)
uf.union(1, 2)
print(uf.find(0) == uf.find(2))  # True
```

هذا يحافظ على الكفاءة — جربه مع `n` أكبر لترى السرعة!

لمزيد من العمق، تحقق من [GeeksforGeeks: Union-Find Algorithm](https://www.geeksforgeeks.org/union-find-algorithm-set-2-union-by-rank-and-path-compression/) أو [CP-Algorithms: DSU](https://cp-algorithms.com/data_structures/disjoint_set_union.html).