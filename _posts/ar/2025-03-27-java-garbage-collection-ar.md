---
audio: false
generated: true
lang: ar
layout: post
title: جمع النفايات في جافا
translated: true
type: note
---

حسنًا، دعنا نتعلم عن Garbage Collection (GC) في Java! إنه جانب حاسم في إدارة الذاكرة في Java الذي يساعد المطورين على تجنب التخصيص والتحرير اليدوي للذاكرة.

**ما هي عملية Garbage Collection في Java؟**

Garbage Collection هي العملية التلقائية لاستعادة الذاكرة التي تشغلها الكائنات التي لم تعد قيد الاستخدام من قبل تطبيق Java. في جوهرها، هي طريقة Java لتنظيف "البيانات غير المرغوب فيها" (الكائنات غير المستخدمة) لتوفير مساحة للكائنات الجديدة.

**لماذا نحتاج إلى Garbage Collection؟**

في العديد من لغات البرمجة الأخرى (مثل C أو C++)، يكون المطورون مسؤولين عن تخصيص وتحرير الذاكرة صراحةً باستخدام دوال مثل `malloc` و `free`. يمكن أن تؤدي إدارة الذاكرة اليدوية هذه إلى عدة مشاكل:

* **تسريبات الذاكرة:** إذا تم تخصيص الذاكرة ولكن لم يتم تحريرها أبدًا، قد ينفد ذاكرة التطبيق في النهاية ويتعطل.
* **المؤشرات المتعلقة (Dangling Pointers):** إذا تم تحرير الذاكرة ولكن لا يزال المؤشر يشير إلى موقع الذاكرة ذلك، فإن استخدام ذلك المؤشر يمكن أن يؤدي إلى سلوك غير متوقع أو تعطل.
* **زيادة تعقيد التطوير:** تضيف إدارة الذاكرة يدويًا طبقة كبيرة من التعقيد إلى تطوير البرمجيات.

تقوم Garbage Collection في Java بأتمتة هذه العملية، مما يحرر المطورين من عبء إدارة الذاكرة اليدوية ويجعل كتابة كود أكثر أمانًا وموثوقية أسهل.

**كيف تعمل Garbage Collection؟**

الفكرة الأساسية وراء garbage collection هي تحديد الكائنات في الذاكرة التي لا تزال قيد الاستخدام من قبل التطبيق وتلك التي ليست كذلك. ثم يقوم جامع البيانات غير المرغوب فيها (garbage collector) باستعادة الذاكرة التي تشغلها الكائنات غير المستخدمة.

إليك نظرة مبسطة على العملية:

1.  **تحديد الكائنات النشطة (Marking):** يبدأ جامع البيانات غير المرغوب فيها بتحديد مجموعة الكائنات التي لا تزال قابلة للوصول من الكائنات "الجذرية". الكائنات الجذرية هي عادةً كائنات يمكن للتطبيق الوصول إليها مباشرة، مثل:
    * المتغيرات المحلية في الطرق قيد التنفيذ حاليًا.
    * المتغيرات الساكنة (Static variables).
    * الكائنات التي يشير إليها الكود الأصلي (native code).
    * مؤشرات الترابط (threads) النشطة في Java Virtual Machine (JVM).

    يجتاز جامع البيانات غير المرغوب فيها رسم الكائنات بدءًا من هذه الجذور، معلمًا جميع الكائنات التي يمكن الوصول إليها.

2.  **استعادة الذاكرة (Sweeping and Compacting):** بمجرد تحديد الكائنات النشطة، يحتاج جامع البيانات غير المرغوب فيها إلى استعادة الذاكرة التي تشغلها الكائنات غير المعلمة (غير القابلة للوصول). تستخدم خوارزميات جمع البيانات غير المرغوب فيها المختلفة استراتيجيات مختلفة لهذا:

    * **Mark and Sweep:** تحدد هذه الخوارزمية الكائنات النشطة وتعلمها، ثم تقوم بالمسح (sweep) عبر الذاكرة، محررة المساحة التي تشغلها الكائنات غير المعلمة. يمكن أن يؤدي هذا إلى تجزئة الذاكرة (كتل صغيرة ومشتتة من الذاكرة الحرة ليست كبيرة بما يكفي لتخصيص كائنات جديدة).
    * **Mark and Compact:** تحدد هذه الخوارزمية أيضًا الكائنات النشطة. بعد التحديد، تقوم بنقل (ضغط) الكائنات النشطة معًا في الذاكرة، مما يلغي التجزئة ويجعل تخصيص كتل متجاورة من الذاكرة للكائنات الجديدة أسهل.
    * **Copying:** تقسم هذه الخوارزمية الذاكرة إلى منطقتين أو أكثر. يتم نسخ الكائنات النشطة من منطقة إلى أخرى، مما يؤدي بشكل فعال إلى استعادة المساحة في المنطقة الأصلية.

**المفاهيم الأساسية في Garbage Collection في Java:**

* **الكومة (Heap):** منطقة الذاكرة حيث يتم تخصيص الكائنات في Java. يعمل جامع البيانات غير المرغوب فيها بشكل أساسي على الكومة.
* **الجيل الشاب (Young Generation - Nursery):** هذا جزء من الكومة حيث يتم تخصيص الكائنات newly created مبدئيًا. وهي مقسمة further إلى:
    * **منطقة Eden (Eden Space):** حيث يتم إنشاء معظم الكائنات الجديدة.
    * **مناطق الناجين (Survivor Spaces - S0 and S1):** تُستخدم لحمل الكائنات التي صمدت خلال بضع دورات صغيرة من garbage collection.
* **الجيل القديم (Old Generation - Tenured Generation):** يتم نقل الكائنات التي صمدت خلال دورات متعددة من garbage collection في الجيل الشاب في النهاية إلى الجيل القديم. الكائنات في الجيل القديم هي generally طويلة العمر.
* **الجيل الدائم (Permanent Generation - PermGen) / Metaspace:** في الإصدارات القديمة من Java (قبل Java 8)، كان الجيل الدائم يخزن metadata عن الفئات والطرق. في Java 8 والإصدارات اللاحقة، تم استبدال هذا بـ Metaspace، والذي هو جزء من الذاكرة الأصلية (native memory) (وليس Java heap).
* **خوارزميات Garbage Collection:** تُستخدم خوارزميات مختلفة لجمع البيانات غير المرغوب فيها، لكل منها مقايضاتها الخاصة من حيث الأداء والكفاءة.

**Garbage Collection الأجيال (Generational):**

تستخدم Java HotSpot JVM (أشهر JVM) نهجًا generational لجمع البيانات غير المرغوب فيها. يستند هذا على الملاحظة أن معظم الكائنات في التطبيق لها عمر قصير.

1.  **Minor GC (Young Generation GC):** عندما تمتلئ منطقة Eden، يتم تشغيل minor GC. يتم نسخ الكائنات النشطة من Eden ومن إحدى مناطق الناجين (لنقل، S0) إلى منطقة الناجين الأخرى (S1). يتم نقل الكائنات التي صمدت خلال عدد معين من دورات minor GC إلى الجيل القديم. يتم التخلص من الكائنات غير القابلة للوصول.

2.  **Major GC (Old Generation GC) / Full GC:** عندما يمتلئ الجيل القديم، يتم تنفيذ major GC (أو أحيانًا full GC، والذي يمكن أن يشمل كلا الجيلين الشاب والقديم). هذه العملية generally تستغرق وقتًا أطول من minor GC ويمكن أن تسبب توقفات أطول في تنفيذ التطبيق.

**جامعو البيانات غير المرغوب فيها الشائعون في Java HotSpot JVM:**

تقدم Java HotSpot JVM عدة خوارزميات لجمع البيانات غير المرغوب فيها يمكن اختيارها بناءً على متطلبات التطبيق (مثل low latency، high throughput). بعض الخوارزميات الشائعة تشمل:

* **Serial Collector:** يستخدم مؤشر ترابط واحد (single thread) لجمع البيانات غير المرغوب فيها. مناسب للتطبيقات الصغيرة ذات الموارد المحدودة.
* **Parallel Collector:** يستخدم multiple threads لجمع البيانات غير المرغوب فيها، مما يحسن الإنتاجية (throughput). مناسب للتطبيقات ذات مجموعات البيانات متوسطة إلى كبيرة التي تعمل على معالجات multi-core.
* **CMS (Concurrent Mark Sweep) Collector:** يحاول تقليل أوقات التوقف (pause times) من خلال أداء معظم عمل جمع البيانات غير المرغوب فيها بالتزامن (concurrently) مع مؤشرات ترابط التطبيق. ومع ذلك، يمكن أن يؤدي إلى التجزئة وقد يتطلب full GC في النهاية.
* **G1 (Garbage-First) Collector:** يهدف إلى توفير توازن جيد بين الإنتاجية (throughput) و low latency. يقسم الكومة إلى مناطق ويولي الأولوية لجمع البيانات غير المرغوب فيها من المناطق التي تحتوي على أكبر قدر من البيانات غير المرغوب فيها. إنه الجامع الافتراضي في Java 9 والإصدارات اللاحقة.
* **ZGC (Z Garbage Collector):** جامع بيانات غير مرغوب فيها منخفض latency مصمم للكومة الكبيرة. يهدف إلى تحقيق أوقات توقف أقل من 10 مللي ثانية.
* **Shenandoah:** جامع بيانات غير مرغوب فيها آخر منخفض latency بأهداف مشابهة لـ ZGC.

يمكنك تحديد جامع البيانات غير المرغوب فيها الذي تريد استخدامه عبر خيارات سطر أوامر JVM.

**متى يتم تشغيل Garbage Collection؟**

Garbage Collection هي mostly عملية تلقائية driven by the JVM. تعمل typically عندما:

* يمتلئ الجيل الشاب (منطقة Eden).
* يمتلئ الجيل القديم.
* النظام منخفض في الذاكرة.

بينما لا يمكنك التحكم مباشرة *في وقت* تشغيل garbage collection، يمكنك اقتراح إلى JVM أنه قد يكون الوقت مناسبًا لأداء garbage collection باستخدام `System.gc()`. ومع ذلك، لا يوجد ضمان بأن JVM سيشغل بالفعل جامع البيانات غير المرغوب فيها فورًا أو على الإطلاق عند استدعاء هذه الطريقة. من generally الأفضل الاعتماد على آلية garbage collection التلقائية في JVM.

**`System.gc()` و Finalization:**

* **`System.gc()`:** كما ذكر، هذا طلب إلى JVM لتشغيل جامع البيانات غير المرغوب فيها. غالبًا ما يُنصح بعدم الاعتماد على هذه الطريقة لإدارة الذاكرة الحرجة، حيث أن JVM يكون usually أفضل في تحديد وقت تنفيذ GC.
* **طريقة `finalize()`:** قبل أن يتم جمع كائن garbage collection، تمنحه JVM فرصة لأداء أي عمليات تنظيف عن طريق استدعاء طريقة `finalize()` الخاصة به (إذا تم تنفيذها). ومع ذلك، فإن `finalize()` لها عدة عيوب ويتم generally تثبيط استخدامها في تطوير Java الحديث. يمكن أن تقدم مشاكل في الأداء وتجعل garbage collection أقل قابلية للتنبؤ. فكر في استخدام آليات أخرى مثل try-with-resources لإدارة الموارد.

**تأثير Garbage Collection على أداء التطبيق:**

بينما تعتبر garbage collection ضرورية لإدارة الذاكرة، إلا أنها يمكن أن تؤثر أيضًا على أداء التطبيق due to the "stop-the-world" pauses. خلال هذه التوقفات، يتم إيقاف جميع مؤشرات ترابط التطبيق بينما يؤدي جامع البيانات غير المرغوب فيها عمله. تعتمد مدة وتكرار هذه التوقفات على خوارزمية جمع البيانات غير المرغوب فيها المستخدمة وحجم وخصائص الكومة.

تهدف جامعات البيانات غير المرغوب فيها منخفضة latency مثل G1 و ZGC و Shenandoah إلى تقليل أوقات التوقف هذه لجعل التطبيقات أكثر استجابة.

**ضبط Garbage Collection (Tuning):**

للتطبيقات ذات متطلبات الأداء المحددة، يمكن ضبط garbage collection عن طريق تعديل معلمات JVM مثل:

* حجم الكومة (`-Xms`, `-Xmx`)
* حجم الجيل الشاب (`-Xmn`)
* نسب الناجين (`-XX:SurvivorRatio`)
* اختيار جامع بيانات غير مرغوب فيها محدد (`-XX:+UseG1GC`, `-XX:+UseZGC`, إلخ.)
* تعيين flags لجمع البيانات غير المرغوب فيها للتحكم الأكثر دقة.

يعتبر ضبط GC موضوعًا متقدمًا وعادةً ما يتطلب تحليلًا دقيقًا لسلوك وأداء التطبيق.

**أفضل الممارسات لكتابة كود صديق لـ Garbage Collector:**

بينما تتعامل Java مع إدارة الذاكرة تلقائيًا، فإن كتابة التعليمات البرمجية مع مراعاة جامع البيانات غير المرغوب فيها يمكن أن تؤدي إلى أداء أفضل:

* **قلل من إنشاء الكائنات:** يمكن أن يؤدي إنشاء عدد كبير من الكائنات قصيرة العمر إلى الضغط على جامع البيانات غير المرغوب فيها. حاول إعادة استخدام الكائنات عندما يكون ذلك مناسبًا.
* **حرر مراجع الكائنات:** إذا كان لديك مرجع إلى كائن لم تعد بحاجة إليه، عيّن المرجع إلى `null`. هذا يجعل الكائن مؤهلاً لجمع البيانات غير المرغوب فيها في وقت sooner.
* **استخدم هياكل البيانات بحكمة:** اختر هياكل البيانات المناسبة لاحتياجاتك. على سبيل المثال، استخدام `ArrayList` كبيرة ثم التخلص من معظم عناصرها يمكن أن يكون غير فعال.
* **تجنب Finalizers:** كما ذكرنا سابقًا، تجنب الاعتماد على طريقة `finalize()` لتنظيف الموارد. استخدم try-with-resources للموارد مثل الملفات واتصالات الشبكة.
* **كن mindful من المتغيرات الساكنة (Static Variables):** ستعيش الكائنات التي تشير إليها المتغيرات الساكنة طوال مدة التطبيق، لذا كن حذرًا بشأن تخزين كائنات كبيرة أو غير ضرورية في الحقول الساكنة.

**باختصار:**

Garbage Collection في Java هي عملية إدارة ذاكرة تلقائية تستعيد الذاكرة التي تشغلها الكائنات غير المستخدمة. إنها تبسط التطوير من خلال تحرير المطورين من إدارة الذاكرة اليدوية. يمكن أن يساعدك فهم كيفية عملها، والأجيال المختلفة للكومة، وخوارزميات جمع البيانات غير المرغوب فيها المتاحة على كتابة تطبيقات Java أكثر كفاءة وأداءً.