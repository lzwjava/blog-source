---
audio: false
generated: true
lang: ar
layout: post
title: دالة التجزئة SHA-1
translated: true
type: note
---

لنستكشف كيف يعمل مقتطف الكود المعطى، بالتحديد الأسطر:

```python
hash_obj = hashlib.sha1(piece)
hashes.append(hash_obj.hexdigest())
return hashes
```

طلب المستخدم منا شرح هذا دون استخدام مكتبة، لذا سأشرح أولاً ما يفعله الكود مع مكتبة `hashlib`، ثم سأستكشف كيف يمكن تحقيق نفس الوظيفة بدونها.

---

### فهم الكود باستخدام `hashlib`

يحسب هذا المقتطف قيمة تجزئة (Hash) لقطعة من البيانات ويخزنها في قائمة. إليك تفصيل خطوة بخطوة لما يحدث:

1. **`hash_obj = hashlib.sha1(piece)`**
   - **ما يفعله**: يستخدم هذا السطر وحدة `hashlib` في بايثون لإنشاء كائن تجزئة من نوع SHA-1. SHA-1 (خوارزمية التجزئة الآمنة 1) هي دالة تجزئة تشفيرية تأخذ مدخلاً (هنا، `piece`) وتنتج قيمة تجزئة طولها 160 بت (20 بايت).
   - **المدخل**: `piece` هي جزء من البيانات، غالباً بايتات، قُرئت من ملف أو مصدر آخر.
   - **العملية**: تقوم الدالة `hashlib.sha1()` بتهيئة كائن التجزئة وتحديثه فوراً بالبيانات الموجودة في `piece`. فكر في الأمر كإدخال البيانات إلى آلة حساب التجزئة التي تبدأ في معالجة الأرقام.

2. **`hashes.append(hash_obj.hexdigest())`**
   - **ما يفعله**: تسترجع طريقة `hexdigest()` قيمة التجزئة المحسوبة بواسطة كائن التجزئة وتحولها إلى سلسلة نصية ست عشرية (تنسيق مقروء للإنسان يستخدم الأرقام من 0-9 والحروف من a-f).
   - **المخرج**: بالنسبة لـ SHA-1، يبلغ طول هذه السلسلة 40 حرفاً لأن كل بايت من الـ 20 بايت يتم تمثيله برقمين ست عشرين (على سبيل المثال، القيمة البايت 255 تصبح "ff").
   - **التخزين**: يتم إضافة السلسلة الناتجة إلى قائمة تسمى `hashes`، التي من المفترض أنها تجمع قيم التجزئة لقطع متعددة من البيانات.

3. **`return hashes`**
   - **ما يفعله**: بعد معالجة جميع القطع (بافتراض أن هذا الكود موجود داخل حلقة أو دالة)، يتم إرجاع القائمة `hashes` التي تحتوي على جميع سلاسل تجزئة الست عشرية.

**باختصار**: لكل `piece` من البيانات، يحسب الكود تجزئة SHA-1 الخاصة بها باستخدام `hashlib.sha1()`، يحول التجزئة إلى سلسلة ست عشرية باستخدام `hexdigest()`، ويخزنها في قائمة `hashes`، التي يتم إرجاعها لاحقاً.

---

### بدون استخدام مكتبة: حساب SHA-1 من الصفر

يشير تعليم المستخدم "لا تستخدم lib" إلى أنه يريد فهم كيف يمكن أن يعمل هذا دون الاعتماد على `hashlib`. تنفيذ SHA-1 من الصفر أمر معقد، لكنني سأشرح العملية بوضوح وأقدم نسخة مبسطة يمكنك البناء عليها.

#### ما هي SHA-1؟
SHA-1 هي دالة تجزئة:
- تأخذ أي بيانات إدخال (مثلاً، `piece`).
- تنتج مخرجاً ثابتاً طوله 160 بت (20 بايت).
- تستخدم سلسلة من العمليات على مستوى البت، والدوران، والجمع لتحويل المدخل.

بدون `hashlib`، سنحتاج إلى إعادة إنشاء هذه الخوارزمية بأنفسنا. إليك كيف يمكن أن تعمل للكود المعطى:

#### عملية SHA-1 خطوة بخطوة

1. **تحضير المدخل (الحشو - Padding)**
   - تعالج SHA-1 البيانات في كتل طولها 512 بت (64 بايت). إذا لم يكن `piece` طوله 64 بايت بالضبط، نقوم بحشوه:
     - نضيف بت `1` (مثلاً، `0x80` بالبايتات).
     - نضيف عدداً كافياً من البتات `0` لجعل الطول 448 بت (56 بايت) modulo 512.
     - نضيف الطول الأصلي لـ `piece` (بالبتات) كعدد صحيح طوله 64 بت.
   - للتبسيط، إذا كان `piece` أصغر من 64 بايت، يمكننا حشوه ليكون كتلة واحدة.

2. **تهيئة قيم التجزئة**
   - تستخدم SHA-1 خمس متغيرات طولها 32 بت (160 بت إجمالاً)، مُهيأة إلى ثوابت محددة:
     - `h0 = 0x67452301`
     - `h1 = 0xEFCDAB89`
     - `h2 = 0x98BADCFE`
     - `h3 = 0x10325476`
     - `h4 = 0xC3D2E1F0`

3. **معالجة كتلة البيانات**
   - نقسم كتلة الـ 64 بايت إلى 16 كلمة طولها 32 بت (4 بايت لكل منها).
   - نوسع هذه إلى 80 كلمة باستخدام الصيغة:
     ```python
     w[i] = left_rotate(w[i-3] ^ w[i-8] ^ w[i-14] ^ w[i-16], 1)  # for i = 16 to 79
     ```
     حيث `left_rotate` تقوم بإزاحة البتات لليسار وتدويرها.
   - لمدة 80 دورة، نقوم بتحديث المتغيرات المؤقتة `a`, `b`, `c`, `d`, `e` (التي تبدأ كنسخ من `h0` إلى `h4`):
     - نستخدم دوال وثوابت مختلفة بناءً على رقم الدورة (0-19, 20-39, إلخ).
     - مثال للدورات من 0 إلى 19:
       ```python
       f = (b & c) | (~b & d)
       k = 0x5A827999
       temp = (left_rotate(a, 5) + f + e + k + w[i]) & 0xFFFFFFFF
       ```
     - نقوم بإزاحة المتغيرات: `e = d`, `d = c`, `c = left_rotate(b, 30)`, `b = a`, `a = temp`.

4. **تحديث قيم التجزئة**
   - بعد 80 دورة، نضيف النتائج إلى قيم التجزئة الأولية:
     ```python
     h0 = (h0 + a) & 0xFFFFFFFF
     h1 = (h1 + b) & 0xFFFFFFFF
     # ...وهكذا لـ h2, h3, h4
     ```

5. **إنتاج المخرج الست عشري**
   - ندمج `h0` إلى `h4` كقيمة طولها 160 بت ونحولها إلى سلسلة ست عشرية مكونة من 40 حرفاً.

#### تنفيذ بايثون مبسط

إليك نسخة أساسية لكيفية إعادة كتابة الكود بدون `hashlib`:

```python
def left_rotate(value, shift):
    """قم بتدوير عدد صحيح 32 بت لليسار بمقدار 'shift' بت."""
    return ((value << shift) | (value >> (32 - shift))) & 0xFFFFFFFF

def custom_sha1(piece):
    """احسب تجزئة SHA-1 لـ 'piece' وأعدها كسلسلة ست عشرية."""
    # للتبسيط، افترض أن piece أقل من 56 بايت وقم بحشوه ليكون كتلة واحدة
    message = piece + b'\x80' + (b'\x00' * (55 - len(piece))) + (len(piece) * 8).to_bytes(8, 'big')
    
    # تهيئة قيم التجزئة
    h0, h1, h2, h3, h4 = (
        0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0
    )
    
    # تقسيم إلى 16 كلمة طولها 32 بت
    w = [int.from_bytes(message[i:i+4], 'big') for i in range(0, 64, 4)]
    
    # توسيع إلى 80 كلمة
    for i in range(16, 80):
        w.append(left_rotate(w[i-3] ^ w[i-8] ^ w[i-14] ^ w[i-16], 1))
    
    # تهيئة متغيرات العمل
    a, b, c, d, e = h0, h1, h2, h3, h4
    
    # 80 دورة من المعالجة
    for i in range(80):
        if 0 <= i < 20:
            f = (b & c) | (~b & d)
            k = 0x5A827999
        elif 20 <= i < 40:
            f = b ^ c ^ d
            k = 0x6ED9EBA1
        elif 40 <= i < 60:
            f = (b & c) | (b & d) | (c & d)
            k = 0x8F1BBCDC
        else:
            f = b ^ c ^ d
            k = 0xCA62C1D6
        
        temp = (left_rotate(a, 5) + f + e + k + w[i]) & 0xFFFFFFFF
        e = d
        d = c
        c = left_rotate(b, 30)
        b = a
        a = temp
    
    # تحديث قيم التجزئة
    h0 = (h0 + a) & 0xFFFFFFFF
    h1 = (h1 + b) & 0xFFFFFFFF
    h2 = (h2 + c) & 0xFFFFFFFF
    h3 = (h3 + d) & 0xFFFFFFFF
    h4 = (h4 + e) & 0xFFFFFFFF
    
    # الإرجاع كسلسلة ست عشرية مكونة من 40 حرفاً
    return f"{h0:08x}{h1:08x}{h2:08x}{h3:08x}{h4:08x}"

# الكود المعاد كتابته بدون hashlib
def compute_hashes(pieces):
    hashes = []
    for piece in pieces:  # بافتراض أن pieces هي قائمة بأجزاء البايت
        hash_value = custom_sha1(piece)
        hashes.append(hash_value)
    return hashes

# مثال للاستخدام
pieces = [b"hello", b"world"]
hashes = compute_hashes(pieces)
print(hashes)
```

#### كيف يتطابق مع الأصل
- **`hash_obj = hashlib.sha1(piece)`**: تم استبداله بـ `custom_sha1(piece)`، التي تحسب تجزئة SHA-1 يدوياً.
- **`hashes.append(hash_obj.hexdigest())`**: ترجع دالة `custom_sha1` السلسلة الست عشرية مباشرة، لذا نضيفها إلى `hashes`.
- **`return hashes`**: تبقى كما هي، لإرجاع قائمة سلاسل التجزئة.

---

### الاختلافات الرئيسية والمحاذير
- **التبسيط**: يفترض هذا التنفيذ أن كل `piece` يتناسب مع كتلة 512 بت واحدة (أقل من 56 بايت بسبب الحشو). سيحتوي تنفيذ SHA-1 الكامل على معالجة لكتل متعددة.
- **الأداء**: التنفيذ اليدوي أبطأ وأقل كفاءة من `hashlib`.
- **الموثوقية**: المكتبات مثل `hashlib` تم اختبارها وهي آمنة؛ بينما قد تحتوي النسخة المخصصة على أخطاء ما لم يتم التحقق منها بدقة.

في الجوهر، يستخدم الكود الأصلي `hashlib` كاختصار لحساب تجزئات SHA-1 بكفاءة، بينما القيام بذلك بدون مكتبة يتطلب برمجة خوارزمية SHA-1 بالكامل يدوياً، والتعامل مع الحشو، وتحويل النتيجة إلى تنسيق ست عشري. يبقى المنطق كما هو: معالجة كل قطعة، وحساب تجزئتها، وتخزينها، وإرجاع المجموعة.