---
audio: false
generated: true
image: false
lang: ar
layout: post
model: x-ai/grok-4-fast
title: خوارزمية كيه إم بي للبحث الفعال في النصوص
translated: true
type: note
---

### فهم خوارزمية كنوث-موريس-برات (KMP)

حدسك صحيح تمامًا: تتمحور خوارزمية KMP حول **عدم إهدار التطابقات الجزئية** أثناء البحث في النصوص. عندما تبحث عن نمط (مثل "abc") داخل نص أطول (مثل "ababcabc")، فإن الطريقة الساذجة تعيد البدء من الصفر في كل مرة يفشل فيها التطابق، مما يجعلها غير فعالة. بينما تتذكر خوارزمية KMP بذكاء مقدار النمط الذي تم تطابقه بالفعل وتقفز للأمام، متجنبة المقارنات الزائدة عن الحاجة. هذا يجعلها سريعة جدًا — بوقت خطي، O(n + m)، حيث n طول النص و m طول النمط.

سأشرحها خطوة بخطوة بمثال بسيط. سنبحث عن النمط `P = "abab"` في النص `T = "ababababc"`. (يظهر في المواضع 0 و 2 و 4).

#### الخطوة 1: المشكلة والطريقة الساذجة
- **الهدف**: إيجاد جميع مواضع البداية حيث يتطابق `P` تمامًا في `T`.
- **الطريقة الساذجة**: انزلق `P` فوق `T`، وقارن حرفًا بحرف. إذا حدث عدم تطابق في الموضع i في `P`، انقل `P` بمقدار 1 وأعد المحاولة من بداية `P`.
  - لمثالنا:
    - ابدأ عند T[0]: "a"=="a" (تطابق)، "b"=="b" (تطابق)، "a"=="a" (تطابق)، "b"=="b" (تطابق) → وجد عند 0.
    - انتقل إلى T[1]: "b"=="a"؟ لا → أعد بدء `P` من البداية. إهدار!
    - T[2]: "a"=="a"، "b"=="b"، "a"=="a"، "b"=="b" → وجد عند 2.
    - T[3]: "a"=="a"، "b"=="b"، "a"=="a"، "b"=="a"؟ لا → أعد البدء.
    - وهكذا. الكثير من التراجع إلى الحرف 0 من `P`.

هذا يمكن أن يكون O(n*m) في أسوأ الحالات (مثل البحث عن "aaa...ab" في "aaaaa...a").

#### الخطوة 2: الفكرة الأساسية لـ KMP – جدول البادئة (أو "دالة الفشل")
تحسب خوارزمية KMP مسبقًا جدول `π` (باي) للنمط `P`. يخبرك هذا الجدول، لكل موضع i في `P`، **بأطول بادئة صحيحة لـ `P[0..i]` والتي هي أيضًا لاحقة**. بعبارة أخرى: "إذا فشل التطابق هنا، فما مقدار التطابق الجزئي الذي يمكننا إعادة استخدامه بالقفز إلى هذه البادئة المتداخلة؟"

- **البادئة/اللاحقة الصحيحة**: بادئة/لاحقة ليست السلسلة الكاملة (مثلاً، لـ "aba"، البادئة "a" تطابق اللاحقة "a").
- لماذا؟ لأنها تتيح لك "انزلاق" النمط بأكثر من 1 عند عدم التطابق، مع إعادة استخدام التداخل بدلاً من إعادة البدء.

لـ `P = "abab"`:
- ابني `π` خطوة بخطوة (سنبرمج هذا قريبًا).

| الموضع i | P[0..i] | أطول بادئة صحيحة = لاحقة | π[i] |
|------------|---------|--------------------------------|------|
| 0          | "a"     | لا شيء (حرف واحد)             | 0    |
| 1          | "ab"    | لا شيء                           | 0    |
| 2          | "aba"   | "a" (البادئة "a" == اللاحقة "a") | 1    |
| 3          | "abab"  | "ab" (البادئة "ab" == اللاحقة "ab") | 2  |

- π[2] = 1 تعني: إذا طابقت "aba" ولكن فشل التطابق على الحرف التالي، فتصرف كما لو أنك طابقت البادئة "a" (الطول 1) حتى الآن.
- π[3] = 2 تعني: بالنسبة لـ "abab" الكاملة، التداخل هو "ab".

#### الخطوة 3: بناء جدول البادئة (π)
يتم هذا في وقت O(m). إنه يشبه البحث عن `P` داخل نفسه، باستخدام منطق مشابه.

كود زائف:
```
def compute_prefix_function(P):
    m = len(P)
    pi = [0] * m
    k = 0  # طول التطابق الحالي بين البادئة واللاحقة
    for i in range(1, m):
        while k > 0 and P[k] != P[i]:
            k = pi[k-1]  # اقفز إلى التداخل السابق (أعد الاستخدام!)
        if P[k] == P[i]:
            k += 1
        pi[i] = k
    return pi
```

- ابدأ بـ π[0] = 0.
- لكل i=1 إلى m-1:
  - حاول تمديد طول التطابق الحالي k.
  - إذا فشل التطابق، ارجع إلى π[k-1] (لا تهدر — أعد استخدام التداخل السابق).
  - إذا تطابق، k++.

لـ "abab":
- i=1: P[0]='a' != P[1]='b' → k=0, π[1]=0.
- i=2: P[0]='a' == P[2]='a' → k=1, π[2]=1.
- i=3: P[1]='b' == P[3]='b' → k=2, π[3]=2.

#### الخطوة 4: البحث باستخدام جدول البادئة
ابحث الآن في `T` باستخدام `P` و `π`:
- احتفظ بمتغير `q` = الحالة الحالية (طول البادئة المطابقة حتى الآن).
- لكل حرف في `T`:
  - بينما يوجد عدم تطابق و q>0، اضبط q = π[q-1] (اقفز للخلف بذكاء).
  - إذا تطابق، q++.
  - إذا أصبح q == m، وجدت تطابقًا! ثم اضبط q = π[q-1] للمتابعة بحثًا عن التداخلات.

كود زائف:
```
def kmp_search(T, P):
    n, m = len(T), len(P)
    if m == 0: return []
    pi = compute_prefix_function(P)
    q = 0
    matches = []
    for i in range(n):
        while q > 0 and P[q] != T[i]:
            q = pi[q-1]
        if P[q] == T[i]:
            q += 1
        if q == m:
            matches.append(i - m + 1)  # موضع البداية
            q = pi[q-1]  # التداخل للبحث التالي
    return matches
```

لـ `T = "ababababc"`, `P = "abab"`:
- i=0: 'a'=='a' → q=1
- i=1: 'b'=='b' → q=2
- i=2: 'a'=='a' → q=3
- i=3: 'b'=='b' → q=4 == m → تطابق عند 0, q=π[3]=2
- i=4: الآن q=2, T[4]='a' == P[2]='a' → q=3
- i=5: 'b'=='b' → q=4 == m → تطابق عند 2, q=2
- i=6: q=2, 'a'=='a' → q=3
- i=7: q=3, 'b' == P[3]='b' → q=4 == m → تطابق عند 4, q=2
- i=8: 'c' != P[2]='a'? أثناء q=2 → بينما q>0 و P[2]='a' != 'c' → q = π[1]=0. ثم P[0]='a' != 'c' → q=0.

النتيجة: تطابقات عند 0, 2, 4.

أترى؟ عند عدم التطابق (مثل لو كان هناك واحد)، تقفز q=π[q-1] بدلاً من q=0.

#### لماذا تبدو سحرية
- لا تراجع في `T` — تتحرك للأمام فقط.
- حلقة "while" لعدم التطابق تعمل بمتوسط O(1) مرة إجمالاً، لأن كل قفزة تقلل q، و q تزداد على الأكثر n مرة.

#### جربها بنفسك: كود Python بسيط
```python
def compute_prefix_function(P):
    m = len(P)
    pi = [0] * m
    k = 0
    for i in range(1, m):
        while k > 0 and P[k] != P[i]:
            k = pi[k - 1]
        if P[k] == P[i]:
            k += 1
        pi[i] = k
    return pi

def kmp_search(T, P):
    n, m = len(T), len(P)
    if m == 0: return []
    pi = compute_prefix_function(P)
    q = 0
    matches = []
    for i in range(n):
        while q > 0 and P[q] != T[i]:
            q = pi[q - 1]
        if P[q] == T[i]:
            q += 1
        if q == m:
            matches.append(i - m + 1)
            q = pi[q - 1]
    return matches

# اختبار
T = "ababababc"
P = "abab"
print(kmp_search(T, P))  # الناتج: [0, 2, 4]
```

شغّل هذا — عدّل P/T لترى القفزات أثناء العمل (أضف عبارات طباعة لـ q).

#### الأخطاء الشائعة والنصائح
- π[0] دائمًا 0.
- للأنماط بدون تداخلات ذاتية (مثل "abc")، π تكون كلها أصفار — تعود إلى الطريقة الساذجة.
- رائعة لتسلسلات الحمض النووي DNA أو الإكمال التلقائي للكود.
- إذا كانت لا تزال غير واضحة، تصور π كـ "آلة حالات": كل حالة هي طول مطابق، والانتقالات تحدث عند التطابق/عدم التطابق.

يجب أن تكون الفكرة واضحة الآن — إنها مجرد تخطي ذكي عبر التداخلات المحسوبة مسبقًا. إذا كان لديك مثال محدد يربكك، شاركه!

[GeeksforGeeks: KMP Algorithm](https://www.geeksforgeeks.org/dsa/kmp-algorithm-for-pattern-searching/)  
[Wikipedia: Knuth–Morris–Pratt Algorithm](https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm)