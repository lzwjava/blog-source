---
audio: false
generated: true
lang: ar
layout: post
title: البحث الثنائي في مشاريع البيانات المالية
translated: true
type: note
---

البحث الثنائي هو خوارزمية فعالة للعثور على عنصر من قائمة **مرتبة** من العناصر عن طريق تقسيم فاصل البحث إلى النصف بشكل متكرر. في سياق مشروعك المالي الذي يركز على البيانات، وقواعد البيانات، وواجهة Angular الأمامية، واستعلامات SQL، يمكن تطبيق البحث الثنائي في سيناريوهات محددة تحتاج فيها للبحث خلال بيانات مرتبة. أدناه، سأشرح كيف وأين يمكنك استخدام البحث الثنائي في مشروعك، مخصصًا لمجموعة التقنيات الخاصة بك ومجال التمويل.

### الخصائص الرئيسية للبحث الثنائي
- **المتطلب**: يجب أن تكون البيانات **مرتبة** (على سبيل المثال، بترتيب تصاعدي أو تنازلي).
- **تعقيد الوقت**: O(log n)، مما يجعله أسرع بكثير من البحث الخطي (O(n)) لمجموعات البيانات الكبيرة.
- **حالة الاستخدام**: الأفضل للبيانات الثابتة أو التي نادرًا ما تتغير والمُرتبة حيث تحتاج إلى تحديد قيمة محددة بسرعة.

### أين يمكن تطبيق البحث الثنائي في مشروعك المالي
في مشروع مالي يحتوي على backend يعتمد بشكل كبير على قواعد البيانات وواجهة Angular frontend، يمكن تطبيق البحث الثنائي في المجالات التالية:

#### 1. **Backend: البحث في نتائج قاعدة البيانات المرتبة**
   - **السيناريو**: من المرجح أن مشروعك المالي يتضمن الاستعلام عن مجموعات بيانات كبيرة (مثل سجلات المعاملات، أسعار الأسهم، أو أرصدة الحسابات) المرتبة حسب حقول مثل معرف المعاملة، التاريخ، أو المبلغ. إذا كانت البيانات مرتبة مسبقًا (أو قمت بترتيبها في استعلام SQL)، يمكنك استخدام البحث الثنائي لتحديد سجلات محددة بكفاءة في الذاكرة بعد جلبها.
   - **مثال**:
     - تقوم باسترداد قائمة مرتبة من المعاملات (مثلًا حسب التاريخ أو المبلغ) من قاعدة البيانات باستخدام استعلام مثل:
       ```sql
       SELECT * FROM transactions WHERE account_id = ? ORDER BY transaction_date;
       ```
     - بعد جلب النتائج إلى الـ backend الخاص بك (مثل Node.js، Java، أو Python)، يمكنك استخدام البحث الثنائي للعثور على معاملة محددة حسب التاريخ أو المعرف دون التكرار خلال القائمة بأكملها.
   - **التنفيذ**:
     - قم بتحميل البيانات المرتبة في مصفوفة أو قائمة في الـ backend الخاص بك.
     - نفذ البحث الثنائي للعثور على السجل المستهدف. على سبيل المثال، في JavaScript:
       ```javascript
       function binarySearch(arr, target, key) {
           let left = 0;
           let right = arr.length - 1;
           while (left <= right) {
               let mid = Math.floor((left + right) / 2);
               if (arr[mid][key] === target) return arr[mid];
               if (arr[mid][key] < target) left = mid + 1;
               else right = mid - 1;
           }
           return null; // Not found
       }

       // Example: Find transaction with specific date
       const transactions = [
           { id: 1, date: '2025-01-01', amount: 100 },
           { id: 2, date: '2025-01-02', amount: 200 },
           { id: 3, date: '2025-01-03', amount: 150 }
       ];
       const result = binarySearch(transactions, '2025-01-02', 'date');
       console.log(result); // { id: 2, date: '2025-01-02', amount: 200 }
       ```
   - **متى تستخدم**:
     - مجموعة البيانات مرتبة وثابتة نسبيًا (مثل بيانات المعاملات التاريخية).
     - مجموعة البيانات كبيرة جدًا للبحث الخطي ولكنها صغيرة بما يكفي لتناسب الذاكرة بعد استعلام SQL.
     - تحتاج إلى إجراء عمليات بحث متعددة على نفس مجموعة البيانات المرتبة.

#### 2. **Frontend: البحث في Angular لميزات واجهة المستخدم**
   - **السيناريو**: في واجهة Angular الأمامية الخاصة بك، قد تعرض بيانات مرتبة (مثل جدول لأسعار الأسهم، مرتب حسب السعر أو التاريخ). إذا أراد المستخدم العثور بسرعة على عنصر معين (مثل سعر سهم معين أو معاملة في تاريخ محدد)، يمكنك تنفيذ البحث الثنائي في الواجهة الأمامية لتجنب فحص مجموعة البيانات بأكملها.
   - **مثال**:
     - تقوم بجلب البيانات المرتبة من الـ backend عبر API وتخزينها في مكون Angular.
     - نفذ البحث الثنائي في TypeScript للعثور على عنصر في المصفوفة المرتبة.
     - اعرض النتيجة في واجهة المستخدم (مثل إبراز معاملة أو التمرير إلى صف معين في جدول).
     - مثال TypeScript في مكون Angular:
       ```typescript
       export class TransactionComponent {
         transactions: any[] = [
           { id: 1, date: '2025-01-01', amount: 100 },
           { id: 2, date: '2025-01-02', amount: 200 },
           { id: 3, date: '2025-01-03', amount: 150 }
         ];

         findTransaction(targetDate: string) {
           let left = 0;
           let right = this.transactions.length - 1;
           while (left <= right) {
             let mid = Math.floor((left + right) / 2);
             if (this.transactions[mid].date === targetDate) {
               return this.transactions[mid];
             }
             if (this.transactions[mid].date < targetDate) {
               left = mid + 1;
             } else {
               right = mid - 1;
             }
           }
           return null; // Not found
         }
       }
       ```
   - **متى تستخدم**:
     - تستقبل الواجهة الأمامية مجموعة بيانات مرتبة (عبر API) وتحتاج إلى إجراء عمليات بحث سريعة لتفاعلات المستخدم (مثل التصفية أو البحث في جدول).
     - مجموعة البيانات صغيرة بما يكفي ليتم التعامل معها في المتصفح دون مشاكل في الأداء.
     - تريد تقليل عدد استدعاءات API إلى الـ backend للبحث.

#### 3. **هياكل البيانات في الذاكرة للحسابات المالية**
   - **السيناريو**: غالبًا ما تتضمن المشاريع المالية حسابات مثل تحليل المحفظة، البحث عن الأسعار التاريخية، أو حسابات أسعار الفائدة. إذا كنت تحافظ على هياكل بيانات مرتبة في الذاكرة (مثل مصفوفات أسعار الأسهم التاريخية أو أسعار الفائدة)، يمكن للبحث الثنائي تحديد القيم للحسابات بسرعة.
   - **مثال**:
     - لديك مصفوفة مرتبة من أسعار الأسهم التاريخية حسب التاريخ وتحتاج إلى العثور على السعر في تاريخ محدد لنموذج مالي (مثل حساب العوائد).
     - استخدم البحث الثنائي لتحديد السعر بكفاءة بدلاً من فحص المصفوفة بأكملها.
     - مثال في Python (إذا كان الـ backend الخاص بك يستخدم Python):
       ```python
       def binary_search(prices, target_date):
           left, right = 0, len(prices) - 1
           while left <= right:
               mid = (left + right) // 2
               if prices[mid]['date'] == target_date:
                   return prices[mid]['price']
               if prices[mid]['date'] < target_date:
                   left = mid + 1
               else:
                   right = mid - 1
           return None  # Not found

       prices = [
           {'date': '2025-01-01', 'price': 100},
           {'date': '2025-01-02', 'price': 105},
           {'date': '2025-01-03', 'price': 110}
       ]
       price = binary_search(prices, '2025-01-02')
       print(price)  # Output: 105
       ```
   - **متى تستخدم**:
     - تقوم بإجراء حسابات على مجموعات بيانات مرتبة مثل البيانات المالية الزمنية (مثل أسعار الأسهم، أسعار الصرف).
     - البيانات مرتبة مسبقًا أو يمكن ترتيبها مسبقًا دون عبء كبير.

#### 4. **تحسين استعلامات SQL باستخدام منطق البحث الثنائي**
   - **السيناريو**: بينما تم تحسين قواعد بيانات SQL للبحث (مثل استخدام الفهارس)، يمكنك محاكاة منطق البحث الثنائي في حالات محددة، مثل عند العمل مع بيانات مفهرسة ومرتبة أو عند تنفيذ منطق بحث مخصص في الإجراءات المخزنة.
   - **مثال**:
     - إذا كان لديك جدول كبير بفهرس مرتب (مثلًا على transaction_date)، يمكنك كتابة إجراء مخزن يستخدم منطقًا مشابهًا للبحث الثنائي لتضييق نطاق البحث.
     - على سبيل المثال، في إجراء مخزن في PostgreSQL:
       ```sql
       CREATE OR REPLACE FUNCTION find_transaction(target_date DATE)
       RETURNS TABLE (id INT, amount NUMERIC) AS $$
       DECLARE
           mid_point DATE;
           lower_bound DATE;
           upper_bound DATE;
       BEGIN
           SELECT MIN(transaction_date), MAX(transaction_date)
           INTO lower_bound, upper_bound
           FROM transactions;

           WHILE lower_bound <= upper_bound LOOP
               mid_point := lower_bound + (upper_bound - lower_bound) / 2;
               IF EXISTS (
                   SELECT 1 FROM transactions
                   WHERE transaction_date = target_date
                   AND transaction_date = mid_point
               ) THEN
                   RETURN QUERY
                   SELECT id, amount FROM transactions
                   WHERE transaction_date = target_date;
                   RETURN;
               ELSIF target_date > mid_point THEN
                   lower_bound := mid_point + INTERVAL '1 day';
               ELSE
                   upper_bound := mid_point - INTERVAL '1 day';
               END IF;
           END LOOP;
           RETURN;
       END;
       $$ LANGUAGE plpgsql;
       ```
   - **متى تستخدم**:
     - أنت تعمل مع مجموعات بيانات كبيرة جدًا، والفهرسة المدمجة في قاعدة البيانات ليست كافية لنمط البحث المحدد الخاص بك.
     - تقوم بتنفيذ منطق مخصص في الإجراءات المخزنة لتحسين الأداء.
     - ملاحظة: هذا أقل شيوعًا، لأن فهارس قواعد البيانات (مثل أشجار-B) تستخدم بالفعل مبادئ مماثلة داخليًا.

#### 5. **التخزين المؤقت للبيانات التي يتم البحث فيها بشكل متكرر**
   - **السيناريو**: في التطبيقات المالية، يتم الوصول إلى بيانات معينة (مثل أسعار الصرف، معدلات الضرائب، أو البيانات التاريخية) بشكل متكرر ويمكن تخزينها مؤقتًا بترتيب مرتب. يمكن استخدام البحث الثنائي للاستعلام عن هذه البيانات المخزنة مؤقتًا بسرعة.
   - **مثال**:
     - خزن مؤقتًا قائمة مرتبة من أسعار الصرف في ذاكرة تخزين مؤقت Redis أو في بنية بيانات في الذاكرة.
     - استخدم البحث الثنائي للعثور على سعر الصرف لتاريخ محدد أو زوج عملات.
     - مثال في Node.js مع Redis:
       ```javascript
       const redis = require('redis');
       const client = redis.createClient();

       async function findExchangeRate(targetDate) {
           const rates = JSON.parse(await client.get('exchange_rates')); // Sorted array
           let left = 0;
           let right = rates.length - 1;
           while (left <= right) {
               let mid = Math.floor((left + right) / 2);
               if (rates[mid].date === targetDate) return rates[mid].rate;
               if (rates[mid].date < targetDate) left = mid + 1;
               else right = mid - 1;
           }
           return null;
       }
       ```
   - **متى تستخدم**:
     - أنت تخزن بيانات ثابتة أو شبه ثابتة مؤقتًا (مثل أسعار الصرف اليومية، جداول الضرائب).
     - البيانات المخزنة مؤقتًا مرتبة، وتحتاج إلى إجراء عمليات بحث متكررة.

### متى **لا** تستخدم البحث الثنائي
- **البيانات غير المرتبة**: البحث الثنائي يتطلب بيانات مرتبة. إذا كان ترتيب البيانات مكلفًا للغاية (O(n log n))، ففكر في خوارزميات أو هياكل بيانات أخرى (مثل جداول التجزئة للبحث بوقت O(1)).
- **البيانات الديناميكية**: إذا كانت مجموعة البيانات تتغير بشكل متكرر (مثل أسعار الأسهم في الوقت الحقيقي)، فقد يكون الحفاظ على الترتيب المرتب مكلفًا. استخدم فهارس قاعدة البيانات أو هياكل بيانات أخرى مثل خرائط التجزئة أو الأشجار بدلاً من ذلك.
- **مجموعات البيانات الصغيرة**: لمجموعات البيانات الصغيرة (مثل < 100 عنصر)، قد يكون البحث الخطي أسرع بسبب انخفاض النفقات العامة.
- **عمليات البحث على مستوى قاعدة البيانات**: قواعد بيانات SQL ذات الفهارس المناسبة (مثل فهارس B-tree أو hash) مُحسّنة للبحث. البحث الثنائي أكثر فائدة للبيانات في الذاكرة أو معالجة ما بعد الاستعلام.

### الاعتبارات العملية لمشروعك
1. **حجم البيانات**: يبرز البحث الثنائي مع مجموعات البيانات الكبيرة (مثل آلاف أو ملايين السجلات). قيّم ما إذا كانت مجموعات البيانات الخاصة بك كبيرة بما يكفي للاستفادة من البحث الثنائي مقارنة بالبحث الخطي أو استعلامات قاعدة البيانات.
2. **عبء الترتيب**: تأكد من أن البيانات مرتبة مسبقًا أو أن الترتيب ممكن. على سبيل المثال، استرجع بيانات مرتبة من SQL (`ORDER BY`) أو حافظ على مصفوفات مرتبة في الذاكرة.
3. **التكامل مع Angular**: في الواجهة الأمامية، استخدم البحث الثنائي للتصفية على جانب العميل أو البحث في الجداول المرتبة لتحسين تجربة المستخدم (مثل العثور بسرعة على معاملة في جدول مقسم إلى صفحات).
4. **حالات الاستخدام المحددة في التمويل**:
   - **البحث عن المعاملات**: ابحث عن معاملات محددة بالمعرف، التاريخ، أو المبلغ في القوائم المرتبة.
   - **تحليل السلاسل الزمنية**: حدد تواريخ محددة في البيانات المالية التاريخية (مثل أسعار الأسهم، أسعار الفائدة).
   - **إدارة المحفظة**: ابحث عن أصول أو مقاييس محددة في المحافظ المرتبة.
5. **هياكل البيانات البديلة**:
   - إذا لم يكن البحث الثنائي مناسبًا (مثل البيانات غير المرتبة أو الديناميكية)، ففكر في:
     - **خرائط التجزئة**: للبحث بوقت O(1) بالمفتاح (مثل معرف المعاملة).
     - **أشجار-B أو الفهارس**: دع قاعدة البيانات تتعامل مع عمليات البحث بكفاءة.
     - **شجرة البادئات أو Trie**: للبحث المستند إلى السلسلة النصية (مثل البحث عن أسماء الحسابات).

### مثال على سير العمل في مشروعك
1. **Backend**:
   - قم بتشغيل استعلام SQL لجلب المعاملات المرتبة: `SELECT * FROM transactions WHERE account_id = ? ORDER BY transaction_date`.
   - قم بتحميل النتائج في مصفوفة في الذاكرة.
   - استخدم البحث الثنائي للعثور على معاملة محددة حسب التاريخ أو المبلغ.
2. **Frontend**:
   - اجلب البيانات المرتبة عبر API واعرضها في جدول Angular.
   - نفذ ميزة بحث في مكون Angular باستخدام البحث الثنائي لإبراز أو تصفية سجلات محددة.
3. **التخزين المؤقت**:
   - خزن مؤقتًا البيانات المرتبة التي يتم الوصول إليها بشكل متكرر (مثل أسعار الصرف) في Redis أو مخزن في الذاكرة.
   - استخدم البحث الثنائي للاستعلام عن ذاكرة التخزين المؤقت للبحث السريع.

### الخلاصة
البحث الثنائي هو أداة قوية لمشروعك المالي عند التعامل مع **البيانات المرتبة، الثابتة، أو شبه الثابتة** في الذاكرة، سواء في الـ backend (مثل بعد استعلامات SQL) أو الـ frontend (مثل جداول Angular). إنه مفيد بشكل خاص لمجموعات البيانات الكبيرة حيث يكون أداء O(log n) مفيدًا، مثل البحث عن المعاملات، أو البحث في البيانات الزمنية، أو استعلامات البيانات المخزنة مؤقتًا. ومع ذلك، تأكد من أن البيانات مرتبة، وفكر في بدائل مثل فهارس قواعد البيانات أو خرائط التجزئة للبيانات غير المرتبة أو الديناميكية. إذا كان لديك مجموعات بيانات أو حالات استخدام محددة في الاعتبار، فأخبرني، ويمكنني تخصيص الأمثلة بشكل أكبر!