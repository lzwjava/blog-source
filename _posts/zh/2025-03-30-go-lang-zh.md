---
audio: false
generated: true
lang: zh
layout: post
title: Go编程语言全面指南
translated: true
type: note
---

本指南旨在全面概述 Go 编程语言，涵盖其基础知识、核心概念和高级特性。本指南既适合有一定编程经验的初学者，也适合希望从其他语言转型的开发者。

**一、Go 语言简介**

* **什么是 Go？**
    * Go（常称为 Golang）是由 Google 的 Robert Griesemer、Rob Pike 和 Ken Thompson 设计的一种静态类型、编译型编程语言。
    * 它强调简洁性、并发性和性能。
    * Go 是开源的，拥有一个活跃且不断增长的社区。
* **主要特性与设计原则：**
    * **简洁性与可读性：** 语法简洁，关键字少，专注于做好一件事。
    * **并发：** 内置对轻量级 Goroutine 和 Channel 的支持，使并发编程更简单、更高效。
    * **性能：** 编译型语言，具有高效的内存管理（垃圾回收），执行速度快。
    * **强类型：** 有助于在开发过程早期捕获错误。
    * **静态链接：** 生成自包含的可执行文件，简化部署。
    * **垃圾回收：** 自动内存管理，减轻开发者负担。
    * **标准库：** 丰富全面的标准库，为各种任务提供工具。
    * **工具链：** 出色的内置工具，用于格式化（gofmt）、代码检查（golint, staticcheck）、测试（go test）和依赖管理（go modules）。
* **应用场景：**
    * 系统编程
    * 网络编程（API、Web 服务器）
    * 云基础设施（Docker、Kubernetes）
    * 命令行工具
    * 分布式系统
    * 大数据处理

**二、搭建 Go 开发环境**

* **安装：**
    * 从官方网站 ([https://go.dev/dl/](https://go.dev/dl/)) 下载适用于您操作系统的 Go 发行版。
    * 按照您平台的安装说明进行操作。
* **验证安装：**
    * 打开终端或命令提示符，运行 `go version`。这将显示已安装的 Go 版本。
* **工作区与 `GOPATH`（传统方式）：**
    * 历史上，Go 项目在 `GOPATH` 环境变量指定的工作区内组织。虽然仍受支持，但已基本被 Go Modules 取代。
* **Go Modules（推荐）：**
    * Go Modules 是官方的依赖管理解决方案。
    * 要使用模块启动新项目，请在终端中导航到您的项目目录并运行 `go mod init <your_module_path>`（例如，`go mod init github.com/yourusername/myproject`）。
    * 依赖项在 `go.mod` 文件中声明。

**三、Go 基础语法与概念**

* **Hello, World!**
    ```go
    package main

    import "fmt"

    func main() {
        fmt.Println("Hello, World!")
    }
    ```
    * `package main`：声明该包为可执行程序的入口点。
    * `import "fmt"`：导入 "fmt" 包，该包提供格式化 I/O 功能。
    * `func main()`：程序执行开始的 main 函数。
    * `fmt.Println()`：向控制台打印一行文本。
* **包与导入：**
    * Go 代码组织在包中。
    * 包有助于代码组织、可重用性和避免命名冲突。
    * 使用 `import` 关键字从其他包（标准库或第三方）引入功能。
    * 导入路径可以是单个包（如 `"fmt"`）或嵌套包（如 `"net/http"`）。
    * 导入别名：`import f "fmt"`（现在可以使用 `f.Println`）。
    * 使用空白标识符（`_`）处理副作用：`import _ "net/http/pprof"`（初始化 pprof 处理程序而不直接使用）。
* **变量：**
    * 声明：
        * `var name type`（例如，`var age int`）
        * `var name = value`（类型推断，例如，`var name = "Alice"`）
        * `name := value`（短变量声明，仅在函数内部使用，例如，`count := 0`）
    * 多重声明：
        ```go
        var (
            firstName string = "John"
            lastName  string = "Doe"
            age       int    = 30
        )
        ```
    * 常量：
        * `const PI float64 = 3.14159`
        * 常量必须在编译时声明。
        * 无类型常量可根据其使用场景采用不同的类型。
* **数据类型：**
    * **基本类型：**
        * **整数：** `int`, `int8`, `int16`, `int32` (`rune` - `int32` 的别名), `int64`, `uint`, `uint8` (`byte` - `uint8` 的别名), `uint16`, `uint32`, `uint64`, `uintptr`（大到足以容纳指针的无符号整数）。
        * **浮点数：** `float32`, `float64`。
        * **复数：** `complex64`, `complex128`。
        * **布尔型：** `bool` (`true`, `false`)。
        * **字符串：** `string`（不可变的字节序列，通常为 UTF-8 编码）。
    * **复合类型：**
        * **数组：** 固定大小的同类型元素序列（例如，`[5]int`）。
        * **切片：** 动态大小、对数组元素的灵活视图（最常用）。
        * **映射：** 无序的键值对集合（哈希表）。
        * **结构体：** 将零个或多个不同类型的命名字段组合在一起的复合数据类型。
        * **指针：** 保存值的内存地址。
        * **函数：** 一等公民，可以赋值给变量并作为参数传递。
        * **接口：** 定义类型必须实现的一组方法。
        * **通道：** 为 Goroutine 提供通信和同步的方式。
* **操作符：**
    * **算术：** `+`, `-`, `*`, `/`, `%`, `++`, `--`。
    * **比较：** `==`, `!=`, `>`, `<`, `>=`, `<=`。
    * **逻辑：** `&&` (AND), `||` (OR), `!` (NOT)。
    * **位运算：** `&` (AND), `|` (OR), `^` (XOR), `&^` (AND NOT), `<<` (左移), `>>` (右移)。
    * **赋值：** `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`。
* **控制流：**
    * **`if`, `else if`, `else`：** 条件执行。
        ```go
        if age >= 18 {
            fmt.Println("Adult")
        } else if age >= 13 {
            fmt.Println("Teenager")
        } else {
            fmt.Println("Child")
        }
        ```
    * **`for` 循环：** Go 中唯一的循环结构。
        * 基本 `for` 循环：
            ```go
            for i := 0; i < 5; i++ {
                fmt.Println(i)
            }
            ```
        * `while` 风格循环：
            ```go
            j := 0
            for j < 5 {
                fmt.Println(j)
                j++
            }
            ```
        * 无限循环：
            ```go
            for {
                // 执行某些操作
            }
            ```
        * 遍历集合 (`range`)：
            ```go
            numbers := []int{1, 2, 3}
            for index, value := range numbers {
                fmt.Printf("Index: %d, Value: %d\n", index, value)
            }

            m := map[string]string{"a": "apple", "b": "banana"}
            for key, val := range m {
                fmt.Printf("Key: %s, Value: %s\n", key, val)
            }
            ```
    * **`switch` 语句：** 多路条件执行。
        ```go
        grade := "B"
        switch grade {
        case "A":
            fmt.Println("Excellent!")
        case "B":
            fmt.Println("Good")
        case "C":
            fmt.Println("Average")
        default:
            fmt.Println("Needs improvement")
        }
        ```
        * 没有自动贯穿（如需贯穿，使用 `fallthrough` 关键字）。
        * Case 可以有多个值。
        * 无条件的 Switch（类似 `if-else if-else`）。
    * **`defer` 语句：** 将函数调用调度到外围函数结束时执行（常用于清理任务，如关闭文件）。
        ```go
        func example() {
            f, err := os.Open("file.txt")
            if err != nil {
                fmt.Println(err)
                return
            }
            defer f.Close() // f.Close() 将在 example() 返回时被调用

            // ... 处理文件 ...
        }
        ```
    * **`goto` 语句：** 将控制转移到带标签的语句（慎用，可能导致代码混乱）。
    * **`break` 和 `continue`：** 控制循环执行。

**四、复合数据类型详解**

* **数组：**
    * 固定大小，同类型元素。
    * 比切片使用较少。
    * 示例：`var a [3]int; a[0] = 1; a[1] = 2; a[2] = 3` 或 `b := [2]string{"hello", "world"}`。
* **切片：**
    * 动态大小，由底层数组支持。
    * 使用切片字面量（例如，`[]int{1, 2, 3}`）、`make()` 函数（`make([]int, length, capacity)`）或对现有数组/切片进行切片（`mySlice[start:end]`）创建。
    * `len()`：返回切片中的元素个数。
    * `cap()`：返回底层数组的容量。
    * `append()`：向切片末尾添加元素（如果容量达到上限，可能会重新分配底层数组）。
    * `copy()`：将元素从一个切片复制到另一个切片。
* **映射：**
    * 无序的键值对集合。
    * 键必须是可比较的类型（例如，整数、字符串、布尔值、仅包含可比较字段的结构体）。
    * 值可以是任何类型。
    * 使用映射字面量（例如，`map[string]int{"apple": 1, "banana": 2}`）或 `make()` 函数（`make(map[string]string)`）创建。
    * 访问值：`value := myMap["key"]`（返回值和一个指示键是否存在的布尔值）。
    * 检查键是否存在：`value, ok := myMap["key"]`（如果键存在，`ok` 为 `true`）。
    * 添加/更新条目：`myMap["newKey"] = "newValue"`。
    * 删除条目：`delete(myMap, "keyToDelete")`。
* **结构体：**
    * 将不同类型的命名字段组合在一起的自定义类型。
    * 用于表示具有多个属性的实体。
    * 声明：
        ```go
        type Person struct {
            FirstName string
            LastName  string
            Age       int
        }
        ```
    * 创建实例：
        ```go
        var p1 Person
        p1.FirstName = "Alice"
        p1.LastName = "Smith"
        p1.Age = 25

        p2 := Person{FirstName: "Bob", LastName: "Johnson", Age: 30}

        p3 := Person{"Charlie", "Brown", 20} // 如果省略字段名，顺序必须一致
        ```
    * 访问字段：`p1.FirstName`。
    * 嵌入结构体（组合）。
    * 匿名字段。
* **指针：**
    * 保存值的内存地址。
    * 使用 `*` 操作符声明（例如，`var ptr *int`）。
    * 使用 `&` 操作符获取变量的地址（例如，`ptr = &age`）。
    * 使用 `*` 操作符解引用指针以访问其指向的值（例如，`value := *ptr`）。
    * Go 没有显式的指针运算。
    * 指针对于通过引用传递数据、直接修改值以及处理某些数据结构非常有用。

**五、函数**

* **函数声明：**
    ```go
    func functionName(parameterName1 type1, parameterName2 type2) returnType {
        // 函数体
        return returnValue
    }
    ```
    * 相同类型的多个参数可以一起声明：`func sum(a, b int) int`。
    * 可变参数函数（接受可变数量的参数）：`func sum(numbers ...int) int`。
    * 多返回值：
        ```go
        func divide(a, b float64) (float64, error) {
            if b == 0 {
                return 0, fmt.Errorf("division by zero")
            }
            return a / b, nil
        }

        result, err := divide(10, 2)
        if err != nil {
            fmt.Println("Error:", err)
        } else {
            fmt.Println("Result:", result)
        }
        ```
    * 命名返回值。
* **一等函数：**
    * 函数可以赋值给变量、作为参数传递给其他函数、以及从函数中返回。
    * 示例：
        ```go
        func add(a, b int) int { return a + b }

        func operate(f func(int, int) int, x, y int) int {
            return f(x, y)
        }

        result := operate(add, 5, 3) // result 将为 8
        ```
* **匿名函数（闭包）：**
    * 没有名称的函数，常用作内联回调。
    * 可以捕获其周围作用域中的变量（闭包）。
    * 示例：
        ```go
        func multiplier(factor int) func(int) int {
            return func(x int) int {
                return x * factor
            }
        }

        double := multiplier(2)
        fmt.Println(double(5)) // 输出: 10
        ```

**六、方法**

* **方法声明：**
    * 方法是与特定接收者类型关联的函数。
    * 语法：
        ```go
        func (receiver Type) methodName(parameters) returnType {
            // 方法体
        }
        ```
    * 接收者可以是值或指针。
    * 值接收者对接收者的副本进行操作。
    * 指针接收者对原始接收者进行操作，并可以修改其状态。
* **示例：**
    ```go
    type Circle struct {
        Radius float64
    }

    func (c Circle) Area() float64 {
        return math.Pi * c.Radius * c.Radius
    }

    func (c *Circle) SetRadius(newRadius float64) {
        c.Radius = newRadius
    }

    func main() {
        myCircle := Circle{Radius: 5}
        fmt.Println("Area:", myCircle.Area()) // 在值接收者上调用 Area 方法

        myCircle.SetRadius(10) // 在指针接收者上调用 SetRadius 方法
        fmt.Println("New Area:", myCircle.Area())
    }
    ```

**七、接口**

* **接口定义：**
    * 接口定义了一组方法签名。
    * 如果一个类型为接口中定义的所有方法提供了实现，则该类型实现了该接口。
    * 接口是隐式满足的（没有显式的 `implements` 关键字）。
    * 语法：
        ```go
        type Writer interface {
            Write(p []byte) (n int, err error)
        }

        type Reader interface {
            Read(p []byte) (n int, err error)
        }

        type ReadWriter interface {
            Reader
            Writer // 嵌入接口
            Close() error
        }
        ```
* **接口使用：**
    * 实现多态（以统一的方式处理不同类型的对象）。
    * 通过面向接口编程而非具体类型来解耦代码。
    * 示例：
        ```go
        import "io"
        import "os"

        func writeData(w io.Writer, data []byte) error {
            _, err := w.Write(data)
            return err
        }

        func main() {
            file, err := os.Create("output.txt")
            if err != nil {
                fmt.Println("Error creating file:", err)
                return
            }
            defer file.Close()

            data :=[]byte("Hello, Go interfaces!\n")
            err = writeData(file, data)
            if err != nil {
                fmt.Println("Error writing to file:", err)
                return
            }

            // 我们也可以使用同样实现了 io.Writer 的 os.Stdout
            err = writeData(os.Stdout, []byte("Writing to stdout through the interface.\n"))
            if err != nil {
                fmt.Println("Error writing to stdout:", err)
                return
            }
        }
        ```
* **空接口 (`interface{}`)：**
    * 空接口没有任何方法。
    * 所有类型都实现了空接口。
    * 可用于表示任何类型的值，但通常需要类型断言来访问底层值。
    ```go
    var i interface{}
    i = 42
    fmt.Println(i)
    i = "hello"
    fmt.Println(i)

    value, ok := i.(string) // 类型断言为 string
    if ok {
        fmt.Println("The value is a string:", value)
    } else {
        fmt.Println("The value is not a string")
    }
    ```
* **类型断言与类型开关：**
    * **类型断言：** 用于从接口变量中提取底层的具体值。
        * 语法：`value, ok := interfaceVar.(ConcreteType)`
        * 如果断言正确，`value` 将保存具体值，`ok` 为 `true`。
        * 如果断言错误且未检查 `ok`，将引发 panic。
    * **类型开关：** 用于根据接口变量持有的具体类型执行不同的操作。
        ```go
        func describe(i interface{}) {
            switch v := i.(type) {
            case int:
                fmt.Printf("Twice %v is %v\n", v, v*2)
            case string:
                fmt.Printf("%q is %v bytes long\n", v, len(v))
            default:
                fmt.Printf("I don't know about type %T!\n", v)
            }
        }

        func main() {
            describe(42)
            describe("hello")
            describe(true)
        }
        ```

**八、Goroutine 与并发**

Go 的并发模型基于 Goroutine 和 Channel。

* **Goroutine：**
    * 轻量级的并发函数。
    * 使用 `go` 关键字后跟函数调用来创建。
    * Goroutine 与其他函数和 Goroutine 并发运行。
    * 创建和管理的开销比传统的 OS 线程小得多。
    ```go
    package main

    import (
        "fmt"
        "time"
    )

    func say(s string) {
        for i := 0; i < 5; i++ {
            time.Sleep(100 * time.Millisecond)
            fmt.Println(s)
        }
    }

    func main() {
        go say("world") // 启动一个新的 Goroutine
        say("hello")    // 在主 Goroutine 中运行

        // 等待一段时间以查看 Goroutine 的输出
        time.Sleep(time.Second)
    }
    ```
* **Channel：**
    * 类型化的管道，Goroutine 可以通过它发送和接收值。
    * 为并发代码提供安全通信和同步的方式。
    * 使用 `make(chan Type)` 语法创建。
    * 发送到 Channel：`channel <- value`
    * 从 Channel 接收：`value := <-channel`
    ```go
    package main

    import "fmt"

    func sum(s []int, c chan int) {
        sum := 0
        for _, v := range s {
            sum += v
        }
        c <- sum // 将 sum 发送到 Channel
    }

    func main() {
        s := []int{7, 2, 8, -9, 4, 0}

        c := make(chan int)
        go sum(s[:len(s)/2], c) // 在一个 Goroutine 中计算前半部分的和
        go sum(s[len(s)/2:], c) // 在另一个 Goroutine 中计算后半部分的和
        x, y := <-c, <-c       // 从 Channel 接收结果

        fmt.Println(x, y, x+y)
    }
    ```
* **缓冲 Channel：**
    * 具有容量的 Channel，可以在接收者未立即就绪时容纳一定数量的值。
    * 使用 `make(chan Type, capacity)` 创建。
    * 仅当缓冲区满时，向缓冲 Channel 发送才会阻塞。
    * 仅当缓冲区空时，从缓冲 Channel 接收才会阻塞。
* **Channel 方向：**
    * 可以在 Channel 类型中指定数据流方向：
        * `chan<- int`：只发送 Channel（只能发送整数）。
        * `<-chan int`：只接收 Channel（只能接收整数）。
    * 对于限制函数中 Channel 的使用方式非常有用。
    ```go
    func sender(out chan<- string) {
        out <- "Hello from sender"
    }

    func receiver(in <-chan string) {
        msg := <-in
        fmt.Println("Received:", msg)
    }

    func main() {
        ch := make(chan string)
        go sender(ch)
        go receiver(ch)
        time.Sleep(time.Second)
    }
    ```
* **`select` 语句：**
    * 允许一个 Goroutine 等待多个通信操作。
    * 阻塞直到其中一个 case 可以执行，然后执行该 case。
    * 如果多个 case 就绪，则随机选择一个执行。
    * 可以有一个 `default` case，如果没有其他 case 就绪，则立即执行。
    ```go
    package main

    import (
        "fmt"
        "time"
    )

    func main() {
        c1 := make(chan string)
        c2 := make(chan string)

        go func() {
            time.Sleep(1 * time.Second)
            c1 <- "one"
        }()
        go func() {
            time.Sleep(2 * time.Second)
            c2 <- "two"
        }()

        for i := 0; i < 2; i++ {
            select {
            case msg1 := <-c1:
                fmt.Println("received", msg1)
            case msg2 := <-c2:
                fmt.Println("received", msg2)
            }
        }
    }
    ```
* **同步原语：**
    * **`sync.WaitGroup`：** 等待一组 Goroutine 完成。
    * **`sync.Mutex`：** 提供基本的互斥锁。
    * **`sync.RWMutex`：** 提供读/写锁，允许多个读取者或单个写入者。
    * **`sync.Once`：** 确保函数只执行一次。

**九、错误处理**

Go 倾向于使用 `error` 接口进行显式错误处理。

* **`error` 接口：**
    * 定义为：`type error interface { Error() string }`
    * 可能失败的函数通常将 `error` 类型的值作为最后一个返回值。
    * `nil` 值表示成功；非 `nil` 的 `error` 值表示失败。
* **创建错误：**
    * 使用 `errors` 包中的 `errors.New()` 函数创建简单的错误值。
    * 使用 `fmt.Errorf()` 创建格式化的错误消息。
* **处理错误：**
    * 在调用可能失败的函数后检查返回的 `error` 值。
    * 使用 `if err != nil` 来处理错误。
    * 可以使用像 `fmt.Errorf()` 与 `%w` 这样的库来包装错误以提供更多上下文。
* **自定义错误类型：**
    * 可以通过定义实现 `error` 接口（即具有 `Error() string` 方法）的结构体来创建自己的错误类型。
    ```go
    package main

    import (
        "errors"
        "fmt"
        "time"
    )

    type TimeoutError struct {
        duration time.Duration
    }

    func (e *TimeoutError) Error() string {
        return fmt.Sprintf("operation timed out after %v", e.duration)
    }

    func performOperation(timeout time.Duration) error {
        time.Sleep(timeout + 1*time.Second) // 模拟长时间操作
        return &TimeoutError{duration: timeout}
    }

    func main() {
        err := performOperation(2 * time.Second)
        if err != nil {
            fmt.Println("Error:", err)
            if te, ok := err.(*TimeoutError); ok {
                fmt.Printf("It was a timeout error of %v\n", te.duration)
            }
        } else {
            fmt.Println("Operation successful")
        }
    }
    ```
* **`panic` 和 `recover`：**
    * `panic` 用于表示程序无法恢复的运行时错误。它会停止当前函数的执行并展开调用栈，沿途执行任何延迟的函数。
    * `recover` 是一个内置函数，可以重新获得对发生 panic 的 Goroutine 的控制。它应该在延迟函数内调用。`recover` 返回传递给 `panic` 的值，如果 Goroutine 未发生 panic，则返回 `nil`。
    * `panic` 和 `recover` 应谨慎使用，主要用于关键的、不可恢复的错误。对于大多数预期错误，请使用 `error` 接口。
    ```go
    package main

    import "fmt"

    func mightPanic() {
        panic("something went wrong")
    }

    func recoverFunc() {
        if r := recover(); r != nil {
            fmt.Println("Recovered from panic:", r)
        }
    }

    func main() {
        defer recoverFunc()
        fmt.Println("Before mightPanic")
        mightPanic()
        fmt.Println("After mightPanic (this will not be reached)")
    }
    ```

**十、包与模块**

Go 代码组织在包中。

* **包：**
    * 同一目录下一起编译的源文件集合。
    * 提供命名空间以避免命名冲突。
    * 包名通常是目录的名称。
    * 可执行程序必须有一个包含 `main` 函数的 `main` 包。
    * 库可以有任何包名。
* **导入：**
    * 使用 `import` 关键字从其他包引入功能。
    * 标准库包使用其短名称导入（例如，`"fmt"`, `"net/http"`）。
    * 第三方包通常使用其模块路径导入（例如，`"github.com/gin-gonic/gin"`）。
    * **导入路径：**
        * 相对导入（不鼓励，在模块内有特定规则）。
        * 绝对导入（推荐），以模块路径开头。
    * **导入别名：** 可以使用别名在本地为包指定不同的名称：`import f "fmt"`。
    * **空白标识符 (`_`)：** 用于仅为了包的副作用（例如，初始化内部状态）而导入包：`import _ "net/http/pprof"`。
* **模块（Go 1.11 及更高版本）：**
    * Go 中管理依赖的主要方式。
    * 由项目根目录下的 `go.mod` 文件定义。
    * `go.mod` 文件跟踪模块路径和项目的依赖项。
    * **`go mod init <module_path>`：** 初始化新模块。
    * **`go get <package>@<version>`：** 添加或更新依赖项。
    * **`go build`, `go run`, `go test`：** 自动管理模块依赖。
    * **`go.sum`：** 包含依赖项的加密哈希以确保完整性。
* **可见性：**
    * 以大写字母开头的标识符（变量、函数、类型等）是导出的（公开的），可以从其他包访问。
    * 以小写字母开头的标识符是未导出的（私有的），只能在同一包内访问。

**十一、测试**

Go 内置了对测试的支持。

* **测试文件：**
    * 测试文件以 `_test.go` 后缀命名（例如，`myfunction_test.go`）。
    * 它们与待测试代码位于同一个包中。
* **测试函数：**
    * 测试函数名称以 `Test` 开头，并接受一个类型为 `*testing.T` 的参数。
    * 使用 `*testing.T` 上的方法（例如，`t.Log`, `t.Error`, `t.Errorf`, `t.Fatal`, `t.Fatalf`）报告测试结果。
* **测试示例：**
    ```go
    // myfunction.go
    package mypackage

    func Add(a, b int) int {
        return a + b
    }

    // myfunction_test.go
    package mypackage_test

    import "testing"

    func TestAdd(t *testing.T) {
        result := Add(2, 3)
        expected := 5
        if result != expected {
            t.Errorf("Add(2, 3) returned %d, expected %d", result, expected)
        }
    }
    ```
* **运行测试：**
    * 在包含您的包的目录中使用 `go test` 命令。
    * `go test -v`：详细输出，显示每个测试的名称。
    * `go test ./...`：运行当前目录及所有子目录中的测试。
    * `go test -run <pattern>`：仅运行名称与给定正则表达式匹配的测试。
* **基准测试：**
    * 测量代码性能。
    * 基准测试函数名称以 `Benchmark` 开头，并接受一个类型为 `*testing.B` 的参数。
    * 使用 `b.N` 循环多次运行被基准测试的代码。
    ```go
    // myfunction_test.go
    package mypackage_test

    import (
        "testing"
    )

    func BenchmarkAdd(b *testing.B) {
        for i := 0; i < b.N; i++ {
            Add(2, 3)
        }
    }
    ```
    * 使用 `go test -bench=.` 运行基准测试。
* **示例测试：**
    * 在包的文档中提供可运行的示例。
    * 示例函数名称以 `Example` 开头。
    * 它们在测试期间被编译和执行，并将其输出与函数内的注释进行比较。

这份全面的 Go 编程语言指南到此结束。请记住，实践和探索是掌握任何编程语言的关键。祝你好运！