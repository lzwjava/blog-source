---
audio: true
generated: true
lang: zh
layout: post
title: 使用 SAX（简单 API 为 XML）
translated: true
---

使用 Java 中的 `org.xml.sax` 包解析 XML 文档，可以按照以下步骤使用 SAX（Simple API for XML）解析方法。SAX 是一个事件驱动的解析器，它按顺序读取 XML 文档，并在遇到文档的各个部分（如元素或文本内容）时触发回调方法。这使得它在处理大 XML 文件时非常高效，因为它不会像 DOM 那样将整个文档加载到内存中。以下是使用 `org.xml.sax` 的分步指南。

---

### 第 1 步：设置 SAX 解析器
要开始使用 SAX 解析 XML，需要使用 `SAXParserFactory` 类创建一个 `SAXParser` 实例。这个工厂允许你在创建解析器之前配置其行为。

以下是如何创建 `SAXParser`：

```java
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;

public class SAXExample {
    public static void main(String[] args) {
        try {
            // 创建一个 SAXParserFactory 实例
            SAXParserFactory factory = SAXParserFactory.newInstance();

            // 可选：配置工厂（例如，启用命名空间感知）
            factory.setNamespaceAware(true); // 如果你的 XML 使用命名空间，设置为 true

            // 创建一个 SAXParser
            SAXParser parser = factory.newSAXParser();

            // 下一步将在这里
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

- **`SAXParserFactory.newInstance()`**：创建一个新的工厂实例。
- **`factory.setNamespaceAware(true)`**：可选。如果你的 XML 使用命名空间，启用命名空间处理。默认情况下，它是 `false`。
- **`factory.newSAXParser()`**：创建一个 `SAXParser`。如果解析器无法配置或初始化，这可能会抛出 `ParserConfigurationException` 或 `SAXException`。

---

### 第 2 步：创建 XML 事件处理程序
SAX 解析依赖于一个处理程序来处理它遇到的 XML 事件，例如元素的开始、结束或文本内容。这个主要接口是 `ContentHandler`，但为了简单起见，你可以扩展 `DefaultHandler` 类，它为 `ContentHandler` 和其他处理程序接口（`ErrorHandler`、`DTDHandler` 等）提供了空实现。你只需要覆盖你关心的方法。

以下是一个自定义处理程序的示例：

```java
import org.xml.sax.Attributes;
import org.xml.sax.helpers.DefaultHandler;

public class MyHandler extends DefaultHandler {
    // 变量来累积文本内容
    private StringBuilder content = new StringBuilder();

    @Override
    public void startElement(String uri, String localName, String qName, Attributes attributes) {
        // 为新元素清除内容缓冲区
        content.setLength(0);
        System.out.println("开始元素: " + qName);

        // 如果元素有属性，处理它们
        for (int i = 0; i < attributes.getLength(); i++) {
            System.out.println("属性: " + attributes.getQName(i) + " = " + attributes.getValue(i));
        }
    }

    @Override
    public void characters(char[] ch, int start, int length) {
        // 累积文本内容（可能会在一个元素的内容中多次调用）
        content.append(ch, start, length);
    }

    @Override
    public void endElement(String uri, String localName, String qName) {
        // 处理累积的文本内容
        String text = content.toString().trim();
        if (!text.isEmpty()) {
            System.out.println("内容: " + text);
        }
        System.out.println("结束元素: " + qName);
        content.setLength(0); // 为下一个元素重置
    }

    @Override
    public void startDocument() {
        System.out.println("文档解析开始");
    }

    @Override
    public void endDocument() {
        System.out.println("文档解析完成");
    }
}
```

- **`startElement`**：当解析器遇到元素的开始时调用。参数包括：
  - `uri`：命名空间 URI（如果启用命名空间感知）。
  - `localName`：元素的本地名称（不包括前缀，如果启用命名空间感知）。
  - `qName`：限定名称（包括前缀，如果有）。
  - `attributes`：元素的属性列表。
- **`characters`**：在元素内调用文本内容。请注意，这可能会在一个元素的内容中多次调用，因此使用 `StringBuilder` 来累积它。
- **`endElement`**：当元素结束时调用。
- **`startDocument` 和 `endDocument`**：在 XML 文档的开始和结束时调用。

---

### 第 3 步：解析 XML
准备好解析器和处理程序后，可以通过在 `SAXParser` 上调用 `parse` 方法并传递你的处理程序来解析 XML 源（例如文件、`InputStream` 或字符串）。

以下是如何解析 XML 文件：

```java
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import java.io.File;

public class SAXExample {
    public static void main(String[] args) {
        try {
            // 创建解析器
            SAXParserFactory factory = SAXParserFactory.newInstance();
            SAXParser parser = factory.newSAXParser();

            // 创建处理程序
            MyHandler handler = new MyHandler();

            // 解析一个 XML 文件
            File xmlFile = new File("example.xml");
            parser.parse(xmlFile, handler);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

- **`parser.parse`**：接受一个 XML 源（例如 `File`）和一个 `DefaultHandler`。它可能会抛出 `IOException`（输入错误）或 `SAXException`（解析错误）。

对于 XML 字符串而不是文件，使用 `InputSource`：

```java
import org.xml.sax.InputSource;
import java.io.StringReader;

// 在 main 方法内
String xml = "<book><title>XML 解析</title></book>";
InputSource inputSource = new InputSource(new StringReader(xml));
parser.parse(inputSource, handler);
```

---

### 第 4 步：处理异常
SAX 解析涉及几种异常，你应该处理：

- **`ParserConfigurationException`**：由 `newSAXParser()` 抛出，如果解析器无法配置。
- **`SAXException`**：由 `newSAXParser()` 或 `parse()` 抛出，用于一般解析错误。
- **`IOException`**：由 `parse()` 抛出，如果读取输入源时出现问题。

将代码包装在 `try-catch` 块中：

```java
try {
    SAXParserFactory factory = SAXParserFactory.newInstance();
    SAXParser parser = factory.newSAXParser();
    MyHandler handler = new MyHandler();
    parser.parse(new File("example.xml"), handler);
} catch (ParserConfigurationException e) {
    System.err.println("解析器配置错误: " + e.getMessage());
} catch (SAXException e) {
    System.err.println("SAX 错误: " + e.getMessage());
} catch (IOException e) {
    System.err.println("IO 错误: " + e.getMessage());
}
```

---

### 第 5 步：可选功能
#### 错误处理
`DefaultHandler` 也实现了 `ErrorHandler`。覆盖其方法以处理解析错误：

```java
public class MyHandler extends DefaultHandler {
    @Override
    public void error(SAXParseException e) {
        System.err.println("解析错误: " + e.getMessage());
    }

    @Override
    public void fatalError(SAXParseException e) throws SAXException {
        System.err.println("致命错误: " + e.getMessage());
        throw e; // 停止解析
    }

    @Override
    public void warning(SAXParseException e) {
        System.out.println("警告: " + e.getMessage());
    }
    // 其他方法如上
}
```

#### 命名空间处理
如果你的 XML 使用命名空间，设置 `factory.setNamespaceAware(true)`，并在处理程序方法中使用 `uri` 和 `localName` 而不是 `qName` 来正确识别元素。

#### 验证
要验证 XML 文件是否符合 DTD 或模式，设置 `factory.setValidating(true)`。你可能还需要一个 `ErrorHandler` 来管理验证错误。

---

### 示例 XML 和输出
对于 XML 文件 `example.xml`：
```xml
<book id="123">
    <title>XML 解析</title>
    <author>John Doe</author>
</book>
```

运行上述代码可能输出：
```
文档解析开始
开始元素: book
属性: id = 123
开始元素: title
内容: XML 解析
结束元素: title
开始元素: author
内容: John Doe
结束元素: author
结束元素: book
文档解析完成
```

---

### 总结
使用 `org.xml.sax`：
1. 使用 `SAXParserFactory` 创建一个 `SAXParser`。
2. 通过扩展 `DefaultHandler` 并覆盖 `startElement`、`endElement` 和 `characters` 等方法来实现处理程序。
3. 通过调用 `parser.parse()` 并传递你的处理程序和 XML 源来解析 XML。
4. 处理异常（`SAXException`、`IOException`、`ParserConfigurationException`）。
5. 可选地配置命名空间感知、验证或错误处理。

这种方法适用于高效解析大 XML 文档，当你只需要提取特定数据而不需要构建内存树时。