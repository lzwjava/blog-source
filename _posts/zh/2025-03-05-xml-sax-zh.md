---
audio: false
generated: true
lang: zh
layout: post
title: 使用SAX（XML简单API）
translated: true
type: note
---

要在 Java 中使用 `org.xml.sax` 包解析 XML 文档，可以遵循基于 SAX（XML 简单 API）解析方法的直观流程。SAX 是一种事件驱动解析器，它会顺序读取 XML 文档，并在遇到文档的不同部分（如元素或文本内容）时触发回调方法。这种解析方式内存效率高，特别适用于大型 XML 文件，因为它不像 DOM 那样需要将整个文档加载到内存中。以下是使用 `org.xml.sax` 的详细步骤指南。

---

### 步骤 1：配置 SAX 解析器
要开始使用 SAX 解析 XML，需要通过 `SAXParserFactory` 类创建 `SAXParser` 实例。该工厂类允许在创建解析器前配置其行为。

创建 `SAXParser` 的方法如下：

```java
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;

public class SAXExample {
    public static void main(String[] args) {
        try {
            // 创建 SAXParserFactory 实例
            SAXParserFactory factory = SAXParserFactory.newInstance();

            // 可选：配置工厂（例如启用命名空间感知）
            factory.setNamespaceAware(true); // 如果 XML 使用命名空间则设为 true

            // 创建 SAXParser
            SAXParser parser = factory.newSAXParser();

            // 后续步骤将在此添加
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

- **`SAXParserFactory.newInstance()`**：创建新工厂实例
- **`factory.setNamespaceAware(true)`**：可选配置。若 XML 使用命名空间则启用命名空间处理，默认值为 `false`
- **`factory.newSAXParser()`**：创建 `SAXParser`。若解析器无法配置或初始化，可能抛出 `ParserConfigurationException` 或 `SAXException`

---

### 步骤 2：创建 XML 事件处理器
SAX 解析依赖处理器来处理遇到的 XML 事件，例如元素开始、元素结束或文本内容。主要处理接口是 `ContentHandler`，但为简化操作，您可以扩展 `DefaultHandler` 类，该类提供了 `ContentHandler` 和其他处理器接口（`ErrorHandler`、`DTDHandler` 等）的空实现。只需重写需要关注的方法即可。

以下是自定义处理器的示例：

```java
import org.xml.sax.Attributes;
import org.xml.sax.helpers.DefaultHandler;

public class MyHandler extends DefaultHandler {
    // 用于累积文本内容的变量
    private StringBuilder content = new StringBuilder();

    @Override
    public void startElement(String uri, String localName, String qName, Attributes attributes) {
        // 为新元素清空内容缓冲区
        content.setLength(0);
        System.out.println("开始元素: " + qName);

        // 如果元素有属性，则处理属性
        for (int i = 0; i < attributes.getLength(); i++) {
            System.out.println("属性: " + attributes.getQName(i) + " = " + attributes.getValue(i));
        }
    }

    @Override
    public void characters(char[] ch, int start, int length) {
        // 累积文本内容（每个元素可能调用多次）
        content.append(ch, start, length);
    }

    @Override
    public void endElement(String uri, String localName, String qName) {
        // 处理累积的文本内容
        String text = content.toString().trim();
        if (!text.isEmpty()) {
            System.out.println("内容: " + text);
        }
        System.out.println("结束元素: " + qName);
        content.setLength(0); // 为下一个元素重置
    }

    @Override
    public void startDocument() {
        System.out.println("文档解析开始");
    }

    @Override
    public void endDocument() {
        System.out.println("文档解析完成");
    }
}
```

- **`startElement`**：解析器遇到元素开始时调用。参数包括：
  - `uri`：命名空间 URI（如果启用命名空间感知）
  - `localName`：元素本地名称（如果启用命名空间感知则不包含前缀）
  - `qName`：元素限定名（包含前缀）
  - `attributes`：元素属性列表
- **`characters`**：处理元素内的文本内容。注意单个元素的内容可能分多次调用，建议使用 `StringBuilder` 累积内容
- **`endElement`**：元素结束时调用
- **`startDocument` 和 `endDocument`**：分别在 XML 文档开始和结束时调用

---

### 步骤 3：解析 XML
准备好解析器和处理器后，可通过调用 `SAXParser` 的 `parse` 方法并传入处理器来解析 XML 源（如文件、`InputStream` 或字符串）。

解析 XML 文件的方法如下：

```java
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import java.io.File;

public class SAXExample {
    public static void main(String[] args) {
        try {
            // 创建解析器
            SAXParserFactory factory = SAXParserFactory.newInstance();
            SAXParser parser = factory.newSAXParser();

            // 创建处理器
            MyHandler handler = new MyHandler();

            // 解析 XML 文件
            File xmlFile = new File("example.xml");
            parser.parse(xmlFile, handler);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

- **`parser.parse`**：接收 XML 源（如 `File`）和 `DefaultHandler`。可能抛出 `IOException`（输入错误）或 `SAXException`（解析错误）

若需解析字符串而非文件，可使用 `InputSource`：

```java
import org.xml.sax.InputSource;
import java.io.StringReader;

// 在 main 方法内
String xml = "<book><title>XML Parsing</title></book>";
InputSource inputSource = new InputSource(new StringReader(xml));
parser.parse(inputSource, handler);
```

---

### 步骤 4：异常处理
SAX 解析涉及以下几种需要处理的异常：

- **`ParserConfigurationException`**：`newSAXParser()` 在解析器无法配置时抛出
- **`SAXException`**：`newSAXParser()` 或 `parse()` 在解析错误时抛出
- **`IOException`**：`parse()` 在读取输入源出现问题时抛出

使用 `try-catch` 代码块包装解析逻辑：

```java
try {
    SAXParserFactory factory = SAXParserFactory.newInstance();
    SAXParser parser = factory.newSAXParser();
    MyHandler handler = new MyHandler();
    parser.parse(new File("example.xml"), handler);
} catch (ParserConfigurationException e) {
    System.err.println("解析器配置错误: " + e.getMessage());
} catch (SAXException e) {
    System.err.println("SAX 错误: " + e.getMessage());
} catch (IOException e) {
    System.err.println("IO 错误: " + e.getMessage());
}
```

---

### 步骤 5：可选功能
#### 错误处理
`DefaultHandler` 同样实现了 `ErrorHandler`。通过重写其方法可处理解析错误：

```java
public class MyHandler extends DefaultHandler {
    @Override
    public void error(SAXParseException e) {
        System.err.println("解析错误: " + e.getMessage());
    }

    @Override
    public void fatalError(SAXParseException e) throws SAXException {
        System.err.println("致命错误: " + e.getMessage());
        throw e; // 停止解析
    }

    @Override
    public void warning(SAXParseException e) {
        System.out.println("警告: " + e.getMessage());
    }
    // 其他方法同上
}
```

#### 命名空间处理
如果 XML 使用命名空间，需设置 `factory.setNamespaceAware(true)`，并在处理器方法中使用 `uri` 和 `localName` 而非 `qName` 来正确识别元素。

#### 验证功能
要通过 DTD 或模式验证 XML，需设置 `factory.setValidating(true)`。同时可能需要 `ErrorHandler` 来处理验证错误。

---

### 示例 XML 与输出
假设存在 `example.xml` 文件：
```xml
<book id="123">
    <title>XML Parsing</title>
    <author>John Doe</author>
</book>
```

运行上述代码可能输出：
```
文档解析开始
开始元素: book
属性: id = 123
开始元素: title
内容: XML Parsing
结束元素: title
开始元素: author
内容: John Doe
结束元素: author
结束元素: book
文档解析完成
```

---

### 总结
使用 `org.xml.sax` 的要点：
1. 通过 `SAXParserFactory` 创建 `SAXParser`
2. 通过扩展 `DefaultHandler` 并重写 `startElement`、`endElement` 和 `characters` 等方法实现处理器
3. 调用 `parser.parse()` 传入处理器和 XML 源进行解析
4. 处理异常（`SAXException`、`IOException`、`ParserConfigurationException`）
5. 可选配置命名空间感知、验证功能或错误处理

这种方法适用于高效解析大型 XML 文档，特别适合只需提取特定数据而不需要构建内存树结构的场景。