---
audio: false
generated: true
image: false
lang: zh
layout: post
model: openai/gpt-5
title: 3x3矩阵求逆
translated: true
type: note
---

好的——让我们清晰直观地逐步解析，不使用表格格式，以便逐行阅读。  

---

### 1. 目标是什么  
我们想求一个 3×3 矩阵的逆，通常写作 A⁻¹。  
逆矩阵是能够“抵消”A 作用的矩阵，即  
A × A⁻¹ = I，  
其中 I 是单位矩阵。  

---

### 2. 核心公式  
任意可逆方阵的通用公式为  

A⁻¹ = (1 / det(A)) × adj(A)。  

因此我们需要两个要素：  
- 行列式 det(A)，以及  
- 伴随矩阵 adj(A)，它是余子矩阵的转置。  

---

### 3. 3×3 矩阵的行列式  
如果  
A =  
[a  b  c]  
[d  e  f]  
[g  h  i]，  

那么  

det(A) = a(ei − fh) − b(di − fg) + c(dh − eg)。  

这个值告诉你矩阵是否可逆：  
- 如果 det(A) = 0 → 没有逆（矩阵是奇异的），  
- 如果 det(A) ≠ 0 → 逆存在。  

---

### 4. 余子式  
为了构造 adj(A)，我们首先求每个元素的余子式。  
元素 aᵢⱼ 的余子式为  
Cᵢⱼ = (−1)^(i+j) × Mᵢⱼ，  
其中 Mᵢⱼ 是删除第 i 行和第 j 列后得到的 2×2 子矩阵的行列式。  

对所有九个位置执行此操作，得到“余子矩阵”。  
对于上述一般情况：  

C₁₁ = ei − fh  
C₁₂ = −(di − fg)  
C₁₃ = dh − eg  

C₂₁ = −(bi − ch)  
C₂₂ = ai − cg  
C₂₃ = −(ah − bg)  

C₃₁ = bf − ce  
C₃₂ = −(af − cd)  
C₃₃ = ae − bd  

---

### 5. 转置余子矩阵  
现在取该余子矩阵并转置——即交换行和列。  
这个新矩阵称为 A 的**伴随矩阵**，记作 adj(A)。  
如果形象地理解，“转置”就像旋转矩阵：原本在第一行的元素现在变成第一列，依此类推。  

---

### 6. 乘以 1/det(A)  
最后，将伴随矩阵的每一项除以 det(A) 进行缩放。  
这样就得到了 A⁻¹。  

符号表示：  
A⁻¹ = (1/det(A)) × adj(A)。  

---

### 7. 为什么这个方法有效  
这个公式源于行列式和余子式的基本性质：  

A × adj(A) = det(A) × I。  

如果两边同时除以 det(A)，正好得到  
A × [(1/det(A)) × adj(A)] = I。  

因此右边的因子必然是逆矩阵。  

该恒等式成立的原因是，当你将 A 乘以其余子矩阵时，每个对角线项都变成了行列式本身（因为它是沿该行的展开式），而每个非对角线项由于交替的余子式符号而变为零——这是代数消去在起作用。  

---

### 8. 示例  
设  
A =  
[1  2  3]  
[0  1  4]  
[5  6  0]。  

计算 det(A)：  
= 1(1×0 − 4×6) − 2(0×0 − 4×5) + 3(0×6 − 1×5)  
= (−24) − (−40) + (−15)  
= −24 + 40 − 15 = 1。  

所以 det(A) = 1。  

然后找出所有余子式（有点繁琐但直接），转置得到 adj(A)，由于 det(A) = 1，伴随矩阵本身就是逆矩阵。  

---

### 9. 直观总结  
- 行列式 → 衡量矩阵“缩放空间”的程度。  
- 余子式 → 捕捉每个元素对该缩放的贡献。  
- 转置 → 对齐这些贡献，使乘法能够重构单位矩阵。  
- 除以行列式 → 归一化缩放效果。  

---

需要我展示该示例（即 [1 2 3; 0 1 4; 5 6 0]）的详细余子式计算过程吗？这样你可以看到每个子式和符号的处理。