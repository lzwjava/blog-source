---
audio: false
generated: true
lang: zh
layout: post
title: 在Java中使用Apache Kafka
translated: true
type: note
---

在 Java 中使用 Apache Kafka 需要设置 Kafka 客户端来生产和消费消息。Kafka 是一个分布式流处理平台，其 Java 客户端库可以轻松集成。下面我将带您了解基本入门步骤。

首先需要配置环境。确保已在系统或服务器上安装并运行 Kafka。您可以从 Apache Kafka 官网下载，并通过提供的脚本启动 ZooKeeper 和 Kafka 服务器。为简化说明，我假设您使用默认配置在本地运行 Kafka（例如使用 `localhost:9092` 作为引导服务器）。

接下来在 Java 项目中添加 Kafka 客户端依赖。若使用 Maven，请在 `pom.xml` 中添加：

```xml
<dependency>
    <groupId>org.apache.kafka</groupId>
    <artifactId>kafka-clients</artifactId>
    <version>3.6.0</version> <!-- 请使用最新版本 -->
</dependency>
```

现在让我们编写代码。我将演示如何创建简单的生产者和消费者。

### Kafka 生产者示例
生产者负责向 Kafka 主题发送消息。基础示例如下：

```java
import org.apache.kafka.clients.producer.*;
import java.util.Properties;

public class SimpleProducer {
    public static void main(String[] args) {
        // 配置生产者属性
        Properties props = new Properties();
        props.put("bootstrap.servers", "localhost:9092"); // Kafka 服务器地址
        props.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer");
        props.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer");

        // 创建生产者实例
        try (Producer<String, String> producer = new KafkaProducer<>(props)) {
            // 向名为 "test-topic" 的主题发送消息
            String topic = "test-topic";
            for (int i = 0; i < 10; i++) {
                String key = "key" + i;
                String value = "Hello, Kafka " + i;
                ProducerRecord<String, String> record = new ProducerRecord<>(topic, key, value);

                producer.send(record, (metadata, exception) -> {
                    if (exception == null) {
                        System.out.println("已发送消息: " + value + " 至分区 " + metadata.partition());
                    } else {
                        exception.printStackTrace();
                    }
                });
            }
        }
    }
}
```

代码说明：
- `bootstrap.servers` 指定 Kafka 运行地址
- 序列化器定义键值对（此处均为字符串）如何转换为字节
- `ProducerRecord` 代表消息，`send()` 通过回调函数异步处理发送结果

### Kafka 消费者示例
消费者通过订阅主题来读取消息。示例如下：

```java
import org.apache.kafka.clients.consumer.*;
import java.util.Collections;
import java.util.Properties;

public class SimpleConsumer {
    public static void main(String[] args) {
        // 配置消费者属性
        Properties props = new Properties();
        props.put("bootstrap.servers", "localhost:9092");
        props.put("group.id", "test-group"); // 消费者组ID
        props.put("key.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");
        props.put("value.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");
        props.put("auto.offset.reset", "earliest"); // 从主题起始位置开始消费

        // 创建消费者实例
        try (KafkaConsumer<String, String> consumer = new KafkaConsumer<>(props)) {
            // 订阅主题
            consumer.subscribe(Collections.singletonList("test-topic"));

            // 轮询获取消息
            while (true) {
                ConsumerRecords<String, String> records = consumer.poll(1000); // 超时时间毫秒
                for (ConsumerRecord<String, String> record : records) {
                    System.out.printf("收到: key=%s, value=%s, partition=%d, offset=%d%n",
                            record.key(), record.value(), record.partition(), record.offset());
                }
            }
        }
    }
}
```

代码说明：
- `group.id` 用于消费者组协调
- 反序列化器将字节数据转换回字符串
- `poll()` 循环获取消息，`auto.offset.reset` 确保在无提交偏移量时从最早消息开始消费

### 运行代码
1. **启动 Kafka**：确保 ZooKeeper 和 Kafka 正在运行（类 Unix 系统可执行 `bin/zookeeper-server-start.sh config/zookeeper.properties` 和 `bin/kafka-server-start.sh config/server.properties`）
2. **创建主题**：使用 Kafka 命令行工具创建 `test-topic`（若不存在）：`bin/kafka-topics.sh --create --topic test-topic --bootstrap-server localhost:9092 --partitions 1 --replication-factor 1`
3. **运行生产者**：执行 `SimpleProducer` 类发送消息
4. **运行消费者**：执行 `SimpleConsumer` 类查看消息消费

### 实用建议
- **错误处理**：生产环境请添加 try-catch 块或日志记录
- **配置调优**：根据需求调整 `acks`（生产者可靠性）或 `max.poll.records`（消费者批处理大小）等参数
- **开发库**：复杂应用建议使用 Spring Kafka 简化配置

以上是基础入门指南。如果您想深入了解分区策略、错误处理或大型应用集成等特性，欢迎随时交流！