---
audio: false
generated: true
lang: zh
layout: post
title: WebGL指南
translated: true
type: note
---

让我们深入了解 WebGL（Web图形库）的完整指南。内容涵盖其定义、工作原理、应用价值、入门方法及更广泛的背景知识——非常适合理解它在 Figma 等工具或更广泛领域中的作用。系好安全带，准备出发！

---

### **1. 什么是 WebGL？**
WebGL 是一种 JavaScript API，可将硬件加速的 2D 和 3D 图形技术引入网络。它基于 OpenGL ES（嵌入式系统），这是原生应用中使用的 OpenGL 标准的子集，并针对浏览器进行了适配。通过 WebGL，您可以直接利用 GPU 在 `<canvas>` 元素上渲染图形，绕过传统 HTML/CSS 基于 CPU 的较慢渲染方式。

- **主要特性：**
  - **硬件加速：** 利用 GPU 实现快速渲染。
  - **跨平台：** 可在所有主流浏览器（Chrome、Firefox、Safari、Edge）中运行。
  - **可编程：** 使用着色器（小型程序）定义外观和运动方式。
  - **无需插件：** 与 Flash 或旧技术不同，它是浏览器原生功能。

- **历史背景：**
  - 由 Khronos Group（OpenGL 的幕后团队）于 2011 年推出。
  - WebGL 1.0 基于 OpenGL ES 2.0；WebGL 2.0（2017年）则基于 OpenGL ES 3.0。

- **应用场景：**
  - 游戏（例如基于浏览器的 3D 游戏）。
  - 数据可视化（例如交互式图表或地图）。
  - 创意工具（例如 Figma 的矢量渲染）。
  - 模拟（例如物理引擎或 3D 建模）。

---

### **2. WebGL 的工作原理**
WebGL 通过 JavaScript API 提供对 GPU 的低层级访问。它围绕**渲染管线**构建——这是一系列将代码转换为屏幕上像素的步骤。

1. **设置：**
   - 在 HTML 中创建 `<canvas>` 元素。
   - 获取 WebGL 上下文：`canvas.getContext('webgl')`（或使用 `'webgl2'` 获取 2.0 版本）。

2. **着色器：**
   - **顶点着色器：** 定义 3D 空间中点（顶点）的位置。
   - **片段着色器：** 为顶点之间的每个像素着色。
   - 使用 GLSL（OpenGL 着色语言）编写，并在运行时编译。

3. **缓冲区：**
   - 数据（例如顶点位置、颜色）通过缓冲区存储在 GPU 内存中。
   - 示例：将三角形的三个角点作为坐标数组发送。

4. **渲染：**
   - 绑定缓冲区、设置着色器，并发出绘制调用（例如 `gl.drawArrays()`）。
   - GPU 并行处理这些指令，输出到画布上。

- **坐标系：** WebGL 使用标准化的 3D 空间（x、y、z 轴范围从 -1 到 1），您可以通过矩阵（例如用于透视或旋转）进行变换。

- **状态机：** WebGL 是无状态的——您需要在每次绘制调用前设置参数（例如纹理、混合模式）。

---

### **3. 为何使用 WebGL？**
- **性能：** 对于复杂图形，GPU 加速优于 CPU 渲染。
- **灵活性：** 着色器允许您自定义到像素级别的视觉效果。
- **网络集成：** 与 JavaScript、DOM 事件及其他 API 无缝协作。
- **无需安装：** 在任何可运行浏览器的地方均可使用。

**权衡考虑：**
- 学习曲线陡峭——与 HTML5 Canvas 2D 相比更为底层。
- 调试困难（GLSL 错误信息晦涩难懂）。
- 浏览器兼容性可能有所不同（尤其是 WebGL 2.0）。

---

### **4. WebGL 入门**
让我们渲染一个简单的彩色三角形，亲身体验 WebGL。

#### **步骤 1：HTML 设置**
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
</head>
<body>
    <canvas id="glCanvas" width="400" height="400"></canvas>
    <script>
        // JavaScript 代码放在这里
    </script>
</body>
</html>
```

#### **步骤 2：JavaScript 基础**
在 `<script>` 标签内添加以下代码：
```javascript
// 获取画布和上下文
const canvas = document.getElementById('glCanvas');
const gl = canvas.getContext('webgl');
if (!gl) {
    alert('不支持 WebGL！');
}

// 顶点着色器源码（GLSL）
const vsSource = `
    attribute vec2 a_position;
    void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
    }
`;

// 片段着色器源码（GLSL）
const fsSource = `
    void main() {
        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); // 红色
    }
`;

// 编译着色器
function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
    }
    return shader;
}

const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);

// 链接成程序
const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);
if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error(gl.getProgramInfoLog(program));
}

// 顶点数据（一个三角形）
const positions = new Float32Array([
    0.0,  0.5,  // 顶部
   -0.5, -0.5,  // 左下角
    0.5, -0.5   // 右下角
]);

// 缓冲区设置
const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

// 告诉 WebGL 如何读取缓冲区
const positionLocation = gl.getAttribLocation(program, 'a_position');
gl.enableVertexAttribArray(positionLocation);
gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

// 清除并绘制
gl.clearColor(0.0, 0.0, 0.0, 1.0); // 黑色背景
gl.clear(gl.COLOR_BUFFER_BIT);
gl.useProgram(program);
gl.drawArrays(gl.TRIANGLES, 0, 3); // 绘制 3 个顶点
```

#### **步骤 3：测试**
- 保存为 `index.html`，启动服务器（例如使用 `python -m http.server 8080`），并在浏览器中打开。
- 您将看到黑色背景上的红色三角形。

---

### **5. 核心概念**
- **着色器：** 顶点着色器定位几何体；片段着色器为其着色。GLSL 类似 C 语言，但针对 GPU 特定优化。
- **缓冲区：** 在 GPU 内存中存储顶点数据（位置、法线、颜色）。
- **纹理：** 映射到 3D 对象上的 2D 图像（例如使用 `gl.texImage2D()`）。
- **矩阵：** 通过如 `glMatrix` 等库进行变换（平移、旋转、缩放）。
- **绘制调用：** `gl.drawArrays()` 用于简单形状；`gl.drawElements()` 用于索引几何体。

**WebGL 2.0 新增功能：**
- 更好的纹理（例如 3D 纹理）。
- 多渲染目标。
- 增强的着色器功能（例如统一缓冲区对象）。

---

### **6. 生态系统与工具**
- **库：**
  - **Three.js：** 高层 3D 框架（隐藏原始 WebGL 复杂性）。
  - **Babylon.js：** 专注于游戏的 3D 引擎。
  - **PixiJS：** 2D 渲染，支持 WebGL 回退。
  - **glMatrix：** 用于变换的数学工具。

- **浏览器支持：**
  - WebGL 1.0：几乎全面支持。
  - WebGL 2.0：大多数现代浏览器支持（请查看 caniuse.com）。

- **调试：**
  - 浏览器开发者工具（例如 Chrome 的 WebGL 检查器）。
  - 如 Spector.js 等扩展。

---

### **7. WebGL 实际应用**
- **Figma：** 使用 WebGL 进行矢量图形渲染，并结合 WebAssembly 进行计算。
- **游戏：** Unity 和 Unreal Engine 可导出为 WebGL，以便在浏览器中运行。
- **地图：** Google Maps 和 Mapbox 使用它实现平滑缩放和 3D 地形。

---

### **8. 未来展望**
- **WebGPU：** 下一代 API（基于 Vulkan/Metal）正在兴起，承诺更好的性能和现代功能。它目前并非替代品，而是补充。
- **更广泛的应用：** WebGL 目前仍占主导地位，尤其是随着 WebGL 2.0 的升级。

---

### **9. 资源推荐**
- **官方资源：** [webglfundamentals.org](https://webglfundamentals.org/)——出色的初学者教程。
- **MDN：** [WebGL 文档](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API)。
- **书籍：** Kouichi Matsuda 所著的《WebGL 编程指南》。
- **X 平台帖子：** 搜索 #WebGL 获取示例和社区技巧。

---

### **总结**
WebGL 是您在浏览器中通往 GPU 驱动图形的门户。它层级较低、功能强大，且有些令人生畏——但通过实践（和库的支持），您可以构建从简单动画到完整 3D 世界的任何内容。想尝试特定项目或深入研究着色器吗？请随时告诉我！