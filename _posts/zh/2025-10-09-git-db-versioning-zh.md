---
audio: false
generated: true
image: false
lang: zh
layout: post
model: x-ai/grok-4-fast
title: Git友好的数据库版本控制
translated: true
type: note
---

### 在 Git 友好型版本控制中选择 JSON（或 CSV）与 SQLite

对于包含 1-2 张数据表和 1-10 万条记录的小型数据库，JSON 和 SQLite 都是可行的选择，因为总文件大小应该可控（即使是密度较高的数据，通常也不会超过 10-50 MB）。您遇到的核心问题——每次更新时 Git 差异对比将整个文件视为二进制数据块——是数据库的常见问题。Git 擅长基于文本的差异对比，因此 JSON 等格式在这方面表现优异，而 SQLite（单个二进制文件）则需要通过变通方案才能实现可读的变更记录。

下面我将从优缺点进行分析，然后根据您的优先级给出建议。

#### 快速对比

| 对比维度           | JSON（或 CSV）                                                                 | SQLite                                                                 |
|--------------------|-------------------------------------------------------------------------------|------------------------------------------------------------------------|
| **文件格式**       | 基于文本（人类可读）。在 Git 中可轻松进行逐行差异对比。                  | 二进制文件。Git 默认显示全文件变更；差异对比结果不可读。 |
| **1-10万条记录的文件大小** | 若记录结构简单则文件较小（例如每条记录 1-5 KB → 总量 10-500 MB）。在 Git 中压缩效果良好。 | 大小相近，但无法通过文本差异获得压缩增益。                |
| **Git 体验**       | 极佳：可查看具体新增/编辑的行。使用 `git diff --word-diff` 等工具查看结构化变更。通过数据排序确保差异对比清晰。 | 开箱即用体验差。需通过自定义 git 配置修复（例如在差异对比时转储为 SQL）。或使用 Dolt 等支持类 Git 数据库版本控制的扩展工具。 |
| **更新操作**       | 保存时需完整重写，但若通过脚本选择性加载/编辑/保存，差异对比仍能高亮显示变更内容。 | 支持原子事务，但每次提交在 Git 中均显示为完整替换。 |
| **查询/功能**      | 基础功能（需通过 jq/Python 等代码进行筛选）。无索引/事务支持。适用于扁平化数据结构。 | 完整 SQL 支持：查询、连接（适用于 2 张表）、索引、约束。更适合需要"数据库"特性的场景。 |
| **适用场景**       | 若您的应用/脚本在内存中处理 CRUD 且优先考虑协作/差异对比，此为理想选择。 | 若需真实数据库操作且差异对比为次要需求时更合适。                   |
| **所需工具**       | 原生 Git + jq（用于 JSON）或 csvkit（用于 CSV）。                               | sqlite3 命令行工具 + 用于自定义差异对比的 git 属性配置。                         |

#### 建议方案
- **若清晰的差异对比是首要需求，请选择 JSON（或 CSV）**：该方案保持全文本格式且原生兼容 Git。针对 1-2 张表：
  - 使用 **单个 JSON 文件** 存储对象数组（例如 `[{"id":1, "name":"foo", ...}, ...]`）。对于简单关联关系（将一张表嵌入另一张表）具有灵活性。
  - 或使用 **CSV 文件**（每张表单独文件）处理严格表格数据——极度轻量且差异对比友好。Pandas 等工具可轻松加载/编辑/导出。
  - **工作流技巧**：保存前始终按 ID/键值对记录排序（例如在 Python 中：`df.sort_values('id').to_csv(...)`）。这样可确保差异对比仅显示真实变更，避免重排序干扰。更新时采用读取→修改特定行→排序→写入流程。文件大小保持较小，Git 历史记录清晰。
  - 缺点：对于 10 万条记录，每次将整个文件加载到内存可能较慢，需通过优化解决（例如使用 ijson 等流式处理库）。

- **若需要数据库功能，请使用 SQLite**：它在查询/连接方面更稳健，且单文件配置便于 Git 提交。解决差异对比问题的方法：
  - 添加 `.gitattributes` 文件：`*.db diff=sqlite` 并在 `.gitconfig` 中添加配置片段，实现在差异对比时将数据库转储为 SQL（例如通过 `sqlite3 db dump.sql`）。这样可将二进制变更转换为可读的 SQL 插入/更新语句。
  - 示例设置脚本（使用 bash/Python）：提交时，将架构/数据导出为 SQL 文件供审查。
  - 对于高级需求，可考虑 Dolt——它堪称"面向数据库的 Git"，支持可分支表格和规范差异对比，但对于小型设置略显臃肿。

建议从 JSON/CSV 入手以保持简洁——对于小规模场景"足够好用"，且符合您对 Git 的关切。若后续需求增长（例如需要复杂查询），再迁移至 SQLite。可对两种方案进行原型验证：将示例数据转储至文件并测试若干 Git 提交。

若您的记录具有特定结构，欢迎提供更多细节以获取定制化的代码片段。

[在 Git 中对 SQLite 进行版本控制](https://dunkels.com/adam/git-diff-sqlite3/)  
[小型数据场景中 JSON 与数据库的对比](https://www.reddit.com/r/flask/comments/lvccgo/using_a_database_such_as_sqlite3_versus_json_to/)  
[数据版本控制方案选型](https://dolthub.com/blog/2022-04-27-data-version-control/)