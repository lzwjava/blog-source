---
audio: false
generated: true
lang: zh
layout: post
title: 正则表达式
translated: true
type: note
---

正则表达式，常简称为 "regex" 或 "regexp"，是一种用于文本模式匹配的强大且多功能的工具。它们提供了一种简洁灵活的方式来基于定义的模式搜索、操作和验证字符串。虽然语法起初可能看起来令人生畏，但掌握正则表达式可以显著增强您在各种编程语言、文本编辑器和命令行工具中的文本处理能力。

本指南将带您从正则表达式的基础知识到更高级的概念。

**I. 基础：正则表达式的构建模块**

正则表达式的核心是一系列定义搜索模式的字符。这些字符可以是字面字符（匹配自身）或特殊字符（具有特定含义）。

**A. 字面字符：**

正则表达式中的大多数字符都按字面意义匹配自身。例如：

* `abc` 将匹配字符串中的确切序列 "abc"。
* `123` 将匹配确切序列 "123"。
* `hello` 将匹配确切序列 "hello"。

**B. 元字符：特殊能力**

元字符是赋予正则表达式威力的构建模块。它们具有特殊含义，不按字面意义匹配自身。以下是最常见的元字符：

1.  **`.` (点号):** 匹配除换行符（默认为 `\n`）之外的任何单个字符。
    * `a.c` 将匹配 "abc"、"adc"、"a1c"、"a c"，但不匹配 "ac" 或 "abbc"。

2.  **`^` (脱字符):**
    * **在字符集内部（见下文）:** 否定该集合，匹配任何*不*在集合中的字符。
    * **在字符集外部:** 匹配字符串的开头（或多行模式下行的开头）。
        * `^hello` 将匹配 "hello world" 但不匹配 "say hello"。

3.  **`$` (美元符号):** 匹配字符串的结尾（或多行模式下行的结尾）。
    * `world$` 将匹配 "hello world" 但不匹配 "world hello"。

4.  **`*` (星号):** 匹配前面的字符或组零次或多次。
    * `ab*c` 将匹配 "ac"、"abc"、"abbc"、"abbbc" 等等。

5.  **`+` (加号):** 匹配前面的字符或组一次或多次。
    * `ab+c` 将匹配 "abc"、"abbc"、"abbbc"，但不匹配 "ac"。

6.  **`?` (问号):**
    * 匹配前面的字符或组零次或一次（使其成为可选的）。
        * `ab?c` 将匹配 "ac" 和 "abc"，但不匹配 "abbc"。
    * 用作量词修饰符以使匹配变为非贪婪模式（见量词部分）。

7.  **`{}` (花括号):** 指定前面字符或组的确切出现次数或范围。
    * `a{3}` 匹配恰好三个 "a"（例如，"aaa"）。
    * `a{2,4}` 匹配两到四个 "a"（例如，"aa"、"aaa"、"aaaa"）。
    * `a{2,}` 匹配两个或更多个 "a"（例如，"aa"、"aaa"、"aaaa"、...）。

8.  **`[]` (方括号):** 定义一个字符集，匹配括号内的任何单个字符。
    * `[abc]` 将匹配 "a"、"b" 或 "c"。
    * `[a-z]` 将匹配从 "a" 到 "z" 的任何小写字母（范围）。
    * `[0-9]` 将匹配从 "0" 到 "9" 的任何数字。
    * `[A-Za-z0-9]` 将匹配任何字母数字字符。
    * `[^abc]`（以 `^` 开头）将匹配*除* "a"、"b" 或 "c" 之外的任何字符。

9.  **`\` (反斜杠):** 转义下一个字符，将元字符视为字面字符或引入特殊字符序列。
    * `\.` 将匹配一个字面点号 "."。
    * `\*` 将匹配一个字面星号 "*"。
    * `\d` 匹配任何数字（等同于 `[0-9]`）。
    * `\D` 匹配任何非数字字符（等同于 `[^0-9]`）。
    * `\s` 匹配任何空白字符（空格、制表符、换行符等）。
    * `\S` 匹配任何非空白字符。
    * `\w` 匹配任何单词字符（字母数字和下划线，等同于 `[a-zA-Z0-9_]`）。
    * `\W` 匹配任何非单词字符（等同于 `[^a-zA-Z0-9_]`）。
    * `\b` 匹配单词边界（单词字符和非单词字符之间的位置）。
    * `\B` 匹配非单词边界。
    * `\n` 匹配换行符。
    * `\r` 匹配回车符。
    * `\t` 匹配制表符。

10. **`|` (竖线符号):** 充当 "或" 运算符，匹配竖线之前或之后的表达式。
    * `cat|dog` 将匹配 "cat" 或 "dog"。

11. **`()` (圆括号):**
    * **分组:** 将正则表达式的部分组合在一起，允许您将量词或 OR 运算符应用于整个组。
        * `(ab)+c` 将匹配 "abc"、"ababc"、"abababc" 等等。
        * `(cat|dog) food` 将匹配 "cat food" 或 "dog food"。
    * **捕获组:** 捕获括号内表达式匹配的文本。这些捕获的组可以在以后引用（例如，用于替换或提取）。

**II. 量词：控制重复**

量词指定前一个元素（字符、组或字符集）可以出现的次数。

* `*`: 零次或多次
* `+`: 一次或多次
* `?`: 零次或一次
* `{n}`: 恰好 `n` 次
* `{n,}`: `n` 次或更多次
* `{n,m}`: 在 `n` 到 `m` 次之间（包含）

**贪婪与非贪婪匹配：**

默认情况下，量词是**贪婪的**，这意味着它们尝试匹配尽可能多的字符串。您可以通过在量词后添加 `?` 来使其变为**非贪婪的**（或懒惰的）。非贪婪量词尝试匹配尽可能短的字符串。

* `a.*b`（贪婪）在 "axxbxb" 上将匹配 "axxbxb"。
* `a.*?b`（非贪婪）在 "axxbxb" 上将匹配 "axb" 然后是 "xb"。

**III. 锚点：指定位置**

锚点本身不匹配任何字符，而是断言字符串内的一个位置。

* `^`: 匹配字符串（或行）的开头。
* `$`: 匹配字符串（或行）的结尾。
* `\b`: 匹配单词边界。
* `\B`: 匹配非单词边界。

**IV. 字符类：预定义集合**

字符类为常用字符集提供了简写形式。

* `\d`: 匹配任何数字（0-9）。
* `\D`: 匹配任何非数字字符。
* `\s`: 匹配任何空白字符（空格、制表符、换行符、回车符、换页符）。
* `\S`: 匹配任何非空白字符。
* `\w`: 匹配任何单词字符（字母数字和下划线：a-zA-Z0-9_）。
* `\W`: 匹配任何非单词字符。

**V. 分组与捕获**

圆括号 `()` 有两个主要目的：

* **分组:** 允许您将量词或 OR 运算符应用于一系列字符。
* **捕获:** 创建一个捕获组，该组存储与括号内表达式匹配的字符串部分。这些捕获的组可以被访问并用于反向引用或替换。

**反向引用：**

您可以在同一个正则表达式中使用 `\1`、`\2`、`\3` 等引用先前捕获的组，其中数字对应于捕获组开括号的顺序。

* `(.)\1` 将匹配任何字符后跟相同字符（例如，"aa"、"bb"、"11"）。
* `(\w+) \1` 将匹配一个单词后跟一个空格，然后是同一个单词（例如，"hello hello"）。

**非捕获组：**

如果您需要对正则表达式的部分进行分组而不创建捕获组，可以使用 `(?:...)`。这对于提高清晰度或性能很有用。

* `(?:ab)+c` 将匹配 "abc"、"ababc" 等，但不会捕获 "ab"。

**VI. 环视：不消耗字符的断言**

环视是零宽度断言，它们检查字符串中当前位置之前或之后的模式，而不将匹配的环视部分包含在整体匹配中。

* **正向先行断言 `(?=...)`:** 断言括号内的模式必须跟在当前位置之后。
    * `\w+(?=:)` 将匹配任何后跟冒号的单词，但冒号本身不会成为匹配的一部分（例如，在 "name:" 中，它将匹配 "name"）。

* **负向先行断言 `(?!...)`:** 断言括号内的模式必须*不*跟在当前位置之后。
    * `\w+(?!:)` 将匹配任何不后跟冒号的单词（例如，在 "name value" 中，它将匹配 "name" 和 "value"）。

* **正向后行断言 `(?<=...)`:** 断言括号内的模式必须出现在当前位置之前。后行断言内的模式必须具有固定宽度（不能有像 `*` 或 `+` 这样的可变量词）。
    * `(?<=\$)\d+` 将匹配前面有美元符号的一个或多个数字，但美元符号本身不会成为匹配的一部分（例如，在 "$100" 中，它将匹配 "100"）。

* **负向后行断言 `(?<!...)`:** 断言括号内的模式必须*不*出现在当前位置之前。后行断言内的模式必须具有固定宽度。
    * `(?<!\$)\d+` 将匹配前面没有美元符号的一个或多个数字（例如，在 "100$" 中，它将匹配 "100"）。

**VII. 标志（修饰符）：控制正则表达式行为**

标志（或修饰符）用于改变正则表达式引擎的行为。它们通常在正则表达式模式的开头或结尾指定，具体取决于实现。常见的标志包括：

* **`i` (不区分大小写):** 使匹配不区分大小写。`[a-z]` 将匹配小写和大写字母。
* **`g` (全局):** 查找字符串中的所有匹配项，而不仅仅是第一个。
* **`m` (多行):** 使 `^` 和 `$` 匹配每行的开头和结尾（由 `\n` 或 `\r` 分隔），而不仅仅是整个字符串的开头和结尾。
* **`s` (点号匹配所有/单行):** 使 `.` 元字符匹配任何字符，包括换行符。
* **`u` (Unicode):** 为字符类和其他功能启用完整的 Unicode 支持。
* **`x` (扩展/详细):** 允许您通过忽略模式中的空格和注释来编写更易读的正则表达式（对于复杂的正则表达式很有用）。

**VIII. 正则表达式的实际应用**

正则表达式广泛用于各个领域：

* **文本编辑器（例如 Notepad++、Sublime Text、VS Code）:** 基于模式查找和替换文本。
* **编程语言（例如 Python、JavaScript、Java、C#）:**
    * 验证用户输入（例如，电子邮件地址、电话号码、URL）。
    * 从文本中提取特定信息（例如，日期、数字、标签）。
    * 基于模式替换字符串的部分内容。
    * 解析日志文件或其他结构化文本数据。
* **命令行工具（例如 `grep`、`sed`、`awk`）:** 搜索和操作文本文件。
* **Web 开发:** 表单验证、URL 路由、内容处理。
* **数据科学:** 数据清理、数据提取、模式识别。
* **安全:** 入侵检测、日志分析。

**IX. 不同编程语言中的正则表达式**

大多数现代编程语言都内置了对正则表达式的支持，尽管具体的语法和功能可能略有不同。您通常可以在标准库或模块中找到正则表达式功能。

* **Python:** `re` 模块。
* **JavaScript:** 内置的 `RegExp` 对象和字符串方法，如 `match()`、`replace()`、`search()`、`split()`。
* **Java:** `java.util.regex` 包。
* **C# (.NET):** `System.Text.RegularExpressions` 命名空间。
* **PHP:** 函数如 `preg_match()`、`preg_replace()`、`preg_match_all()`。

**X. 编写有效正则表达式的技巧**

* **从简单开始:** 从一个基本模式开始，逐渐增加复杂性。
* **频繁测试:** 使用在线正则表达式测试器或您编程语言的正则表达式工具来针对样本数据测试您的模式。
* **要具体:** 避免过于宽泛的模式，以免匹配到意外的文本。
* **明智地使用字符类和量词:** 它们功能强大，但如果使用不当也可能导致意外行为。
* **理解贪婪与非贪婪匹配:** 根据您的需求选择适当的行为。
* **明智地使用分组和捕获:** 只捕获您需要的内容。当不需要捕获时，使用非捕获组。
* **记录您的正则表达式:** 对于复杂的模式，添加注释（尤其是在使用 `x` 标志时）以解释其目的。
* **考虑边缘情况:** 考虑输入文本的不同变体，并确保您的正则表达式能正确处理它们。
* **分解复杂问题:** 如果您有一个非常复杂的匹配任务，考虑将其分解为多个更简单的正则表达式模式。

**XI. 学习资源**

* **在线正则表达式测试器:** regex101.com, regexr.com, regextester.com
* **语言特定文档:** 参考您所选编程语言的正则表达式文档。
* **在线教程和课程:** Coursera、Udemy 和 YouTube 等平台提供全面的正则表达式课程。
* **书籍:** Jeffrey Friedl 的《精通正则表达式》是一个强烈推荐的资源。

**结论**

正则表达式是任何处理文本数据的人都不可或缺的工具。虽然最初的学习曲线可能看起来陡峭，但基于复杂模式高效搜索、操作和验证文本的能力是一项宝贵的技能。通过理解正则表达式的基本概念、元字符、量词和其他特性，您可以在广泛的应用中显著提高生产力和解决问题的能力。练习是掌握正则表达式的关键，所以不要犹豫，尝试并探索不同模式以应对各种文本处理任务。