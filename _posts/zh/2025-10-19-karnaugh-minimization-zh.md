---
audio: false
generated: true
image: false
lang: zh
layout: post
model: x-ai/grok-4-fast
title: 卡诺图化简实例
translated: true
type: note
---

### 卡诺图应用示例：最小化三变量布尔函数

让我们通过一个实际示例来演示如何使用卡诺图简化布尔表达式。我们将使用一个三变量函数（A, B, C），当最小项 m(1, 2, 4, 7) 时输出为 1。这意味着：

- f(A, B, C) = A'B'C + A'BC' + AB'C' + ABC

目标是将此表达式最小化为最少的项（和文字），从而减少电路中的逻辑门数量。

#### 步骤 1：构建卡诺图
三变量卡诺图是一个 2x4 网格（或 4x2，但我们将使用行表示 AB，列表示 C）。行按格雷码顺序（00, 01, 11, 10）标记，确保相邻单元格仅有一位不同。在与最小项对应的单元格中填入 1：

| AB \ C | 0     | 1     |
|--------|-------|-------|
| **00** | 0     | 1 (m1) |
| **01** | 1 (m2) | 0     |
| **11** | 0     | 1 (m7) |
| **10** | 1 (m4) | 0     |

（此处，m1 = A'B'C，m2 = A'BC'，m4 = AB'C'，m7 = ABC。）

#### 步骤 2：分组相邻的 1
最小化的关键在于找到尽可能大的相邻 1 组（矩形或正方形，包括环绕边缘，如环形）。每组的大小必须是 2 的幂（1, 2, 4, 8 等）。组可以重叠。

- **组 1**：左列中的两个 1（m2 和 m4）形成一个垂直对。它们共享 A'B'C'？等等——分析位：m2 (010) 和 m4 (100) 仅在 A 和 B 上不同，但在格雷码中，行 01 和 10 是相邻的。该组覆盖了 A 的变化，因此是 B'C'（A 是无关项）。
- **组 2**：右列中的两个 1（m1 和 m7）形成一个垂直对，可以环绕（行 00 和 11 不直接相邻，等等——实际上对于此映射，更好的分组是：注意 m1 (001) 和 m2 (010) 在行 00-01 中是水平相邻的吗？等等，让我们更正。

等等，为了清晰起见重新绘制——实际上，此函数的最优分组：

- 水平对：m1（行00 列1）和 m2（行01 列0）？不，不相邻。
这些最小项的标准分组：
- 四元组？不。对：
  - m1 和 m2？m1=001，m2=010——相差两位，不相邻。
  更好：m2 (010) 和 m4 (100)——在 A 和 B 上不同？010 和 100 在 A（0 到 1）和 B（1 到 0）上不同，两位——不相邻。

我选了一个不好的示例——让我选一个具有清晰组别的更好示例来说明。

**为清晰起见修订的示例**：让我们使用 f(A, B, C) = Σ m(0, 1, 2, 4, 5, 6) = A'B'C' + A'B'C + A'BC' + AB'C' + AB'C + ABC'

卡诺图：

| AB \ C | 0     | 1     |
|--------|-------|-------|
| **00** | 1 (m0) | 1 (m1) |
| **01** | 1 (m2) | 0 (m3) |
| **11** | 1 (m6) | 0 (m7) |
| **10** | 1 (m4) | 1 (m5) |

最小项：0(000),1(001),2(010),4(100),5(101),6(110)——是的 m3(011)=0, m7(111)=0。

所以表格：

| AB \ C | 0     | 1     |
|--------|-------|-------|
| **00** | 1     | 1     |
| **01** | 1     | 0     |
| **11** | 1     | 0     |
| **10** | 1     | 1     |

#### 步骤 3：识别组
现在，对 1 进行分组：

- **大组（4 个 1）**：整个左列（C=0）：m0, m2, m6, m4。这些是所有 C=0 的单元格，AB 变化——全部在列中相邻（行可环绕）。这覆盖了 **C'**（因为 C 是 0，A 和 B 是无关项）。
- **对组（2 个 1）**：顶部行右侧（m0 和 m1？m0 列0，m1 列1——行 00 中的水平对：A'B'（C 是无关项）。
- 但 m1 (001) 尚未覆盖？等等，顶部行：m0 和 m1 水平相邻，覆盖 A'B'（C 变化）。
- 还有，底部行右侧 m5 (101 列1 行10)——但要覆盖 m1 和 m5？它们在列1，行 00 和 10，这两行是相邻的（环绕），所以列1 中的垂直对：m1 和 m5，覆盖 AC（等等，位：001 和 101 = A 无关，B=0，C=1？001 B=0 C=1，101 A=1 B=0 C=1——是的 B'C。

为了最小化，我们选择覆盖所有 1 的、大小最大的非重叠或最小覆盖组。

最优：
- 组 1：列0 中的 4 单元格垂直组：覆盖 C'（所有那里的 1：m0,m2,m4,m6 → 项：C'）
- 组 2：行00 中的 2 单元格水平组：m0 和 m1 → A'B'
- 组 3：列1 行10 和 00 的环绕垂直对？等等，行 00 和 10 对于列1 是相邻的：m1(001) 和 m5(101) → 仅在 A 上不同，所以 B'C（A 无关）。

m5 被覆盖，m1 被覆盖。

注意：m0 同时在组1 和组2 中，但这没问题——允许重叠。

#### 步骤 4：推导最小化表达式
每个组变成一个乘积项（公共文字的 AND）：
- 组 1 (C')：**C'**
- 组 2 (A'B')：**A' B'**
- 组 3 (B' C)：**B' C**

所以，最小化 SOP（积之和）：f = C' + A'B' + B'C

验证：这有 3 项（对比原始 6 项），更少的文字（4 对比 12），更简单的电路（基本上 3 个 AND/OR 门）。

你可以在真值表上绘制此表达式以确认它与原始 1 匹配。

#### 为什么这能最小化？
- **相邻规则**：组仅在变量变化一位时形成，确保该项忽略该变量（无关项 = 图中的 -）。
- **先大后小**：更大的组 = 项中变量更少 = 更简单。
- **覆盖所有 1**：没有 1 被遗漏；0 必须保持为 0（不要对它们分组）。
- 对于更多变量（4 变量卡诺图是 4x4），过程相同，但视觉上更难。

此示例展示了卡诺图如何将最小项之和快速转换为紧凑形式，而无需代数操作。对于 4+ 变量，使用软件，但练习 2-3 变量示例可以建立直觉。

[数字逻辑设计基础](https://www.allaboutcircuits.com/textbook/digital/chpt-7/karnaugh-mapping/)