---
audio: false
date: 2025-09-11
generated: true
image: false
lang: zh
layout: post
model: google/gemini-2.5-flash
title: Verilog：硬件描述语言入门
translated: true
type: note
---

Verilog，通常被称为 **Verilog HDL（硬件描述语言）**，是一种功能强大且广泛使用的语言，用于描述、设计、仿真和综合数字电子电路与系统。它是现代电子设计自动化（EDA）的基础工具。

以下是关于 Verilog 的全面介绍：

---

### 1. 什么是 Verilog？

Verilog 的核心是一种 **硬件描述语言（HDL）**。与在处理器上顺序执行的传统软件编程语言（如 C++ 或 Python）不同，Verilog 专门用于描述 **硬件电路的结构和行为**。这意味着它可以建模：

*   **并发性：** 硬件组件并行运行。Verilog 原生支持这一概念。
*   **时间：** 延迟、时钟周期和时序关系是硬件的基础，Verilog 可以明确地建模这些。
*   **层次结构：** 复杂电路由更小的、互连的子电路构建而成。Verilog 支持模块化和层次化设计。

### 2. 为什么使用 Verilog？（它解决的问题）

在 HDL 出现之前，数字电路主要使用 **原理图捕获**（手动绘制门和连线）或编写极低级的网表来设计。这种方法对于复杂设计变得难以管理，原因在于：

*   **复杂性：** 现代芯片包含数十亿个晶体管。手动设计容易出错且耗时。
*   **抽象：** 设计师需要在投入物理布局之前，使用更高层次的抽象来概念化和验证功能。
*   **可重用性：** 原理图组件难以修改和在项目间重用。
*   **验证：** 测试大型原理图设计的功能极其困难。

Verilog 通过提供一种 **基于文本的高层次抽象** 来解决这些挑战，使工程师能够：

*   **高效描述复杂逻辑：** 无需绘制门电路，而是编写代码。
*   **仿真行为：** 在制造前验证设计的正确性。
*   **综合硬件：** 自动将高层次描述转换为物理的门级网表。
*   **管理复杂性：** 使用模块化和层次结构。
*   **促进可重用性：** 设计模块可以轻松实例化和重用。

### 3. 关键特性和概念

#### a. 并发性质
这是与软件编程最关键的区分。所有 Verilog 的 `always` 块和 `assign` 语句（描述硬件行为）在概念上 **并行执行**。执行流程由事件（例如，时钟边沿、输入信号的变化）驱动，而不是由自上而下的顺序程序计数器驱动。

#### b. 抽象层次

Verilog 支持多种抽象层次，允许设计者从高层次的功能描述过渡到门级实现：

*   **行为级：** 使用算法、顺序语句和数据流描述电路的功能。它关注电路 *做什么*，而不一定详述其确切的物理结构。
    *   *示例：* 描述计数器递增逻辑或 FSM 状态转换的 `always` 块。
*   **寄存器传输级（RTL）：** 数字设计中最常用的级别。它描述数据在寄存器之间的流动以及组合逻辑如何转换这些数据。它暗示了特定的硬件组件（寄存器、多路复用器、加法器），但没有指定它们确切的门级实现。
    *   *示例：* `always @(posedge clk) begin if (reset) count <= 0; else count <= count + 1; end`
*   **结构级：** 将电路描述为门和/或先前定义模块的互连。这就像通过连接预制组件来构建电路。
    *   *示例：* 实例化一个 AND 门并连接其输入和输出。
*   **门级：** 最低级别，使用 Verilog 提供的原始门（AND, OR, NOT, XOR, NAND, NOR, XNOR）描述电路。通常在综合后用于工艺映射。
    *   *示例：* `and (out, in1, in2);`

#### c. 模块

Verilog 中的基本构建块。模块封装了一块硬件，定义了其输入、输出和内部逻辑。复杂设计通过实例化和连接多个模块来创建。

*   **端口：** 模块与外部世界通信的输入、输出和双向端口。

#### d. 数据类型

Verilog 有特定的数据类型来表示硬件信号：

*   **线网类型（`wire`, `tri`）：** 表示组件之间的物理连接。它们不存储值；它们的值由某物（`assign` 语句、模块输出）持续驱动。主要用于组合逻辑。
*   **寄存器类型（`reg`）：** 表示数据存储元素。它们可以保持一个值直到被显式改变。在 `initial` 和 `always` 块内使用。注意：`reg` 在综合后不一定意味着物理寄存器；它只是在仿真中表示其保持一个值。当 `reg` 在时钟边沿同步更新时，才会推断出物理寄存器（触发器）。
*   **参数：** 用于配置的常量（例如，位宽、内存大小）。

#### e. 赋值语句

*   **连续赋值（`assign`）：** 用于组合逻辑。只要任何输入发生变化，输出就会持续更新，就像物理连线一样。
    *   *示例：* `assign sum = a ^ b ^ carry_in;`
*   **过程赋值：** 发生在 `initial` 或 `always` 块内。
    *   **阻塞赋值（`=`）：** 行为类似于传统的软件赋值；立即计算并赋值。如果在 `always` 块中不小心使用，可能导致竞争条件。
    *   **非阻塞赋值（`<=`）：** 所有右侧表达式在时间步开始时计算，赋值在时间步结束时进行。对于建模同步（有时钟的）硬件（如触发器）至关重要，因为它避免了竞争条件并准确反映了并行数据传输。

#### f. 过程块

*   **`always` 块：** 描述随时间重复或在特定事件上发生的行为。用于组合逻辑（对所有输入敏感）和时序逻辑（对时钟边沿、复位敏感）。
*   **`initial` 块：** 仅在仿真开始时执行一次。主要用于测试平台（施加激励）或初始化内存/寄存器。

### 4. 设计流程集成

Verilog 在典型的数字 IC/FPGA 设计流程中扮演着关键角色：

1.  **规范：** 定义电路的需求。
2.  **设计（RTL 编码）：** 编写 Verilog 代码，在寄存器传输级描述电路的行为和结构。
3.  **仿真与验证：** 使用 Verilog 测试平台（提供输入和检查输出的独立模块）和 EDA 仿真器来验证 RTL 设计的功能是否正确。这是一个迭代过程。
4.  **综合：** 将行为级/RTL Verilog 代码转换为针对特定目标技术（例如，FPGA 或 ASIC 库）的门级网表（使用原始门及其互连描述电路）。
5.  **布局布线：** 在芯片上物理排列门并用导线连接它们。
6.  **布局后仿真/时序分析：** 使用实际的物理延迟重新验证设计。
7.  **制造（对于 ASIC）/ 编程（对于 FPGA）。**

### 5. 应用

Verilog 广泛应用于以下领域的设计：

*   **FPGA（现场可编程门阵列）：** 用于快速原型设计、中低产量生产和可重构计算。
*   **ASIC（专用集成电路）：** 用于高产量生产、最高性能和低功耗。
*   **微处理器和微控制器**
*   **数字信号处理器（DSP）**
*   **通信系统（网络、无线）**
*   **图形处理器**
*   **嵌入式系统**

### 6. Verilog 的优势

*   **行业标准：** 由 IEEE（IEEE 1364）标准化，确保跨不同 EDA 工具和供应商的互操作性。
*   **抽象：** 允许设计者在更高层次上工作，管理复杂性。
*   **并发建模：** 自然地支持硬件的并行特性。
*   **时间建模：** 能够精确仿真时序行为。
*   **工具支持：** 几乎所有主要的 EDA 工具都支持，用于仿真、综合、形式验证等。
*   **可读性与可维护性：** 基于文本的代码比复杂的原理图更易于阅读、修改和记录。
*   **可重用性：** 设计模块可以在未来的项目中轻松重用。
*   **广泛采用：** 拥有庞大的社区和丰富的资源。

### 7. 演进：SystemVerilog

虽然 Verilog 非常强大，但其在复杂验证任务方面的能力有限。这导致了 **SystemVerilog** 的发展，它是 Verilog HDL 的扩展和超集。SystemVerilog 包含：

*   **高级数据类型：** 枚举类型、结构体、联合体、类（用于验证）。
*   **增强的行为建模：** 断言、接口、新的过程构造。
*   **面向对象编程（OOP）结构：** 专门用于构建健壮且可重用的测试平台（通常与 UVM - 通用验证方法学一起使用）。
*   **功能覆盖率和随机化：** 对现代验证至关重要。

SystemVerilog 现已成为业界设计和验证的主导 HDL，尽管普通的 Verilog 仍然被广泛使用，尤其是在遗留代码和较简单的设计中。

---

总之，Verilog 不仅仅是一种编程语言；它是一种设计范式，弥合了抽象概念与物理电子电路之间的鸿沟，使得创建当今极其复杂的数字系统成为可能。