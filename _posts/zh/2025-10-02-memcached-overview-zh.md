---
audio: false
generated: true
image: false
lang: zh
layout: post
model: x-ai/grok-code-fast-1
title: Memcached内存缓存系统概述
translated: true
type: note
---

### 什么是 Memcached？

Memcached 是一款开源的高性能分布式内存对象缓存系统。它主要通过将数据库查询结果、API 响应或其他计算密集型数据缓存在内存中，来加速动态 Web 应用程序（例如使用 CodeIgniter 等 PHP 框架构建的应用）。这减轻了数据库的负载并提升了应用响应速度。它并非完整的数据库，而是专为临时数据存储设计的简易键值存储系统。

### Memcached 工作原理

Memcached 以后台守护进程的形式运行在一台或多台服务器上，通常通过类似 `memcached -p 11211 -m 64` 的命令启动（指定端口和内存限制）。其简要工作流程如下：

1. **内存存储**：数据以键值对形式完全存储在内存中以实现快速访问。单个值最大为 1 MB，键为最长 250 字符的字符串。数据具有易失性——服务器重启时缓存数据会丢失。

2. **客户端-服务器模型**：应用程序（客户端）通过 TCP 或 UDP 协议连接 Memcached。提供的 CodeIgniter 配置片段展示了 PHP 连接本地 Memcached 实例的配置：
   - **主机名**：'127.0.0.1'（本地主机，即与应用同服务器）
   - **端口**：'11211'（Memcached 默认端口）
   - **权重**：'1'（定义集群中服务器优先级，值越高负载越大）

3. **操作指令**：
   - Set：存储键值对，可设置过期时间（例如通过 telnet 执行 `set app_name 0 3600 13\n"cached_data"`）
   - Get：通过键获取值
   - Delete：通过键删除数据
   在集群环境中使用简易哈希算法分配键到各服务器（如采用一致性哈希处理服务器增减）

4. **数据淘汰与扩展**：内存占满时采用 LRU（最近最少使用）策略淘汰旧数据。扩展可通过多服务器实例实现，常借助 moxi 等工具自动发现或外部分片。

其性能峰值可达每秒数百万次操作，但主要针对读多写少场景优化。可使用 memcached-top 等监控工具追踪使用情况。

### 与 Redis 的对比

虽然 Memcached 和 Redis 都是用于缓存和高速数据访问的内存键值存储系统，但它们在特性、架构和适用场景上存在差异：

| 对比维度       | Memcached                                    | Redis                                                          |
|----------------|----------------------------------------------|----------------------------------------------------------------|
| **数据类型**   | 简单字符串（仅键值对）                      | 支持字符串、哈希、列表、集合、有序集合、位图、基数统计等，允许复杂数据结构（如 JSON 对象或计数器） |
| **持久化**     | 无持久化——数据纯内存存储，重启即丢失        | 支持可选持久化（AOF 日志或 RDB 快照）至硬盘，可实现数据恢复      |
| **淘汰策略**   | 仅 LRU                                      | 支持 LRU、LFU（最不经常使用）或基于过期时间的淘汰机制           |
| **操作指令**   | 基础 set/get/delete/multiget                | 数千条命令（如发布订阅、事务、Lua 脚本、地理空间查询），支持原子操作如递增 |
| **性能表现**   | 简单读写场景稍快（multigets 可提升效率）    | 整体性能优异，但复杂数据结构会带来轻微开销。基准测试显示在低复杂度纯缓存场景中 Memcached 略占优势 |
| **扩展与集群** | 通过一致性哈希内置扩展；无原生集群（需外部分区） | 支持原生集群、主从复制及 Redis Cluster 自动分区               |
| **适用场景**   | 理想用于 Web 应用缓存（如会话或查询缓存），如 CodeIgniter 配置中的场景。简单轻量 | 应用更广：缓存、会话存储、消息队列、实时分析，甚至可作为完整数据库替代方案 |
| **内存效率**   | 固定尺寸数据效率高；无压缩功能              | 对大尺寸数据集更高效，支持压缩选项（Redis 5+）                |
| **通信协议**   | 自定义二进制/文本协议                       | RESP（Redis 序列化协议），错误处理更完善                       |
| **许可与生态** | 开源（BSD 许可），广泛用于 LAMP 技术栈      | 开源（BSD 许可），拥有更庞大的社区生态（如 RedisInsight 工具）  |

总结来说，基础缓存场景追求简洁高效时选择 Memcached（如示例中的 CodeIgniter 配置）；若需持久化、高级数据类型或发布订阅等功能则选择 Redis。从 Memcached 迁移时，虽然存在 redis-memcached 等兼容层项目，但 Redis 常因其多功能性成为替代选择。对于 CodeIgniter 框架，其配置支持在不同驱动间无缝切换。