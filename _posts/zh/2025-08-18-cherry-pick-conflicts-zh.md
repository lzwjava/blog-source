---
audio: false
generated: true
image: false
lang: zh
layout: post
title: 代码拣选冲突及解决方案
translated: true
type: note
---

Git **cherry-pick** 是一个允许你将某个分支的提交应用到另一个分支的命令，而无需合并整个分支历史。

---

### 工作原理

* 当你运行 `git cherry-pick <commit-hash>` 时，Git 会：

  1. 定位该提交引入的更改（与其父提交的差异）。
  2. 将这些更改重新应用到当前分支，创建一个具有新哈希值的新提交。
  3. 这意味着提交内容被重用，但不会保留原始提交的祖先关系。

这就像是说：
*“只取这一个提交的补丁，并将其粘贴到我当前的位置。”*

---

### 冲突产生的原因

冲突的产生是因为 cherry-pick 在**脱离原始上下文**的情况下应用更改。一些常见原因包括：

1. **代码漂移**
   如果目标分支自原始提交以来在代码的相同区域发生了更改，Git 将无法干净地应用补丁。例如：

   * 原始提交在 `fileA` 中添加了一个函数。
   * 在目标分支中，有人重命名或删除了该函数。
     → 执行 cherry-pick 时发生冲突。

2. **缺少依赖提交**
   有时一个提交依赖于之前的提交（例如重构、变量重命名）。如果你在没有这些依赖提交的情况下进行 cherry-pick，上下文会不同，从而出现冲突。

3. **重叠更改**
   如果两个分支都修改了相同的代码行（即使出于不同的原因），Git 无法自动决定，会停止并等待手动解决。

---

### 示例场景

* `feature-branch` 有提交 A → B → C。
* 你希望将提交 B 应用到 `main` 分支。
* 你运行 `git checkout main && git cherry-pick B`。
* 如果 `main` 分支已经修改了与 B 相同的文件/代码行，Git 会引发冲突。你必须打开文件，解决差异，执行 `git add`，然后运行 `git cherry-pick --continue`。

---

👉 简而言之：**Cherry-pick 在新的上下文中重新应用补丁。当该上下文与原始上下文差异过大时，就会发生冲突。**

需要我进一步讲解**减少 cherry-pick 冲突的最佳实践**吗（例如提交排序、使用 `-x` 选项或先进行 rebase）？