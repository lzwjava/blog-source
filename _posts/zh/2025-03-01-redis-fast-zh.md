---
audio: false
lang: zh
layout: post
title: 为什么 Redis 快
translated: true
---

### 关键要点
- ByteByteGo 的 YouTube 视频 "System Design: Why is single-threaded Redis so fast?" 可能解释了 Redis 的速度，原因包括内存存储、IO 多路复用和高效的数据结构。
- 研究表明，这些因素使 Redis 能够处理每秒 100,000 个查询，尽管请求处理是单线程的。
- 证据表明，最近的 Redis 版本为特定任务添加了多线程，但核心仍然是单线程。

---

### 引言
本博客文章基于 ByteByteGo 的 YouTube 视频 "System Design: Why is single-threaded Redis so fast?"，这是他们系统设计系列的一部分。Redis 以其高性能著称，可以在单台机器上处理每秒 100,000 个查询，这对于单线程系统来说是非常了不起的。让我们探讨为什么这是可能的，以及是什么使 Redis 如此快速。

### Redis 速度的原因
Redis 的速度可以归因于几个关键因素，可能在视频中有所涉及：

- **内存存储**：Redis 将数据存储在 RAM 中，这比磁盘存储快得多。这减少了延迟，增加了吞吐量，因为内存访问时间是纳秒级别，而磁盘访问时间是毫秒级别。

- **IO 多路复用和单线程执行**：IO 多路复用，使用类似于 Linux 的 epoll 机制，允许单个线程高效地处理多个客户端连接。这避免了上下文切换的开销，单线程循环通过消除同步问题简化了操作。

- **高效的数据结构**：Redis 使用优化的数据结构，如哈希表（O(1) 查找）、链表和跳表，通过最小化内存使用和加速操作来提高性能。

### 扩展和演变
对于高并发，Redis 可以通过使用多个实例或集群进行水平扩展。一个意外的细节是，尽管核心请求处理仍然是单线程的，但自 4.0 版本以来，Redis 为特定任务引入了多线程，如后台对象删除，进一步提高了性能，而没有改变主要模型。

---

### 调查笔记：Redis 单线程性能的详细分析

本节提供了对为什么单线程 Redis 如此快速的全面分析，基于 ByteByteGo 的 YouTube 视频 "System Design: Why is single-threaded Redis so fast?" 和相关研究。该视频于 2022 年 8 月 13 日发布，是一个专注于系统设计的系列，由畅销书《System Design Interview》的创作者制作。鉴于频道的重点，视频可能提供了适合技术面试和系统设计讨论的详细见解。

#### 背景和上下文
Redis 是一个开源的内存键值存储，广泛用作缓存、消息代理和流引擎。它支持字符串、列表、集合、哈希、有序集合和概率数据结构，如布隆过滤器和 HyperLogLog。视频的标题暗示探讨了 Redis 为什么在单线程请求处理的情况下保持高性能，这是其设计的核心。

根据相关文章，Redis 可以在单台机器上处理每秒 100,000 个查询（QPS），这是性能基准测试中常引用的一个数字。这个速度在单线程模型下令人惊讶，但研究表明，这要归因于几个架构选择。

#### 影响 Redis 速度的关键因素

1. **内存存储**
   Redis 将数据存储在 RAM 中，至少比随机磁盘访问快 1000 倍。这消除了磁盘 I/O 的延迟，RAM 访问时间约为 100-120 纳秒，而 SSD 为 50-150 微秒，HDD 为 1-10 毫秒。视频可能强调这一点作为主要原因，因为它与频道对系统设计基础的重点一致。

   | 方面               | 详细信息                                      |
   |----------------------|----------------------------------------------|
   | 存储介质       | RAM（内存）                              |
   | 访问时间          | ~100-120 纳秒                        |
   | 与磁盘比较   | 1000 倍快于随机磁盘访问        |
   | 对性能的影响| 减少延迟，增加吞吐量        |

2. **IO 多路复用和单线程执行循环**
   IO 多路复用允许单个线程使用系统调用（如 `select`、`poll`、`epoll`（Linux）、`kqueue`（Mac OS）或 `evport`（Solaris））同时监控多个 I/O 流。这对于在不阻塞的情况下处理多个客户端连接至关重要，这是视频中可能详细讨论的一个点。单线程执行循环避免了上下文切换和同步开销，简化了开发和调试。

   | 机制            | 描述                                  |
   |----------------------|----------------------------------------------|
   | epoll/kqueue         | 高并发，非阻塞，高效 |
   | select/poll          | 旧的，可扩展性差，O(n) 复杂度        |
   | 影响               | 减少连接开销，启用管道 |

   然而，客户端阻塞命令（如 `BLPOP` 或 `BRPOP`）可能会延迟流量，这是相关文章中提到的一个潜在缺点。视频可能讨论了这种设计选择如何在简单性和性能之间取得平衡。

3. **高效的低级数据结构**
   Redis 利用哈希表进行 O(1) 密钥查找、链表进行列表和跳表进行有序集合的数据结构。这些数据结构优化用于内存操作，最小化内存使用，最大化速度。视频可能包括图表或示例，例如哈希表如何实现快速键值操作，这是系统设计面试中的常见话题。

   | 数据结构       | 用例                                     | 时间复杂度 |
   |----------------------|----------------------------------------------|-----------------|
   | 哈希表           | 键值存储                           | O(1) 平均    |
   | 链表          | 列表，两端高效                    | O(1) 两端   |
   | 跳表            | 有序集，有序存储                | O(log n)        |

   这种优化至关重要，因为大多数 Redis 操作都是基于内存的，瓶颈通常在内存或网络，而不是 CPU。

#### 附加考虑和演变
虽然核心请求处理是单线程的，但最近的 Redis 版本为特定任务引入了多线程。自 4.0 版本以来，实现了异步内存释放（懒惰释放），自 6.0 版本以来，在高并发下为协议解析添加了多线程。这些变化，视频中可能提到，增强了性能，而没有改变主操作的单线程模型。

为了超出单个实例的扩展，Redis 支持集群和运行多个实例，这是一个可能讨论的策略，以应对高并发需求。这是系统设计的一个重要方面，与频道对大规模系统的重点一致。

#### 潜在缺点和比较
单线程模型的优点包括没有锁争用和更简单的调试，但它在高负载下可能面临阻塞操作和内存/网络瓶颈的挑战。相关文章建议，对于 CPU 密集型任务，多线程数据库可能表现更好，但对于 Redis 的典型用例，单线程设计是最佳的。

#### 结论
ByteByteGo 的视频 "System Design: Why is single-threaded Redis so fast?" 可能涵盖了内存存储、IO 多路复用和高效数据结构作为 Redis 速度的关键原因。这些因素使其能够处理高 QPS，最近的版本为特定优化添加了多线程。本分析提供了全面的理解，适合技术学习者和系统设计专业人士。

---

### 关键引用
- [Why is redis so fast blog post](https://blog.bytebytego.com/p/why-is-redis-so-fast)
- [Why is Redis So Fast Despite Being Single-Threaded article](https://medium.com/@aditimishra_541/why-is-redis-so-fast-despite-being-single-threaded-dc06ba33fc75)
- [Interview on Redis thread model article](https://medium.com/javarevisited/interview-why-is-redis-so-fast-even-though-it-is-single-threaded-bfe663dabe08)
- [Why is single threaded Redis so fast article](https://www.pixelstech.net/article/1677580861-Why-is-single-threaded-Redis-so-fast)