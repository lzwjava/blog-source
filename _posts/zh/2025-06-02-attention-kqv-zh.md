---
audio: false
generated: true
lang: zh
layout: post
title: Transformers中的K、Q、V机制
translated: true
type: note
---

**键（K）、查询（Q）和值（V）** 机制是基于 Transformer 的大型语言模型（LLM）中**自注意力**机制的核心组成部分。该机制由开创性论文《Attention is All You Need》（Vaswani 等人，2017 年）提出，使模型在处理或生成文本时能够权衡序列中不同词语的重要性。以下将全面介绍 **K、Q、V** 机制在 Transformer LLM 中的工作原理，涵盖其直观理解、数学公式、自注意力中的实现，以及其在整体架构中的作用。

---

### 1. **K、Q、V 在自注意力中的直观理解**
自注意力机制使 Transformer 模型能够通过关注序列中每个词（或标记）的相关部分来处理输入序列。**K、Q、V** 组件是这一过程的基础构建块，使模型能够动态确定输入序列中哪些部分彼此最相关。

- **查询（Q）：** 代表一个标记对序列中其他标记提出的“问题”。对于每个标记，查询向量编码了该标记希望从序列其他部分获取的信息。
- **键（K）：** 代表序列中每个标记的“描述”。键向量编码了一个标记可以向其他标记提供的信息。
- **值（V）：** 代表标记携带的实际内容或信息。一旦模型通过 Q 和 K 的交互确定了哪些标记是相关的，就会检索相应的值向量以构建输出。

**Q** 和 **K** 之间的交互决定了每个标记应给予其他标记多少注意力，然后根据这种注意力对 **V** 向量进行加权和组合，以生成每个标记的输出。

可以将其类比为图书馆检索：
- **查询**：您的检索查询（例如“机器学习”）。
- **键**：图书馆中书籍的标题或元数据，您将其与查询进行比较以找到相关书籍。
- **值**：在识别出相关书籍后，您检索到的书籍的实际内容。

---

### 2. **K、Q、V 在自注意力中的工作方式**
自注意力机制计算 **值** 向量的加权和，其中权重由 **查询** 和 **键** 向量之间的相似度决定。以下是该过程的逐步分解：

#### 步骤 1：输入表示
- Transformer 层的输入是一个标记序列（例如，单词或子词），每个标记表示为一个高维嵌入向量（例如，维度 \\( d_{\text{model}} = 512 \\)）。
- 对于长度为 \\( n \\) 的标记序列，输入是一个矩阵 \\( X \in \mathbb{R}^{n \times d_{\text{model}}} \\)，其中每一行是一个标记的嵌入。

#### 步骤 2：生成 K、Q、V 的线性变换
- 为每个标记计算三个向量：**查询（Q）**、**键（K）** 和 **值（V）**。这些通过对输入嵌入应用学习的线性变换得到：
  \\[
  Q = X W_Q, \quad K = X W_K, \quad V = X W_V
  \\]
  - \\( W_Q, W_K, W_V \in \mathbb{R}^{d_{\text{model}} \times d_k} \\) 是学习的权重矩阵。
  - 通常，\\( d_k = d_v \\)，并且它们通常设置为 \\( d_{\text{model}} / h \\)（其中 \\( h \\) 是注意力头的数量，稍后解释）。
  - 结果是：
    - \\( Q \in \mathbb{R}^{n \times d_k} \\)：所有标记的查询矩阵。
    - \\( K \in \mathbb{R}^{n \times d_k} \\)：所有标记的键矩阵。
    - \\( V \in \mathbb{R}^{n \times d_v} \\)：所有标记的值矩阵。

#### 步骤 3：计算注意力分数
- 注意力机制通过计算一个标记的查询向量与所有标记的键向量之间的**点积**，来确定每个标记应关注其他标记的程度：
  \\[
  \text{注意力分数} = Q K^T
  \\]
  - 这产生一个矩阵 \\( \in \mathbb{R}^{n \times n} \\)，其中每个条目 \\( (i, j) \\) 表示标记 \\( i \\) 的查询与标记 \\( j \\) 的键之间的未归一化相似度。
- 为了稳定梯度并防止值过大，分数通过键维度的平方根进行缩放：
  \\[
  \text{缩放后的分数} = \frac{Q K^T}{\sqrt{d_k}}
  \\]
  - 这称为**缩放点积注意力**。

#### 步骤 4：应用 Softmax 获取注意力权重
- 缩放后的分数通过 **softmax** 函数转换为概率（注意力权重），每个标记的权重之和为 1：
  \\[
  \text{注意力权重} = \text{softmax}\left( \frac{Q K^T}{\sqrt{d_k}} \right)
  \\]
  - 结果是一个矩阵 \\( \in \mathbb{R}^{n \times n} \\)，其中每一行代表一个标记对所有标记的注意力分布。
  - 高注意力权重表示相应的标记彼此高度相关。

#### 步骤 5：计算输出
- 注意力权重用于计算 **值** 向量的加权和：
  \\[
  \text{注意力输出} = \text{softmax}\left( \frac{Q K^T}{\sqrt{d_k}} \right) V
  \\]
  - 输出是一个矩阵 \\( \in \mathbb{R}^{n \times d_v} \\)，其中每一行是标记的新表示，融合了基于相关性从所有其他标记获取的信息。

#### 步骤 6：多头注意力
- 在实践中，Transformers 使用 **多头注意力**，上述过程并行执行多次（使用不同的 \\( W_Q, W_K, W_V \\)）以捕获不同类型的关系：
  - 输入被分成 \\( h \\) 个头，每个头具有更小的 \\( Q, K, V \\) 向量，维度为 \\( d_k = d_{\text{model}} / h \\)。
  - 每个头计算自己的注意力输出。
  - 所有头的输出被拼接并通过最终的线性变换：
    \\[
    \text{MultiHead}(Q, K, V) = \text{Concat}(\text{head}_1, \text{head}_2, \dots, \text{head}_h) W_O
    \\]
    其中 \\( W_O \in \mathbb{R}^{h \cdot d_v \times d_{\text{model}}} \\) 是学习的输出投影矩阵。

---

### 3. **K、Q、V 在 Transformer LLM 中的作用**
**K、Q、V** 机制在 Transformer 架构的不同部分中使用，具体取决于注意力的类型：

- **编码器中的自注意力（例如 BERT）：**
  - 所有标记关注输入序列中的所有其他标记（双向注意力）。
  - \\( Q, K, V \\) 均来自相同的输入序列 \\( X \\)。
  - 这使得模型能够捕获来自前后标记的上下文，这对于文本分类或问答等任务非常有用。

- **解码器中的自注意力（例如 GPT）：**
  - 在像 GPT 这样的自回归模型中，解码器使用**掩码自注意力**来防止关注未来的标记（因为模型是顺序生成文本的）。
  - 掩码确保对于每个标记 \\( i \\)，标记 \\( j > i \\) 的注意力分数在 softmax 之前被设置为 \\(-\infty\\)，从而有效地使它们的权重为零。
  - \\( Q, K, V \\) 仍然来自输入序列，但注意力是因果的（仅关注先前的标记）。

- **编码器-解码器模型中的交叉注意力（例如 T5）：**
  - 在编码器-解码器架构中，解码器使用交叉注意力来关注编码器的输出。
  - 这里，\\( Q \\) 来自解码器的输入，而 \\( K \\) 和 \\( V \\) 来自编码器的输出，允许解码器在生成输出时聚焦于输入序列的相关部分。

---

### 4. **K、Q、V 为何如此有效**
**K、Q、V** 机制之所以强大，有以下几个原因：
- **动态上下文化**：它允许每个标记基于其他标记的内容收集信息，而不是依赖固定模式（例如，像 RNN 或 CNN 那样）。
- **并行化**：与循环神经网络不同，自注意力同时处理所有标记，使其在现代硬件（如 GPU）上非常高效。
- **灵活性**：多头注意力使模型能够通过学习 \\( Q, K, V \\) 的不同投影来捕获多样化的关系（例如，句法、语义）。
- **可扩展性**：该机制能很好地扩展到长序列（尽管计算成本随序列长度呈二次增长，但通过稀疏注意力或高效 Transformer 等技术得以缓解）。

---

### 5. **数学总结**
缩放点积注意力的公式为：
\\[
\text{Attention}(Q, K, V) = \text{softmax}\left( \frac{Q K^T}{\sqrt{d_k}} \right) V
\\]
对于多头注意力：
\\[
\text{MultiHead}(Q, K, V) = \text{Concat}(\text{head}_1, \dots, \text{head}_h) W_O
\\]
其中：
\\[
\text{head}_i = \text{Attention}(Q W_{Q_i}, K W_{K_i}, V W_{V_i})
\\]

---

### 6. **实际示例**
考虑句子：*"The cat sat on the mat."*
- **输入**：每个单词被转换为嵌入向量（例如，通过词嵌入层）。
- **Q、K、V 计算**：对于每个标记，模型使用学习的权重计算查询、键和值向量。
- **注意力分数**：对于单词 "cat"，其查询向量可能给 "sat" 和 "mat" 分配较高的注意力分数，因为它们在上下文中相关，而给 "the" 分配较低的分数。
- **输出**：注意力机制为 "cat" 生成一个新的表示，该表示融合了来自 "sat" 和 "mat" 的信息，并根据它们的注意力分数进行加权。

---

### 7. **扩展与优化**
- **高效注意力**：为了处理长序列，Performer、Linformer 或 Longformer 等变体降低了注意力的计算复杂度。
- **位置编码**：由于自注意力是排列不变的，Transformers 向输入嵌入添加位置编码以捕获词序，这间接影响 \\( Q, K, V \\)。
- **层堆叠**：Transformers 堆叠多层自注意力，允许 \\( Q, K, V \\) 在越来越抽象的表示上操作。

---

### 8. **结论**
**K、Q、V** 机制是 Transformer 自注意力的核心，使 LLM 能够高效且有效地建模文本中的复杂关系。通过基于查询和键计算注意力分数，并从值向量聚合信息，Transformers 在语言建模、翻译等任务中实现了最先进的性能。理解这一机制是掌握现代 LLM 如何处理和生成类人文本的关键。

如果您想深入了解任何特定方面（例如，多头注意力、代码实现或在特定模型中的应用），请告诉我！