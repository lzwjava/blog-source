---
audio: false
generated: true
lang: zh
layout: post
title: Java内存模型
translated: true
type: note
---

让我们深入探讨Java内存模型（JMM）！这是理解多线程Java程序行为方式的基础概念，特别是在处理共享数据时。

**什么是Java内存模型（JMM）？**

Java内存模型是Java程序中线程与内存交互方式的抽象描述。它定义了一系列规则，用于管理一个线程对共享变量的修改何时以及如何对其他线程可见。它并非物理内存架构，而是一套JVM必须遵循的规则，以确保并发程序在不同硬件平台上具有一致且可预测的行为。

**为什么需要Java内存模型？**

在多线程环境中，多个线程可以访问和修改共享变量。若没有明确定义的内存模型，可能会出现以下问题：

* **可见性问题**：一个线程对共享变量的修改可能不会立即对其他线程可见。这可能由于缓存等优化导致，每个线程可能拥有变量的本地副本。
* **顺序性问题**：操作在源代码中出现的顺序可能与处理器实际执行的顺序不同。编译器和处理器可能为了性能优化而重排序指令。虽然在单线程程序中通常是安全的，但在多线程程序中若未正确管理，可能导致意外行为。
* **原子性问题**：在源代码中看似单个操作的某些操作，在处理器层面可能被分解为多个较小步骤。在多线程环境中，这些步骤可能与其他线程的操作交错执行，导致不一致的结果。

JMM提供了一个解决这些问题的框架，确保无论底层硬件架构如何，并发程序都能正确运行。

**JMM的抽象架构：**

JMM定义了线程与主内存之间的抽象关系：

1.  **主内存**：所有共享变量存放的位置。类似于可供多个线程访问的所有数据的中央存储。
2.  **工作内存（本地缓存）**：每个线程都有自己的工作内存（概念上类似于CPU缓存）。当线程需要访问共享变量时，它首先将变量从主内存复制到其工作内存。当线程修改变量时，通常在其工作内存中进行，最终将更改写回主内存。

**JMM解决的关键挑战：**

* **可见性**：JMM定义了关于线程在工作内存中对共享变量的更改何时以及如何对其他线程可见的规则（即写回主内存并随后被其他线程读取）。
* **顺序性**：JMM规定了编译器和处理器可以重排序指令的限制，以确保不同线程中的某些操作之间存在一致的happens-before关系。

**"Happens-Before"关系：**

"Happens-before"关系是JMM中最基本的概念。它定义了程序中操作的部分排序。如果一个操作happens-before另一个操作，那么第一个操作的效果（例如，对变量的写入）保证对第二个操作可见。

以下是JMM定义的一些关键"happens-before"规则：

1.  **程序顺序规则**：在单个线程内，程序中的每个操作happens-before程序中该操作之后出现的每一个操作。
2.  **监视器锁规则**：对监视器（与`synchronized`块或方法关联的锁）的解锁操作happens-before随后对同一监视器的每个加锁操作。这确保当一个线程释放锁时，它在同步块内所做的任何更改对下一个获取同一锁的线程可见。
3.  **volatile变量规则**：对`volatile`变量的写操作happens-before随后对同一变量的每个读操作。这保证当一个线程写入`volatile`变量时，该值会立即写回主内存，任何其他读取该变量的线程都将获得最新值。
4.  **线程启动规则**：Thread对象的start()方法happens-before新启动线程中的任何操作。
5.  **线程终止规则**：线程中的所有操作（包括对共享变量的写入）happens-before该线程join()方法的成功返回，或者在另一个线程检测到该线程已终止之前（例如，通过检查`isAlive()`）。
6.  **传递性**：如果操作A happens-before操作B，且操作B happens-before操作C，则操作A happens-before操作C。
7.  **对象创建规则**：对象构造函数的完成happens-before使用该对象的任何其他操作的开始。

**关键语言结构与JMM：**

* **`volatile`关键字**：将变量声明为`volatile`对JMM有两个主要影响：
    * **可见性**：保证所有对此变量的写入将立即写回主内存，所有读取都将从主内存获取最新值。这防止线程使用过时的缓存值。
    * **禁止指令重排序（在一定程度上）**：防止可能导致多线程程序错误行为的某些类型的指令重排序。具体来说，写入`volatile`变量之前的操作不能被重排序到写入之后，读取`volatile`变量之后的操作不能被重排序到读取之前。

* **`synchronized`关键字**：当线程进入`synchronized`块或方法时，它会获取关联监视器的锁。JMM确保：
    * **互斥（原子性）**：在任何给定时间，只有一个线程可以持有特定监视器的锁，确保同步块内的代码相对于在同一监视器上同步的其他线程是原子执行的。
    * **可见性**：当线程释放锁（通过退出`synchronized`块或方法）时，它会有效地将其在该块内对共享变量所做的任何更改刷新回主内存。当另一个线程获取同一锁时，它将从主内存重新读取共享变量，确保看到最新更新。

* **`final`字段**：JMM提供了关于`final`字段可见性的保证。一旦`final`字段在对象的构造函数中正确初始化，其值将对所有其他线程可见，无需显式同步。这是因为构造函数中对`final`字段的写入happens-before任何其他线程可以访问该对象。

**对并发编程的影响：**

理解JMM对于在Java中编写正确且高效的并发程序至关重要。通过遵守JMM定义的规则并使用适当的同步机制（`volatile`、`synchronized`、`java.util.concurrent`包中的锁），开发人员可以确保共享数据被多个线程安全地访问和修改。

**常见陷阱及JMM如何帮助：**

* **竞态条件**：当程序的结果取决于多个线程访问共享资源的不可预测顺序时发生。JMM与适当的同步一起，通过确保对共享变量的访问得到适当协调，帮助防止竞态条件。
* **数据竞争**：当多个线程并发访问同一共享变量，且至少有一次访问是写入，而没有任何同步时发生。JMM定义，如果程序存在数据竞争，则行为未定义。使用`volatile`或`synchronized`有助于防止数据竞争。
* **乱序执行问题**：没有JMM的保证，编译器或处理器可能会以破坏多线程程序预期逻辑的方式重排序操作。JMM对重排序施加限制，特别是在`volatile`变量和同步块周围，以防止此类问题。

**总结：**

Java内存模型是一套管理Java中线程与内存交互方式的规则。它解决了多线程程序中与可见性、顺序性和原子性相关的挑战。关键概念包括主内存、工作内存和"happens-before"关系。通过遵守JMM规范，`volatile`和`synchronized`等语言结构提供了确保并发Java应用程序正确和可预测行为的机制。理解JMM对于编写健壮且高效的多线程Java代码至关重要。