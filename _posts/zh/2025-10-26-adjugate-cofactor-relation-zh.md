---
audio: false
generated: true
image: false
lang: zh
layout: post
model: x-ai/grok-4-fast
title: 伴随矩阵定义与余子式关系
translated: true
type: note
---

### 澄清伴随矩阵的定义（及其与余因子的关系）

你对于伴随矩阵通过余因子构建的理解基本正确，但有一个微小而重要的修正需要说明。伴随矩阵（通常记为 `adj(A)`）并非通过将原始元素 `a(i,j)` 与「剩余部分」（删除第 i 行第 j 列后的子矩阵）的带符号行列式相乘来构建。实际上：

- 元素 `a(i,j)` 的**余因子** `C_ij` 定义为 `C_ij = (-1)^{i+j} * det(M_ij)`，其中 `M_ij` 是从矩阵 A 中删除第 i 行第 j 列得到的子矩阵。这纯粹是**带符号的子式**——不涉及与 `a(i,j)` 本身的乘法运算。
- **余因子矩阵** C 以这些 `C_ij` 作为其元素。
- **伴随矩阵**是余因子矩阵的**转置**：`adj(A) = C^T`。因此，`adj(A)` 中位置 (i,j) 的元素实际上是 `C_ji`（来自互换索引的余因子）。

这种带符号子式的结构源于计算行列式的拉普拉斯展开（下文详述）。你的描述听起来有点像行列式公式本身：`det(A) = 对 j 求和 a(i,j) * C_ij`（沿任意行 i），这个公式确实涉及与 `a(i,j)` 的乘法。但伴随矩阵跳过了这个乘法步骤——它仅仅是这些带符号子式的集合，经过转置后能够实现简洁的代数恒等式。

用一个简单的 2x2 示例说明（设 A = [[a, b], [c, d]]）：
- 余因子：C_11 = (-1)^{1+1} det([d]) = d；C_12 = (-1)^{1+2} det([c]) = -c；C_21 = (-1)^{2+1} det([b]) = -b；C_22 = (-1)^{2+2} det([a]) = a。
- 余因子矩阵 C = [[d, -c], [-b, a]]。
- 伴随矩阵 adj(A) = C^T = [[d, -b], [-c, a]]。
- 注意余因子中没有原始元素 a、b、c、d 的乘数——它完全基于「剩余」子矩阵。

是的，这正是计算伴随矩阵的方法：为每个位置移除对应的行和列，计算剩余部分的行列式，应用符号 `(-1)^{i+j}`，组装成余因子矩阵 C，然后转置得到 adj(A)。这个过程是递归的（子式涉及更小的矩阵），因此对于大型 n x n 矩阵，计算量很大——这就是为什么在实践中我们通常使用高斯消元法来求逆矩阵。

### 为什么我们需要伴随矩阵？（它不仅仅是一个中间步骤）

你认为它感觉像是矩阵求逆的「中间表示」——在许多计算意义上确实如此！关键公式是 `A^{-1} = (1 / det(A)) * adj(A)`，前提是 det(A) ≠ 0。这个公式直接使用子矩阵的行列式来给出逆矩阵，无需进行行操作。但它不仅仅是一个垫脚石；以下是它有用且必要的原因：

1. **矩阵求逆公式**：对于小型矩阵或符号计算（例如在证明或精确算术中），这是一种简洁、明确的表达逆矩阵的方式。它突显了逆矩阵如何「分解」为缩放后的余因子。

2. **理论洞察**：恒等式 `A * adj(A) = adj(A) * A = det(A) * I`（其中 I 是单位矩阵）揭示了深层结构。它表明每个矩阵与其伴随矩阵在标量倍内可交换，并且是理解奇异矩阵的基础（det(A)=0 意味着 A adj(A)=0，因此零空间对齐）。

3. **线性方程组的克莱姆法则**：为了求解 Ax = b，第 i 个解的分量是 `x_i = det(A_i) / det(A)`，其中 A_i 是将 A 的第 i 列替换为 b 后的矩阵。但 det(A_i) 通过涉及 b 元素的余因子进行展开——本质上是在幕后利用伴随矩阵进行高效计算，而无需完全求逆。

4. **行列式展开**：余因子使得拉普拉斯展开（你的「det(剩余部分)」想法）成为可能，这对于通过将问题分解为更小问题来计算 det(A) 至关重要。历史上，在计算机出现之前，这使得行列式计算变得易于处理。

5. **更广泛的应用**：在射影几何、计算机图形学（变换）甚至物理学（例如阻抗矩阵）中，伴随矩阵出现在处理奇点或推导实数域之外（如多项式环）的逆矩阵时。

简而言之，尽管行约简在数值计算上更快，但伴随矩阵提供了一条「解析」路径，对于理论、教育以及需要显式公式的情况来说非常优雅。它就像是逆矩阵背后的「原理」，而不仅仅是一种手段。

### 伴随矩阵是如何被发明的？（一点历史）

伴随矩阵并非源于某个「尤里卡」时刻——它是 18-19 世纪关于行列式和线性方程工作的自然产物，当时矩阵尚未被形式化（「矩阵」一词出现在 1850 年）。没有单一的发明确认给某个人，但发展脉络如下：

- **源于行列式（17世纪末–18世纪）**：行列式源于求解线性方程组（例如莱布尼茨在 1693 年处理 2x2 情况）。到了 18 世纪，像克莱姆（1750 年）这样的数学家使用子式展开来求解，隐式地触及了余因子。

- **早期「伴随」概念（1760年代–1800年代）**：约瑟夫·路易斯·拉格朗日大约在 1766 年针对微分方程创造了「伴随方程」一词，其中「伴随」算子镜像了原始算子（类似于矩阵的转置）。阿瑟·凯莱（1840–50 年代）在他的矩阵工作中将其扩展到「伴随线性形式」。马克西姆·博赫在 20 世纪初形式化了「伴随矩阵」，但其核心思想早于他。

- **高斯的关键见解（1801 年）**：卡尔·弗里德里希·高斯在他的《算术研究》中定义了二次型的「伴随」（例如 ax² + 2bxy + cy²）。他构建了一个伴随形式，其系数本质上是代表原始型的对称矩阵的带符号 2x2 子式—— precisely 就是现代伴随矩阵的定义（除了符号约定）。这是用于数论（二元二次型）的，但它直接预示了现代定义。高斯的工作使这种构建变得系统化。

- **形式化（19世纪中期及以后）**：随着矩阵理论的巩固（凯莱、西尔维斯特、克罗内克），余因子展开（来自拉普拉斯，1772 年）与这些思想融合。到 1850–60 年代，完整的逆矩阵公式 `A^{-1} = adj(A)/det(A)` 出现在教科书中，「伴随矩阵」（源自拉丁语「adjugare」，意为连接在一起）强调了它在求逆中的纽带作用。

「发明」很可能源于模式的发现：在展开行列式时，数学家们注意到余因子的集合在缩放后可以「逆转」矩阵。这 less 是灵光一现，more 是从手工解方程中 organic 演变而来。现代教材（例如斯特朗的《线性代数导论》）仍然以这种方式教授它以培养直觉。

如果你需要代码示例（例如使用 NumPy/SymPy 在 Python 中计算伴随矩阵）或想更深入了解高斯的构建方法，请告诉我！

[伴随矩阵 - 维基百科](https://en.wikipedia.org/wiki/Adjugate_matrix)  
[「伴随」一词的首次使用 - 科学史与数学史 Stack Exchange](https://hsm.stackexchange.com/questions/5908/what-is-the-first-usage-of-the-term-adjoint-and-why-was-this-word-chosen)