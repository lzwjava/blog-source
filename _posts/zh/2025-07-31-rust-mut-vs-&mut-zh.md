---
audio: false
generated: true
image: false
lang: zh
layout: post
title: Rust中的mut与&mut详解
translated: true
type: note
---

在 Rust 中，关键字 `mut` 和 `&mut` 有着相关但不同的用途，它们并不直接等同于 Java 的深拷贝/浅拷贝概念或 C 语言的指针——尽管我们可以通过一些类比来帮助理解。我将逐步分解说明，解释它们的区别，并回答你关于值传递与引用传递、可变性以及修改如何影响原始数据的问题。我会基于你提供的代码示例进行说明。

### 1. **理解变量声明中的 `mut`**
   - 当你使用 `let mut` 声明变量时，你是在使*绑定*（变量名）可变。这意味着你可以在声明它的作用域内重新赋值或直接修改其内容。
   - 代码示例：
     ```rust
     let mut arr = [3, 6, 8, 10, 1, 2, 1];
     ```
     这里，`arr` 是可变的，因此你可以执行 `arr[0] = 99;` 或者稍后重新赋值 `arr = [1, 2, 3];`。如果没有 `mut`，Rust 会拒绝修改不可变变量（Rust 默认不可变以确保安全）。
   - 这个 `mut` 是关于变量本身的，与如何传递给函数无关。它不意味着复制或引用——仅仅是允许就地修改变量的权限。

### 2. **理解函数参数和引用中的 `&mut`**
   - `&mut` 创建一个*可变引用*（也称为可变借用）。这类似于 C 语言中允许读取*和*写入指向数据的指针，但 Rust 严格的借用检查器确保了安全性（无数据竞争，无悬垂指针）。
   - 在你的代码中：
     ```rust
     fn quick_sort(arr: &mut [i32]) { ... }
     ```
     - 参数 `arr` 是一个对 `i32` 切片（`&mut [i32]`）的可变引用。Rust 中的切片是对数组或向量的视图（类似于指针 + 长度），它们几乎总是作为引用传递，因为切片是“非固定大小”类型（其大小在编译时未知）。
     - 当你调用 `quick_sort(&mut arr);` 时，你传递的是对原始 `arr` 的可变引用。这使得函数能够通过引用修改原始数组的元素（例如，在 `partition` 中进行交换）。
     - 在函数内部，像 `arr.swap(i, j);` 这样的操作会直接影响原始数据，因为 `arr` 是指向它的引用。
   - 如果没有 `&`，你无法以这种方式直接传递像 `[i32]` 这样的切片作为参数——Rust 要求对非固定大小类型使用引用。但更一般地说，`&mut` 实现了具有修改权限的引用传递。

### 3. **Rust 中的值传递与引用传递**
   - Rust 使用*所有权*作为其核心模型，这与 Java（主要是基于引用配合垃圾回收）或 C（手动指针）不同。
     - **值传递（所有权转移）**：当你传递没有 `&` 的值时（例如 `fn foo(x: i32)` 或 `fn bar(mut v: Vec<i32>)`），数据的所有权会转移到函数。函数可以局部修改它，但更改不会影响调用者的原始数据（因为调用者不再拥有它）。如果类型实现了 `Copy`（如 `i32` 等基本类型），它会自动复制而不是移动——除非显式克隆，否则不会进行深拷贝。
       - 示例：
         ```rust
         fn foo(mut x: i32) {
             x += 1;  // 修改局部 x，但调用者的原始数据不变（或被移动/复制）。
             println!("内部: {}", x);
         }

         let y = 5;
         foo(y);  // 通过值传递（复制，因为 i32 是 Copy）。
         println!("之后: {}", y);  // 仍然是 5。
         ```
       - 这类似于其他语言中的“值传递”：基本类型被复制，较大的类型（如数组/向量）被移动（高效，除非克隆否则不复制）。
     - **引用传递（借用）**：使用 `&`（不可变引用）或 `&mut`（可变引用）“借用”数据而不转移所有权。函数获得一个临时视图（类似于指针），原始所有者保留控制权。
       - `&`：只读借用。无法修改原始数据。
       - `&mut`：读写借用。*可以*修改原始数据，类似于 C++ 中的引用传递或 C 中的可变指针。
       - 示例：
         ```rust
         fn bar(x: &mut i32) {
             *x += 1;  // 解引用并修改原始数据。
         }

         let mut y = 5;
         bar(&mut y);  // 传递可变引用。
         println!("之后: {}", y);  // 现在是 6，原始数据被更改。
         ```
       - 在你的快速排序代码中，使用的是带有 `&mut` 的引用传递，因此交换操作会改变原始数组。如果只是 `& [i32]`，你将无法修改它（不可变借用）。

   - 针对你的观点：是的，`&mut` 允许更改原始值（具有修改权限的引用传递），而不带 `&` 的传递（值传递）则会复制/移动数据，因此修改是局部的，不会影响原始数据。但请注意：
     - 并非所有类型都会自动复制——只有实现了 `Copy` 的类型才会（例如 `i32`，不包括数组或向量）。对于像你的数组这样的非 `Copy` 类型，通过值传递会*移动*所有权，你需要返回它才能“归还”给调用者。
     - Rust 为避免不必要的复制以提高效率。你的数组在作为 `&mut [i32]` 传递时不会被复制——它只是一个引用（浅层，类似于指针）。

### 4. **与 Java 和 C 的比较**
   - **Java**：所有非基本类型都是通过引用传递（浅层——对象是共享的，但重新分配参数不会影响调用者）。基本类型通过值传递（复制）。没有直接等同于 `mut` 或 `&mut` 的概念；可变性由类设计控制（例如 final 字段）。Java 没有 Rust 的所有权概念，因此更容易出现共享可变状态的问题。深拷贝需要手动克隆。
   - **C**：`&mut` 类似于传递指针（`int*`），你可以解引用并修改（`*ptr = 10;`）。普通的 `mut`（在声明中）类似于非常量变量。但 C 没有借用检查器，因此你需要手动管理生命周期（容易出错）。在 C 中通过值传递会复制数据（对于结构体是浅拷贝，除非你进行深拷贝）。
   - 关键区别：Rust 强制“一次只能有一个可变引用（或多个不可变引用）”，从而防止错误。没有空值，没有野指针。

### 5. **为什么代码中有时用 `mut`，有时用 `&mut`？**
   - 单独使用 `mut`：用于需要可变的局部变量，如 `let mut arr`（以便稍后可以传递 `&mut arr` 或直接修改它）。
   - 使用 `&mut`：在函数需要借用并修改调用者数据而不获取所有权时，用于参数中。在 `quick_sort` 和 `partition` 中，`&mut [i32]` 允许它们就地排序数组而无需移动/复制它。
   - 如果你尝试 `fn quick_sort(mut arr: [i32])`，它将无法编译——切片不能以这种方式通过值传递。你需要一个固定大小的数组（例如 `[i32; 7]`），并且它会移动所有权。
   - 在 `partition` 中，循环内部使用 `mut i`——那是一个局部可变变量，与传递无关。

### 6. **它是否会更改原始值？**
   - 对于 `&mut`：是，更改会传播到原始数据（引用传递）。
   - 对于值传递（没有 `&`）：否，只有局部更改（除非你返回修改后的值）。
   - 在你的 `quick_sort_interact()` 中，`println!("After: {:?}", arr);` 将显示排序后的数组，因为使用了 `&mut`。

如果你运行你的代码，它应该输出：
```
Before: [3, 6, 8, 10, 1, 2, 1]
After: [1, 1, 2, 3, 6, 8, 10]
```
（`mod simple;` 和 `simple::run_simple();` 似乎无关——可能是占位符？如果那里有错误，可能是因为 `simple` 未定义。）

如果这还没有澄清，或者你有特定的代码部分需要调整/测试，请告诉我！