---
audio: false
generated: false
image: false
lang: zh
layout: post
title: 优化基于段落的Markdown的翻译成本
translated: true
---

我的 Jekyll 博客使用 Markdown 编写段落。在用英文写作后，我使用 DeepSeek 或 Mistral 等 AI 工具将其翻译成其他八种语言。虽然它们已经很便宜，但仍有改进空间。

有时，我只是修改一个单词或一个段落，然后整篇文章会被翻译成其他八种语言。在这种情况下，token 使用量很高。如果只重新翻译修改后的段落，token 使用量会更低，尤其是对于长篇文章。

然而，我仍然希望使用 Markdown 记录我的想法。使用数据库维护和更新文章并不方便。使用 YAML 或 JSON 可能也过于繁琐。

关键在于识别编辑前后文本的差异。如果采用基于段落的方法，这意味着使用换行符 "\n" 分割文本。

我需要知道编辑后哪些段落发生了变化，哪些没有。我们需要在编辑前后的文本之间建立一一对应的段落映射。

我们采用基于段落的方法，因为我们希望更新 AI 模型生成的翻译。如果使用句子，可能不够准确。

对于 Markdown，可能更重要的做法是使用 Markdown 解析来基于 Markdown 元素同步翻译。

但如果没有代码块或特殊 Markdown 语法，我们可以使用基于段落的方法。

对于简单的基于段落的方法，我们有两个段落数组，需要了解它们如何匹配。

在比较这两个数组中的任何段落时，有两种可能的结果：它们相同或不同。如果不同，有几种情况：两者都是新增的，左边的是新增的，或者右边的是新增的。

我只是想节省成本，所以目标是减少 token 使用量。我不需要其他任何东西。我只需要翻译每个段落，缓存结果，下次对于每个段落，我会先查找翻译结果。如果不存在，则需要重新翻译。

对于 Markdown，情况稍微复杂一些。我不想翻译代码块。因此，我们可以使用 Markdown 解析库，对代码块和普通文本进行不同处理。

几周后，我将用 Python 和 Grok 实现这个功能，因为这是一个实际问题。我需要解决它。

一个设计是关于缓存文件。我将缓存存储在缓存目录中，文件名为 `lang.json`，例如 `zh.json` 等。