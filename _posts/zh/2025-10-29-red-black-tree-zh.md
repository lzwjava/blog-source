---
audio: false
generated: true
image: false
lang: zh
layout: post
model: x-ai/grok-4-fast
title: 红黑树概述
translated: true
type: note
---

### 什么是红黑树？

**红黑树**是计算机科学中用于高效存储和检索数据的一种自平衡二叉搜索树（BST）。它通过确保在插入和删除操作后树保持大致平衡，从而保证搜索、插入和删除操作的时间复杂度为 O(log n)，其中 n 是节点数量。

#### 关键特性
红黑树通过以下五条规则维持平衡：
1. **节点颜色**：每个节点要么是红色，要么是黑色。
2. **根节点**：根节点始终为黑色。
3. **叶节点**：所有 NIL（空）叶节点均为黑色。
4. **红节点规则**：红色节点不能有红色子节点（不允许连续两个红色节点）。
5. **黑高规则**：从任意节点到其所有后代叶节点的路径包含相同数量的黑色节点（确保平衡）。

这些规则防止树退化为链状结构（如链表），否则性能会下降至 O(n)。

#### 工作原理
- **插入**：首先像标准二叉搜索树插入一样操作。如果新节点违反规则（例如出现红-红父子节点），则通过“旋转”（左右旋转以调整结构）和“重新着色”来修复，从而保持树的高度为对数级别。
- **删除**：与插入类似但更复杂；涉及查找替代节点并通过调整颜色和旋转来维持特性。
- **搜索**：与二叉搜索树完全相同——根据键值比较向左或向右遍历。

旋转是局部操作，能在修复平衡的同时保持二叉搜索树特性。

#### 可视化示例
以下是一个键值为 10、20、30、40、50 的平衡红黑树的简易标记表示（R=红色，B=黑色）：

```
       B(30)
      /     \
   B(20)    B(40)
  /   \       \
R(10) R(25)  R(50)
```

#### 优势
- **与AVL树对比**：红黑树允许轻微不平衡以减少插入删除时的旋转次数，使其在实际动态数据场景中更快（例如Java的TreeMap和Linux内核中的使用）。
- **权衡**：相比完全平衡的树稍高，但实现更简单。

如需深入探索，可参考Python（通过sortedcontainers库）或C++（std::set）等语言的实现。若需代码示例或具体实现细节，请随时告知！