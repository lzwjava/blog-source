---
audio: false
generated: true
lang: zh
layout: post
title: 延迟数字
translated: true
type: note
---

### 核心要点
- 根据视频标题及相关网络内容推断，该视频很可能探讨了程序员应当掌握的典型延迟数值。
- 研究表明这些数值包含L1缓存访问（0.5纳秒）到网络往返（最高150毫秒）等操作时间，具体数值因硬件而异。
- 现有证据表明这些数值多为近似值，且会随技术发展更新，尤其在固态硬盘和网络领域表现明显。

### 引言解析
《程序员应当掌握的延迟数值：系统设计速成课 #1》这部视频很可能涵盖了计算机操作中的关键延迟指标，这对系统设计至关重要。这些数值能帮助程序员理解性能影响并优化系统。

### 延迟数值及其重要性
延迟是指从发起操作到完成操作之间的时间间隔，例如访问内存或通过网络传输数据。视频可能列举的典型延迟包括：
- L1缓存访问0.5纳秒，这是最快的内存访问方式
- 同数据中心内往返延迟500微秒（即0.5毫秒），这对分布式系统设计产生影响

这些近似值为系统设计提供决策依据，比如在内存存储与磁盘存储之间的选择权衡。

### 系统设计中的语境价值
理解这些延迟有助于代码优化、权衡决策和提升用户体验。例如，知晓磁盘寻道需要10毫秒，会影响数据库设计以尽量减少此类操作。

### 值得关注的细节
有趣的是，像SSD读取时间这类数值会随技术进步而提升，但L1缓存访问等核心CPU延迟却保持稳定，这揭示了硬件演进的不均衡性。

---

### 调研笔记：视频延迟数值深度解析

本笔记基于现有网络资源，对《程序员应当掌握的延迟数值：系统设计速成课 #1》视频可能讨论的延迟数值进行全面梳理。该分析旨在为程序员和系统设计师整合信息，既提供概要总结也深入解析这些数值的重要意义。

#### 背景与语境
该视频作为系统设计系列课程的一部分（观看地址：[YouTube](https://www.youtube.com/watch?v=FqR5vESuKe0)），重点聚焦程序员需要掌握的关键延迟数值。延迟作为衡量操作发起与完成间时间间隔的指标，对理解系统性能具有核心意义。根据视频标题及相关搜索推断，内容很可能涵盖被编程社区广泛引用的标准延迟数值，这些数值常归功于Google的Jeff Dean等人。

通过网络调研发现多个相关资源，包括GitHub上的《程序员应当掌握的延迟数值》Gist（[访问链接](https://gist.github.com/jboner/2841832)）和2023年的Medium文章（[阅读原文](https://medium.com/@bojanskr/latency-numbers-every-programmer-should-know-d85f8d3f8e6a)）。这些资源与2013年High Scalability文章（[查看详情](https://highscalability.com/more-numbers-every-awesome-programmer-must-know/)）共同构成了推测视频内容的基础。

#### 延迟数值汇总
根据收集信息，下表汇总了视频可能讨论的标准延迟数值，并附各项操作说明：

| 操作类型                                       | 延迟（纳秒） | 延迟（微秒） | 延迟（毫秒） | 技术说明                                                       |
|------------------------------------------------|--------------|--------------|--------------|----------------------------------------------------------------|
| L1缓存访问                                    | 0.5          | -            | -            | 访问最靠近CPU的一级缓存数据，速度最快                           |
| 分支预测失败                                   | 5            | -            | -            | CPU错误预测条件分支时产生的性能惩罚                             |
| L2缓存访问                                    | 7            | -            | -            | 访问二级缓存数据，容量大于L1但速度稍慢                          |
| 互斥锁加锁/解锁                                | 25           | -            | -            | 多线程程序中获取和释放互斥锁所需时间                            |
| 主内存访问                                     | 100          | -            | -            | 从主随机存取存储器读取数据                                      |
| 使用Zippy压缩1KB数据                         | 10,000       | 10           | -            | 采用Zippy算法压缩1千字节数据所需时间                           |
| 通过1Gbps网络发送1KB数据                     | 10,000       | 10           | -            | 在1千兆比特每秒网络中传输1千字节数据耗时                       |
| 从SSD随机读取4KB                              | 150,000      | 150          | -            | 从固态硬盘随机读取4千字节数据                                  |
| 从内存顺序读取1MB                             | 250,000      | 250          | -            | 从主内存顺序读取1兆字节数据                                    |
| 同数据中心内网络往返                           | 500,000      | 500          | 0.5          | 同一数据中心内的网络往返延迟                                    |
| 从SSD顺序读取1MB                              | 1,000,000    | 1,000        | 1            | 从固态硬盘顺序读取1兆字节数据                                  |
| 硬盘寻道                                       | 10,000,000   | 10,000       | 10           | 机械硬盘磁头定位到新位置所需时间                                |
| 从磁盘顺序读取1MB                             | 20,000,000   | 20,000       | 20           | 从机械硬盘顺序读取1兆字节数据                                  |
| 数据包加州-荷兰往返                            | 150,000,000  | 150,000      | 150          | 从美国加利福尼亚到荷兰的网络数据包往返时间                      |

这些主要源自2012年并经过部分更新的数值反映了典型硬件性能，近期讨论特别指出SSD和网络领域因技术发展存在的差异。

#### 分析与影响
延迟数值并非固定不变，会因具体硬件和配置产生差异。例如Ivan Pesin2020年的博客（[原文链接](http://pesin.space/posts/2020-09-22-latencies/)）指出，磁盘和网络延迟随着SSD（NVMe）和高速网络（10/100Gb）发展已显著改善，但L1缓存访问等核心CPU延迟保持稳定。这种不均衡演进凸显了系统设计中考虑具体语境的重要性。

实践中这些数值指导着多个方面：
- **性能优化**：减少高延迟操作（如10毫秒的磁盘寻道）能显著提升应用速度。例如将频繁访问数据缓存在内存（读取1MB需250微秒）而非磁盘，可有效降低等待时间。
- **权衡决策**：系统设计师常需在内存缓存与数据库使用间选择。了解主内存访问（100纳秒）比L1缓存访问（0.5纳秒）慢200倍，能为这类决策提供依据。
- **用户体验**：在网络应用中，数据中心往返延迟（500微秒）等网络延迟会影响页面加载速度，进而影响用户满意度。Vercel2024年博客（[文章链接](https://vercel.com/blog/latency-numbers-every-web-developer-should-know)）特别强调了前端开发中网络请求瀑布流会叠加延迟的影响。

#### 历史沿革与更新
原始数值可追溯至2010年左右，归功于Jeff Dean并通过Peter Norvig推广，后由Colin Scott等研究者更新（[交互式延迟网站](https://colin-scott.github.io/personal_website/research/interactive_latency.html)）。Dan Hon2019年在Medium（[文章链接](https://medium.com/@hondanhon/more-latency-numbers-every-programmer-should-know-3142f0cf614d)）中增加了幽默而相关的延迟数据，如重启MacBook Pro需90秒，这展示了更广泛的技术相关延迟。但核心延迟数值变化甚微，GitHub Gist指出截至2023年这些数值因物理限制仍保持"高度相似"。

#### 结论与建议
对程序员和系统设计师而言，记忆这些延迟数值能为性能调优建立思维模型。它们应被视为指导原则，具体硬件仍需实际基准测试。及时关注量子计算或5G网络等新兴技术的更新至关重要，GitHub Gist和Medium文章可作为深入探索的起点。

本分析基于视频可能内容并辅以广泛网络研究，强调了延迟数值在计算领域的持久重要性，同时呼吁顺应技术变革以实现最优系统设计。

#### 关键引用
- [程序员应当掌握的延迟数值 GitHub Gist](https://gist.github.com/jboner/2841832)
- [程序员应当掌握的延迟数值 YouTube视频](https://www.youtube.com/watch?v=FqR5vESuKe0)
- [更新的延迟数值 Medium文章](https://medium.com/@bojanskr/latency-numbers-every-programmer-should-know-d85f8d3f8e6a)
- [优秀程序员必须掌握的更多数值 High Scalability](https://highscalability.com/more-numbers-every-awesome-programmer-must-know/)
- [Web开发者应当掌握的延迟数值 Vercel博客](https://vercel.com/blog/latency-numbers-every-web-developer-should-know)
- [工程师应当掌握的延迟数值 Pesin空间博客](http://pesin.space/posts/2020-09-22-latencies/)
- [程序员应当掌握的更多延迟数值 Dan Hon Medium](https://medium.com/@hondanhon/more-latency-numbers-every-programmer-should-know-3142f0cf614d)
- [按年列出的程序员必备数值 交互式延迟网站](https://colin-scott.github.io/personal_website/research/interactive_latency.html)