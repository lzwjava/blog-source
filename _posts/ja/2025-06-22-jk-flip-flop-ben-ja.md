---
audio: false
generated: true
lang: ja
layout: post
title: ベン・イーターによるSRラッチとフリップフロップの改造
translated: true
type: note
---

前回の動画ではSRラッチについて説明しましたので、もしご存知でない方はそちらをご覧になることをお勧めします。簡単にまとめると、SRラッチには2つの入力、**R**（リセット）と**S**（セット）があります。リセット入力がHighになると、出力**Q**はLow（オフ）になり、ラッチがリセットされます。セット入力がHighになると、出力**Q**はHigh（オン）になり、ラッチがセットされます。また、補完出力である**Q̅**（Qバー）もあり、これは常に**Q**と反対の値になります。ただし、**R**入力と**S**入力が同時にHighになった場合のみ例外です。このシナリオでは、**Q**と**Q̅**の両方がLowになり、これは無効状態と見なされます。なぜなら、ラッチをセットとリセットを同時に行うべきではないからです。両方の入力が解除されると、ラッチの状態はどちらの入力が先に解除されるかに依存するため、予測不能になります。一般的に、SRラッチは2つの安定状態のいずれかにラッチされたままになります。

この動画では、基本的なSRラッチ回路への修正点について説明します。最初の修正は、**イネーブル付きSRラッチ**です。このバージョンでは、**R**入力と**S**入力の両方に**ANDゲート**を追加し、それらを**イネーブル**信号で制御します。イネーブル信号がHigh(1)のとき、ANDゲートは**R**入力と**S**入力を変更せずに通過させます。例えば、**イネーブル**が1で**リセット**が1の場合、ANDゲートの出力は1になります。**リセット**が0の場合、出力は0になります。しかし、**イネーブル**信号がLow(0)の場合、**R**入力と**S**入力に関わらず、ANDゲートの出力は常に0になります。これにより、ラッチは最後の状態を維持し、実質的に入力を無視します。したがって、イネーブル信号を使用すると、ラッチを**R**および**S**入力に応答するように有効にするか、現在の状態を保持するように無効にすることができます。

次に、この概念を拡張して**SRフリップフロップ**を作成できます。ラッチとフリップフロップの主な違いは、ラッチの出力は入力が変化するたびに変化するのに対し、フリップフロップの出力は特定のトリガー、通常はクロックパルスでのみ変化する点です。SRフリップフロップでは、**クロック**入力（図では三角形の記号で示される）が出力を更新するタイミングを制御します。具体的には、出力**Q**と**Q̅**は、クロックがLowからHighに遷移する時（立ち上がりエッジ）のみ変化します。それ以外の時間では、入力**R**と**S**は無視され、フリップフロップは以前の状態を保持します。

SRフリップフロップは、クロック回路にコンデンサを使用することでこれを実現します。クロックがLowからHighに遷移するとき、コンデンサが充電される間に短い電流が流れ、ANDゲートの入力に短い電圧パルスが生成されます。このパルスは、その瞬間だけイネーブル付きSRラッチを実質的に有効にし、**R**入力と**S**入力が出力**Q**と**Q̅**に影響を与えることを可能にします。コンデンサが完全に充電されると、パルスは停止し、フリップフロップは次の立ち上がりエッジまでそれ以降の入力変化を無視します。

以下は、クロックの立ち上がりエッジにおけるSRフリップフロップの動作です：
- **R**がHighで**S**がLowの場合、**Q**はLow（リセット）になり、**Q̅**はHighになります。
- **S**がHighで**R**がLowの場合、**Q**はHigh（セット）になり、**Q̅**はLowになります。
- **R**と**S**の両方がLowの場合、フリップフロップは以前の状態を維持します。
- **R**と**S**の両方がHighの場合（SRラッチの無効状態）、動作は予測不能です。SRラッチと同様に、パルス中は**Q**と**Q̅**の両方がLowになる可能性がありますが、入力が解除されると、フリップフロップはどちらの入力が先に落ちるかに基づいて、いずれかの状態に落ち着きます。これにより、出力は（数ナノ秒などの）タイミングの差に依存するため不確実になり、これは無効で予測不能な状態となります。

この予測不能性に対処するために、**JKフリップフロップ**を使用できます。これはSRフリップフロップと似ていますが、出力**Q**と**Q̅**から入力へのフィードバックを含みます。JKフリップフロップは、**J**（**S**に相当）、**K**（**R**に相当）、およびフィードバック信号**Q**と**Q̅**を取り込む3入力ANDゲートを使用します。文字**J**と**K**は任意のもので特定の用語を表すものではありませんが、この回路をSRフリップフロップと区別する役割を果たします。

JKフリップフロップの動作は以下の通りです：
- **J**と**K**が両方とも0の場合、ANDゲートの出力は0なので、フリップフロップはクロックパルス中でも以前の状態を維持します。
- ラッチが現在セットされている状態（**Q** = 1, **Q̅** = 0）で、それをリセットしたい場合（**K** = 1, **J** = 0）、**K**に接続されたANDゲートはクロックパルス中に1を出力し（**Q** = 1なので）、フリップフロップをリセットします（**Q** = 0, **Q̅** = 1）。
- ラッチが既にリセットされている状態（**Q** = 0, **Q̅** = 1）で、**K** = 1, **J** = 0の場合、ANDゲートの出力は0のままなので、フリップフロップはリセット状態を維持します。これは望ましい動作です。
- 同様に、ラッチがリセットされている状態（**Q** = 0, **Q̅** = 1）で、それをセットしたい場合（**J** = 1, **K** = 0）、**J**に接続されたANDゲートはクロックパルス中に1を出力し（**Q̅** = 1なので）、フリップフロップをセットします（**Q** = 1, **Q̅** = 0）。
- ラッチが既にセットされており、**J** = 1, **K** = 0の場合、期待通りセット状態を維持します。

JKフリップフロップのユニークな機能は、**J**と**K**が両方とも1の場合に生じます。フィードバックにより、一方のANDゲートのみが同時にアクティブになります（なぜなら**Q**と**Q̅**が両方とも1になることはないからです）。もし**Q**が1であれば、**K**用のANDゲートがアクティブになり、次のクロックパルスでフリップフロップはリセットされます（**Q** = 0, **Q̅** = 1）。もし**Q**が0であれば、**J**用のANDゲートがアクティブになり、次のクロックパルスでフリップフロップはセットされます（**Q** = 1, **Q̅** = 0）。これにより、**トグル**動作が生まれます：もし**J** = **K** = 1の場合、フリップフロップは各クロックパルスでその状態を切り替えます（**Q**が0から1、または1から0に反転します）。この予測可能なトグル動作により、SRフリップフロップの無効で予測不能な状態が排除され、JKフリップフロップはより堅牢で汎用性の高いものになります。