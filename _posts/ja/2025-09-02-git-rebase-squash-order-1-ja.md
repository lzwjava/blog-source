---
audio: false
generated: true
image: false
lang: ja
layout: post
title: Gitリベースでのスカッシュ順序の解説
translated: true
type: note
---

`git rebase -i`（インタラクティブリベース）でコミットを squash する場合、Git は特定の順序とロジックに従います：

---

### 1. デフォルトの順序

インタラクティブリベース（例：`git rebase -i HEAD~5`）を開始すると、Git はエディタを開き、**コミットが古いものから新しいものへ**（上＝最も古い、下＝最も新しい）とリスト表示します。
この順序は重要です：これは Git が新しいベースにリプレイしようとするシーケンスです。

---

### 2. Pick と Squash

* **pick** → コミットをそのまま保持します。
* **squash (または s)** → このコミットを、**前の `pick` が付いたコミット** と結合します。
* **fixup (または f)** → squash と同じですが、コミットメッセージを破棄します（最初のコミットのメッセージのみを保持します）。

したがって、次のように記述した場合：

```
pick  a1b2c3  Initial feature
squash d4e5f6  Minor fix
squash g7h8i9  Small cleanup
pick  j1k2l3  Another feature
```

Git は `d4e5f6` と `g7h8i9` を `a1b2c3` にマージし、単一のコミットを生成します。

---

### 3. コミットの並べ替え

リベースエディタで行を上下に移動することで、コミットを直接**並べ替える**ことができます。
例：

```
pick  a1b2c3  Initial feature
pick  j1k2l3  Another feature
squash d4e5f6  Minor fix
squash g7h8i9  Small cleanup
```

ここでは、Git は最初に `a1b2c3` を適用し、次に `j1k2l3` を適用します。
`squash` コミット（`d4e5f6` と `g7h8i9`）は、squash が常に直前の `pick` にマージされるため、**`j1k2l3`** に squash されます。

---

### 4. メッセージの編集

squash 後、Git は一時停止し、squash されたコミットの**コミットメッセージを編集**できるようにします。以下のことが可能です：

* すべてのメッセージを保持する。
* 手動で結合する。
* 最初のもののみを保持する。

---

### 5. よくある落とし穴

* 最初のコミット（その前に `pick` がない）に `squash` を置くと、Git はエラーをスローします — squash するためのベースコミットが必要です。
* 並べ替え後にコミットが競合すると、リベース中に手動で競合を解決する必要があります。
* 並べ替えは履歴を大幅に変更する可能性があります。履歴の書き換えを確実に望まない限り、プッシュ/共有していないブランチでのみ実行してください。

---

✅ 要約：

* コミットは**古い→新しい**順にリストされます。
* `pick` は保持、`squash` は**直前の `pick`** にマージします。
* エディタでコミットを手動で並べ替えることができます。squash は常に下位のコミットを前の pick されたコミットに取り込みます。

---

これを **コミット履歴の前後例**（squash 前後の `git log --oneline` を表示）で説明しましょうか？通常、これにより順序がより明確になります。