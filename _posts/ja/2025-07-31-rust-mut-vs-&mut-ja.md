---
audio: false
generated: true
image: false
lang: ja
layout: post
title: Rustのmutと&mutの解説
translated: true
type: note
---

Rustにおいて、キーワード`mut`と`&mut`は関連しているものの異なる目的を持ち、Javaのディープ/シャローコピーの概念やCのポインタと直接同等ではありませんが、明確化のためにいくつかの類似点を引き出すことができます。段階的に説明し、違いを解説し、値渡しと参照渡し、可変性、および変更が元のデータにどのように影響するかについての質問に対処します。提供されたコードに基づいた例を使用して説明します。

### 1. **変数宣言における`mut`の理解**
   - `let mut`で変数を宣言する場合、*バインディング*（変数名）を可変にしています。これは、変数を再代入したり、その内容を直接変更したりできることを意味しますが、宣言されたスコープ内でのみです。
   - コードからの例:
     ```rust
     let mut arr = [3, 6, 8, 10, 1, 2, 1];
     ```
     ここで、`arr`は可変なので、`arr[0] = 99;`を行ったり、後で`arr = [1, 2, 3];`と再代入したりできます。`mut`なしでは、Rustは不変変数を変更しようとしていることについて文句を言います（Rustは安全性のためにデフォルトで不変性を採用しています）。
   - この`mut`は変数自体に関するものであり、関数にどのように渡されるかについては関係ありません。コピーや参照を暗示するものではなく、単に変数をその場で変更する許可です。

### 2. **関数パラメータと参照における`&mut`の理解**
   - `&mut`は*可変参照*（可変借用とも呼ばれる）を作成します。これは、Cのポインタのように、指し示すデータの読み取り*と*書き込みを可能にしますが、Rustの厳格な借用チェッカーが安全性（データ競合なし、ダングリングポインタなし）を保証します。
   - コード内:
     ```rust
     fn quick_sort(arr: &mut [i32]) { ... }
     ```
     - パラメータ`arr`は`i32`のスライスへの可変参照（`&mut [i32]`）です。Rustのスライスは配列やベクターへのビュー（ポインタ＋長さのようなもの）であり、スライスは「非サイズ型」（コンパイル時にサイズが不明な型）であるため、ほとんど常に参照として渡されます。
     - `quick_sort(&mut arr);`を呼び出すとき、元の`arr`への可変参照を渡しています。これにより、関数は参照を通じて元の配列の要素を変更できます（例：`partition`内でのスワップ）。
     - 関数内で、`arr.swap(i, j);`のような操作は、`arr`が元のデータを指す参照であるため、直接元のデータに影響を与えます。
   - `&`なしでは、この方法でスライス`[i32]`を直接パラメータとして渡すことはできません—Rustは非サイズ型に対して参照を要求します。しかし、より一般的には、`&mut`は変更権限を持つ参照渡しを可能にします。

### 3. **Rustにおける値渡しと参照渡し**
   - Rustはその核心モデルとして*所有権*を使用しており、これはJava（ガベージコレクションを伴うほとんど参照ベース）やC（手動ポインタ）とは異なります。
     - **値渡し（所有権の転送）**: `&`なしで値を渡す場合（例：`fn foo(x: i32)`または`fn bar(mut v: Vec<i32>)`）、データの所有権が関数に移動します。関数はローカルでそれを変更できますが、変更は呼び出し元の元のデータに影響しません（呼び出し元はもはや所有していないため）。型が`Copy`を実装している場合（`i32`のようなプリミティブ）、自動的にコピーされ、移動されません—明示的にクローンしない限り、ディープコピーは行われません。
       - 例:
         ```rust
         fn foo(mut x: i32) {
             x += 1;  // ローカルのxを変更するが、呼び出し元の元のデータは変更されない（または移動/コピーされる）。
             println!("Inside: {}", x);
         }

         let y = 5;
         foo(y);  // 値で渡す（i32はCopyなのでコピー）。
         println!("After: {}", y);  // まだ5。
         ```
       - これは他の言語での「値渡し」に似ています：プリミティブはコピーされ、大きな型（配列/ベクターなど）は移動されます（効率的で、クローンしない限りコピーされません）。
     - **参照渡し（借用）**: `&`（不変参照）または`&mut`（可変参照）を使用すると、所有権を転送せずにデータを「借用」します。関数は一時的なビュー（ポインタのようなもの）を取得し、元の所有者は制御を保持します。
       - `&`: 読み取り専用借用。元のデータを変更できません。
       - `&mut`: 読み書き可能な借用。C++での参照渡しやCでの可変ポインタのように、元のデータを*変更できます*。
       - 例:
         ```rust
         fn bar(x: &mut i32) {
             *x += 1;  // 参照を外して元のデータを変更。
         }

         let mut y = 5;
         bar(&mut y);  // 可変参照を渡す。
         println!("After: {}", y);  // 今は6、元のデータが変更された。
         ```
       - クイックソートコードでは、`&mut`を使用した参照渡しであるため、スワップは元の配列を変更します。もし単に`& [i32]`であれば、変更できません（不変借用）。

   - 要点について：はい、`&mut`は元の値を変更することを許可します（変更を伴う参照渡し）。一方、`&`なしで渡す（値渡し）場合はデータをコピー/移動するため、変更はローカルであり元のデータに影響しません。ただし：
     - すべての型が自動的にコピーされるわけではありません—`Copy`を実装する型のみ（例：`i32`、配列やベクターは除く）。配列のような非`Copy`型の場合、値渡しは所有権を*移動*し、呼び出し元に「返す」ために返す必要があります。
     - Rustは効率のために不必要なコピーを避けます。配列は`&mut [i32]`として渡されるときにコピーされません—単なる参照（浅い、ポインタのようなもの）です。

### 4. **JavaとCとの比較**
   - **Java**: プリミティブ以外はすべて参照渡し（浅い—オブジェクトは共有されるが、パラメータの再代入は呼び出し元に影響しない）。プリミティブは値渡し（コピー）。`mut`や`&mut`に直接相当するものはありません；可変性はクラス設計によって制御されます（例：finalフィールド）。JavaにはRustの所有権がないため、共有された可変状態の問題が起こりやすいです。ディープコピーには手動でのクローンが必要です。
   - **C**: `&mut`はポインタを渡すようなもの（`int*`）で、参照を外して変更できます（`*ptr = 10;`）。単なる`mut`（宣言内）は非const変数のようなものです。しかし、Cには借用チェッカーがないため、ライフタイムを手動で管理します（エラーが起こりやすい）。Cでの値渡しはデータをコピーします（構造体に対してはディープコピーしない限り浅い）。
   - 主な違い：Rustは「一度に一つの可変参照」を強制し（または複数の不変参照）、バグを防ぎます。nullなし、ワイルドポインタなし。

### 5. **コード内で時々`mut`、時々`&mut`が使われる理由は？**
   - `mut`単独：変更可能なローカル変数に使用されます。例：`let mut arr`（後で`&mut arr`を渡したり直接変更したりできるように）。
   - `&mut`：関数が所有権を取らずに呼び出し元のデータを借用して変更する必要がある場合に、パラメータで使用されます。`quick_sort`と`partition`では、`&mut [i32]`により、配列を移動/コピーせずにその場でソートできます。
   - `fn quick_sort(mut arr: [i32])`を試みると、コンパイルされません—スライスはそのように値で渡せません。固定サイズの配列（例：`[i32; 7]`）が必要で、所有権が移動します。
   - `partition`では、ループが内部的に`mut i`を使用しています—これはローカルの可変変数であり、渡し方とは無関係です。

### 6. **元の値は変更されるか？**
   - `&mut`の場合：はい、変更は元のデータに伝搬します（参照渡し）。
   - 値渡し（`&`なし）の場合：ローカルの変更のみ（変更された値を返さない限り）。
   - `quick_sort_interact()`では、`println!("After: {:?}", arr);`はソートされた配列を表示します。なぜなら`&mut`が使用されたからです。

コードを実行すると、次のように出力されるはずです：
```
Before: [3, 6, 8, 10, 1, 2, 1]
After: [1, 1, 2, 3, 6, 8, 10]
```
（`mod simple;`と`simple::run_simple();`は無関係のようです—おそらくプレースホルダー？エラーがある場合、`simple`が定義されていないためかもしれません。）

これで明確にならない場合、または調整/テストするコードの特定の部分がある場合は、お知らせください！