---
audio: false
generated: true
lang: ja
layout: post
title: Dockerの仕組み
translated: true
type: note
---

Docker の仕組みについて、Linux のファイルシステムの活用方法と、アプリケーションを互いに分離する方法に焦点を当てて探っていきましょう。

---

### Docker の本質とは？
Docker は、**コンテナ** と呼ばれる軽量で分離された環境内でアプリケーションをパッケージ化、配布、実行することを可能にするプラットフォームです。オペレーティングシステム全体を含む仮想マシン (VM) とは異なり、Docker コンテナはホスト OS のカーネルを共有し、その機能を利用して分離と効率性を実現します。

---

### Docker の仕組み
Docker はコンテナの作成と管理のために、いくつかの Linux カーネル機能を活用しています：
1.  **Namespaces** - 分離のため。
2.  **Control Groups (cgroups)** - リソース管理のため。
3.  **Union Filesystems** - 効率的なストレージとレイヤリングのため。

これらの要素がどのように組み合わさるかを以下に示します：

---

#### 1. Linux Namespaces: 分離メカニズム
Namespaces はシステムリソースの分離された「ビュー」を作成し、あるコンテナ内のプロセスが他のコンテナ内のプロセスに干渉しないようにします。Docker が使用する主な名前空間は以下の通りです：

-   **PID Namespace**: 各コンテナは独自のプロセス ID 空間を持ちます。コンテナ内のプロセス ID 1 は、ホストの PID 1 (通常は `init` または `systemd`) から分離されています。
-   **Network Namespace**: コンテナは独自のネットワークスタック (IP アドレス、ポート、ルーティングテーブル) を取得します。これにより、2 つのコンテナが競合することなくポート 8080 でリッスンできます。
-   **Mount Namespace**: 各コンテナは、ホストや他のコンテナから分離された、ファイルシステムの独自のビューを持ちます。
-   **UTS Namespace**: コンテナは独自のホスト名とドメイン名を持つことができます。
-   **IPC Namespace**: プロセス間通信 (共有メモリ、メッセージキューなど) を分離します。
-   **User Namespace** (オプション): コンテナのユーザーをホストのユーザーにマッピングし、セキュリティを強化します。

**例**: コンテナ内で `ps` を実行すると、そのコンテナの PID 名前空間内のプロセスのみが表示され、ホストのプロセスは表示されません。

---

#### 2. Control Groups (cgroups): リソース制限
Cgroups は、各コンテナのリソース使用量 (CPU、メモリ、ディスク I/O など) を制限および監視します。これにより、あるコンテナがすべてのシステムリソースを占有し、他のコンテナがリソース不足に陥るのを防ぎます。

-   **仕組み**: Docker は各コンテナに cgroup を割り当てます。以下のように制限を設定できます：
    ```bash
    docker run --memory="512m" --cpus="0.5" myapp
    ```
    これは、コンテナを 512 MB の RAM と CPU コアの半分に制限します。

-   **分離**: Namespaces が可視性を分離するのに対し、cgroups はリソース消費を分離します。

---

#### 3. Union Filesystems: 階層化ストレージ
Docker は **union filesystem** (例: OverlayFS, AUFS) を使用して、コンテナイメージとそのファイルシステムを効率的に管理します。これが Linux ファイルシステムとどのように結びつくかです：

-   **Image Layers**: Docker イメージは、積み重ねられた読み取り専用のレイヤーから構築されます。各レイヤーは、`Dockerfile` で定義された一連の変更 (パッケージのインストール、ファイルのコピーなど) を表します。
    -   例: `FROM openjdk:17` は 1 つのレイヤー、`COPY app.jar` は別のレイヤーを追加します。
    -   レイヤーはキャッシュされ再利用されるため、ディスクスペースを節約し、ビルドを高速化します。

-   **Container Filesystem**: コンテナを実行すると、Docker は読み取り専用のイメージレイヤーの上に薄い書き込み可能なレイヤーを追加します。これは **copy-on-write (CoW)** メカニズムと呼ばれます：
    -   読み取りはイメージレイヤーから行われます。
    -   書き込み (ログファイル、一時データなど) は書き込み可能なレイヤーに行われます。
    -   下位レイヤーのファイルが変更されると、まず書き込み可能なレイヤーにコピーされます (これが "copy-on-write" の由来です)。

-   **分離**: 各コンテナは独自の書き込み可能なレイヤーを取得するため、たとえ同じベースイメージを共有していても、あるコンテナでの変更が他のコンテナに影響を与えることはありません。

-   **ディスク上**: ホスト上では、これらのレイヤーは `/var/lib/docker` (例: OverlayFS の場合は `/var/lib/docker/overlay2`) に保存されます。これは直接操作するものではなく、Docker が管理します。

---

### アプリケーションが互いにどのように分離されるか
上記のコンポーネントが連携してアプリケーションを分離する仕組みは以下の通りです：

1.  **プロセス分離 (PID Namespace)**:
    -   各コンテナは、他のコンテナやホストを認識しない独立したプロセスツリーとしてアプリを実行します。

2.  **ネットワーク分離 (Network Namespace)**:
    -   コンテナは分離されたネットワークインターフェースを持ちます。Docker のデフォルトの "bridge" ネットワークは各コンテナに一意の IP を割り当て、NAT が外部通信を処理します。
    -   例: 2 つの Spring Boot アプリは、競合することなく両方ともコンテナ内のポート 8080 にバインドできます。

3.  **ファイルシステム分離 (Mount Namespace + UnionFS)**:
    -   各コンテナは、イメージレイヤーとその書き込み可能なレイヤーから構築された、自身のファイルシステムのみを参照します。
    -   コンテナ A が `/tmp` に書き込んでも、コンテナ B はそれを参照しません。

4.  **リソース分離 (cgroups)**:
    -   あるアプリがホストの CPU やメモリを枯渇させ、別のアプリをクラッシュさせることはできません。

5.  **カーネルの共有**:
    -   コンテナはホストの Linux カーネルを共有しますが、namespaces はそれらが互いに干渉しないようにします。システムコールは必要に応じてフィルタリングまたはリダイレクトされます。

---

### 簡略化されたワークフロー
1.  **Build**: `Dockerfile` でアプリとその依存関係を定義してイメージを作成します。Docker は union filesystem を使用してこれらをレイヤーに積み重ねます。
2.  **Run**: Docker は以下の手順でコンテナを作成します：
    -   分離のために namespaces を設定。
    -   リソース制限のために cgroups を割り当て。
    -   イメージレイヤーと書き込み可能なレイヤーをマウント。
    -   エントリポイントとしてアプリを起動 (例: `java -jar app.jar`)。
3.  **Cleanup**: コンテナが停止すると、書き込み可能なレイヤーは破棄されます (`docker commit` で新しいイメージとして保存しない限り)。

---

### なぜ Linux なのか？
Docker は、その動作方法に深く統合されている Linux カーネル機能 (namespaces, cgroups, union filesystems) に依存しています。macOS または Windows では、Docker は軽量な Linux VM (HyperKit または WSL2 経由) を実行してこれらの機能を提供し、それらをホスト OS にマッピングします。

---

### 視覚的な例え
Docker コンテナを建物内のアパートメントと考えてみてください：
-   **Namespaces**: 壁とドアが居住者を分離します。
-   **Cgroups**: 大家は各部屋の水道や電気を制限します。
-   **UnionFS**: すべてのアパートメントは共通の設計図 (イメージレイヤー) を共有しますが、各居住者は自分の空間を装飾できます (書き込み可能なレイヤー)。

---

Docker の仕組みとアプリの分離方法について明確になりましたか？どの部分についてさらに深く掘り下げたいか、お知らせください！