---
audio: false
generated: true
lang: ja
layout: post
title: SAXを用いたXML解析
translated: true
type: note
---

JavaでXML文書を解析するために`org.xml.sax`パッケージを使用するには、SAX（Simple API for XML）解析アプローチを用いた簡単なプロセスに従うことができます。SAXはイベント駆動型のパーサーで、XML文書を順次読み取り、要素やテキストコンテンツなどの文書の様々な部分に遭遇するとコールバックメソッドをトリガーします。これにより、DOMのように文書全体をメモリにロードしないため、特に大規模なXMLファイルに対してメモリ効率が良くなります。以下は、`org.xml.sax`を使用するためのステップバイステップガイドです。

---

### ステップ 1: SAXパーサーのセットアップ
SAXでXMLを解析し始めるには、`SAXParserFactory`クラスを使用して`SAXParser`インスタンスを作成する必要があります。このファクトリーを使用すると、パーサーを作成する前にその動作を設定できます。

`SAXParser`を作成する方法は以下の通りです：

```java
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;

public class SAXExample {
    public static void main(String[] args) {
        try {
            // SAXParserFactoryインスタンスを作成
            SAXParserFactory factory = SAXParserFactory.newInstance();

            // オプション: ファクトリーを設定（例：名前空間の認識を有効化）
            factory.setNamespaceAware(true); // XMLが名前空間を使用する場合にtrueに設定

            // SAXParserを作成
            SAXParser parser = factory.newSAXParser();

            // 次のステップはここに記述
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

- **`SAXParserFactory.newInstance()`**: 新しいファクトリーインスタンスを作成します。
- **`factory.setNamespaceAware(true)`**: オプションです。XMLが名前空間を使用する場合、名前空間処理を有効にします。デフォルトは`false`です。
- **`factory.newSAXParser()`**: `SAXParser`を作成します。パーサーが設定できない場合や初期化できない場合、`ParserConfigurationException`または`SAXException`がスローされる可能性があります。

---

### ステップ 2: XMLイベントのハンドラーを作成
SAX解析は、遭遇したXMLイベント（要素の開始、要素の終了、テキストコンテンツなど）を処理するためのハンドラーに依存します。主要なインターフェースは`ContentHandler`ですが、簡単にするために`DefaultHandler`クラスを拡張することができます。これは`ContentHandler`および他のハンドラーインターフェース（`ErrorHandler`、`DTDHandler`など）の空の実装を提供します。必要なメソッドだけをオーバーライドすればよいです。

カスタムハンドラーの例は以下の通りです：

```java
import org.xml.sax.Attributes;
import org.xml.sax.helpers.DefaultHandler;

public class MyHandler extends DefaultHandler {
    // テキストコンテンツを蓄積するための変数
    private StringBuilder content = new StringBuilder();

    @Override
    public void startElement(String uri, String localName, String qName, Attributes attributes) {
        // 新しい要素のためにコンテンツバッファをクリア
        content.setLength(0);
        System.out.println("要素開始: " + qName);

        // 要素が属性を持つ場合、それらを処理
        for (int i = 0; i < attributes.getLength(); i++) {
            System.out.println("属性: " + attributes.getQName(i) + " = " + attributes.getValue(i));
        }
    }

    @Override
    public void characters(char[] ch, int start, int length) {
        // テキストコンテンツを蓄積（要素ごとに複数回呼び出される可能性あり）
        content.append(ch, start, length);
    }

    @Override
    public void endElement(String uri, String localName, String qName) {
        // 蓄積されたテキストコンテンツを処理
        String text = content.toString().trim();
        if (!text.isEmpty()) {
            System.out.println("コンテンツ: " + text);
        }
        System.out.println("要素終了: " + qName);
        content.setLength(0); // 次の要素のためにリセット
    }

    @Override
    public void startDocument() {
        System.out.println("文書解析開始");
    }

    @Override
    public void endDocument() {
        System.out.println("文書解析完了");
    }
}
```

- **`startElement`**: パーサーが要素の開始に遭遇したときに呼び出されます。パラメーターには以下が含まれます：
  - `uri`: 名前空間URI（名前空間を認識する場合）。
  - `localName`: 要素のローカル名（プレフィックスなし、名前空間を認識する場合）。
  - `qName`: 修飾名（プレフィックスを含む、もしあれば）。
  - `attributes`: 要素の属性のリスト。
- **`characters`**: 要素内のテキストコンテンツに対して呼び出されます。単一の要素のコンテンツに対して複数回呼び出される可能性があるため、`StringBuilder`を使用して蓄積します。
- **`endElement`**: 要素が終了したときに呼び出されます。
- **`startDocument`および`endDocument`**: XML文書の開始時と終了時に呼び出されます。

---

### ステップ 3: XMLを解析
パーサーとハンドラーの準備ができたら、`SAXParser`の`parse`メソッドを呼び出し、ハンドラーを渡すことでXMLソース（ファイル、`InputStream`、文字列など）を解析できます。

XMLファイルを解析する方法は以下の通りです：

```java
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import java.io.File;

public class SAXExample {
    public static void main(String[] args) {
        try {
            // パーサーを作成
            SAXParserFactory factory = SAXParserFactory.newInstance();
            SAXParser parser = factory.newSAXParser();

            // ハンドラーを作成
            MyHandler handler = new MyHandler();

            // XMLファイルを解析
            File xmlFile = new File("example.xml");
            parser.parse(xmlFile, handler);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

- **`parser.parse`**: XMLソース（例：`File`）と`DefaultHandler`を取ります。`IOException`（入力エラーの場合）または`SAXException`（解析エラーの場合）がスローされる可能性があります。

ファイルの代わりにXML文字列を使用する場合は、`InputSource`を使用します：

```java
import org.xml.sax.InputSource;
import java.io.StringReader;

// mainメソッド内
String xml = "<book><title>XML Parsing</title></book>";
InputSource inputSource = new InputSource(new StringReader(xml));
parser.parse(inputSource, handler);
```

---

### ステップ 4: 例外の処理
SAX解析には、処理すべきいくつかの例外が関与します：

- **`ParserConfigurationException`**: `newSAXParser()`によって、パーサーが設定できない場合にスローされます。
- **`SAXException`**: `newSAXParser()`または`parse()`によって、一般的な解析エラーのためにスローされます。
- **`IOException`**: `parse()`によって、入力ソースの読み込みに問題がある場合にスローされます。

コードを`try-catch`ブロックで囲みます：

```java
try {
    SAXParserFactory factory = SAXParserFactory.newInstance();
    SAXParser parser = factory.newSAXParser();
    MyHandler handler = new MyHandler();
    parser.parse(new File("example.xml"), handler);
} catch (ParserConfigurationException e) {
    System.err.println("パーサー設定エラー: " + e.getMessage());
} catch (SAXException e) {
    System.err.println("SAXエラー: " + e.getMessage());
} catch (IOException e) {
    System.err.println("IOエラー: " + e.getMessage());
}
```

---

### ステップ 5: オプション機能
#### エラー処理
`DefaultHandler`は`ErrorHandler`も実装しています。そのメソッドをオーバーライドして解析エラーを処理します：

```java
public class MyHandler extends DefaultHandler {
    @Override
    public void error(SAXParseException e) {
        System.err.println("解析エラー: " + e.getMessage());
    }

    @Override
    public void fatalError(SAXParseException e) throws SAXException {
        System.err.println("致命的エラー: " + e.getMessage());
        throw e; // 解析を停止
    }

    @Override
    public void warning(SAXParseException e) {
        System.out.println("警告: " + e.getMessage());
    }
    // 他のメソッドは上記と同じ
}
```

#### 名前空間処理
XMLが名前空間を使用する場合、`factory.setNamespaceAware(true)`を設定し、要素を正しく識別するためにハンドラーメソッドで`qName`の代わりに`uri`と`localName`を使用します。

#### 検証
DTDまたはスキーマに対してXMLを検証するには、`factory.setValidating(true)`を設定します。検証エラーを管理するために`ErrorHandler`も必要になる場合があります。

---

### 例 XMLと出力
`example.xml`ファイルの場合：
```xml
<book id="123">
    <title>XML Parsing</title>
    <author>John Doe</author>
</book>
```

上記のコードを実行すると、以下のような出力が得られる可能性があります：
```
文書解析開始
要素開始: book
属性: id = 123
要素開始: title
コンテンツ: XML Parsing
要素終了: title
要素開始: author
コンテンツ: John Doe
要素終了: author
要素終了: book
文書解析完了
```

---

### まとめ
`org.xml.sax`を使用するには：
1. `SAXParserFactory`を使用して`SAXParser`を作成します。
2. `DefaultHandler`を拡張し、`startElement`、`endElement`、`characters`などのメソッドをオーバーライドしてハンドラーを実装します。
3. ハンドラーとXMLソースを指定して`parser.parse()`を呼び出してXMLを解析します。
4. 例外（`SAXException`、`IOException`、`ParserConfigurationException`）を処理します。
5. オプションで名前空間の認識、検証、またはエラー処理を設定します。

このアプローチは、メモリ内ツリーを構築せずに特定のデータのみを抽出する必要がある場合に、大規模なXML文書を効率的に解析するのに理想的です。