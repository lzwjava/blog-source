---
audio: false
generated: true
lang: ja
layout: post
title: SAX（Simple API for XML）を使用する
translated: true
---

`org.xml.sax` パッケージを使用してJavaでXMLドキュメントを解析するには、SAX（Simple API for XML）解析アプローチを使用する簡単なプロセスに従うことができます。SAXは、イベント駆動型のパーサで、XMLドキュメントを順次読み取り、要素やテキストコンテンツなどのドキュメントの各部分に遭遇するたびにコールバックメソッドをトリガーします。これにより、特に大きなXMLファイルの場合、メモリ効率が高くなります。DOMのようにドキュメント全体をメモリに読み込む必要がないためです。以下に、`org.xml.sax`の使用方法のステップバイステップガイドを示します。

---

### ステップ1: SAXパーサの設定
SAXでXMLの解析を開始するには、`SAXParserFactory`クラスを使用して`SAXParser`のインスタンスを作成する必要があります。このファクトリを使用すると、パーサの動作を作成する前に構成できます。

以下のように`SAXParser`を作成します：

```java
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;

public class SAXExample {
    public static void main(String[] args) {
        try {
            // SAXParserFactoryのインスタンスを作成
            SAXParserFactory factory = SAXParserFactory.newInstance();

            // オプション: ファクトリの構成（例: 名前空間の認識を有効にする）
            factory.setNamespaceAware(true); // 名前空間を使用する場合はtrueに設定

            // SAXParserを作成
            SAXParser parser = factory.newSAXParser();

            // 次のステップはここに入ります
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

- **`SAXParserFactory.newInstance()`**: 新しいファクトリインスタンスを作成します。
- **`factory.setNamespaceAware(true)`**: オプション。名前空間を使用するXMLがある場合に名前空間処理を有効にします。デフォルトでは`false`です。
- **`factory.newSAXParser()`**: `SAXParser`を作成します。パーサが構成または初期化できない場合、`ParserConfigurationException`または`SAXException`をスローします。

---

### ステップ2: XMLイベントのハンドラを作成
SAX解析は、要素の開始、終了、テキストコンテンツなどのXMLイベントを処理するハンドラに依存しています。このための主要なインターフェースは`ContentHandler`ですが、簡単にするために`DefaultHandler`クラスを拡張することができます。このクラスは、`ContentHandler`および他のハンドラインターフェース（`ErrorHandler`、`DTDHandler`など）の空の実装を提供します。関心のあるメソッドのみをオーバーライドする必要があります。

以下は、カスタムハンドラの例です：

```java
import org.xml.sax.Attributes;
import org.xml.sax.helpers.DefaultHandler;

public class MyHandler extends DefaultHandler {
    // テキストコンテンツを蓄積する変数
    private StringBuilder content = new StringBuilder();

    @Override
    public void startElement(String uri, String localName, String qName, Attributes attributes) {
        // 新しい要素のためにコンテンツバッファをクリア
        content.setLength(0);
        System.out.println("要素開始: " + qName);

        // 要素に属性がある場合は、それを処理します
        for (int i = 0; i < attributes.getLength(); i++) {
            System.out.println("属性: " + attributes.getQName(i) + " = " + attributes.getValue(i));
        }
    }

    @Override
    public void characters(char[] ch, int start, int length) {
        // テキストコンテンツを蓄積（要素ごとに複数回呼び出される可能性があります）
        content.append(ch, start, length);
    }

    @Override
    public void endElement(String uri, String localName, String qName) {
        // 蓄積されたテキストコンテンツを処理
        String text = content.toString().trim();
        if (!text.isEmpty()) {
            System.out.println("コンテンツ: " + text);
        }
        System.out.println("要素終了: " + qName);
        content.setLength(0); // 次の要素のためにリセット
    }

    @Override
    public void startDocument() {
        System.out.println("ドキュメントの解析が開始されました");
    }

    @Override
    public void endDocument() {
        System.out.println("ドキュメントの解析が完了しました");
    }
}
```

- **`startElement`**: パーサが要素の開始を検出したときに呼び出されます。パラメータには以下が含まれます。
  - `uri`: 名前空間URI（名前空間認識の場合）。
  - `localName`: 要素のローカル名（名前空間認識の場合、プレフィックスなし）。
  - `qName`: 修飾名（プレフィックスを含む場合）。
  - `attributes`: 要素の属性のリスト。
- **`characters`**: 要素内のテキストコンテンツに対して呼び出されます。1つの要素のコンテンツに対して複数回呼び出される可能性があるため、`StringBuilder`を使用して蓄積します。
- **`endElement`**: 要素が終了したときに呼び出されます。
- **`startDocument`および`endDocument`**: XMLドキュメントの開始と終了時に呼び出されます。

---

### ステップ3: XMLを解析
パーサとハンドラが準備できたら、`SAXParser`の`parse`メソッドを呼び出してXMLソース（例: ファイル、`InputStream`、または文字列）を解析し、ハンドラを渡すことで解析を開始できます。

以下のようにXMLファイルを解析します：

```java
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import java.io.File;

public class SAXExample {
    public static void main(String[] args) {
        try {
            // パーサを作成
            SAXParserFactory factory = SAXParserFactory.newInstance();
            SAXParser parser = factory.newSAXParser();

            // ハンドラを作成
            MyHandler handler = new MyHandler();

            // XMLファイルを解析
            File xmlFile = new File("example.xml");
            parser.parse(xmlFile, handler);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

- **`parser.parse`**: XMLソース（例: `File`）と`DefaultHandler`を受け取ります。入力ソースの読み取りに問題がある場合は`IOException`を、解析エラーがある場合は`SAXException`をスローします。

ファイルではなくXML文字列を使用する場合は、`InputSource`を使用します：

```java
import org.xml.sax.InputSource;
import java.io.StringReader;

// mainメソッド内
String xml = "<book><title>XML Parsing</title></book>";
InputSource inputSource = new InputSource(new StringReader(xml));
parser.parse(inputSource, handler);
```

---

### ステップ4: 例外の処理
SAX解析には、いくつかの例外を処理する必要があります。

- **`ParserConfigurationException`**: `newSAXParser()`によってパーサが構成できない場合にスローされます。
- **`SAXException`**: `newSAXParser()`または`parse()`によって一般的な解析エラーが発生した場合にスローされます。
- **`IOException`**: `parse()`によって入力ソースの読み取りに問題がある場合にスローされます。

コードを`try-catch`ブロックでラップします：

```java
try {
    SAXParserFactory factory = SAXParserFactory.newInstance();
    SAXParser parser = factory.newSAXParser();
    MyHandler handler = new MyHandler();
    parser.parse(new File("example.xml"), handler);
} catch (ParserConfigurationException e) {
    System.err.println("パーサの構成エラー: " + e.getMessage());
} catch (SAXException e) {
    System.err.println("SAXエラー: " + e.getMessage());
} catch (IOException e) {
    System.err.println("IOエラー: " + e.getMessage());
}
```

---

### ステップ5: オプション機能
#### エラーハンドリング
`DefaultHandler`も`ErrorHandler`を実装しています。解析エラーを処理するためにそのメソッドをオーバーライドします：

```java
public class MyHandler extends DefaultHandler {
    @Override
    public void error(SAXParseException e) {
        System.err.println("解析エラー: " + e.getMessage());
    }

    @Override
    public void fatalError(SAXParseException e) throws SAXException {
        System.err.println("致命的なエラー: " + e.getMessage());
        throw e; // 解析を停止
    }

    @Override
    public void warning(SAXParseException e) {
        System.out.println("警告: " + e.getMessage());
    }
    // 上記の他のメソッド
}
```

#### 名前空間の処理
名前空間を使用するXMLがある場合は、`factory.setNamespaceAware(true)`を設定し、ハンドラメソッドで`uri`と`localName`を使用して要素を正しく識別します。

#### バリデーション
DTDまたはスキーマに対してXMLを検証するには、`factory.setValidating(true)`を設定します。検証エラーを管理するために`ErrorHandler`も必要になる場合があります。

---

### 例XMLと出力
以下のようなXMLファイル`example.xml`があれば：

```xml
<book id="123">
    <title>XML Parsing</title>
    <author>John Doe</author>
</book>
```

上記のコードを実行すると、以下のような出力が得られます：

```
ドキュメントの解析が開始されました
要素開始: book
属性: id = 123
要素開始: title
コンテンツ: XML Parsing
要素終了: title
要素開始: author
コンテンツ: John Doe
要素終了: author
要素終了: book
ドキュメントの解析が完了しました
```

---

### まとめ
`org.xml.sax`を使用するには：
1. `SAXParserFactory`を使用して`SAXParser`を作成します。
2. `DefaultHandler`を拡張して`startElement`、`endElement`、`characters`などのメソッドをオーバーライドしてハンドラを実装します。
3. `parser.parse()`を呼び出してハンドラとXMLソースを渡してXMLを解析します。
4. 例外（`SAXException`、`IOException`、`ParserConfigurationException`）を処理します。
5. オプションで名前空間の認識、検証、エラーハンドリングを構成します。

このアプローチは、特定のデータを抽出するだけで、メモリ内のツリーを構築する必要がない場合に、大きなXMLドキュメントを効率的に解析するのに適しています。