---
audio: false
generated: true
image: false
lang: ja
layout: post
model: x-ai/grok-4-fast
title: IBM DB2 インデックス構造の解説
translated: true
type: note
---

### IBM DB2 インデックスの仕組み

IBM DB2 は、そのインデックスの主要なデータ構造として **B+ ツリー** を使用しています。これは、リレーショナルデータベースで一般的な、ディスクベースのストレージと範囲検索に最適化された平衡木の一種です。B+ ツリーは、対数時間計算量 (O(log n)) で効率的な検索、挿入、削除を保証し、大規模なデータセットに理想的です。以下に、構造、主要な操作、および DB2 固有の注意点について説明します。

#### DB2 における B+ ツリー構造
DB2 における B+ ツリーは、通常ディスク上で 4KB サイズの**ページ** (ノードとも呼ばれる) の階層として構成されます。このツリーは自己平衡型であり、すべてのリーフノードが同じ深さにあり、データの変更に応じて動的に成長または縮小します。内訳は以下の通りです:

- **ルートページ**: ツリーの最上部にあるエントリポイント。ソートされたキー値と、その下位にある子ページへのポインタを含みます。小さなインデックスの場合、ルートが直接リーフページを指すこともあります。
  
- **内部 (非リーフ) ページ**: これらの中間レベルはディレクトリとして機能します。各ページは以下を保持します:
  - **インデックスキー** (従業員 ID など、インデックスが付けられた列の値) のソート済みリスト。
  - 子ページへのポインタ (キーよりも1つ多い数のポインタを持ち、範囲を分離します)。
  - 具体的には、各エントリはその下位にあるサブツリーの**最高キー値**と、テーブル内の実際のデータ行が存在するページとスロットへの一意のポインタである **Record Identifier (RID)** のペアです。
  
  非リーフページは実際のデータポインタを*保存せず*、走査を誘導します。

- **リーフページ**: 最下層であり、効率的な範囲スキャンのために双方向 (前方向および後方向) にリンクされています。各リーフページは以下を含みます:
  - インデックスが付けられた列からの完全なソート済み**キー値**。
  - テーブルの行を直接指す関連する **RID**。
  - 隣接するリーフページへのポインタ。これにより順次アクセスが可能になります (例: `WHERE column BETWEEN x AND y`)。

ツリーは少なくとも 2 レベル (ルート + リーフ) で始まり、大規模なテーブル (数百万行) では 3〜5+ レベルに成長することがあります。レベル数 (NLEVELS) は `SYSCAT.INDEXES` を介して問い合わせ可能で、パフォーマンスに影響します—レベル数が少ないほど走査は速くなりますが、DB2 はこれを自動管理します。

インデックスはテーブルとは別に、それ自身のテーブルスペースに保存され、インデックス付けされたデータに比例してディスク容量を消費します (例: 100万行のテーブルに対する一意インデックスは、テーブルサイズの約 10〜20% を占める可能性があります)。

#### 検索の仕組み
1. **ルートページ**から開始し、それをメモリにロードします。
2. 検索キー (例: `WHERE id = 123`) を現在のページ内のソートされたキーと比較します。
3. 適切な子ポインタを選択します (例: 検索キー > 現在のキーの場合、右へ進む)。
4. **リーフページ**に到達するまでツリーを下って繰り返します (通常、1〜5 回の I/O 操作)。
5. リーフ内で、ソートされたキーをスキャンして一致するものを探し、その後 RID を使用してテーブルから正確な行を取得します (さらに 1 回の I/O)。

このパス圧縮により、走査は浅く保たれます。範囲検索の場合、開始リーフに到達したら、兄弟リンクをたどって順次スキャンし、ツリーを再び上にジャンプする必要はありません。

#### 挿入と削除
- **挿入**:
  1. 正しいリーフまで走査します (検索時と同様)。
  2. 新しいキー + RID をソートされたリーフページに挿入します。
  3. ページがオーバーフローした場合 (最大エントリ数を超える、キーサイズに依存して約200〜500)、ページを 2 つに分割し、セパレータキーを親 (内部) ページに挿入します。
  4. 親がオーバーフローした場合、上方に分割します (新しいルートが作成される可能性があります)。DB2 は並行性のためにページを短時間ロックします。

- **削除**:
  1. リーフまで走査し、キー + RID を削除します。
  2. ページがアンダーフローした場合 (エントリ数が少なすぎる場合)、兄弟から借用するか兄弟とマージし、セパレータキーを親から削除します。
  3. 必要に応じてマージを上方に伝播させます。DB2 は効率化のために変更をバッチ処理するため、リorganization を遅延させる場合があります。

これらの操作は自動的にバランスを維持し、ページの分割/マージは最小限 (操作の約 1%) に抑えられます。

#### DB2 固有の機能
- **最適化された B+ ツリー** (DB2 for z/OS 内): メインフレームの並行処理向けに強化され、ページを予測してプリロードするフラクタルプリフェッチにより I/O を削減。
- **クラスタリング**: インデックスを「クラスター化」 (データをインデックス順に物理的にソート) して範囲パフォーマンスを向上させることが可能。
- **タイプ**: 一意、複合 (複数列)、ビットマップインデックスをサポートし、すべて B+ ベース。ネイティブのハッシュインデックスはなし。
- **メンテナンス**: 一括変更後に `RUNSTATS` を実行して、オプティマイザーの統計を更新します。`INSPECT` のようなツールで問題をチェックします。

B+ ツリーが DB2 で優れている理由は、ランダム I/O を最小化し (ディスク束縛システムにとって重要)、テーブル全体のスキャンなしでソートされたアクセスをサポートするためです。

[インデックス構造 - IBM](https://www.ibm.com/docs/en/db2/11.1.0?topic=indexes-index-structure)  
[DB2 LUW インデックス: B-ツリーの詳細](https://datageek.blog/2013/09/19/db2-luw-basics-indexes/)  
[Inside Db2 for z/OS: 最適化された B+ ツリーが高速インデックス作成を支える仕組み](https://planetmainframe.com/2025/06/inside-db2-for-z-os-how-optimized-b-trees-power-high-speed-indexing/)  
[DB2 B-ツリーインデックスを素早く理解する方法](https://srinimf.com/2021/07/26/db2-how-to-understand-b-tree-structure-of-index/)  
[Db2 インデックス概要](https://www.idug.org/news/db2-index-overview)