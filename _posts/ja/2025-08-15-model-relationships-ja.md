---
audio: false
generated: true
image: false
lang: ja
layout: post
title: モデル関係とデータ
translated: true
type: note
---

その通りです——「1対1、1対多、多対多」は至る所に存在します：家族、チーム、支払い；クラス、リポジトリ、プルリクエスト。以下は、設計をシンプルに保ち、実際の使用方法に合致させるための**関係性の整理**に関するコンパクトなプレイブックです。

# 実践的なモデリングプレイブック

## 1) データではなく振る舞いから始める

* **上位5つのユーザータスク**（「注文する」、「経費を承認する」、「レビュアーを割り当てる」）を書き出す。
* 各タスクの下に、**名詞**（エンティティ）と**動詞**（関係性/アクション）をリストアップする。
* それらのタスクで**結果を変える**関係性のみを保持し、それ以外はすべてメタデータとする。

## 2) 最初に所有権と境界を決める

* 問う：*誰が誰のライフサイクルを所有しているか？*
  * AがBなしでは存在できない → AはBの**一部**（コンポジション）。
  * AとBが独立して存在する → **参照**関係。
* **境界付けられたコンテキスト**を使用する：同じ「顧客」でも、請求とマーケティングでは異なる場合がある。1つの巨大なモデルに強制しない。

## 3) 機能する**最も単純なカーディナリティ**を選択する

* **1→1**は、2つのレコードが運用的に分離不能だが、セキュリティや揮発性の点で異なる扱いが必要な場合（例：ユーザー ↔ 認証情報）にのみ優先する。
* **1→N**は、明確な所有権があり、親→子へのアクセスが頻繁に行われる場合（注文 → 注文明細）に優先する。
* **M↔N**は、両側が対等で、リンク自体が独自のビジネス概念である場合（「成績、ステータス、日付」を持つ「登録」を通した学生 ↔ コース）にのみ使用する。

## 4) 不変条件を用いて関係性を明示的にする

各関係について、平易な言葉で不変条件を書く：

* **カーディナリティ**：「1人のユーザーは最大1つのプライマリメールを持つ。」
* **オプショナリティ**：「請求書は1つ以上の明細を持たなければならない。」
* **時間的制約**：「メンバーシップは[start,end)の期間有効である。」
* **一意性**：「製品コードはテナントごとに一意である。」
  これらは直接、制約、インデックス、チェックに変換される。

## 5) カーディナリティ別のモデリングパターン (テーブルなし😉)

### 1対1

* 揮発性/セキュリティフィールドを分割する場合、またはエンティティがモジュール式に成長する場合に使用する。
* 外部キーにユニークキーを設定して強制する。
* 常に一緒に読み込まれる場合は、**埋め込み**（ドキュメント）を検討する。

### 1対多

* 子が親間で移動しない場合 → 子に**親キー**を保持し、削除時はポリシーとしてカスケードする。
* 親の再割り当てが発生する場合 → NULL許容のFK + 遷移のためのビジネスルールを許可する。
* 読み込みが親中心の場合 → 親に要約フィールド（カウント、最終更新日時）を非正規化する。

### 多対多

* リンクを**第一級エンティティ**（登録、メンバーシップ、割り当て）に昇格させる。
* **ビジネスデータ**（役割、優先度、重み、タイムスタンプ）をリンクに置く。
* リンクに属性がなく、サイズが大きい場合は、より負荷の高い側のクエリに合わせてストレージとインデックスを選択する。

## 6) アクセスパターンに応じてストレージを選択する

* **リレーショナル**：最强の整合性、複雑な結合、レポート。
* **ドキュメント**：集約ファースト、読み込み負荷が高く親中心のフロー、局所的な更新。
* **グラフ**：パスクエリ、レコメンデーション、権限継承、可変深度の走査。
  **境界付けられたコンテキストごとに**1つを選択し、共有テーブルではなくイベント経由で同期する。

## 7) APIサーフェスは関係性を意図的に反映する

* **集約**は主要なAPIリソースになる。
* **子コレクション**はネストされたルートとして（例：`/orders/{id}/items`）。
* **結合エンティティ**は、重要な場合に独自のリソースを持つ（`/enrollments`）。
* クライアントの柔軟性のために、ドメインがグラフ的であるか、クライアントが大きく異なる場合にのみ**GraphQL**を公開する。それ以外はRESTをシンプルに保つ。

## 8) 進化可能に保つ（時間的＋ソフト変更）

* 重要なリンクには`updated_at`だけでなく、**有効時間**（`valid_from`, `valid_to`）を追跡する。
* 履歴を再構築できるように、関係行には**ソフトデリート**を優先する。
* すべてのエンティティとリンク行に**代理ID**を使用する。IDに意味を埋め込まない。

## 9) 積極的に単純化する

* ユーザーが違いを認識しない場合はエンティティを統合する。
* セキュリティ/パフォーマンス上の理由がなくなったら1→1分割を統合する。
* ビジネスルールが真にツリー構造である場合は、広範なM↔Nの網を**階層**に置き換える。
* 複数のリンクタイプの代わりに**役割**を導入する（例：別々のリンクの代わりにrole=owner/viewerを持つ1つのメンバーシップ）。

## 10) 既存の複雑な状態をリバースリサーチ（リバースエンジニアリング）する

* **実際のクエリ**（スローログ、ダッシュボード）をマッピングする。重要なクエリで使用される関係性のみを保持する。
* **コンテキストマップ**を描く：どのチーム/システムがどのエンティティを所有し、誰がどのイベントを消費しているか。
* **ホットジョイン**を特定する → 非正規化、キャッシュ、または集約に変換する。
* ノイズの多いM↔Nリンクを、明確な不変条件を持つ**第一級概念**に昇格させる。
* **契約**を追加する：スキーマとAPIのための制約、テスト、リンターを追加してずれを防ぐ。

# 避けるべき一般的な落とし穴

* M↔Nを、実際にはビジネスの中心である（例：権限、割り当て）のに「単なる結合テーブル」として扱うこと。
* 低レイテンシーが必要な読み取りパスを過度に正規化すること；**読み取りモデル**（CQRS）または具体化されたビューで修正する。
* オプショナリティを過少指定すること——`NULL`は複雑性を爆発させる。意味がある場合は明示的な「不明/該当なし」状態を優先する。
* **マルチテナンシー**を無視すること：一意性とクエリをテナントでスコープすることを早期に行う。
* **方向性**を忘れること：「フォロー」と「フレンド」は同じではない。

# 再利用可能な軽量チェックリスト

* 主要なタスクとその成功指標は何か？
* 集約（所有権/ライフサイクル）は何か？
* 不変条件（カーディナリティ、オプショナリティ、時間的制約、一意性）は何か？
* どの関係性がビジネス属性を持つか（エンティティに昇格させる）？
* どのアクセスパターンが支配的か（それに応じてストア/インデックスを選択する）？
* 今日安全に行える単純化は何か（統合/分割/非正規化）？
* これを強制する契約は何か（制約、APIテスト、イベントスキーマ）？

もしよろしければ、あなたのドメインの小さな一部分（3つのエンティティ＋主要なユーザータスク）を教えてください。関係性、不変条件、および直接実装可能なストレージ/APIの形状をスケッチします。