---
audio: false
generated: true
lang: ja
layout: post
title: カフカはなぜ高速なのか
translated: true
type: note
---

### 主なポイント
- 「System Design: Why is Kafka fast?」というビデオは、Apache Kafkaの高速性をそのアーキテクチャと設計選択を通じて説明していると考えられます。
- 調査によると、Kafkaのパフォーマンスは、追記専用ログ、ゼロコピー原則、バッチ処理、効率的なパーティショニングによって向上しています。
- 証拠は、Kafkaの高速性が、プロデューサ、ブローカー、コンシューマといった主要コンポーネントを持つ分散型イベントストリーミングプラットフォームの設計に起因するという方向に傾いています。

### はじめに
このブログ記事は、ByteByteGoによるYouTubeビデオ「System Design: Why is Kafka fast?」の内容に基づいており、その洞察を読みやすく参照しやすい書面形式に変換することを目的としています。Apache Kafkaはリアルタイムデータ処理における高いパフォーマンスで知られており、この記事ではその高速性の理由を探求し、このトピックが初めての方にも理解しやすいように解説します。

### Kafkaの主要コンポーネント
Apache Kafkaは、以下の3つの主要コンポーネントを持つ分散型イベントストリーミングプラットフォームとして動作します：
- **プロデューサ**: Kafkaトピックにデータを送信するアプリケーション。
- **ブローカー**: データを保存および管理し、レプリケーションと分散を保証するサーバー。
- **コンシューマ**: トピックからデータを読み取り処理するアプリケーション。

この構造により、Kafkaは大量のデータを効率的に処理でき、その高速性に貢献しています。

### アーキテクチャレイヤーとパフォーマンス最適化
Kafkaのアーキテクチャは2つのレイヤーに分かれています：
- **コンピュートレイヤー**: プロデューサ、コンシューマ、ストリーム処理のためのAPIを含み、相互作用を容易にします。
- **ストレージレイヤー**: トピックとパーティション内のデータストレージを管理するブローカーで構成され、パフォーマンスのために最適化されています。

主な最適化には以下が含まれます：
- **追記専用ログ**: データをファイルの末尾に順次書き込むことで、ランダム書き込みよりも高速です。
- **ゼロコピー原則**: データをプロデューサからコンシューマに直接転送し、CPUオーバーヘッドを削減します。
- **バッチ処理**: データをバッチで処理することで、レコードごとのオーバーヘッドを低減します。
- **非同期レプリケーション**: リーダーブローカーがレプリカの更新中もリクエストを処理できるようにし、パフォーマンスを損なうことなく可用性を確保します。
- **パーティショニング**: データを複数のパーティションに分散して並列処理と高スループットを実現します。

これらの設計選択は、ByteByteGoのサポートブログ記事（[Why is Kafka so fast? How does it work?](https://bytebytego.substack.com/p/why-is-kafka-so-fast-how-does-it)）で詳述されており、Kafkaが高速性とスケーラビリティに優れる理由を説明しています。

### データフローとレコード構造
プロデューサがブローカーにレコードを送信すると、検証され、ディスク上のコミットログに追記され、耐久性のためにレプリケートされ、コミット時にプロデューサに通知されます。このプロセスはシーケンシャルI/Oのために最適化され、パフォーマンスを向上させます。

各レコードには以下が含まれます：
- タイムスタンプ: イベントが作成された時刻。
- キー: パーティショニングと順序付けのため。
- 値: 実際のデータ。
- ヘッダー: オプションのメタデータ。

この構造は、ブログ記事で概説されているように、効率的なデータ処理を保証し、Kafkaの高速性に貢献します。

---

### 調査ノート：Apache Kafkaのパフォーマンス詳細分析

このセクションでは、Apache Kafkaのパフォーマンスについて包括的に探求し、ByteByteGoのビデオ「System Design: Why is Kafka fast?」を拡張し、追加リソースからも情報を引き出して完全な理解を保証します。分析は、Kafkaのアーキテクチャ、コンポーネント、および特定の最適化をカバーするように構成され、明確さのために詳細な説明と例を提供します。

#### 背景と状況
分散型イベントストリーミングプラットフォームとして開発されたApache Kafkaは、高スループットで低レイテンシのデータストリーミングを扱う能力で有名であり、現代のデータアーキテクチャにおいて定番となっています。2022年6月29日に公開されたこのビデオは、システム設計に関するプレイリストの一部であり、データストリーミングニーズの指数関数的成長を考えると非常に興味深いトピックである、Kafkaが高速である理由を解明することを目的としています。ここでの分析は、ビデオコンテンツを補完し追加の洞察を提供するByteByteGoの詳細なブログ記事（[Why is Kafka so fast? How does it work?](https://bytebytego.substack.com/p/why-is-kafka-so-fast-how-does-it)）に基づいています。

#### Kafkaの主要コンポーネントとアーキテクチャ
Kafkaの高速性はその主要コンポーネントから始まります：
- **プロデューサ**: これらは、イベントを生成しKafkaトピックに送信するアプリケーションまたはシステムです。例えば、Webアプリケーションがユーザーインタラクションのイベントを生成する場合があります。
- **ブローカー**: これらはクラスタを形成するサーバーであり、データの保存、パーティションの管理、レプリケーションの処理を担当します。典型的なセットアップでは、フォールトトレランスとスケーラビリティのために複数のブローカーが関与する場合があります。
- **コンシューマ**: トピックを購読してイベントを読み取り処理するアプリケーションであり、リアルタイムデータを処理する分析エンジンのようなものです。

このアーキテクチャは、Kafkaをイベントストリーミングプラットフォームとして位置づけ、従来のメッセージキューと区別するために「メッセージ」ではなく「イベント」を使用します。これは、イベントが不変であり、パーティション内でオフセットによって順序付けられるという設計に明らかです。これはブログ記事で詳述されています。

| コンポーネント   | 役割                                                                 |
|------------------|----------------------------------------------------------------------|
| プロデューサ     | トピックにイベントを送信し、データフローを開始します。               |
| ブローカー       | データを保存および管理し、レプリケーションを処理し、コンシューマにサービスを提供します。 |
| コンシューマ     | トピックからイベントを読み取り処理し、リアルタイム分析を可能にします。 |

ブログ記事には、[このURL](https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fdd3690db-87b8-4165-8798-37d1d083f837_1600x1527.png)にある図が含まれており、クラスタモードでのプロデューサ、ブローカー、コンシューマ間の相互作用を示しています。

#### 階層化アーキテクチャ：コンピュートとストレージ
Kafkaのアーキテクチャは以下の2つに分けられます：
- **コンピュートレイヤー**: APIを通じて通信を容易にします：
  - **プロデューサAPI**: アプリケーションがイベントを送信するために使用します。
  - **コンシューマAPI**: イベントの読み取りを可能にします。
  - **Kafka Connect API**: データベースのような外部システムと統合します。
  - **Kafka Streams API**: シリアライゼーションのためのSerdesを使用した「orders」のようなトピックのKStreamを作成するなど、ストリーム処理をサポートし、ksqlDBはREST APIを使用したストリーム処理ジョブ用です。提供されている例は、「orders」を購読し、製品ごとに集計し、分析のために「ordersByProduct」に送信するものです。
- **ストレージレイヤー**: クラスタ内のKafkaブローカーで構成され、データはトピックとパーティションで編成されます。トピックはデータベースのテーブルに似ており、パーティションはノード間で分散され、スケーラビリティを保証します。パーティション内のイベントはオフセットによって順序付けられ、不変で追記専用であり、削除はイベントとして扱われるため、書き込みパフォーマンスが向上します。

ブログ記事はこれを詳述し、ブローカーがパーティション、読み取り、書き込み、レプリケーションを管理し、[このURL](https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb869cd88-3d6e-43af-8fd0-26f3737d8f1f_1600x559.png)にある図は、「orders」のパーティション0が3つのレプリカ（Broker 1のリーダー（オフセット4）、Broker 2のフォロワー（オフセット2）、Broker 3のフォロワー（オフセット3））を持つレプリケーションを示しています。

| レイヤー         | 説明                                                                 |
|------------------|----------------------------------------------------------------------|
| コンピュートレイヤー | 相互作用のためのAPI: Producer, Consumer, Connect, Streams, ksqlDB。 |
| ストレージレイヤー | クラスタ内のブローカー、分散されたトピック/パーティション、オフセットで順序付けられたイベント。 |

#### コントロールプレーンとデータプレーン
- **コントロールプレーン**: クラスタメタデータを管理し、歴史的にはZookeeperを使用していましたが、現在は選択されたブローカー上のコントローラーを持つKRaftモジュールに置き換えられました。この単純化によりZookeeperが排除され、特別なトピックを介したメタデータ伝播がより効率的になり、設定が容易になります。これはブログ記事で述べられています。
- **データプレーン**: データレプリケーションを処理し、フォロワーがFetchRequestを発行し、リーダーがデータを送信し、特定のオフセットより前のレコードをコミットするプロセスにより、一貫性を確保します。オフセット2、3、4を持つパーティション0の例はこれを強調しており、[このURL](https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe17a4454-a194-45f9-8a1f-f4882501657c_1095x1600.png)に図があります。

#### レコード構造とブローカー操作
各レコード（イベントの抽象化）には以下が含まれます：
- タイムスタンプ: 作成された時刻。
- キー: 順序付け、コロケーション、および保持のため。パーティショニングに重要。
- 値: データ内容。
- ヘッダー: オプションのメタデータ。

キーと値はバイト配列であり、serdesを使用してエンコード/デコードされ、柔軟性を確保します。ブローカー操作には以下が含まれます：
- プロデューサリクエストがソケット受信バッファに着地。
- ネットワークスレッドが共有リクエストキューに移動。
- I/OスレッドがCRCを検証し、コミットログ（データとインデックスを持つディスクセグメント）に追記。
- リクエストがレプリケーションのために purgatory に隠される。
- レスポンスがキューに入れられ、ネットワークスレッドがソケット送信バッファを介して送信。

このプロセスはシーケンシャルI/Oのために最適化されており、ブログ記事で詳述され、フローを説明する図があり、Kafkaの高速性に大きく貢献しています。

| レコードコンポーネント | 目的                                                                 |
|----------------------|----------------------------------------------------------------------|
| タイムスタンプ       | イベントが作成された時刻を記録します。                               |
| キー                 | 順序付け、コロケーション、およびパーティショニングのための保持を保証します。 |
| 値                   | 実際のデータ内容を含みます。                                         |
| ヘッダー             | 追加情報のためのオプションのメタデータ。                             |

#### パフォーマンス最適化
いくつかの設計決定がKafkaの高速性を高めています：
- **追記専用ログ**: ファイルの末尾に順次書き込むことで、ディスクシーク時間を最小限に抑えます。日記の最後にエントリを追加するのと同様で、文書の途中に挿入するよりも高速です。
- **ゼロコピー原則**: データをプロデューサからコンシューマに直接転送し、CPUオーバーヘッドを削減します。箱を開梱せずにトラックから倉庫に移動するようなもので、時間を節約します。
- **バッチ処理**: データをバッチで処理することで、レコードごとのオーバーヘッドを低減し、効率を向上させます。
- **非同期レプリケーション**: リーダーブローカーがレプリカの更新中もリクエストを処理し、パフォーマンスに影響を与えることなく可用性を確保します。
- **パーティショニング**: データをパーティション間で分散して並列処理し、スループットを向上させます。これは大量のデータを扱う際の重要な要素です。

これらの最適化は、ブログ記事で探求されているように、Kafkaが高スループットと低レイテンシを達成する理由であり、リアルタイムアプリケーションに適しています。

#### 結論と追加の洞察
Apache Kafkaの高速性は、その綿密に設計されたアーキテクチャとパフォーマンス最適化の結果であり、追記専用ログ、ゼロコピー原則、バッチ処理、非同期レプリケーション、効率的なパーティショニングを活用しています。この分析は、ビデオに基づき、ブログ記事によって補完され、単純な概要を期待していた人々にとっては予想外の深さで包括的な視点を提供し、Kafkaをデータストリーミングのリーダーにする設計選択の複雑なバランスを明らかにしています。

ブログ記事はまた、完全なアーカイブへの7日間無料トライアルを提供しており、[この購読リンク](https://blog.bytebytego.com/subscribe?simple=true&next=https%3A%2F%2Fblog.bytebytego.com%2Fp%2Fwhy-is-kafka-so-fast-how-does-it&utm_source=paywall-free-trial&utm_medium=web&utm_content=137028631&coupon=3920da80)でアクセスでき、興味のある方にさらなるリソースを提供します。

この詳細な探求は、Kafkaのパフォーマンスについて教育するというビデオの意図に沿って、完全な理解を保証し、様々なソースから収集された研究と洞察に基づいて、正確性と深さを確保しています。

#### 主要な引用文献
- [System Design: Why is Kafka fast? YouTube video](https://www.youtube.com/watch?v=UNUz1-msbOM)
- [Why is Kafka so fast? How does it work? ByteByteGo blog post](https://bytebytego.substack.com/p/why-is-kafka-so-fast-how-does-it)
- [Kafka architecture diagram ByteByteGo](https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fdd3690db-87b8-4165-8798-37d1d083f837_1600x1527.png)
- [Kafka replication diagram ByteByteGo](https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb869cd88-3d6e-43af-8fd0-26f3737d8f1f_1600x559.png)
- [Kafka broker operations diagram ByteByteGo](https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe17a4454-a194-45f9-8a1f-f4882501657c_1095x1600.png)
- [ByteByteGo newsletter subscription for Kafka post](https://blog.bytebytego.com/subscribe?simple=true&next=https%3A%2F%2Fblog.bytebytego.com%2Fp%2Fwhy-is-kafka-so-fast-how-does-it&utm_source=paywall-free-trial&utm_medium=web&utm_content=137028631&coupon=3920da80)