---
audio: false
generated: true
image: false
lang: ja
layout: post
model: x-ai/grok-4-fast
title: 停止問題はメモリリークを装う
translated: true
type: note
---

では、この「ハルティング問題の変装版」という議論を、順を追って平易な英語で説明し、実際に理解できるようにしていきましょう。

### 核心となる考え
著者は、**完璧な自動メモリリーク検出は不可能である**ことを証明したいと考えています。
そのために、「このプログラムは、特定のオブジェクトOをリークするか？」という問いが、実はハルティング問題（すべてのケースで解くことが既知不可能であることが分かっている問題）と同様に難しいことを示しています。

### 巧妙な構成（ゆっくり説明）

ガベージコレクションを備えた言語（Java、Python、JavaScriptなど）で、このような奇妙なプログラムを書けると想像してください：

```pseudo
void tricky(入力プログラム P, 入力_x) {
    Object O = new Object();          // オブジェクトを割り当てる

    if (P が入力 x で停止する) {      // ← これが魔法の質問
        // ケース 1: P が停止する場合
        O = null;                     // 唯一の参照を放棄 → O はゴミになる
                                      // GC は後で安全に解放できる
    } else {
        // ケース 2: P が停止しない（永久にループする）場合
        global_reference = O;         // O をグローバル変数 / ルートセットに保存
        while (true) {                // 無限ループ
            use(O);                   // O を使い続け、決して死なないように見せる
        }
    }
}
```

ここで、超賢い**静的アナライザー**（プログラムを実行せずにソースコードだけを見るツール）があると想像し、それにひとつの単純な質問を投げかけます：

> 「オブジェクトOのメモリは、確実に到達不能になり（ガベージコレクタが最終的に解放できるようになりますか）？」

または、同等の質問として：

> 「このプログラムはオブジェクトOに対してメモリリークを起こしますか？」

### なぜアナライザーは行き詰まるのか

可能性は2つしかありません：

1.  **Pがxで停止する** → `if` 分岐が実行される → Oへの参照が放棄される → **リークなし**、メモリは解放される。
2.  **Pがxで停止しない** → `else` 分岐が実行される → グローバル参照を永久に保持し続ける → **恒久的なリーク**、メモリは決して解放されない。

したがって、「Oは解放されるか？」に対する正しい答えは：

-   はい、もしPがxで停止するなら
-   いいえ、もしPがxで永久にループするなら

これはまさに、変装したハルティング問題なのです！

もし静的アナライザーが、あらゆる可能なプログラムに対して「このオブジェクトは解放されるか？」という問いに常に正しく答えられるなら、それはハルティング問題も解けることになります：

```pseudo
ハルティング問題を解く (P, x):
    上記の tricky() プログラムを構築する
    完璧なリーク検出器をそれに対して実行する
    もし「Oは解放される」と言えば → P は停止する
    もし「Oは解放されない」と言えば → P は永久にループする
```

しかし、1936年（アラン・チューリング）に、すべてのプログラムに対するハルティング問題を解くアルゴリズムは存在しないことが証明されています。したがって、どんな静的アナライザーも、すべてのプログラムに対するリークの質問に完璧に答えることはできません。

### 実世界での教訓

これは、ガベージコレクタやリーク検出器が役に立たないという意味では**ありません**。
これは単に、以下のことを意味します：

-   任意のコードに対して、100%完璧なリーク検出を保証するツールは存在しない。
-   実用的なツール (Valgrind, LeakSanitizer, Java Flight Recorder など) は近似を使用する：プログラムを実行する（動的解析）か、一般的なパターンのみを扱う（保守的静的解析）。
-   それらのツールは、いくつかの奇妙なプログラムでは、常に偽陽性や偽陰性を持つことになる。

上記の構成は、静的ツールがあらゆるケースで正しく判断できない「奇妙なプログラム」の一つです — なぜなら、そうすることができれば、解決不可能な問題を解くことができるようになってしまうからです。

これが、ジョーク／トリック／証明の全体です。これで理解できましたか？