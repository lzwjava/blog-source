---
audio: false
generated: true
lang: ja
layout: post
title: epollをLinuxで使用する
translated: true
---

# Linuxで`epoll`を使用する方法

`epoll`は、データが読み取り可能かソケットが書き込み可能かなどのイベントを効率的に監視するためのLinuxシステムコールです。特にネットワークプログラミングで、サーバーが多くの接続を同時に処理する必要がある場合に有用です。`select`や`poll`などの古いメカニズムと比較して、`epoll`は多くのファイルディスクリプタを扱う際にスケールが良いです。これは、すべてのディスクリプタの準備状態を繰り返しスキャンする必要がないためです。

以下に、Linuxで`epoll`を使用する手順と、接続を受け入れてデータをエコーバックする簡単なサーバーの例を示します。

---

## `epoll`の使用手順

### 1. **Epollインスタンスの作成**
`epoll`を使用するには、ファイルディスクリプタで表されるepollインスタンスを作成する必要があります。`epoll_create1`システムコールを使用します。

```c
int epoll_fd = epoll_create1(0);
```
- **パラメータ**: 基本的な使用には`0`を渡します（特別なフラグなし）。`EPOLL_CLOEXEC`などのフラグを使用する高度なシナリオもあります。
- **戻り値**: 成功時にはファイルディスクリプタ（`epoll_fd`）を返し、エラー時には`-1`を返します（詳細については`errno`を確認）。

古い`epoll_create`関数は似ていますが、サイズのヒントを取るため、`epoll_create1`が推奨されます。

### 2. **監視するファイルディスクリプタの追加**
`epoll_ctl`を使用して、ファイルディスクリプタ（例：ソケット）をepollインスタンスに登録し、監視したいイベントを指定します。

```c
struct epoll_event ev;
ev.events = EPOLLIN;  // 読み取り可能を監視
ev.data.fd = some_fd; // 監視するファイルディスクリプタ
epoll_ctl(epoll_fd, EPOLL_CTL_ADD, some_fd, &ev);
```
- **パラメータ**:
  - `epoll_fd`: epollインスタンスのファイルディスクリプタ。
  - `EPOLL_CTL_ADD`: ファイルディスクリプタを追加する操作。
  - `some_fd`: 監視するファイルディスクリプタ（例：ソケット）。
  - `&ev`: イベントとオプションのユーザーデータを定義する`struct epoll_event`へのポインタ。
- **一般的なイベント**:
  - `EPOLLIN`: 読み取り可能なデータ。
  - `EPOLLOUT`: 書き込み可能。
  - `EPOLLERR`: エラーが発生。
  - `EPOLLHUP`: ハングアップ（例：接続が閉じる）。
- **ユーザーデータ**: `struct epoll_event`の`data`フィールドには、ファイルディスクリプタ（上記のように）または他のデータ（例：ポインタ）を格納して、イベントが発生したときにソースを識別できます。

### 3. **イベントの待ち受け**
`epoll_wait`を使用して、監視中のファイルディスクリプタでイベントをブロックして待ちます。

```c
struct epoll_event events[MAX_EVENTS];
int nfds = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);
```
- **パラメータ**:
  - `epoll_fd`: epollインスタンス。
  - `events`: トリガーされたイベントを格納する配列。
  - `MAX_EVENTS`: 返すイベントの最大数（配列のサイズ）。
  - `-1`: ミリ秒単位のタイムアウト（`-1`は無限に待つことを意味し、`0`は即座に返す）。
- **戻り値**: イベントがあるファイルディスクリプタの数（`nfds`）またはエラー時には`-1`。

### 4. **イベントの処理**
`epoll_wait`によって返されたイベントをループして処理します。

```c
for (int i = 0; i < nfds; i++) {
    if (events[i].events & EPOLLIN) {
        // ファイルディスクリプタevents[i].data.fdは読み取り可能
    }
}
```
- ビット演算（例：`events[i].events & EPOLLIN`）を使用して、`events`フィールドを確認し、イベントの種類を決定します。
- `events[i].data.fd`を使用して、どのファイルディスクリプタがイベントをトリガーしたかを特定します。

### 5. **ファイルディスクリプタの管理（オプション）**
- **削除**: `epoll_ctl`を`EPOLL_CTL_DEL`と一緒に使用して、ファイルディスクリプタの監視を停止します。
  ```c
  epoll_ctl(epoll_fd, EPOLL_CTL_DEL, some_fd, NULL);
  ```
- **修正**: `EPOLL_CTL_MOD`を使用してイベントを調整します。
  ```c
  ev.events = EPOLLOUT; // 書き込み可能を監視に変更
  epoll_ctl(epoll_fd, EPOLL_CTL_MOD, some_fd, &ev);
  ```

---

## 主要な概念

### **レベルトリガー対エッジトリガー**
- **レベルトリガー（デフォルト）**: `epoll`は、条件が継続している限り繰り返し通知します（例：データが未読のまま）。ほとんどの場合にとってはシンプルです。
- **エッジトリガー（`EPOLLET`）**: 状態が変化したときにのみ通知します（例：新しいデータが到着）。`EAGAIN`になるまですべてのデータを読み書きする必要があり、イベントを欠かさないために効率的ですが、やや難しいです。
- エッジトリガーモードを使用する場合は、`ev.events`に`EPOLLET`を設定します（例：`EPOLLIN | EPOLLET`）。

### **非ブロッキングI/O**
`epoll`は、I/O操作でブロックしないようにするために、非ブロッキングファイルディスクリプタと組み合わせることが一般的です。ソケットを非ブロッキングモードに設定するには、以下のようにします。

```c
fcntl(fd, F_SETFL, fcntl(fd, F_GETFL) | O_NONBLOCK);
```

---

## 例：シンプルなエコーサーバー

以下は、`epoll`を使用して接続を受け入れ、クライアントにデータをエコーバックする基本的なサーバーの例です。シンプルさのためにレベルトリガーモードを使用します。

```c
#include <sys/epoll.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>

#define MAX_EVENTS 10
#define PORT 8080

int main() {
    // リスニングソケットの作成
    int listen_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (listen_fd == -1) { perror("socket"); exit(1); }

    struct sockaddr_in addr = { .sin_family = AF_INET, .sin_addr.s_addr = INADDR_ANY, .sin_port = htons(PORT) };
    if (bind(listen_fd, (struct sockaddr*)&addr, sizeof(addr)) == -1) { perror("bind"); exit(1); }
    if (listen(listen_fd, 5) == -1) { perror("listen"); exit(1); }

    // リスニングソケットを非ブロッキングに設定
    fcntl(listen_fd, F_SETFL, fcntl(listen_fd, F_GETFL) | O_NONBLOCK);

    // epollインスタンスの作成
    int epoll_fd = epoll_create1(0);
    if (epoll_fd == -1) { perror("epoll_create1"); exit(1); }

    // リスニングソケットをepollに追加
    struct epoll_event ev, events[MAX_EVENTS];
    ev.events = EPOLLIN; // レベルトリガー
    ev.data.fd = listen_fd;
    if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, listen_fd, &ev) == -1) { perror("epoll_ctl"); exit(1); }

    // イベントループ
    while (1) {
        int nfds = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);
        if (nfds == -1) { perror("epoll_wait"); exit(1); }

        for (int i = 0; i < nfds; i++) {
            int fd = events[i].data.fd;

            if (fd == listen_fd) {
                // 新しい接続を受け入れる
                int client_fd = accept(listen_fd, NULL, NULL);
                if (client_fd == -1) { perror("accept"); continue; }

                // クライアントソケットを非ブロッキングに設定
                fcntl(client_fd, F_SETFL, fcntl(client_fd, F_GETFL) | O_NONBLOCK);

                // クライアントソケットをepollに追加
                ev.events = EPOLLIN;
                ev.data.fd = client_fd;
                if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, client_fd, &ev) == -1) {
                    perror("epoll_ctl: client_fd");
                    close(client_fd);
                }
            } else {
                // クライアントデータの処理
                char buf[1024];
                ssize_t n = read(fd, buf, sizeof(buf));
                if (n <= 0) {
                    // エラーまたはEOF: 閉じてepollから削除
                    if (n == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) continue;
                    close(fd);
                    epoll_ctl(epoll_fd, EPOLL_CTL_DEL, fd, NULL);
                } else {
                    // データをエコーバック
                    write(fd, buf, n); // 注意: 実際のアプリケーションでは部分的な書き込みを処理
                }
            }
        }
    }

    close(epoll_fd);
    close(listen_fd);
    return 0;
}
```

### 例の注意点
- **リスニングソケット**: 新しい接続を検出するために`EPOLLIN`を監視します。
- **クライアントソケット**: 受信データを検出するために`EPOLLIN`を監視します。
- **簡略化**: `write`が完全に完了することを前提としています。本番環境では、バッファリングされたデータを使用し、`EPOLLOUT`を部分的な書き込みに使用します。
- **エラーハンドリング**: エラーまたはEOFが発生した場合、ソケットを閉じてepollから削除します。

---

## 総括
`epoll`は、Linuxで複数のファイルディスクリプタを効率的に処理する方法を提供します。
1. `epoll_create1`でインスタンスを作成します。
2. `epoll_ctl`でファイルディスクリプタとイベントを登録します。
3. `epoll_wait`でイベントを待ちます。
4. イベントをループして処理し、必要に応じて監視中のイベントを調整またはディスクリプタを削除します。

シンプルなアプリケーションには、レベルトリガーモードを推奨します。高性能が必要な場合は、すべての利用可能なデータを慎重に処理するエッジトリガーモードを検討してください。常に`epoll`を非ブロッキングI/Oと組み合わせることを忘れないでください。