---
audio: false
generated: true
lang: ja
layout: post
title: Linuxでのepollの使用
translated: true
type: note
---

`epoll`は、複数のファイルディスクリプタのイベント（データ読み取り可能やソケット書き込み準備完了など）を効率的に監視するためのLinuxシステムコールです。多数の接続を同時に処理する必要があるネットワークプログラミングで特に有用です。`select`や`poll`のような古いメカニズムと比較して、`epoll`は準備状態のディスクリプタを繰り返しスキャンすることを避けるため、多数のファイルディスクリプタに対してより優れたスケーラビリティを発揮します。

以下に、Linuxで`epoll`を使用する手順を示し、接続を受け入れデータをエコーする簡単なサーバーの例を紹介します。

---

## epollを使用する手順

### 1. **Epollインスタンスの作成**
`epoll`の使用を開始するには、ファイルディスクリプタで表されるepollインスタンスを作成する必要があります。`epoll_create1`システムコールを使用します：

```c
int epoll_fd = epoll_create1(0);
```
- **パラメータ**: 基本的な使用法では`0`を渡します（特別なフラグなし）。`EPOLL_CLOEXEC`のようなフラグは高度なシナリオで使用できます。
- **戻り値**: 成功時はファイルディスクリプタ（`epoll_fd`）を、エラー時は`-1`を返します（詳細は`errno`を確認）。

古い`epoll_create`関数も同様ですが、サイズヒント（現在は無視される）を取るため、`epoll_create1`が推奨されます。

### 2. **監視するファイルディスクリプタの追加**
`epoll_ctl`を使用して、ファイルディスクリプタ（例：ソケット）をepollインスタンスに登録し、監視したいイベントを指定します：

```c
struct epoll_event ev;
ev.events = EPOLLIN;  // 読み取り可能性を監視
ev.data.fd = some_fd; // 監視するファイルディスクリプタ
epoll_ctl(epoll_fd, EPOLL_CTL_ADD, some_fd, &ev);
```
- **パラメータ**:
  - `epoll_fd`: epollインスタンスのファイルディスクリプタ。
  - `EPOLL_CTL_ADD`: ファイルディスクリプタを追加する操作。
  - `some_fd`: 監視するファイルディスクリプタ（例：ソケット）。
  - `&ev`: イベントとオプションのユーザーデータを定義する`struct epoll_event`へのポインタ。
- **一般的なイベント**:
  - `EPOLLIN`: 読み取り可能なデータがあります。
  - `EPOLLOUT`: 書き込み準備ができています。
  - `EPOLLERR`: エラーが発生しました。
  - `EPOLLHUP`: ハングアップ（例：接続が閉じられました）。
- **ユーザーデータ**: `struct epoll_event`の`data`フィールドは、イベント発生時にソースを識別するために、ファイルディスクリプタ（図示のように）やその他のデータ（例：ポインタ）を格納できます。

### 3. **イベントの待機**
`epoll_wait`を使用して、監視中のファイルディスクリプタでイベントが発生するまでブロックして待機します：

```c
struct epoll_event events[MAX_EVENTS];
int nfds = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);
```
- **パラメータ**:
  - `epoll_fd`: epollインスタンス。
  - `events`: トリガーされたイベントを格納する配列。
  - `MAX_EVENTS`: 返すイベントの最大数（配列のサイズ）。
  - `-1`: タイムアウト（ミリ秒単位）（`-1`は無期限待機、`0`は即時返却）。
- **戻り値**: イベントが発生したファイルディスクリプタの数（`nfds`）、エラー時は`-1`。

### 4. **イベントの処理**
`epoll_wait`から返されたイベントをループ処理します：

```c
for (int i = 0; i < nfds; i++) {
    if (events[i].events & EPOLLIN) {
        // ファイルディスクリプタ events[i].data.fd が読み取り可能
    }
}
```
- ビット演算（例：`events[i].events & EPOLLIN`）を使用して`events`フィールドをチェックし、イベントタイプを決定します。
- `events[i].data.fd`を使用して、どのファイルディスクリプタがイベントをトリガーしたかを識別します。

### 5. **ファイルディスクリプタの管理（オプション）**
- **削除**: `EPOLL_CTL_DEL`を指定して`epoll_ctl`を使用し、ファイルディスクリプタの監視を停止します：
  ```c
  epoll_ctl(epoll_fd, EPOLL_CTL_DEL, some_fd, NULL);
  ```
- **変更**: `EPOLL_CTL_MOD`でイベントを調整します：
  ```c
  ev.events = EPOLLOUT; // 書き込み可能性の監視に変更
  epoll_ctl(epoll_fd, EPOLL_CTL_MOD, some_fd, &ev);
  ```

---

## 主要な概念

### **レベルトリガーとエッジトリガー**
- **レベルトリガー（デフォルト）**: 条件が持続する限り（例：データが未読のまま）、`epoll`は繰り返し通知します。ほとんどの場合より簡単です。
- **エッジトリガー（`EPOLLET`）**: 状態が変化したとき（例：新しいデータが到着したとき）のみ一度通知します。イベントを見逃さないように、`EAGAIN`になるまで全てのデータを読み書きする必要があります。より効率的ですが扱いが難しいです。
- エッジトリガーモードを使用する場合は、`ev.events`に`EPOLLET`を設定します（例：`EPOLLIN | EPOLLET`）。

### **非ブロッキングI/O**
`epoll`は、I/O操作でのブロッキングを防ぐために、非ブロッキングファイルディスクリプタと組み合わせて使用されることが多いです。ソケットを非ブロッキングモードに設定します：

```c
fcntl(fd, F_SETFL, fcntl(fd, F_GETFL) | O_NONBLOCK);
```

---

## 例: シンプルなエコーサーバー

以下は、`epoll`を使用して接続を受け入れ、クライアントにデータをエコーバックするサーバーの基本的な例です。簡単のため、レベルトリガーモードを使用しています。

```c
#include <sys/epoll.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>

#define MAX_EVENTS 10
#define PORT 8080

int main() {
    // リスニングソケットの作成
    int listen_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (listen_fd == -1) { perror("socket"); exit(1); }

    struct sockaddr_in addr = { .sin_family = AF_INET, .sin_addr.s_addr = INADDR_ANY, .sin_port = htons(PORT) };
    if (bind(listen_fd, (struct sockaddr*)&addr, sizeof(addr)) == -1) { perror("bind"); exit(1); }
    if (listen(listen_fd, 5) == -1) { perror("listen"); exit(1); }

    // リスニングソケットを非ブロッキングに設定
    fcntl(listen_fd, F_SETFL, fcntl(listen_fd, F_GETFL) | O_NONBLOCK);

    // epollインスタンスの作成
    int epoll_fd = epoll_create1(0);
    if (epoll_fd == -1) { perror("epoll_create1"); exit(1); }

    // リスニングソケットをepollに追加
    struct epoll_event ev, events[MAX_EVENTS];
    ev.events = EPOLLIN; // レベルトリガー
    ev.data.fd = listen_fd;
    if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, listen_fd, &ev) == -1) { perror("epoll_ctl"); exit(1); }

    // イベントループ
    while (1) {
        int nfds = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);
        if (nfds == -1) { perror("epoll_wait"); exit(1); }

        for (int i = 0; i < nfds; i++) {
            int fd = events[i].data.fd;

            if (fd == listen_fd) {
                // 新しい接続を受け入れる
                int client_fd = accept(listen_fd, NULL, NULL);
                if (client_fd == -1) { perror("accept"); continue; }

                // クライアントソケットを非ブロッキングに設定
                fcntl(client_fd, F_SETFL, fcntl(client_fd, F_GETFL) | O_NONBLOCK);

                // クライアントソケットをepollに追加
                ev.events = EPOLLIN;
                ev.data.fd = client_fd;
                if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, client_fd, &ev) == -1) {
                    perror("epoll_ctl: client_fd");
                    close(client_fd);
                }
            } else {
                // クライアントデータを処理
                char buf[1024];
                ssize_t n = read(fd, buf, sizeof(buf));
                if (n <= 0) {
                    // エラーまたはEOF: 閉じてepollから削除
                    if (n == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) continue;
                    close(fd);
                    epoll_ctl(epoll_fd, EPOLL_CTL_DEL, fd, NULL);
                } else {
                    // データをエコーバック
                    write(fd, buf, n); // 注: 実際のアプリでは部分書き込みを処理
                }
            }
        }
    }

    close(epoll_fd);
    close(listen_fd);
    return 0;
}
```

### 例に関する注記
- **リスニングソケット**: 新しい接続を検出するために`EPOLLIN`を監視します。
- **クライアントソケット**: 受信データを検出するために`EPOLLIN`も監視します。
- **簡略化**: `write`が完全に完了すると仮定しています。本番環境では、データをバッファリングし、部分書き込みに`EPOLLOUT`を使用します。
- **エラーハンドリング**: エラーまたはEOF時にソケットを閉じ、epollから削除します。

---

## まとめ
`epoll`は、Linuxで複数のファイルディスクリプタを効率的に処理する方法を提供します：
1. `epoll_create1`でインスタンスを作成。
2. `epoll_ctl`でファイルディスクリプタとイベントを登録。
3. `epoll_wait`でイベントを待機。
4. 必要に応じて監視イベントを調整したりディスクリプタを削除したりしながら、ループ内でイベントを処理。

簡単なアプリケーションにはレベルトリガーモードが推奨されます。高性能が求められる場合は、全ての利用可能なデータを注意深く扱うエッジトリガーモードを検討してください。最良の結果を得るために、常に`epoll`を非ブロッキングI/Oと組み合わせて使用します。