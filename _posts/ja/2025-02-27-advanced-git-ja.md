---
audio: false
lang: ja
layout: post
title: 高度なGitコマンド
translated: true
---

Gitは、開発者にとってスイスアーミーナイフのようなものです—多機能で強力で、どのツールを使うべきか分からないと混乱することもあります。今日は、Gitの最も便利な機能とワークフローに触れていきます：変更のチェリーピック、スタイルのあるマージ、クリーンな履歴のためのリベース、偶然にコミットした大きなファイルの削除、そしてレールを外れたことに気づいたときにコミットを元に戻す方法です。分解してみましょう。

#### チェリーピック：必要なものだけを取り出す
例えば、12のコミットがある機能ブランチがあり、その中に1つの素晴らしいコミットがあるとします。それをメインブランチに適用したいが、他のものを一緒に持ってきたくない場合、そこで`git cherry-pick`が役立ちます。

非常に簡単です：コミットハッシュを見つけて（`git log`から取得できます）、それを希望するブランチに切り替え、以下を実行します：
```
git cherry-pick <commit-hash>
```
これで、そのコミットは現在のブランチの一部になります。コンフリクトがある場合、Gitは一時停止し、マージのように解決するように促します。満足したら、変更をコミットし、完了です。

私は、バグ修正がメッシな機能ブランチに潜り込んだとき、それを`main`にすぐに必要なときにこれをよく使います。ただし、注意してください—チェリーピックはコミットを重複させるため、新しいハッシュが生成されます。後で元のブランチをマージしても、いくつかのクリーンアップなしでうまくいくとは限りません。

#### マージオプション：マージだけでなく
マージはGitの基本的な機能ですが、知っていますか？いくつかのバリエーションがあります。デフォルトの`git merge`は、可能であれば「ファストフォワード」を行い（履歴を直線化）、分岐が分岐している場合はマージコミットを作成します。しかし、いくつかのオプションがあります：

- **`--no-ff`（ノーファストフォワード）**：ファストフォワードが可能でもマージコミットを強制します。私は、機能ブランチが`main`に到着したときに明確な記録を保つためにこれを愛しています。以下のように実行します：
  ```
  git merge --no-ff feature-branch
  ```
- **`--squash`**：すべての変更を現在のブランチに1つのコミットとして取り込みます。マージコミットはなく、ただ1つのきれいなパッケージです。メッシなブランチを何か見せられるものに押し込むのに最適です：
  ```
  git merge --squash feature-branch
  ```
  これで、手動でコミットして完了します。

それぞれに適した場所があります。私は、長期間のブランチには`--no-ff`を、「WIP」コミットがたくさんあるブランチには`--squash`を使います。

#### リベース：プロのように履歴を書き換える
マージが混雑しているように感じる場合、`git rebase`があなたのスタイルかもしれません。これは、コミットを他のブランチに再生し、最初からすべてを計画していたかのように線形の履歴を提供します。

機能ブランチに切り替え、以下を実行します：
```
git rebase main
```
Gitはコミットを取り外し、ブランチを`main`に合わせて更新し、変更を再度上に載せます。コンフリクトが発生した場合は解決し、`git rebase --continue`を実行して完了します。

メリットは、きれいなタイムラインです。デメリットは、すでにそのブランチをプッシュし、他の人がそれを使用している場合、リベースは履歴を書き換えます—チームメンバーからの怒りのメールが始まります。私は、リベースをローカルブランチやソロプロジェクトに使用します。共有するものにはマージの方が安全です。

#### 履歴から大きなファイルを削除：2GBのビデオ、しまった
私たちはみんな同じです：巨大なファイルを偶然にコミットし、プッシュし、リポジトリが膨張しました。Gitは簡単に忘れませんが、少しの努力で履歴からそのファイルを消去できます。

ここでは、`git filter-branch`または新しい`git filter-repo`（後者をお勧めします—速くてエラーが少ない）が使えます。例えば、`bigfile.zip`をコミットし、それを消したい場合：
1. `git-filter-repo`をインストールします（設定についてはそのドキュメントを参照）。
2. 以下を実行します：
   ```
   git filter-repo --path bigfile.zip --invert-paths
   ```
   これで、`bigfile.zip`が履歴のすべてのコミットから削除されます。
3. 書き換えられた履歴を強制プッシュします：
   ```
   git push --force
   ```

注意：これは履歴を書き換えるため、チームと調整してください。プルリクエストに含まれている場合は、リファレンスもクリーンアップする必要があるかもしれません。消えた後、リポジトリはガベージコレクション（`git gc`）後にスリムになります。

#### コミットの取り消し：時計を巻き戻す
コミットをしてすぐに後悔しましたか？Gitがサポートします。いくつかの方法がありますが、どれだけ進んだかによって異なります：

- **まだプッシュしていない場合**：`git reset`を使用します。最後のコミットを取り消し、変更を作業ディレクトリに保持するには：
  ```
  git reset HEAD^ --soft
  ```
  変更を完全に捨てたい場合：
  ```
  git reset HEAD^ --hard
  ```
- **すでにプッシュした場合**：履歴を書き換える必要があります。ローカルで`git reset HEAD^`をリセットし、強制プッシュします：
  ```
  git push --force
  ```
  これは共有履歴を混乱させるため、慎重に進んでください。

私は、`git reset --soft`で何度も救われました—コミットが早すぎて何かを調整するのに最適です。

#### まとめ

Gitの柔軟性が強力な理由ですが、選択肢を知らないと混乱しやすいです。チェリーピックは外科的な精度、マージはワークフローに合わせて調整、リベースはきれいな履歴、そして大きなファイルや急なコミットのミスを消去する必要があるときにパニックを起こさないでください。練習はテストリポジトリで行い、すぐに慣れるでしょう。

あなたのお気に入りのGitのトリックは何ですか？教えてください—I’m always up for learning something new!