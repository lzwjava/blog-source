---
audio: false
generated: true
lang: ja
layout: post
title: 高度なGitコマンド
translated: true
type: note
---

Gitは開発者にとってのスイスアーミーナイフのようなものです――多機能で強力ですが、どのツールを使うべきか分かっていないと時々混乱を招きます。今日は、Gitの便利な機能とワークフローについて掘り下げていきます：変更のチェリーピック、スタイルを考慮したマージ、よりクリーンな履歴のためのリベース、誤ってコミットしてしまった面倒な大きなファイルの削除、そして道を外れたことに気づいた時のコミットの取り消しです。順に説明していきましょう。

#### チェリーピック: 必要なものだけを取得する
1ダースものコミットがあるfeatureブランチがあると想像してください。しかし、その中に1つだけ光るコミットがあり、それをmainブランチに適用したい――しかし他のものは持ってきたくない――という場合があります。そこで`git cherry-pick`の出番です。

これは非常に簡単です：コミットハッシュを見つけ（`git log`から取得できます）、それを適用したいブランチに切り替えて、以下を実行します：
```
git cherry-pick <コミットハッシュ>
```
これで、そのコミットが現在のブランチの一部になります。コンフリクトが発生した場合、Gitはマージ時と同様に一時停止し、解決する機会を与えます。問題が解決したら、変更をコミットして完了です。

私は、バグ修正がごちゃごちゃしたfeatureブランチに紛れ込んでしまい、それを`main`にすぐに適用する必要がある場合に、この方法をよく使います。ただし注意点として――チェリーピックはコミットを複製するので、新しいハッシュが割り当てられます。後で何らかのクリーンアップなしに元のブランチをマージする場合、それがうまくいくとは期待しないでください。

#### マージオプション: 単なる「マージ」以上のもの
マージはGitの基本ですが、それにはいくつかの種類があることをご存知でしたか？デフォルトの`git merge`は、可能であれば「fast-forward」（履歴を一直線にすること）を実行し、ブランチが分岐している場合はマージコミットを作成します。しかし、オプションがあります：

- **`--no-ff` (No Fast-Forward)**: fast-forwardが可能な場合でも、強制的にマージコミットを作成します。これは、featureブランチが`main`に統合された時期を明確に記録するのに便利です。以下のように実行します：
  ```
  git merge --no-ff feature-branch
  ```
- **`--squash`**: ブランチからのすべての変更を、現在のブランチ上の1つのコミットにまとめます。マージコミットは作成されず、単一の整理されたパッケージになります。ごちゃごちゃしたブランチを提示可能なものに圧縮するのに最適です：
  ```
  git merge --squash feature-branch
  ```
  この後、手動でコミットして確定させる必要があります。

それぞれに役立つ場面があります。私は長期間存続するブランチには`--no-ff`を、「WIP」コミットでいっぱいの、むしろ忘れたいブランチには`--squash`を使う傾向があります。

#### リベース: プロのように履歴を書き換える
マージが煩雑に感じるなら、`git rebase`があなたの好みに合うかもしれません。これはあなたのコミットを取り出し、別のブランチの上で再実行し、最初からすべて完璧に計画していたかのような直線的な履歴を提供します。

featureブランチに切り替えて、以下を実行します：
```
git rebase main
```
Gitはあなたのコミットを持ち上げ、ブランチを`main`に合わせて更新し、あなたの変更を再び上に載せます。コンフリクトが発生した場合は、それを解決し、`git rebase --continue`を実行して完了するまで続けます。

利点は？ pristineなタイムラインです。欠点は？もしそのブランチを既にプッシュしていて、他の誰かがそのブランチで作業している場合、リベースは履歴を書き換えるため――チームメートからの怒りのメールが待っています。私はローカルブランチや個人プロジェクトでのリベースに留めています。共有されているものについては、マージの方が安全です。

#### 履歴からの大きなファイルの削除: おっと、あの2GBの動画ファイル
誰もが経験したことがあるでしょう：誤って巨大なファイルをコミットし、プッシュしてしまい、リポジトリが膨れ上がってしまった。Gitは簡単には忘れませんが、多少の努力を払えば、そのファイルを履歴から削除することができます。

ここで使うツールは`git filter-branch`、またはより新しい`git filter-repo`です（後者を推奨します――より高速で、エラーが発生しにくいです）。`bigfile.zip`をコミットしてしまい、それを削除する必要があるとします：
1.  `git-filter-repo`をインストールします（セットアップ方法はそのドキュメントを確認してください）。
2.  以下を実行します：
    ```
    git filter-repo --path bigfile.zip --invert-paths
    ```
    これにより、履歴上のすべてのコミットから`bigfile.zip`が削除されます。
3.  書き換えられた履歴をforce-pushします：
    ```
    git push --force
    ```

注意：これは履歴を書き換えるため、チームと連携を取ってください。また、どこかのプルリクエストにある場合は、refsもクリーンアップする必要があるかもしれません。ファイルが削除されると、ガベージコレクション（`git gc`）の後、リポジトリは縮小します。

#### コミットの取り消し: 時計を巻き戻す
コミットをした瞬間に後悔したことはありませんか？Gitはあなたをサポートします。どこまで進んでしまったかによって、取り消す方法はいくつかあります：

- **まだプッシュしていない場合**: `git reset`を使用します。直前のコミットを取り消し、変更は作業ディレクトリに保持したい場合：
  ```
  git reset HEAD^ --soft
  ```
  変更も完全に破棄したい場合：
  ```
  git reset HEAD^ --hard
  ```
- **既にプッシュしてしまった場合**: 履歴を書き換える必要があります。ローカルで`git reset HEAD^`を実行し、その後force-pushします：
  ```
  git push --force
  ```
  繰り返しになりますが、これは共有履歴を混乱させるので、注意して進めてください。

`git reset --soft`で数え切れないほど危機を救ってきました――早すぎるコミットをして何かを調整する必要がある場合に最適です。

#### まとめ

Gitの柔軟性は、それを非常に強力にしている理由ですが、オプションを知っていなければ絡み合ってしまうのも簡単です。チェリーピックで外科的な精度を発揮し、マージをワークフローに合わせて調整し、リベースで磨かれた履歴を実現し、大きなファイルや軽率なコミットといった間違いを消す必要がある時に慌てないでください。不安ならテスト用のリポジトリでこれらを練習してみてください。すぐに第二の天性のように感じられるでしょう。

あなたのお気に入りのGitの技は何ですか？教えてください――私はいつも新しいことを学ぶのに貪欲です！