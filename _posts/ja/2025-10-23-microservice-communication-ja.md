---
audio: false
generated: true
image: false
lang: ja
layout: post
model: x-ai/grok-4-fast
title: マイクロサービス通信：同期型とイベント駆動型
translated: true
type: note
---

### マイクロサービスにおける同期通信とイベント駆動通信

マイクロサービスアーキテクチャでは、サービス間の通信は主に2つの方法で行われます：**同期通信**（HTTP/REST APIのような直接的なアクティブな呼び出し）と**非同期/イベント駆動通信**（Kafkaのようなツールを使用したイベントの発行と消費）です。あなたの質問は、一般的なトレードオフを浮き彫りにしています：なぜ単にロジックを1つのサービス（「呼び出し元」）に集中させ、それが下流のサービス（「呼び出し先」）をアクティブに呼び出すようにしないのか、あるいは呼び出し元を変更して複数の呼び出し先への呼び出しをファンアウトさせないのか？その代わりに、なぜKafkaのようなものを使ってイベント経由でそれらを分離するのか？

短い答え：Kafkaを使用したイベント駆動アーキテクチャは、**疎結合、スケーラビリティ、および回復性**を促進し、システム（特に複雑性が増す場合）の構築、維持、拡張を容易にします。直接呼び出しは単純なセットアップでは問題なく機能しますが、分散された高負荷環境では破綻します。詳しく見ていきましょう。

#### なぜ単に1箇所からサービスをアクティブに呼び出さない（あるいは呼び出し元を変更しない）のか？
このアプローチ、つまり中央の「オーケストレーター」サービス（または元の呼び出し元）がAPIを介して下流サービスを直接呼び出す方法は、最初は単純明快です。必要に応じて（例えば、複数のサービスへのシーケンシャルまたはパラレルなファンアウトのために）「呼び出し先を追加する」ように呼び出し元を更新することもできます。しかし、これがうまくいかない理由は以下の通りです：

- **密結合**: 呼び出し元は、すべての呼び出し先の正確な場所（URL/エンドポイント）、スキーマ、および可用性を知っている必要があります。下流サービスがそのAPIを変更したり、ダウンしたり、名前が変更された場合、*すべての*呼び出し元を更新しなければなりません。これはリファクタリングが困難な依存関係の網を生み出します。

- **同期ブロッキング**: 呼び出しはブロッキングです。呼び出し元は応答を待ちます。1つの呼び出し先が遅いか失敗すると、チェーン全体が停止します（連鎖障害）。ファンアウトのシナリオ（呼び出し元が複数の呼び出し先を呼び出す）では、単一のタイムアウトがすべてを遅延させる可能性があります。

- **スケーラビリティの限界**: 高いトラフィックは、呼び出し元をボトルネックにします。呼び出し元はすべての調整、リトライ、およびエラーハンドリングを処理しなければなりません。呼び出し先をさらに追加しますか？そうすると、呼び出し元にロジックが肥大化し、単一責任の原則に違反します。

- **信頼性の問題**: 組み込みのキューイングやリトライのメカニズムがありません。障害は即座に伝播し、サービスが呼び出し途中でクラッシュすると、イベント/データを失います。

本質的に、これは全員が直接ダイヤルする電話ツリーのようなものです：3～4人では効率的ですが、100人ではカオスです。

#### なぜKafkaを使ったイベント駆動なのか？（下流にイベントを消費させる）
Kafkaは、耐久性のある順序付けられたイベントのログとして機能する分散イベントストリーミングプラットフォームです。プロデューサー（上流サービス）はトピック（例：「user-registered」）にイベントを発行し、コンシューマー（下流サービス）はそれらを独立して購読し処理します。これは「プッシュ/プル調整」から「パブリッシュ/サブスクライブ」（pub/sub）への転換です。

この転換を価値あるものにする主な利点：

1. **疎結合と柔軟性**:
   - サービスは互いのことを知る必要がありません。プロデューサーは関連するデータ（例：`{userId: 123, action: "registered"}`）を含むイベントを発行するだけです。任意の数のコンシューマーが、プロデューサーに気を使うことなくそのトピックを購読できます。
   - 新しい下流サービス（例：メール通知、分析更新）を追加したいですか？ただそれをイベントを消費させるようにするだけです。プロデューサーや既存のコードを変更する必要はありません。1つ削除しますか？購読を解除します。これは進化するシステムにとって非常に重要です。

2. **非同期と非ブロッキング**:
   - プロデューサーはファイアーアンドフォゲット：イベントを発行し、即座に次の処理に移ります。下流の処理を待ちません。
   - システム全体の応答性が向上します。ユーザー向けサービスは、ロギングや通知のようなバックグラウンドタスクで待たされることがありません。

3. **スケーラビリティとスループット**:
   - Kafkaは大規模なスケールを処理します：パーティション間で毎秒数百万のイベント。複数のコンシューマーが*同じ*イベントを並列に処理できます（例：1つはキャッシング用、1つは検索インデックス用）。
   - 水平スケーリングが容易です。プロデューサーに触れることなく、より多くのコンシューマーインスタンスを追加します。

4. **回復性と耐久性**:
   - イベントはKafkaのログに数日/数週間保持されます。コンシューマーがクラッシュしたり遅延したりした場合、最後のオフセット（チェックポイント）からイベントを再生します。
   - （適切な設定による）正確に1回のセマンティクスにより、重複を防ぎます。組み込みのリトライ、デッドレターキュー、およびフォールトトレランスは、呼び出し元のカスタムコードを凌駕します。

5. **イベントソーシングと監査可能性**:
   - データを不変のイベントのストリームとして扱い、デバッグ、コンプライアンス、または状態の再構築（例：「バグを修正するためにすべてのユーザーイベントを再生する」）のための再生を可能にします。
   - リアルタイム分析、MLパイプライン、またはCQRS（Command Query Responsibility Segregation）パターンに最適です。

#### これが光るのはいつか？（トレードオフ）
- **最適なケース**: 高負荷の分散システム（例：eコマースの注文処理、IoTデータストリーム、ユーザーアクティビティフィード）。もしあなたのアプリが10以上のサービスを持つか、予測不可能な負荷を持つなら、Kafkaは「巨大な泥の玉」を防ぎます。
- **欠点**: 複雑さが増します（Kafkaの学習、トピック/パーティションの管理、結果整合性）。イベントフローのデバッグは直接呼び出しよりも厄介な場合があります。プロトタイプには同期から始め、スケールするにつれてイベントに移行します。
- **Kafkaの代替**: RabbitMQ（より単純なキューの場合）、AWS SNS/SQS（マネージド）、またはPulsar（マルチテナンシーが必要な場合）。しかし、Kafkaのストリーミング＋キューイングの組み合わせが、それを代表的な選択肢にしています。

#### コード例（疑似コード）
**同期呼び出し元（脆い）**:
```python
def process_user_registration(user_data):
    # 呼び出し元が複数のサービスを直接呼び出す
    email_service.send_welcome(user_data)  # 遅いとブロックする
    analytics_service.log_event(user_data)  # 失敗？全体が失敗する
    cache_service.invalidate(user_data)     # さらに追加？ここを更新
```

**Kafkaを使ったイベント駆動（柔軟）**:
```python
# プロデューサー（上流）
from kafka import KafkaProducer
producer = KafkaProducer(bootstrap_servers='localhost:9092')
producer.send('user-events', value={'userId': 123, 'action': 'registered'})

# コンシューマー1（メールサービス、独立）
from kafka import KafkaConsumer
consumer = KafkaConsumer('user-events', bootstrap_servers='localhost:9092')
for msg in consumer:
    if msg.value['action'] == 'registered':
        send_welcome(msg.value)  # 独立してスケール/リトライ可能

# コンシューマー2（分析、同じトピックを購読 - プロデューサーの変更は不要）
# ... 同様だが、DBにログを記録
```

まとめると、呼び出し元を変更して「呼び出し先を追加する」ことは、スケールせず、すべてを結合してしまう短期的な修正です。Kafkaを使ったイベント駆動は、サービスが独立して進化することを可能にし、あなたのモノリスを偽装したシステムを真にモジュール化されたシステムに変えます。もし何か具体的なものを構築しているのであれば、詳細を共有してアドバイスをカスタマイズしましょう！

**参考文献**:
- [Kafka Documentation: Introduction](https://kafka.apache.org/intro)
- [Martin Fowler: Event-Driven Architecture](https://martinfowler.com/articles/201701-event-driven.html)
- [ThoughtWorks: Microservices Patterns (Ch. 11: Event Collaboration)](https://www.oreilly.com/library/view/microservices-patterns/9781492034018/ch11.html)