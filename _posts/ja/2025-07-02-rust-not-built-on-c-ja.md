---
audio: false
generated: true
lang: ja
layout: post
title: RustとCの関係
translated: true
type: note
---

いいえ、RustはCに「基づいて構築されている」わけではありません。つまり、Cにコンパイルされるわけでも、自身の動作のために基盤層としてCを必要とするわけでもないのです。Rustは独立した、現代的なシステムプログラミング言語です。

以下に、RustとCの関係、およびRustがCライブラリとどのように連携するかについて説明します。

**RustはCに基づいて構築されているか？**

* **コンパイラ:** Rustコンパイラ (`rustc`) は、主にRust自身で書かれています。初期バージョンのコンパイラはOCamlを使ってブートストラップされましたが、現在はセルフホスティングです。
* **低レベルでの相互作用:** Rustは、オペレーティングシステムやハードウェアと直接対話できる低レベル言語であり、CやC++と同様です。これらの基本的な操作において、仲介役としてCに依存することはありません。
* **LLVM:** Rustのコンパイラは、コード生成と最適化のためのバックエンドとしてLLVM (Low Level Virtual Machine) を使用しています。LLVM自体は主にC++で書かれています。これは、Rustコードが最終的にLLVM中間表現 (IR) に変換され、その後最適化されてマシンコードにコンパイルされることを意味します。したがって、その意味では、C++ベースのツールチェーン (LLVM) への依存関係はありますが、Rust自体が「Cに基づいて構築されている」わけではありません。

**RustはすべてのCライブラリを使用できるか？**

はい、Rustは **Foreign Function Interface (FFI)** を通じて、Cライブラリとの優れた相互運用性を備えています。これは、既存のCライブラリの関数やデータ構造をRustコード内から直接呼び出して使用できることを意味します。

以下がその大まかな仕組みです：

1.  **`extern "C"` ブロック:** Rustコード内で `extern "C"` ブロックを定義し、呼び出したいC関数のシグネチャを宣言します。これにより、Rustコンパイラに対して、これらの関数がCのアプリケーションバイナリインタフェース (ABI) に従っていることを伝えます。C ABIは、関数の呼び出し方法やメモリ内でのデータの配置方法を規定します。
2.  **`#[link]` 属性:** `#[link(name = "foo")]` 属性を使用して、Rustリンカーに対し、指定されたCライブラリ (例: `libfoo.so` や `foo.lib`) に対してリンクするように指示します。
3.  **`unsafe` ブロック:** C関数の呼び出しは、通常、Rustでは `unsafe` ブロック内でラップされます。これは、Rustの強力なメモリ安全性保証が、Rustのルールに従わない「外部」コードとの相互作用時には強制できないためです。プログラマはこれらの呼び出しの安全性を保証する責任を負います。
4.  **`bindgen`:** 大規模なCライブラリの場合、すべての `extern "C"` 宣言を手動で書くのは面倒です。`bindgen` のようなツールは、CヘッダーファイルからRustのFFIバインディングを自動生成することができ、このプロセスを大幅に簡素化します。
5.  **`cty` クレート:** `cty` クレートは、RustとCの間で正しいデータ型マッピングを保証するために、C互換のプリミティブ型 (例: `c_int`, `c_char` など) を提供します。

**なぜRustでCライブラリを使用するのか？**

* **既存のコードの活用:** 様々なタスク (例: システムコール、暗号化、数値計算、グラフィックス) に対して、十分にテストされ高度に最適化されたCライブラリの広大なエコシステムが存在します。Rustを使用すると、すべてを一から書き直すことなく、この既存のリソースを利用することができます。
* **オペレーティングシステムインタフェース:** オペレーティングシステムは、その機能の多くをC互換のインタフェースを通じて公開しています。RustはOSと対話するために、これらの関数を呼び出すことができなければなりません。
* **パフォーマンスがクリティカルなセクション:** Rustは一般的に非常に高速ですが、一部の高度に特殊化されたパフォーマンスがクリティカルなコードは、既にCで存在しており、直接統合できる可能性があります。

まとめると、Rustは「Cに基づいて構築されている」わけではありませんが、Cライブラリとのシームレスな相互運用性のための堅牢なメカニズム (FFI) を提供しており、Rust開発者が広範なCのエコシステムを活用できるようにしています。