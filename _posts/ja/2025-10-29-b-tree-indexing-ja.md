---
audio: false
generated: true
image: false
lang: ja
layout: post
model: x-ai/grok-4-fast
title: 効率的なデータベースインデックス作成のためのB木
translated: true
type: note
---

### B-Treeとは

B-Tree（"balanced tree"の略）は、大量のデータを効率的に保存、挿入、削除、検索するために設計された自己平衡木データ構造です。特に、データがディスク（データベースなど）に保存されるシステム向けに最適化されており、ツリーを可能な限り浅く保つことで、高コストなディスクI/O操作の回数を最小限に抑えます。

#### B-Treeの主な特性
- **位数**: パラメータ *t*（最小次数）によって定義され、各ノードは *t-1* から *2t-1* 個のキー（および最大 *2t* 個の子）を持つことができます。これにより、ノードが複数のキーを保持でき、ツリーはより幅広く浅くなります。
- **平衡構造**: すべてのリーフノードは同じレベルにあり、操作の時間計算量が対数時間（O(log n)、nはキー数）で保証されます。
- **ソート済みキー**: 各ノード内のキーはソートされた順序で格納され、ツリーはこの不変条件を維持します。キーの左側のサブツリーにはより小さい値が、右側にはより大きい値が含まれます。
- **ノード構造**: 内部ノードは、検索を子ノードに誘導するためのキーを持ちます。リーフノードは実際のデータ（またはそのポインタ）を格納します。

ノードあたりの子が2つに制限され、不平衡になる可能性がある（最悪の場合の性能がO(n)になる）二分探索木（BST）とは異なり、B-Treeは多分木であり、挿入/削除時のノードの分割やマージを通じて平衡を保ちます。

#### 簡単な例
位数3（*t=3*、したがってノードあたり2〜5キー）のB-Treeを想像してください。小さなツリーは、テキスト形式では次のようになります。

```
       [10, 20, 30]
      /    |    |    \
 [5,7]  [15] [22,25] [35,40]
```

- 25を検索: ルートから開始し、10/20/30と比較 → [22,25] へ右に移動 → 発見。

この構造により、少数のノードを走査するだけで、効率的な範囲クエリ（例：15から25までのすべてのキー）が可能になります。

### データベースにおけるB-Treeの活用

データベース（MySQL、PostgreSQL、SQL Serverなどのリレーショナルデータベース）は、ディスク上に保存された大規模なテーブルに対するクエリを高速化するための**インデックス**として、B-Tree（またはB+ Treeのようなその派生形）に大きく依存しています。インデックスがなければ、クエリはテーブル全体のスキャン（O(n)時間、数百万行に対しては遅い）を必要とします。

#### データベースにおける主な用途
1. **主キーインデックスとセカンダリインデックス**:
   - **主キーインデックス**は、主キー（一意識別子）に基づいて構築されます。テーブルの行をB-Tree順に整理し、高速な検索を実現します。
   - **セカンダリインデックス**は、他の列（名前、日付など）に作成されます。リーフノードは（行IDを介して）実際の行の位置を指し示します。

2. **効率的なディスクアクセス**:
   - ディスクはデータをブロック（例：4KBページ）単位で読み込みます。B-Treeのノードは1つのディスクブロックに収まるようにサイズ設定されるため、検索では通常、ツリーの高さに応じて3〜4ブロックの読み込みのみで済み、リンクリストでは数千に及ぶ可能性があるのに比べて効率的です。
   - 高さは対数的: 10億のキーに対して、高さはわずか4〜5レベルになる可能性があります。

3. **B+ Tree 派生形（データベースで一般的）**:
   - ほとんどのデータベースは**B+ Tree**を使用します。これはB-Treeを調整したもので、以下の特徴があります:
     - データ/ポインタを格納するのはリーフノードのみ。
     - 内部ノードはルーティングのためのキーのみを持つ。
     - リーフノードはリンク（双方向リンクリスト）されており、効率的な順次スキャンと範囲クエリ（例: `SELECT * WHERE age BETWEEN 20 AND 30`）を可能にします。
   - これにより、範囲操作とキャッシュ効率が向上します。

4. **実際の操作**:
   - **INSERT/UPDATE/DELETE**: ツリーは平衡を維持するためにノードの分割やマージを行います。データベースはラッチ/ロックを使用して並行性を制御します。
   - **クエリ最適化**: クエリプランナは、インデックスの統計情報を使用して、テーブルスキャンではなくB-Treeインデックスを選択します。
   - **クラスタ化インデックスと非クラスタ化インデックス**: クラスタ化インデックス（例：MySQLのInnoDB）では、テーブルデータは物理的にB-Treeのリーフノード順に格納されます。非クラスタ化インデックスは単にデータを指し示すだけです。

#### 利点とトレードオフ
- **長所**: 等値検索、範囲検索、ソート済みクエリに対して高速。成長するデータをうまく扱う。
- **短所**: 挿入/削除のためのオーバーヘッド（ツリーのメンテナンス）。バッチ処理なしでの非常に頻繁な更新には理想的ではない。

まとめると、B-Treeは、インデックスを用いたアクセスにおけるデータベースのパフォーマンスの基盤であり、線形検索になりうる操作を、その平衡的でディスクに優しい設計により、ほぼ定数時間に近い操作に変えています。

#### 参考文献
- [B-tree - Wikipedia](https://en.wikipedia.org/wiki/B-tree)
- [B+ Tree in DBMS - GeeksforGeeks](https://www.geeksforgeeks.org/introduction-of-b-tree/)
- [How Indexes Work in SQL Databases - Use The Index, Luke](https://use-the-index-luke.com/sql/anatomy/index-btree)