---
audio: false
generated: true
lang: ja
layout: post
title: WebGLガイド
translated: true
type: note
---

WebGL（Web Graphics Library）に関する包括的なガイドへようこそ。このガイドでは、WebGLの基本概念、動作原理、利点、始め方、そしてFigmaなどのツールにおける役割まで、その全体像を解説します。さあ、始めましょう！

---

### **1. WebGLとは？**
WebGLは、ハードウェアアクセラレーションによる2Dおよび3DグラフィックスをWeb上で実現するJavaScript APIです。OpenGL ES（Embedded Systems）を基盤としており、ブラウザ向けに適応されています。WebGLを使用すると、`<canvas>`要素に対してGPUを直接利用したグラフィックス描画が可能となり、従来のHTML/CSSによるCPUベースの描画よりも高速に処理できます。

- **主な特徴:**
  - **ハードウェアアクセラレーション:** GPUを活用した高速な描画。
  - **クロスプラットフォーム:** 主要なブラウザ（Chrome、Firefox、Safari、Edge）で動作。
  - **プログラム可能:** シェーダー（小さなプログラム）を使用して見た目や動きを定義。
  - **プラグインフリー:** Flashなどのプラグインが不要で、ブラウザネイティブ。

- **歴史:**
  - 2011年にKhronos Group（OpenGLを策定）によって導入。
  - WebGL 1.0はOpenGL ES 2.0、WebGL 2.0（2017）はOpenGL ES 3.0に基づく。

- **使用例:**
  - ゲーム（例：ブラウザベースの3Dタイトル）。
  - データ可視化（例：インタラクティブなチャートや地図）。
  - クリエイティブツール（例：Figmaのベクター描画）。
  - シミュレーション（例：物理エンジンや3Dモデリング）。

---

### **2. WebGLの動作原理**
WebGLは、JavaScript APIを通じてGPUへの低レベルアクセスを提供します。その中心には**レンダリングパイプライン**—コードを画面上のピクセルに変換する一連の工程—があります。

1. **セットアップ:**
   - HTML内で`<canvas>`要素を作成。
   - WebGLコンテキストを取得: `canvas.getContext('webgl')`（または2.0の場合は`'webgl2'`）。

2. **シェーダー:**
   - **頂点シェーダー:** 3D空間内の頂点の位置を定義。
   - **フラグメントシェーダー:** 頂点間の各ピクセルに色を付ける。
   - GLSL（OpenGL Shading Language）で記述され、実行時にコンパイル。

3. **バッファ:**
   - 頂点位置や色などのデータをGPUメモリ内のバッファに格納。
   - 例：三角形の3つの角座標を座標配列として送信。

4. **レンダリング:**
   - バッファをバインドし、シェーダーを設定して描画コール（例：`gl.drawArrays()`）を発行。
   - GPUが並列処理を行い、結果をcanvasに出力。

- **座標系:** WebGLは正規化された3D空間（x、y、z軸で-1から1）を使用し、行列（例：遠近法や回転用）で変換。

- **ステートマシン:** WebGLはステートレス—各描画コール前にパラメータ（例：テクスチャ、ブレンディング）を設定。

---

### **3. WebGLを使用する理由**
- **パフォーマンス:** 複雑なグラフィックスにおいて、CPUレンダリングを凌駕。
- **柔軟性:** シェーダーによりピクセル単位での見た目制御が可能。
- **Web統合:** JavaScript、DOMイベント、他のAPIとシームレスに連携。
- **インストール不要:** ブラウザが動作する環境ならどこでも実行可能。

**トレードオフ:**
- 学習曲線が急峻—HTML5 Canvas 2Dと比べて低レベル。
- デバッグが困難（GLSLのエラーメッセージは難解）。
- ブラウザ互換性にばらつき（特にWebGL 2.0）。

---

### **4. WebGLを使ってみよう**
簡単な色付き三角形を描画して、WebGLの動作を確認します。

#### **ステップ1: HTMLの設定**
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
</head>
<body>
    <canvas id="glCanvas" width="400" height="400"></canvas>
    <script>
        // ここにJavaScriptを記述
    </script>
</body>
</html>
```

#### **ステップ2: JavaScriptの基本**
`<script>`タグ内に以下を追加:
```javascript
// canvasとコンテキストの取得
const canvas = document.getElementById('glCanvas');
const gl = canvas.getContext('webgl');
if (!gl) {
    alert('WebGLがサポートされていません！');
}

// 頂点シェーダーのソース（GLSL）
const vsSource = `
    attribute vec2 a_position;
    void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
    }
`;

// フラグメントシェーダーのソース（GLSL）
const fsSource = `
    void main() {
        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); // 赤色
    }
`;

// シェーダーのコンパイル
function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
    }
    return shader;
}

const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);

// プログラムへのリンク
const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);
if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error(gl.getProgramInfoLog(program));
}

// 頂点データ（三角形）
const positions = new Float32Array([
    0.0,  0.5,  // 上
   -0.5, -0.5,  // 左下
    0.5, -0.5   // 右下
]);

// バッファ設定
const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

// WebGLにバッファの読み方を指示
const positionLocation = gl.getAttribLocation(program, 'a_position');
gl.enableVertexAttribArray(positionLocation);
gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

// クリアと描画
gl.clearColor(0.0, 0.0, 0.0, 1.0); // 黒背景
gl.clear(gl.COLOR_BUFFER_BIT);
gl.useProgram(program);
gl.drawArrays(gl.TRIANGLES, 0, 3); // 3頂点を描画
```

#### **ステップ3: テスト**
- `index.html`として保存し、サーバーで提供（例：`python -m http.server 8080`）してブラウザで開く。
- 黒背景に赤い三角形が表示されます。

---

### **5. コアコンセプト**
- **シェーダー:** 頂点シェーダーはジオメトリの位置を決定、フラグメントシェーダーは色を決定。GLSLはC言語に似ているがGPU専用。
- **バッファ:** 頂点データ（位置、法線、色）をGPUメモリに格納。
- **テクスチャ:** 3Dオブジェクトにマッピングする2D画像（例：`gl.texImage2D()`）。
- **行列:** 変換（平行移動、回転、拡大縮小）に使用。`glMatrix`などのライブラリを利用。
- **描画コール:** 単純な形状には`gl.drawArrays()`、インデックス付きジオメトリには`gl.drawElements()`。

**WebGL 2.0の追加機能:**
- テクスチャの強化（例：3Dテクスチャ）。
- 複数レンダーターゲット。
- シェーダー機能の拡張（例：ユニフォームバッファオブジェクト）。

---

### **6. エコシステムとツール**
- **ライブラリ:**
  - **Three.js:** 高レベル3Dフレームワーク（生のWebGLの複雑さを抽象化）。
  - **Babylon.js:** ゲームに特化した3Dエンジン。
  - **PixiJS:** WebGLフォールバック付き2Dレンダリング。
  - **glMatrix:** 変換用数学ユーティリティ。

- **ブラウザサポート:**
  - WebGL 1.0: ほぼ全ブラウザでサポート。
  - WebGL 2.0: 大半のモダンブラウザ（caniuse.comで確認）。

- **デバッグ:**
  - ブラウザ開発者ツール（例：ChromeのWebGL Inspector）。
  - Spector.jsなどの拡張機能。

---

### **7. 実例でのWebGL**
- **Figma:** ベクターグラフィックス描画にWebGLを採用、計算処理にWebAssemblyを併用。
- **ゲーム:** UnityおよびUnreal EngineがWebGLへエクスポートしブラウザでプレイ可能に。
- **地図:** Google MapsやMapboxがスムーズなズームや3D地形に活用。

---

### **8. 将来展望**
- **WebGPU:** 次世代API（Vulkan/Metalベース）が台頭し、より優れたパフォーマンスとモダンな機能を約束。現時点では代替ではなく補完。
- **広範な採用:** WebGL 2.0の機能強化により、当面はWebGLが主流として継続。

---

### **9. リソース**
- **公式:** [webglfundamentals.org](https://webglfundamentals.org/)—優れた初心者向けチュートリアル。
- **MDN:** [WebGL Docs](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API)。
- **書籍:** 「WebGL Programming Guide」 by Kouichi Matsuda。
- **X投稿:** #WebGLで事例やコミュニティのヒントを検索。

---

### **まとめ**
WebGLは、ブラウザでGPUパワーを引き出すための入口です。低レベルで強力ながら少々とっつきにくい面もありますが、練習（そしてライブラリ）を重ねれば、単純なアニメーションから本格的な3D世界まで構築可能です。特定のプロジェクトに挑戦したり、シェーダーを深掘りしてみませんか？お知らせください！