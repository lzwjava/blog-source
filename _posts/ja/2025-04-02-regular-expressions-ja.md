---
audio: false
generated: true
lang: ja
layout: post
title: 正規表現
translated: true
type: note
---

正規表現（regex または regexp と略される）は、テキスト内のパターンマッチングにおける強力で汎用性の高いツールです。定義されたパターンに基づいて文字列を検索、操作、検証するための簡潔で柔軟な方法を提供します。構文は最初は難解に見えるかもしれませんが、正規表現を習得することで、様々なプログラミング言語、テキストエディタ、コマンドラインツールにおけるテキスト処理能力を大幅に向上させることができます。

このガイドでは、正規表現の基本からより高度な概念までを解説します。

**I. 基本：正規表現の構成要素**

正規表現の核心は、検索パターンを定義する一連の文字です。これらの文字は、リテラル（それ自身に一致）または特殊文字（特定の意味を持つ）のいずれかです。

**A. リテラル文字:**

正規表現内のほとんどの文字は、それ自身にリテラルに一致します。例えば：

* `abc` は文字列内の正確なシーケンス "abc" に一致します。
* `123` は正確なシーケンス "123" に一致します。
* `hello` は正確なシーケンス "hello" に一致します。

**B. メタ文字：特別な力**

メタ文字は、正規表現にその力を与える構成要素です。これらは特別な意味を持ち、それ自身にはリテラルに一致しません。以下は最も一般的なメタ文字です：

1.  **`.` (ドット):** 改行文字（デフォルトでは `\n`）*以外*の任意の1文字に一致します。
    * `a.c` は "abc", "adc", "a1c", "a c" に一致しますが、"ac" や "abbc" には一致しません。

2.  **`^` (キャレット):**
    * **文字セット内（後述）:** セットを否定し、セット内に*ない*任意の文字に一致します。
    * **文字セットの外:** 文字列の先頭（またはマルチラインモードでは行の先頭）に一致します。
        * `^hello` は "hello world" に一致しますが、"say hello" には一致しません。

3.  **`$` (ドル記号):** 文字列の末尾（またはマルチラインモードでは行の末尾）に一致します。
    * `world$` は "hello world" に一致しますが、"world hello" には一致しません。

4.  **`*` (アスタリスク):** 直前の文字またはグループの0回以上の繰り返しに一致します。
    * `ab*c` は "ac", "abc", "abbc", "abbbc" などに一致します。

5.  **`+` (プラス記号):** 直前の文字またはグループの1回以上の繰り返しに一致します。
    * `ab+c` は "abc", "abbc", "abbbc" に一致しますが、"ac" には一致しません。

6.  **`?` (疑問符):**
    * 直前の文字またはグループの0回または1回の出現（オプション化）に一致します。
        * `ab?c` は "ac" と "abc" に一致しますが、"abbc" には一致しません。
    * 量指定子の修飾子として使用し、マッチを非貪欲（non-greedy）にします（量指定子のセクションを参照）。

7.  **`{}` (中括弧):** 直前の文字またはグループの正確な回数または範囲の出現を指定します。
    * `a{3}` は正確に3つの "a"（例: "aaa"）に一致します。
    * `a{2,4}` は2つから4つの "a"（例: "aa", "aaa", "aaaa"）に一致します。
    * `a{2,}` は2つ以上の "a"（例: "aa", "aaa", "aaaa", ...）に一致します。

8.  **`[]` (角括弧):** 文字セットを定義し、括弧内の任意の1文字に一致します。
    * `[abc]` は "a", "b", または "c" のいずれかに一致します。
    * `[a-z]` は "a" から "z" までの任意の小文字（範囲）に一致します。
    * `[0-9]` は "0" から "9" までの任意の数字に一致します。
    * `[A-Za-z0-9]` は任意の英数字に一致します。
    * `[^abc]`（先頭に `^`）は "a", "b", "c" *以外*の任意の文字に一致します。

9.  **`\` (バックスラッシュ):** 次の文字をエスケープし、メタ文字をリテラル文字として扱うか、特別な文字シーケンスを導入します。
    * `\.` はリテラルのドット "." に一致します。
    * `\*` はリテラルのアスタリスク "*" に一致します。
    * `\d` は任意の数字に一致します（`[0-9]` と同等）。
    * `\D` は数字以外の任意の文字に一致します（`[^0-9]` と同等）。
    * `\s` は任意の空白文字（スペース、タブ、改行など）に一致します。
    * `\S` は空白以外の任意の文字に一致します。
    * `\w` は任意の単語文字（英数字とアンダースコア、`[a-zA-Z0-9_]` と同等）に一致します。
    * `\W` は単語文字以外の任意の文字に一致します（`[^a-zA-Z0-9_]` と同等）。
    * `\b` は単語境界（単語文字と非単語文字の間の位置）に一致します。
    * `\B` は非単語境界に一致します。
    * `\n` は改行文字に一致します。
    * `\r` はキャリッジリターン文字に一致します。
    * `\t` はタブ文字に一致します。

10. **`|` (パイプ記号):** 「OR」演算子として機能し、パイプの前の式または後の式のいずれかに一致します。
    * `cat|dog` は "cat" または "dog" のいずれかに一致します。

11. **`()` (丸括弧):**
    * **グループ化:** 正規表現の一部をグループ化し、量指定子やOR演算子をグループ全体に適用できるようにします。
        * `(ab)+c` は "abc", "ababc", "abababc" などに一致します。
        * `(cat|dog) food` は "cat food" または "dog food" に一致します。
    * **キャプチャグループ:** 括弧内の式に一致したテキストをキャプチャします。これらのキャプチャされたグループは後で参照できます（例：置換や抽出用）。

**II. 量指定子：繰り返しの制御**

量指定子は、直前の要素（文字、グループ、文字セット）が何回出現できるかを指定します。

* `*`: 0回以上
* `+`: 1回以上
* `?`: 0回または1回
* `{n}`: 正確に `n` 回
* `{n,}`: `n` 回以上
* `{n,m}`: `n` 回から `m` 回（ inclusive ）

**貪欲マッチと非貪欲マッチ:**

デフォルトでは、量指定子は**貪欲（greedy）** です。つまり、可能な限り多くの文字列に一致しようとします。量指定子の後に `?` を追加することで、量指定子を**非貪欲（non-greedy）**（または怠惰（lazy））にすることができます。非貪欲な量指定子は、可能な限り短い文字列に一致しようとします。

* `a.*b` (貪欲) を "axxbxb" に適用すると "axxbxb" 全体に一致します。
* `a.*?b` (非貪欲) を "axxbxb" に適用すると "axb" に一致し、その後 "xb" に一致します。

**III. アンカー：位置の指定**

アンカーはそれ自体では何の文字にも一致しませんが、文字列内の位置を表明します。

* `^`: 文字列（または行）の先頭に一致します。
* `$`: 文字列（または行）の末尾に一致します。
* `\b`: 単語境界に一致します。
* `\B`: 非単語境界に一致します。

**IV. 文字クラス：事前定義されたセット**

文字クラスは、一般的に使用される文字セットの短縮形を提供します。

* `\d`: 任意の数字（0-9）に一致します。
* `\D`: 数字以外の任意の文字に一致します。
* `\s`: 任意の空白文字（スペース、タブ、改行、キャリッジリターン、フォームフィード）に一致します。
* `\S`: 空白以外の任意の文字に一致します。
* `\w`: 任意の単語文字（英数字とアンダースコア: a-zA-Z0-9_）に一致します。
* `\W`: 単語文字以外の任意の文字に一致します。

**V. グループ化とキャプチャ**

丸括弧 `()` には主に2つの目的があります：

* **グループ化:** 一連の文字に量指定子やOR演算子を適用できるようにします。
* **キャプチャ:** キャプチャグループを作成し、括弧内の式に一致した文字列の部分を保存します。これらのキャプチャされたグループは、後方参照や置換のためにアクセスして使用できます。

**後方参照:**

同じ正規表現内で、以前にキャプチャされたグループを `\1`, `\2`, `\3` などで参照し戻ることができます。番号はキャプチャグループの開き括弧の順序に対応します。

* `(.)\1` は任意の文字とその同じ文字が続くものに一致します（例: "aa", "bb", "11"）。
* `(\w+) \1` は単語、スペース、そして同じ単語が続くものに一致します（例: "hello hello"）。

**非キャプチャグループ:**

キャプチャグループを作成せずに正規表現の一部をグループ化する必要がある場合は、`(?:...)` を使用できます。これは、明確さやパフォーマンス上の理由で有用です。

* `(?:ab)+c` は "abc", "ababc" などに一致しますが、"ab" をキャプチャしません。

**VI. 先読み/後読み：消費しない表明**

先読み/後読みは、文字列内の現在位置の前または後のパターンをチェックするゼロ幅の表明です。マッチした先読み/後読みの部分は全体のマッチには含まれません。

* **肯定先読み `(?=...)`:** 括弧内のパターンが現在位置の後に続かなければならないことを表明します。
    * `\w+(?=:)` はコロンが続く任意の単語に一致しますが、コロン自体はマッチの一部にはなりません（例: "name:" では "name" に一致します）。

* **否定先読み `(?!...)`:** 括弧内のパターンが現在位置の後に続いては*ならない*ことを表明します。
    * `\w+(?!:)` はコロンが続かない任意の単語に一致します（例: "name value" では "name" と "value" に一致します）。

* **肯定後読み `(?<=...)`:** 括弧内のパターンが現在位置の前に前置されなければならないことを表明します。後読み内のパターンは固定幅でなければなりません（`*` や `+` のような可変の量指定子は使用できません）。
    * `(?<=\$)\d+` はドル記号が前置する1つ以上の数字に一致しますが、ドル記号自体はマッチの一部にはなりません（例: "$100" では "100" に一致します）。

* **否定後読み `(?<!...)`:** 括弧内のパターンが現在位置の前に前置されては*ならない*ことを表明します。後読み内のパターンは固定幅でなければなりません。
    * `(?<!\$)\d+` はドル記号が前置しない1つ以上の数字に一致します（例: "100$" では "100" に一致します）。

**VII. フラグ（修飾子）：正規表現の動作制御**

フラグ（または修飾子）は、正規表現エンジンの動作を変更するために使用されます。これらは通常、実装に依存して正規表現パターンの先頭または末尾で指定されます。一般的なフラグには以下があります：

* **`i` (大文字小文字を区別しない):** マッチングで大文字小文字を区別しません。`[a-z]` は小文字と大文字の両方に一致します。
* **`g` (グローバル):** 文字列内の最初のマッチだけでなく、すべてのマッチを見つけます。
* **`m` (マルチライン):** `^` と `$` が文字列全体の先頭と末尾だけでなく、各行（`\n` または `\r` で区切られる）の先頭と末尾に一致するようにします。
* **`s` (Dotall / シングルライン):** メタ文字 `.` が改行文字を含む任意の文字に一致するようにします。
* **`u` (Unicode):** 文字クラスやその他の機能に対する完全なUnicodeサポートを有効にします。
* **`x` (拡張 / 詳細):** パターン内の空白とコメントを無視することで、より読みやすい正規表現を書くことを可能にします（複雑な正規表現に有用）。

**VIII. 正規表現の実用的な応用**

正規表現は様々な領域で広く使用されています：

* **テキストエディタ (例: Notepad++, Sublime Text, VS Code):** パターンに基づいたテキストの検索と置換。
* **プログラミング言語 (例: Python, JavaScript, Java, C#):**
    * ユーザー入力の検証（例: メールアドレス、電話番号、URL）。
    * テキストからの特定の情報の抽出（例: 日付、数値、タグ）。
    * パターンに基づく文字列の一部の置換。
    * ログファイルやその他の構造化テキストデータの解析。
* **コマンドラインツール (例: `grep`, `sed`, `awk`):** テキストファイルの検索と操作。
* **Web開発:** フォーム検証、URLルーティング、コンテンツ処理。
* **データサイエンス:** データクリーニング、データ抽出、パターン認識。
* **セキュリティ:** 侵入検知、ログ分析。

**IX. 異なるプログラミング言語における正規表現**

ほとんどの現代のプログラミング言語は正規表現を組み込みでサポートしていますが、特定の構文と機能は少し異なる場合があります。正規表現の機能は通常、標準ライブラリやモジュールにあります。

* **Python:** `re` モジュール。
* **JavaScript:** 組み込みの `RegExp` オブジェクトと `match()`, `replace()`, `search()`, `split()` などの文字列メソッド。
* **Java:** `java.util.regex` パッケージ。
* **C# (.NET):** `System.Text.RegularExpressions` 名前空間。
* **PHP:** `preg_match()`, `preg_replace()`, `preg_match_all()` などの関数。

**X. 効果的な正規表現を書くためのヒント**

* **単純に始める:** 基本的なパターンから始めて、徐々に複雑さを追加していきます。
* **頻繁にテストする:** オンラインの正規表現テスターや使用しているプログラミング言語の正規表現ツールを使用して、サンプルデータに対してパターンをテストします。
* **具体的にする:** 意図しないテキストに一致する可能性のある過度に広範なパターンを避けます。
* **文字クラスと量指定子を賢く使用する:** これらは強力ですが、正しく使用されないと予期しない動作を引き起こす可能性があります。
* **貪欲マッチと非貪欲マッチを理解する:** 必要性に応じて適切な動作を選択します。
* **グループ化とキャプチャを慎重に使用する:** 必要なものだけをキャプチャします。キャプチャが不要な場合は非キャプチャグループを使用します。
* **正規表現を文書化する:** 複雑なパターンの場合は、（特に `x` フラグを使用する場合）その目的を説明するコメントを追加します。
* **エッジケースを考慮する:** 入力テキストの異なるバリエーションについて考え、正規表現がそれらを正しく処理することを確認します。
* **複雑な問題を分解する:** 非常に複雑なマッチングタスクがある場合は、複数のより単純な正規表現パターンに分解することを検討します。

**XI. 学習リソース**

* **オンライン正規表現テスター:** regex101.com, regexr.com, regextester.com
* **言語固有のドキュメント:** 選択したプログラミング言語の正規表現ドキュメントを参照してください。
* **オンラインチュートリアルとコース:** Coursera, Udemy, YouTubeなどのプラットフォームは包括的な正規表現コースを提供しています。
* **書籍:** Jeffrey Friedl 著「詳説 正規表現」は非常にお勧めのリソースです。

**結論**

正規表現は、テキストデータを扱うすべての人にとって不可欠なツールです。最初の学習曲線は険しく見えるかもしれませんが、複雑なパターンに基づいてテキストを効率的に検索、操作、検証する能力は貴重なスキルです。正規表現の基本概念、メタ文字、量指定子、およびその他の機能を理解することで、幅広いアプリケーションにおいて生産性と問題解決能力を大幅に向上させることができます。正規表現を習得するには練習が鍵ですので、様々なテキスト処理タスクに対して異なるパターンを試し、探求することを躊躇しないでください。