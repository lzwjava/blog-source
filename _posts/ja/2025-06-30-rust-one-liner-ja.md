---
audio: false
generated: true
lang: ja
layout: post
title: シェルチェインを用いたRustワンライナー
translated: true
type: note
---

Python、Ruby、JavaScriptなどの言語から来た経験豊富な開発者に共通する要望に触れていますね。これらの言語では、スクリプトを直接実行する単一コマンドがよくあります。Rustはコンパイル言語であるため、デフォルトでは少し異なるワークフローになります。

しかし、特にシンプルなスクリプトや練習用には、シェルでコマンドを連結することで「ワンライナー」感覚を確実に実現できます。

### 直接的な「ワンライナー」（シェル連結）

必要な要素は既に揃っています：コンパイル用の `rustc` と実行用の `./` です。シェル演算子を使ってこれらを組み合わせられます：

```bash
rustc scripts/rust/example.rs -o test/example && ./test/example
```

**説明:**

  * `rustc scripts/rust/example.rs -o test/example`: これはRustファイルをコンパイルし、実行可能ファイルを `test/example` に配置します。
  * `&&`: これはbash（およびほとんどのUnix系シェル）における**条件付きコマンド区切り文字**です。`&&` の*後*のコマンドは、`&&` の*前*のコマンドが正常に完了した場合（つまり、終了コード0を返した場合）にのみ実行されます。
      * `rustc` がエラーなくコンパイルすると0を返し、その後 `./test/example` が実行されます。
      * `rustc` がコンパイルエラーに遭遇すると、ゼロ以外の終了コードを返し、`./test/example` は実行*されません*。これは良い挙動です\！

### より「スクリプト的」な体験を求める場合 (Cargo)

上記の `&&` アプローチは簡単なテストには有効ですが、些細な単一ファイルスクリプトを超えるものについては、Rustの `cargo` ツールが推奨される方法であり、プロジェクト内のコードを実行するためのPython的なワンライナーを*提供します*：

1.  **Cargoプロジェクトの初期化（まだ行っていない場合）:**
    `scripts/rust/example.rs` が単なるスタンドアロンファイルである場合、通常はその親ディレクトリ（または新しい専用ディレクトリ）にCargoプロジェクトを作成して始めます。

    ```bash
    # プロジェクトを置きたいディレクトリ（例: scripts/rust）に移動
    cd scripts/rust

    # 新しいCargoバイナリプロジェクトを初期化
    cargo init --bin .
    ```

    これにより `Cargo.toml` が作成され、`example.rs` が（もし `main.rs` だったなら）移動されるか、`Cargo.toml` がそれを指すように調整されます（`src/` 内の `example.rs` を `main.rs` にリネームした場合）。

2.  **Cargoでの実行:**
    Cargoプロジェクトが設定されたら、単一コマンドでコンパイルと実行ができます：

    ```bash
    # プロジェクトルート（例: scripts/rust で cargo init を実行した場合）から
    cargo run
    ```

    `cargo run` は以下を行います：

      * コードをコンパイルします（コンパイルされていないか、変更があった場合）。
      * その後、結果のバイナリを実行します。
      * デフォルトでは、バイナリはプロジェクト内の `target/debug/` に配置されますが、その具体的なパスを気にする必要はありません。

**Cargoが推奨される理由:**

  * **依存関係管理:** コードが外部ライブラリ（クレート）を必要とする場合、Cargoが自動的に取得、コンパイル、リンクを処理します。これらは `Cargo.toml` で指定します。
  * **標準的なプロジェクト構造:** 一貫したレイアウト（`src/main.rs`, `Cargo.toml`）を奨励し、コードを他の人（そして将来の自分）が理解しやすくします。
  * **テスト:** `cargo test` は単体テストと統合テストを実行します。
  * **リリースビルド:** `cargo run --release`（または `cargo build --release`）は、本番環境向けの最適化を施してコンパイルします。
  * **手動クリーンアップ不要:** コンパイルされたバイナリを手動で削除する必要はありません。`cargo clean` が処理します。

### Pythonの `python script.py` のような真の「スクリプティング」アプローチについては？

Rustはインタプリタ型のスクリプト言語として設計されていません。コンパイル型のシステム言語です。そのため、明示的なコンパイルステップなしにコンパイルと実行を行う直接的な `rust script.rs` コマンドは得られません。

しかし、クイックな単一ファイルのRust「スクリプト」用にこのギャップを埋めようとするコミュニティツールは存在します（ただし、それらも依然として裏ではコンパイルを行っています）：

  * **`cargo-script`**: 単一の `.rs` ファイルを実行できるCargoサブコマンド。コメント経由で指定された依存関係を処理します。通常 `cargo install cargo-script` でインストールします。その後、`cargo script scripts/rust/example.rs` を実行できる可能性があります。
  * **`rust-script`**: Rustファイルをスクリプトのように直接実行するためのもう一つの人気ツール。`cargo install rust-script` でインストールします。その後、単に `.rs` ファイルを実行可能（`chmod +x example.rs`）にして実行できることがよくあります： `./example.rs`。バックグラウンドでコンパイルと実行を処理します。

`example.rs` を素早くテストするというあなたのユースケースでは、`rustc ... && ./...` ワンライナーは完全に問題なく、2つのコマンドを連結するという質問に直接答えるものです。些細でない開発については、Cargoを受け入れることがより生産的で慣用的なRust体験となるでしょう。