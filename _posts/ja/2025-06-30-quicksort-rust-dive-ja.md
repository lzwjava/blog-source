---
audio: false
generated: true
lang: ja
layout: post
title: 経験豊富な開発者のためのRustでのクイックソート
translated: true
type: note
---

アルゴリズム、フルスタック開発、モバイルエンジニアリングに強いバックグラウンドをお持ちのあなたなら、Rustのメモリ安全性と明示的な制御へのアプローチは、構文や厳密さが新しいものであっても、概念的にはかなり親しみやすいと感じるでしょう。このRustでのクイックソート実装を詳しく見ていきましょう。

-----

### Rustでのクイックソート：経験豊富な開発者のための探求

このRustコードは古典的な**クイックソートアルゴリズム**を実装しています。クイックソートの核となる考え方は、ピボットとして要素を選び、ピボットより小さい要素が一方に、大きい要素がもう一方に来るように配列を分割することです。このプロセスをサブ配列に再帰的に適用します。

関数を見ていきましょう:

-----

### `fn quick_sort(arr: &mut [i32])`

```rust
fn quick_sort(arr: &mut [i32]) {
    if arr.len() <= 1 {
        return;
    }
    let pivot_index = partition(arr);
    let (left, right) = arr.split_at_mut(pivot_index);
    quick_sort(left);
    quick_sort(&mut right[1..]);
}
```

  * **`arr: &mut [i32]`**: ここでRustの型システムの特徴がすぐに現れます。
      * `&mut` は**可変参照**を意味します。これは、`quick_sort`関数が配列`arr`への借用参照を取得し、その配列の内容を*その場で*変更することが許可されていることを意味します。
      * `[i32]` は`i32`整数の**スライス**です。Rustでは、`[T]`がスライスの型であり、連続した要素シーケンスへのビューです。データを所有せず、配列や`Vec`の一部を指し示します。これはデータのコピーを避けるために重要です。C/C++/Javaのバックグラウンドからのポインタや配列セクションに慣れ親しんだあなたにとって、これはRustがそれらを安全かつ明示的に管理する方法と考えてください。
  * **基底ケース `if arr.len() <= 1`**: クイックソートの標準的な再帰の基底ケースです。スライスが0または1要素の場合、すでにソートされているので単に戻ります。
  * **`let pivot_index = partition(arr);`**: これは`partition`関数（次に見ます）を呼び出してスライスを再配置します。ピボット要素の最終的な位置を返します。
  * **`let (left, right) = arr.split_at_mut(pivot_index);`**: これは安全な可変エイリアシングのための重要なRustの機能です。
      * `split_at_mut`は可変スライスのメソッドです。インデックスを受け取り、可変スライスを二つの*互いに素な*可変スライスに分割します。
      * `left`は`arr[0..pivot_index]`、`right`は`arr[pivot_index..len]`になります。
      * これはRustの**ボローチェッカー**の基本です。同じデータへの二つの可変参照を同時に持つことはできません。`split_at_mut`は、`left`と`right`が元の配列の完全に別々の部分を参照することを保証し、ボローチェッカーを満足させ、（これはシングルスレッドですが原則が適用される）マルチスレッドコンテキストでのデータ競合を防ぎます。
  * **`quick_sort(left);`**: `left`サブスライスを再帰的にソートします。
  * **`quick_sort(&mut right[1..]);`**: `right`サブスライスを再帰的にソートします。
      * `right[1..]`が重要です: `right`スライスは`pivot_index`から始まります。`arr[pivot_index]`はすでに正しく配置されたピボット要素なので、右側の再帰呼び出しからはそれを除外します。
      * `&mut`は明示的に`right`から可変スライスを再借用します。

-----

### `fn partition(arr: &mut [i32]) -> usize`

```rust
fn partition(arr: &mut [i32]) -> usize {
    let len = arr.len();
    let pivot = arr[len - 1];
    let mut i = 0;
    for j in 0..len - 1 {
        if arr[j] <= pivot {
            arr.swap(i, j);
            i += 1;
        }
    }
    arr.swap(i, len - 1);
    i
}
```

この関数は、クイックソートのための配列分割の一般的な方法であるLomuto分割スキームを実装しています。

  * **`let len = arr.len();`**: 現在のスライスの長さを取得します。
  * **`let pivot = arr[len - 1];`**: スライスの**最後の要素**がピボットとして選ばれます。
  * **`let mut i = 0;`**: `i`は、ピボット以下の要素とピボットより大きい要素の間の「境界」へのポインタとして機能します。`i`の左側の要素はピボット以下になります。
  * **`for j in 0..len - 1`**: このループは、ピボット（`len - 1`にある）を*除く*すべての要素を反復処理します。
  * **`if arr[j] <= pivot { ... }`**: 現在の要素`arr[j]`がピボット以下ならば:
      * **`arr.swap(i, j);`**: `arr[j]`と`arr[i]`を交換します。これにより、より小さい要素が「以下」のセクションに移動します。
      * **`i += 1;`**: 「以下」のセクションを拡張するために`i`をインクリメントします。
  * **`arr.swap(i, len - 1);`**: ループの後、`i`はピボットの正しい位置です。ピボット（まだ`len - 1`にある）をその最終的なソートされた位置に交換します。これで、`i`の左側のすべての要素は`arr[i]`（ピボット）以下であり、右側のすべての要素は大きくなります。
  * **`i`**: 関数は`i`を返します。これはピボット要素の最終的なインデックスです。

-----

### `fn main()`

```rust
fn main() {
    let mut arr = [3, 6, 8, 10, 1, 2, 1];
    println!("Before: {:?}", arr);
    quick_sort(&mut arr);
    println!("After: {:?}", arr);
}
```

  * **`let mut arr = [3, 6, 8, 10, 1, 2, 1];`**:
      * `let mut`は**可変変数**を宣言します。これにより、変数の再代入やその内容の変更（可変型の場合）が可能になります。
      * `[3, ...]`はスタック上に**固定サイズの配列**を作成します。そのサイズはコンパイル時に既知です。
  * **`println!("Before: {:?}", arr);`**: 出力に`println!`マクロを使用します。
      * `{:?}`は**デバッグプリント**のフォーマット指定子です。`Debug`トレイトを使用して配列の人間が読める表現を出力します。
  * **`quick_sort(&mut arr);`**: `quick_sort`関数を呼び出し、`arr`配列への可変参照を渡します。
  * **`println!("After: {:?}", arr);`**: ソート後の配列を再度出力します。

-----

### あなたのためのRust特有の要点

  * **所有権と借用**: このコードはRustの核心概念の代表例です。データをコピーするのではなく、**参照(`&`と`&mut`)** を渡し回しています。`&mut`参照は配列をその場で変更するために重要であり、**ボローチェッカー**（例えば、`split_at_mut`によって強制される）は、同じデータへの複数の可変参照が決して存在しないことを保証し、コンパイル時に並行性バグの全クラスを排除します。これはJavaやPythonのような言語からの最も大きなパラダイムシフトですが、ガベージコレクタなしでメモリ安全性を提供します。
  * **スライス `[T]`**: これらは連続したデータを扱うために非常に強力です。これらは、新しいメモリを割り当てることなく、配列やベクターの一部への安全で効率的なビューを提供します。
  * **マクロ (`println!`)**: 多くの標準ライブラリ関数（`println!`, `vec!`, `format!`など）の後に`!`が付いているのを見るでしょう。これらは通常の関数ではなく、**マクロ**であることを示します。マクロはコンパイル時にコードを展開し、通常の関数と比較して（可変長引数やコンパイル時コード生成のような）より多くの柔軟性と力を提供します。

あなたのバックグラウンドを考えると、Rustが提供するパフォーマンス特性と安全性の保証は、「ボローチェッカーとの駆け引き」に少し慣れが必要であっても、きっと評価していただけるでしょう。これはメモリ管理についての異なる考え方ですが、非常に堅牢で効率的なコードにつながるものです。