---
audio: false
generated: true
lang: ja
layout: post
title: Codeforces 2108F
translated: true
type: note
---

提供されたJavaコードが「倒れた塔」問題を解決する理由について詳しく見ていきましょう。この問題は、高さ \\( a_i \geq 0 \\) の \\( n \\) 個の塔からなる配列を扱います。位置 \\( i \\) の塔を倒すと、次の \\( a_i \\) 個の塔の高さが1増加し（残りの塔が足りない場合はそれ以下）、その後 \\( a_i \\) が0に設定されます。目標は、任意の順序で \\( n \\) 個すべての塔をちょうど1回ずつ倒し、最終的な配列が非減少（つまり、任意の \\( i < j \\) について、位置 \\( i \\) の高さが位置 \\( j \\) の高さ以下）になるようにすることです。出力は最終配列の最大MEXで、MEXは配列に存在しない最小の非負整数です。

---

### 問題分析

1. **操作の定義**:
   - 高さ \\( a_i \\) の塔 \\( i \\) を倒すと:
     - 位置 \\( i+1, i+2, \dots, i+a_i \\) の塔の高さが1増加します（存在する場合）。
     - \\( a_i = 0 \\) に設定されます。
   - 各塔は任意の順序でちょうど1回ずつ倒されなければなりません。
   - \\( a_i = 0 \\) の場合、塔 \\( i \\) を倒しても他の塔には影響しません。

2. **非減少の最終配列**:
   - すべての操作後、最終配列 \\( b_1, b_2, \dots, b_n \\) はすべての \\( i < n \\) について \\( b_i \leq b_{i+1} \\) を満たさなければなりません。

3. **MEX**:
   - 最終配列のMEXは、\\( \{b_1, b_2, \dots, b_n\} \\) に存在しない最小の非負整数 \\( m \\) です。
   - 配列が非減少であるため、配列が値 \\( 0, 1, 2, \dots, k-1 \\) を含み（重複可能性あり）、\\( k \\) を含まない場合、MEXは \\( k \\) です。
   - 目標はこのMEXを最大化することです。

4. **MEXの解釈**:
   - MEXが \\( m \\) であるためには、最終配列が0から \\( m-1 \\) までのすべての整数を少なくとも1回含み、\\( m \\) が出現してはいけません。
   - 配列が非減少であるため、MEXが \\( m \\) であることは、最終配列が \\( 0, 0, \dots, 1, 1, \dots, m-1, m-1 \\) のような値を持ち、0から \\( m-1 \\) までの各整数が少なくとも1回出現し、値 \\( m \\) 以上が存在しないことを意味します。

5. **重要な洞察**:
   - MEX \\( m \\) は、0から \\( m-1 \\) までの各値に対して少なくとも1つの位置が存在することに対応します。
   - 言い換えると、MEXが \\( m \\) であるためには、最終配列内に少なくとも \\( m \\) 個の位置が必要であり、位置 \\( i \\) が値 \\( i - (n - m) \\) 以上を持つ必要があります。なぜなら:
     - 最後の \\( m \\) 個の位置（インデックス \\( n-m+1 \\) から \\( n \\) まで）が値0から \\( m-1 \\) をカバーしなければなりません。
     - 位置 \\( n-m+1 \\) は少なくとも値0、位置 \\( n-m+2 \\) は少なくとも値1、...、位置 \\( n \\) は少なくとも値 \\( m-1 \\) を持つ必要があります。
   - これは、位置 \\( i \\) の最終的な高さが少なくとも \\( \max(0, m - (n - i + 1)) = \max(0, m - n + i) \\) である必要があることを意味します。

---

### 解法アプローチ

このコードは、二分探索を使用して可能な最大のMEX \\( m \\) を見つけます。各候補 \\( m \\) について、最終的な非減少配列を達成できるかどうかをチェックします。この配列では、各位置 \\( i \\) の高さが少なくとも \\( \max(0, m - n + i) \\) である必要があります。これにより、最後の \\( m \\) 個の位置が値0から \\( m-1 \\) をカバーでき、MEXが少なくとも \\( m \\) であることが保証されます。

#### 二分探索
- **範囲**: MEX \\( m \\) は少なくとも0（空配列の場合）で、最大 \\( n \\) です（値0から \\( m-1 \\) を持つために少なくとも \\( m \\) 個の位置が必要なため）。したがって、\\( m \\) を \\( [0, n] \\) の範囲で探索します。
- **チェック関数**: 与えられた \\( m \\) について、塔を倒す順序が存在し、最終配列が以下を満たすかどうかを判定します:
  - すべての \\( i \\) について \\( b_i \geq \max(0, m - n + i) \\)。
  - 配列が非減少である。

#### チェック関数
チェック関数は、差分配列アプローチを使用して、塔を任意の順序で倒すことができると仮定して、必要な高さを達成できるかどうかをシミュレートします。

1. **必要な高さ**:
   - MEX \\( m \\) の場合、位置 \\( i \\) は最終高さ \\( b_i \geq \text{need}_i \\) が必要で、ここで:
     \\[
     \text{need}_i = \max(0, m - n + i)
     \\]
   - これにより、位置 \\( n-m+1 \\) から \\( n \\) までの高さがそれぞれ少なくとも0, 1, ..., \\( m-1 \\) であることが保証されます。

2. **差分配列**:
   - コードは差分配列 \\( d \\) を使用して操作の累積効果を追跡します。
   - すべての \\( i \\) について \\( d[i] = 0 \\) で初期化します。
   - 各位置 \\( i \\) について:
     - 累積和を計算: \\( d[i] += d[i-1] \\)（\\( i > 0 \\) の場合）、これは位置 \\( i \\) での現在の追加ブロック数を表します。
     - \\( d[i] \geq \text{need}_i \\) かどうかをチェックします。そうでない場合、必要な高さを達成できないため、\\( false \\) を返します。
     - 塔 \\( i \\) を倒すことによって影響を受ける範囲の長さを計算:
       \\[
       \text{len} = d[i] - \text{need}_i + a_i
       \\]
       - \\( d[i] - \text{need}_i \\): 最小要件を満たした後に利用可能な余分なブロック。
       - \\( a_i \\): 塔 \\( i \\) の高さによって寄与されるブロック数。
       - この \\( \text{len} \\) は、塔 \\( i \\) が倒されたときに位置 \\( i \\) の右側の何個の位置を増加させることができるかを表します。
     - 差分配列を更新:
       - \\( d[i+1] \\) を増分（\\( i+1 < n \\) の場合）して、塔 \\( i \\) を倒す効果を開始します。
       - \\( d[i + \text{len} + 1] \\) を減分（\\( i + \text{len} + 1 < n \\) の場合）して、\\( \text{len} \\) 位置後の効果を終了します。

3. **実現可能性**:
   - 差分配列は、現在の状態に基づいて修正された高さで塔 \\( i \\) を倒す効果をシミュレートします。
   - ループが \\( false \\) を返さずに完了した場合、MEX \\( m \\) に必要な高さを達成することが可能です。

4. **これが機能する理由**:
   - チェック関数は実際の操作順序をシミュレートするのではなく、高さの要件を満たす順序が存在するかどうかを検証します。
   - 差分配列アプローチは、各位置に追加されるブロック数が何らかの有効な操作シーケンスと一致することを保証します。
   - 必要な高さ \\( \text{need}_i = \max(0, m - n + i) \\) が非減少である（\\( i \\) が増加すると \\( m - n + i \\) が増加するか0のままである）ため、非減少条件は暗黙的に満たされます。

#### メインループ
- テストケース数 \\( t \\) を読み取ります。
- 各テストケースについて:
  - \\( n \\) と配列 \\( a \\) を読み取ります。
  - \\( m \\) について0から \\( n \\) までの二分探索を実行します。
  - チェック関数を使用してMEX \\( m \\) が達成可能かどうかを判定します。
  - \\( lo \\)（達成可能な場合）または \\( hi \\)（達成不可能な場合）を更新します。
- 各テストケースについて最大の \\( m \\)（つまり \\( lo \\)）を出力します。

---

### コードが問題を解決する理由

1. **二分探索の正しさ**:
   - 二分探索は、チェック関数が \\( true \\) を返すような最大の \\( m \\) を見つけます。
   - MEX \\( m \\) の実現可能性は、より小さいMEX値（より低い \\( m \\) はより低い高さでより少ない位置を必要とする）の実現可能性を意味するため、二分探索は正しく可能な最大MEXを特定します。

2. **チェック関数の精度**:
   - チェック関数は、すべての操作後に各位置 \\( i \\) が少なくとも \\( \max(0, m - n + i) \\) ブロックを持つことができることを保証します。
   - 差分配列は、各塔が次の \\( a_i \\) 個の位置に \\( a_i \\) ブロックを寄与するという事実を考慮して、塔を倒す累積効果をシミュレートします。
   - 位置を左から右に処理し、差分配列を調整することで、初期高さ \\( a_i \\) を再配分して必要な高さを満たすことができるかどうかを検証します。

3. **非減少制約の扱い**:
   - 必要な高さ \\( \max(0, m - n + i) \\) は非減少であり、これは問題の非減少最終配列の要件と一致します。
   - チェック関数が成功した場合、各位置が必要な高さを満たすか超えることを保証することで、結果の配列を非減少にすることができます。

4. **効率性**:
   - **二分探索**: \\( O(\log n) \\) 反復（\\( m \leq n \\) のため）。
   - **チェック関数**: 呼び出しごとに \\( O(n) \\)、各位置を1回処理し、位置ごとに定数時間で差分配列を更新するため。
   - **テストケースごとの合計**: \\( O(n \log n) \\)。
   - **すべてのテストケースの合計**: \\( \sum n \leq 10^5 \\) であるため、全体の計算量は \\( O(t \cdot n \log n) \\) であり、3秒の制限時間内に収まります。

5. **エッジケース**:
   - **\\( n = 1 \\)**: \\( a_1 = 0 \\) の場合、MEX = 1（配列は[0]になる）。\\( a_1 > 0 \\) の場合、MEX = 0（配列は[0]になる）。コードはこれを正しく処理します。
   - **大きな \\( a_i \\)**: \\( a_i \leq 10^9 \\) ですが、影響を受けるのは最初の \\( n-i \\) 個の位置のみであるため、コードは配列制限を使用して効果を正しく制限します。
   - **すべての \\( a_i = 0 \\)**: 最終配列はすべて0、MEX = 1。チェック関数はこれを確認します。
   - **混合値**: 二分探索とチェック関数は任意の \\( a_i \geq 0 \\) を処理します。

---

### Javaコードの詳細

Javaコードは、要求に応じて効率的なI/Oのために `BufferedReader` と `PrintWriter` を使用してC++のロジックを適応させます。主な側面:

1. **入力処理**:
   - `BufferedReader` を使用して行を読み取り、`StringTokenizer` を使用して整数を解析します。
   - \\( t \\) を読み取り、各テストケースについて \\( n \\) と配列 \\( a \\) を読み取ります。

2. **チェッカークラス**:
   - C++のラムダ関数を模倣するためにチェックロジックをカプセル化します。
   - 差分配列アプローチをシミュレートするために配列 \\( d \\) を使用します。

3. **出力**:
   - `PrintWriter` を使用して各テストケースの結果を出力し、`out.flush()` を使用してすべての出力が書き込まれることを保証します。

4. **パフォーマンス**:
   - Javaコードはテストケースごとに同じ \\( O(n \log n) \\) の計算量を維持します。
   - `BufferedReader` と `PrintWriter` は、\\( \sum n \leq 10^5 \\) に対して十分な速さでI/Oを保証します。

---

### 結論

このコードは以下の方法で「倒れた塔」問題を解決します:
- 二分探索を使用して最大MEX \\( m \\) を見つける。
- 差分配列ベースのチェック関数を使用して、初期の塔の高さを再配分して必要な高さを持つ非減少配列を達成できるかどうかを検証する。
- 必要な高さの非減少性と操作シーケンスの実現可能性を通じて正しさを保証する。
- すべてのエッジケースを処理し、時間とメモリの制約内に収める。

Java実装はC++のロジックを忠実に変換し、効率的なI/Oを使用して問題の要件を満たしています。