---
audio: false
generated: true
lang: ja
layout: post
title: Javaのガベージコレクション
translated: true
type: note
---

Javaのガベージコレクション（GC）について学びましょう！これはJavaのメモリ管理における重要な側面であり、開発者が手動でのメモリ割り当てと解放を回避するのに役立ちます。

**Javaにおけるガベージコレクションとは？**

ガベージコレクションは、Javaアプリケーションによって使用されなくなったオブジェクトが占有しているメモリを自動的に回収するプロセスです。本質的に、Javaが「ガベージ」（未使用のオブジェクト）をクリーンアップして新しいオブジェクトのためのスペースを確保する方法です。

**なぜガベージコレクションが必要なのか？**

他の多くのプログラミング言語（CやC++など）では、開発者は `malloc` や `free` のような関数を使用して明示的にメモリを割り当て、解放する責任があります。この手動メモリ管理は、いくつかの問題を引き起こす可能性があります：

*   **メモリリーク:** メモリが割り当てられたまま解放されない場合、アプリケーションは最終的にメモリ不足になりクラッシュする可能性があります。
*   **ダングリングポインタ:** メモリが解放された後もポインタがそのメモリ位置を参照している場合、そのポインタを使用すると予測不能な動作やクラッシュを引き起こす可能性があります。
*   **開発の複雑さの増加:** メモリを手動で管理することは、ソフトウェア開発に大きな複雑さの層を追加します。

Javaのガベージコレクションはこのプロセスを自動化し、開発者を手動メモリ管理の負担から解放し、より安全で信頼性の高いコードを簡単に書けるようにします。

**ガベージコレクションはどのように機能するのか？**

ガベージコレクションの中核となる考え方は、メモリ内のどのオブジェクトがまだアプリケーションによって使用されているか、そしてどれが使用されていないかを識別することです。ガベージコレクタはその後、未使用のオブジェクトが占有しているメモリを回収します。

このプロセスの簡略化された概要を以下に示します：

1.  **ライブオブジェクトの識別（マーキング）:** ガベージコレクタは、「ルート」オブジェクトから到達可能なオブジェクトのセットを識別することから始めます。ルートオブジェクトは通常、アプリケーションによって直接アクセス可能なオブジェクトです。例えば：
    *   現在実行中のメソッドのローカル変数。
    *   静的変数。
    *   ネイティブコードによって参照されるオブジェクト。
    *   Java仮想マシン（JVM）のアクティブなスレッド。

    ガベージコレクタはこれらのルートからオブジェクトグラフを走査し、到達可能なすべてのオブジェクトにマークを付けます。

2.  **メモリの回収（スイープとコンパクション）:** ライブオブジェクトにマークが付けられると、ガベージコレクタはマークされていない（到達不能な）オブジェクトが占有しているメモリを回収する必要があります。異なるガベージコレクションアルゴリズムは、これに対して異なる戦略を採用しています：

    *   **マークアンドスイープ:** このアルゴリズムはライブオブジェクトを識別してマークし、その後メモリをスイープして、マークされていないオブジェクトが占有していたスペースを解放します。これはメモリの断片化（新しいオブジェクトを割り当てるのに十分な大きさではない、小さく散在した空きメモリブロック）を引き起こす可能性があります。
    *   **マークアンドコンパクト:** このアルゴリズムもライブオブジェクトにマークを付けます。マークした後、ライブオブジェクトをメモリ内で一緒に移動（コンパクト）し、断片化を解消し、新しいオブジェクトに対して連続したメモリブロックを割り当てることを容易にします。
    *   **コピーリング:** このアルゴリズムはメモリを2つ以上の領域に分割します。ライブオブジェクトは一方の領域から他方の領域にコピーされ、元の領域のスペースを効果的に回収します。

**Javaガベージコレクションの主要な概念：**

*   **ヒープ:** Javaでオブジェクトが割り当てられるメモリ領域。ガベージコレクタは主にヒープ上で動作します。
*   **ヤングジェネレーション（保育園）:** これは、新しく作成されたオブジェクトが最初に割り当てられるヒープの一部です。さらに以下に分割されます：
    *   **エデン空間:** ほとんどの新しいオブジェクトが作成される場所。
    *   **サーバイバ空間（S0 と S1）:** 数回のマイナーガベージコレクションサイクルを生き延びたオブジェクトを保持するために使用されます。
*   **オールドジェネレーション（永世代）:** ヤングジェネレーションで複数回のガベージコレクションサイクルを生き延びたオブジェクトは、最終的にオールドジェネレーションに移動されます。オールドジェネレーション内のオブジェクトは一般的に長寿命です。
*   **パーマネントジェネレーション（PermGen）/ Metaspace:** 古いバージョンのJava（Java 8以前）では、パーマネントジェネレーションはクラスとメソッドに関するメタデータを格納していました。Java 8以降では、これはMetaspaceに置き換えられており、これはネイティブメモリの一部です（Javaヒープではありません）。
*   **ガベージコレクションアルゴリズム:** ガベージコレクションには、パフォーマンスと効率性の面でそれぞれ独自のトレードオフを持つ異なるアルゴリズムが使用されます。

**世代別ガベージコレクション：**

Java HotSpot JVM（最も一般的なJVM）は、ガベージコレクションに世代別アプローチを使用しています。これは、アプリケーション内のほとんどのオブジェクトの寿命が短いという観察に基づいています。

1.  **マイナーGC（ヤングジェネレーションGC）:** エデン空間がいっぱいになると、マイナーGCがトリガーされます。エデンと一方のサーバイバ空間（例えばS0）からのライブオブジェクトは、もう一方のサーバイバ空間（S1）にコピーされます。一定回数のマイナーGCサイクルを生き延びたオブジェクトは、オールドジェネレーションに移動されます。到達不能なオブジェクトは破棄されます。

2.  **メジャーGC（オールドジェネレーションGC）/ フルGC:** オールドジェネレーションがいっぱいになると、メジャーGC（または時にはヤングとオールドの両方の世代を含むフルGC）が実行されます。このプロセスは一般的にマイナーGCよりも時間がかかり、アプリケーションの実行においてより長い一時停止を引き起こす可能性があります。

**Java HotSpot JVMにおける一般的なガベージコレクタ：**

Java HotSpot JVMは、アプリケーションの要件（例：低レイテンシ、高スループット）に基づいて選択できるいくつかのガベージコレクションアルゴリズムを提供しています。一般的なものには以下があります：

*   **シリアルコレクタ:** ガベージコレクションに単一スレッドを使用します。リソースが限られた小さなアプリケーションに適しています。
*   **パラレルコレクタ:** ガベージコレクションに複数のスレッドを使用し、スループットを向上させます。マルチコアプロセッサ上で実行される中規模から大規模なデータセットを持つアプリケーションに適しています。
*   **CMS（コンカレントマークスイープ）コレクタ:** ガベージコレクション作業の大部分をアプリケーションスレッドと並行して実行することで、一時停止時間を最小化しようと試みます。ただし、断片化を引き起こす可能性があり、最終的にはフルGCが必要になる場合があります。
*   **G1（ガベージファースト）コレクタ:** スループットと低レイテンシの良いバランスを提供することを目指しています。ヒープをリージョンに分割し、最もガベージが多いリージョンからのガベージ収集を優先します。Java 9以降のデフォルトのコレクタです。
*   **ZGC（Zガベージコレクタ）:** 大規模なヒープ向けに設計された低レイテンシのガベージコレクタです。10ms未満の一時停止時間を目標としています。
*   **Shenandoah:** ZGCと同様の目標を持つ、もう一つの低レイテンシガベージコレクタです。

使用するガベージコレクタは、JVMのコマンドラインオプションを介して指定できます。

**ガベージコレクションはいつ実行されるのか？**

ガベージコレクションは、ほとんどがJVMによって駆動される自動プロセスです。通常、以下の場合に実行されます：

*   ヤングジェネレーション（エデン空間）がいっぱいになったとき。
*   オールドジェネレーションがいっぱいになったとき。
*   システムのメモリが少なくなったとき。

ガベージコレクションが*いつ*実行されるかを直接制御することはできませんが、`System.gc()`を使用してガベージコレクションを実行するのに良いタイミングかもしれないとJVMに提案することはできます。ただし、このメソッドを呼び出したときにJVMが実際に直ちに、または全くガベージコレクタを実行するという保証はありません。一般的には、JVMの自動ガベージコレクションメカニズムに頼る方が良いです。

**`System.gc()` とファイナライゼーション：**

*   **`System.gc()`:** 前述のように、これはJVMに対してガベージコレクタを実行するようリクエストするものです。JVMは通常、いつGCを実行するかを決定する方が優れているため、重要なメモリ管理のためにこのメソッドに依存しないことが推奨されます。
*   **`finalize()` メソッド:** オブジェクトがガベージコレクションされる前に、JVMはその `finalize()` メソッド（実装されている場合）を呼び出すことで、クリーンアップ操作を実行する機会をオブジェクトに与えます。ただし、`finalize()` にはいくつかの欠点があり、現代のJava開発では一般的に推奨されません。これはパフォーマンスの問題を引き起こし、ガベージコレクションを予測不能にする可能性があります。リソース管理には、try-with-resourcesのような他のメカニズムの使用を検討してください。

**ガベージコレクションがアプリケーションパフォーマンスに与える影響：**

ガベージコレクションはメモリ管理に不可欠ですが、「ストップ・ザ・ワールド」の一時停止によるアプリケーションのパフォーマンスにも影響を与える可能性があります。これらの一時停止中、ガベージコレクタがその作業を実行している間、すべてのアプリケーションスレッドが停止します。これらの一時停止の持続時間と頻度は、使用されているガベージコレクションアルゴリズム、およびヒープのサイズと特性に依存します。

G1、ZGC、Shenandoahのような低レイテンシガベージコレクタは、これらの一時停止時間を最小化してアプリケーションの応答性を高めることを目指しています。

**ガベージコレクションのチューニング：**

特定のパフォーマンス要件を持つアプリケーションの場合、ガベージコレクションは以下のようなJVMパラメータを調整することでチューニングできます：

*   ヒープサイズ（`-Xms`, `-Xmx`）
*   ヤングジェネレーションサイズ（`-Xmn`）
*   サーバイバ比率（`-XX:SurvivorRatio`）
*   特定のガベージコレクタの選択（`-XX:+UseG1GC`, `-XX:+UseZGC` など）
*   よりきめ細かな制御のためのガベージコレクションフラグの設定。

GCチューニングは高度なトピックであり、通常、アプリケーションの動作とパフォーマンスの注意深い分析が必要です。

**ガベージコレクタに優しいコードを書くためのベストプラクティス：**

Javaはメモリ管理を自動的に処理しますが、ガベージコレクタを意識してコードを書くことは、より良いパフォーマンスにつながる可能性があります：

*   **オブジェクト作成の最小化:** 多数の短命オブジェクトを作成することは、ガベージコレクタに負荷をかける可能性があります。適切な場合はオブジェクトを再利用するようにしてください。
*   **オブジェクト参照の解放:** もはや必要としないオブジェクトへの参照がある場合は、その参照を `null` に設定してください。これにより、そのオブジェクトはより早くガベージコレクションの対象になります。
*   **データ構造の賢明な使用:** あなたのニーズに適したデータ構造を選択してください。例えば、大きな `ArrayList` を使用してその要素の大部分を破棄することは非効率的である可能性があります。
*   **ファイナライザの回避:** 前述のように、リソースのクリーンアップに `finalize()` メソッドに依存するのは避けてください。ファイルやネットワーク接続などのリソースにはtry-with-resourcesを使用してください。
*   **静的変数に注意:** 静的変数によって参照されるオブジェクトはアプリケーションの全期間にわたって存続するため、静的フィールドに大きなまたは不必要なオブジェクトを格納することに注意してください。

**まとめ：**

Javaにおけるガベージコレクションは、未使用のオブジェクトが占有するメモリを回収する自動メモリ管理プロセスです。これは、開発者を手動メモリ管理から解放することで開発を簡素化します。その仕組み、ヒープの異なる世代、および利用可能なガベージコレクションアルゴリズムを理解することは、より効率的でパフォーマンスの高いJavaアプリケーションを書くのに役立ちます。