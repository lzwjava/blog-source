---
audio: false
generated: true
lang: ja
layout: post
title: アセンブリ言語プログラミング
translated: true
type: note
---

以下は、**パート2: アセンブリ言語プログラミング**に関する包括的なチュートリアルです。このチュートリアルでは、*8086 命令セット（データ転送、算術演算、論理演算、制御フロー命令）、アセンブリ言語プログラミング（逐次、分岐、ループ構造）、および割り込みサービスルーチン*について概説されているトピックを網羅しています。このチュートリアルは、マイクロコンピュータ（例: 8086/8088 アーキテクチャ）の基礎知識を基に、詳細で、分かりやすく、実践的な内容となるよう設計されています。CPU レジスタとメモリアドレッシングの基本的な知識を前提としています。

---

## パート 2: アセンブリ言語プログラミング

アセンブリ言語は、マイクロプロセッサの操作を直接制御する低水準プログラミング言語です。Intel 8086/8088 の場合、アセンブリ言語を使用すると、機械語に密接にマッピングされる命令を記述でき、レジスタ、メモリ、I/O デバイスなどのハードウェアリソースをきめ細かく制御できます。

### 1. 8086 命令セット

8086 命令セットは、CPU が理解するコマンドの集合であり、その機能によって**データ転送**、**算術演算**、**論理演算**、**制御フロー**に分類されます。各命令は、8086 のアドレッシングモード（例: レジスタ、直接、間接）を使用して、レジスタ、メモリ、または即値に対して操作を実行します。

#### a. データ転送命令
これらの命令は、レジスタ、メモリ、および即値間でデータを移動します。

- **MOV (Move)**:
  - 構文: `MOV destination, source`
  - 機能: ソースからデスティネーションへデータをコピーします。
  - 例: `MOV AX, BX` (BX を AX にコピー); `MOV AX, [1234h]` (メモリアドレス DS:1234h からのデータを AX にコピー)。
  - 注記: フラグに影響を与えない。ソースとデスティネーションのサイズは同じ（8 ビットまたは 16 ビット）でなければならない。
- **XCHG (Exchange)**:
  - 構文: `XCHG destination, source`
  - 機能: ソースとデスティネーションの内容を交換します。
  - 例: `XCHG AX, BX` (AX と BX を交換)。
- **PUSH (Push onto Stack)**:
  - 構文: `PUSH source`
  - 機能: 16 ビットデータをスタックにプッシュし、SP を 2 減らします。
  - 例: `PUSH AX` (AX をスタックに保存)。
- **POP (Pop from Stack)**:
  - 構文: `POP destination`
  - 機能: スタックから 16 ビットデータをデスティネーションにポップし、SP を 2 増やします。
  - 例: `POP BX` (スタックから BX を復元)。
- **LEA (Load Effective Address)**:
  - 構文: `LEA destination, source`
  - 機能: メモリオペランドのアドレスをレジスタにロードします。
  - 例: `LEA BX, [SI+4]` (DS:SI+4 のアドレスを BX にロード)。
- **IN/OUT**:
  - 構文: `IN destination, port`; `OUT port, source`
  - 機能: I/O ポートとの間でデータを転送します。
  - 例: `IN AL, 60h` (キーボードポートから読み込み); `OUT 61h, AL` (スピーカーポートへ書き込み)。

#### b. 算術演算命令
これらは数学演算を実行し、結果に基づいてフラグ（ZF, CF, SF, OF など）を更新します。

- **ADD (Add)**:
  - 構文: `ADD destination, source`
  - 機能: ソースをデスティネーションに加算し、結果をデスティネーションに格納します。
  - 例: `ADD AX, BX` (AX = AX + BX)。
- **SUB (Subtract)**:
  - 構文: `SUB destination, source`
  - 機能: デスティネーションからソースを減算します。
  - 例: `SUB CX, 10` (CX = CX - 10)。
- **INC (Increment)**:
  - 構文: `INC destination`
  - 機能: デスティネーションを 1 増やします。
  - 例: `INC BX` (BX = BX + 1)。
- **DEC (Decrement)**:
  - 構文: `DEC destination`
  - 機能: デスティネーションを 1 減らします。
  - 例: `DEC CX` (CX = CX - 1)。
- **MUL (Multiply, Unsigned)**:
  - 構文: `MUL source`
  - 機能: AL (8 ビット) または AX (16 ビット) をソースで乗算し、結果を AX または DX:AX に格納します。
  - 例: `MUL BX` (DX:AX = AX * BX)。
- **DIV (Divide, Unsigned)**:
  - 構文: `DIV source`
  - 機能: AX (8 ビット) または DX:AX (16 ビット) をソースで除算し、商を AL/AX に、余りを AH/DX に格納します。
  - 例: `DIV BX` (AX = DX:AX / BX, DX = 余り)。
- **ADC (Add with Carry)** および **SBB (Subtract with Borrow)**:
  - 機能: キャリーフラグを使用して複数ワードの算術演算を処理します。
  - 例: `ADC AX, BX` (AX = AX + BX + CF)。

#### c. 論理演算命令
これらはビット単位の演算を実行し、バイナリデータを操作します。

- **AND (Bitwise AND)**:
  - 構文: `AND destination, source`
  - 機能: ビット単位の AND を実行し、結果をデスティネーションに格納します。
  - 例: `AND AX, 0FFh` (AX の上位バイトをクリア)。
- **OR (Bitwise OR)**:
  - 構文: `OR destination, source`
  - 機能: ビット単位の OR を実行します。
  - 例: `OR BX, 1000h` (BX のビット 12 をセット)。
- **XOR (Bitwise XOR)**:
  - 構文: `XOR destination, source`
  - 機能: ビット単位の XOR を実行します。
  - 例: `XOR AX, AX` (AX を 0 にクリア)。
- **NOT (Bitwise NOT)**:
  - 構文: `NOT destination`
  - 機能: デスティネーションの全ビットを反転します。
  - 例: `NOT BX` (BX = ~BX)。
- **SHL/SHR (Shift Left/Right)**:
  - 構文: `SHL destination, count`; `SHR destination, count`
  - 機能: ビットを左/右にシフトし、0 (SHR) または符号ビット (SAL/SAR) で埋めます。
  - 例: `SHL AX, 1` (AX = AX * 2)。
- **ROL/ROR (Rotate Left/Right)**:
  - 機能: ビットを回転させ、キャリーフラグを介してラップアラウンドします。
  - 例: `ROL BX, 1` (BX を 1 ビット左回転)。

#### d. 制御フロー命令
これらはプログラムの実行シーケンスを変更し、ジャンプ、ループ、サブルーチンを可能にします。

- **JMP (Jump)**:
  - 構文: `JMP label`
  - 機能: 無条件にラベルにジャンプします。
  - 例: `JMP start` (ラベル `start` へ移動)。
  - バリアント:
    - ショートジャンプ (±127 バイト)。
    - ニアジャンプ (セグメント内)。
    - ファージャンプ (異なるセグメント)。
- **条件付きジャンプ**:
  - 構文: `Jcc label` (例: JZ, JNZ, JC, JNC)
  - 機能: フラグの状態に基づいてジャンプします。
  - 例:
    - `JZ loop_end` (ゼロフラグがセットされていればジャンプ)。
    - `JC error` (キャリーフラグがセットされていればジャンプ)。
    - 一般的な条件: JZ (ゼロ), JNZ (非ゼロ), JS (符号), JO (オーバーフロー)。
- **LOOP (Loop)**:
  - 構文: `LOOP label`
  - 機能: CX をデクリメントし、CX ≠ 0 ならラベルにジャンプします。
  - 例: `LOOP process` (CX = 0 になるまで繰り返す)。
  - バリアント:
    - `LOOPE/LOOPZ`: CX ≠ 0 かつ ZF = 1 の場合にループ。
    - `LOOPNE/LOOPNZ`: CX ≠ 0 かつ ZF = 0 の場合にループ。
- **CALL (Call Subroutine)**:
  - 構文: `CALL label`
  - 機能: リターンアドレスをスタックにプッシュし、サブルーチンにジャンプします。
  - 例: `CALL compute_sum` (サブルーチンを呼び出し)。
- **RET (Return)**:
  - 構文: `RET`
  - 機能: スタックからリターンアドレスをポップし、実行を再開します。
  - 例: `RET` (サブルーチンから戻る)。
- **INT (Interrupt)**:
  - 構文: `INT number`
  - 機能: ソフトウェア割り込みをトリガーし、割り込みサービスルーチン (ISR) を呼び出します。
  - 例: `INT 21h` (DOS システムコール)。
- **IRET (Interrupt Return)**:
  - 機能: ISR から戻り、フラグとリターンアドレスを復元します。

---

### 2. アセンブリ言語プログラミング

アセンブリ言語プログラムは、人間が読める形式の命令として記述され、機械語にアセンブルされます。8086 は**セグメント化メモリモデル**を使用し、コードセグメント、データセグメント、スタックセグメントが明示的に定義されます。

#### a. プログラム構造
典型的な 8086 アセンブリプログラムは以下を含みます:
- **ディレクティブ**: アセンブラへの指示 (例: NASM, MASM)。
  - `SEGMENT`: コード、データ、またはスタックセグメントを定義。
  - `ORG`: 開始アドレスを設定。
  - `DB/DW`: バイト/ワードデータを定義。
- **命令**: CPU 操作 (例: MOV, ADD)。
- **ラベル**: ジャンプまたはデータのための場所をマーク。
- **コメント**: コードを説明 (例: `; comment`)。

**プログラム構造の例 (MASM 構文)**:
```asm
.model small
.stack 100h
.data
    message db 'Hello, World!$'
.code
main proc
    mov ax, @data    ; DS を初期化
    mov ds, ax
    mov dx, offset message ; メッセージアドレスをロード
    mov ah, 09h      ; DOS 文字列出力関数
    int 21h          ; DOS 割り込みを呼び出し
    mov ah, 4Ch      ; プログラム終了
    int 21h
main endp
end main
```

#### b. 逐次構造
逐次コードは、ジャンプやループなしで順番に命令を実行します。

**例: 2 つの数値を加算**
```asm
mov ax, 5        ; AX = 5
mov bx, 10       ; BX = 10
add ax, bx       ; AX = AX + BX (15)
mov [result], ax ; 結果をメモリに格納
```
- 命令は次々に実行されます。
- 単純な計算やデータ初期化によく使用されます。

#### c. 分岐構造
分岐は、条件付き/無条件ジャンプを使用して、条件に基づいてプログラムの流れを変更します。

**例: 比較と分岐**
```asm
mov ax, 10       ; AX = 10
cmp ax, 15       ; AX と 15 を比較
je equal         ; AX == 15 ならジャンプ
mov bx, 1        ; それ以外の場合、BX = 1
jmp done
equal:
    mov bx, 0    ; 等しい場合、BX = 0
done:
    ; プログラムを継続
```
- **CMP**: 減算 (AX - 15) に基づいてフラグを設定。
- **JE**: ZF = 1 (等しい) の場合にジャンプ。
- if-then-else ロジックに有用。

#### d. ループ構造
ループは、条件が満たされるまで命令を繰り返し、多くの場合 `LOOP` または条件付きジャンプを使用します。

**例: 1 から 10 までの数値を合計**
```asm
mov cx, 10       ; ループカウンタ = 10
mov ax, 0        ; 合計 = 0
sum_loop:
    add ax, cx   ; 合計に CX を加算
    loop sum_loop ; CX をデクリメント、CX ≠ 0 ならループ
    ; AX = 55 (1 + 2 + ... + 10)
```
- `LOOP` はカウンタベースの反復を簡素化します。
- 代替案: カスタム条件には `CMP` と `JNZ` を使用。

**条件付きループの例**
```asm
mov ax, 0        ; カウンタ
mov bx, 100      ; リミット
count_up:
    inc ax       ; AX++
    cmp ax, bx   ; 100 と比較
    jle count_up ; AX <= 100 ならジャンプ
```
- カウンタベースでないループに柔軟。

#### e. サブルーチン
サブルーチンは `CALL` と `RET` を使用してコードをモジュール化し、再利用を可能にします。

**例: 数値を二乗**
```asm
main:
    mov ax, 4    ; 入力
    call square  ; サブルーチンを呼び出し
    ; AX = 16
    jmp exit
square:
    push bx      ; BX を保存
    mov bx, ax   ; AX をコピー
    mul bx       ; AX = AX * BX
    pop bx       ; BX を復元
    ret          ; 戻る
exit:
    ; プログラム終了
```
- **PUSH/POP**: 副作用を避けるためにレジスタを保存/復元。
- スタックはリターンアドレスを自動的に管理。

---

### 3. 割り込みサービスルーチン (ISR)

割り込みにより、CPU は現在のプログラムを一時停止し、ISR を実行することで、外部または内部イベント（キーボード入力、タイマー刻みなど）に応答できます。

#### 割り込みメカニズム
- **割り込みベクタテーブル (IVT)**:
  - メモリ 0000:0000h–0000:03FFh に配置。
  - 256 の割り込みタイプ (0–255) に対する ISR のアドレスを格納。
  - 各エントリ: セグメント:オフセット (4 バイト)。
- **タイプ**:
  - **ハードウェア割り込み**: デバイスによってトリガー (例: IRQ)。
  - **ソフトウェア割り込み**: `INT` 命令によってトリガー (例: DOS 用 INT 21h)。
  - **例外**: CPU エラー (例: ゼロ除算)。
- **プロセス**:
  1. 割り込み発生。
  2. CPU はフラグ、CS、IP をスタックに保存。
  3. IVT を介して ISR にジャンプ。
  4. ISR が実行され、状態を復元するために `IRET` で終了。

#### ISR の記述
ISR は以下を行う必要があります:
- レジスタを保存 (PUSH/POP)。
- 割り込みを素早く処理。
- `IRET` で終了。

**例: カスタムタイマー ISR**
```asm
.data
old_vec dw 2 dup(0) ; 古い割り込みベクタを格納
.code
install_isr:
    cli             ; 割り込みを無効化
    mov ax, 0
    mov es, ax      ; ES = 0 (IVT セグメント)
    mov bx, 1Ch*4   ; タイマー割り込み (1Ch)
    mov ax, es:[bx] ; 古いベクタを保存
    mov old_vec, ax
    mov ax, es:[bx+2]
    mov old_vec+2, ax
    mov ax, offset my_isr ; 新しいベクタを設定
    mov es:[bx], ax
    mov ax, cs
    mov es:[bx+2], ax
    sti             ; 割り込みを有効化
    ret
my_isr:
    push ax
    inc word ptr [counter] ; カウンタをインクリメント
    pop ax
    iret            ; 割り込みから戻る
```
- タイマー割り込み (1Ch, ~18.2 Hz) をフック。
- カウンタ変数をインクリメント。
- レジスタを保存し、`IRET` を使用。

**例: DOS 割り込み (INT 21h)**
```asm
mov ah, 09h      ; 文字列出力関数
mov dx, offset msg ; '$' で終端される文字列のアドレス
int 21h          ; DOS を呼び出し
```
- INT 21h は OS サービス (例: I/O, ファイル操作) を提供。
- AH は関数コードを指定。

#### 実践的な注意点
- **状態の保存**: ISR はメインプログラムの破損を避けるために全てのレジスタを保存する必要があります。
- **優先度**: ハードウェア割り込みは他の割り込みを横取りする可能性があります (PIC によって管理)。
- **デバッグ**: DEBUG.COM や最新のエミュレータ (例: DOSBox, Bochs) などのツールを使用。

---

### サンプルプログラム: 階乗計算
このプログラムは、ループとサブルーチンを使用して数値の階乗を計算します (例: 5! = 120)。

```asm
.model small
.stack 100h
.data
    num dw 5        ; 入力数
    result dw ?     ; 結果を格納
.code
main proc
    mov ax, @data
    mov ds, ax      ; DS を初期化
    mov ax, num     ; 数値をロード
    call factorial  ; 階乗を計算
    mov result, ax  ; 結果を格納
    mov ah, 4Ch     ; 終了
    int 21h
main endp
factorial proc
    push bx
    mov bx, ax      ; BX = n
    mov ax, 1       ; AX = 結果
fact_loop:
    cmp bx, 1
    jle done        ; BX <= 1 なら終了
    mul bx          ; AX = AX * BX
    dec bx          ; BX--
    jmp fact_loop
done:
    pop bx
    ret
factorial endp
end main
```
- **ロジック**:
  - 入力: num = 5。
  - ループ: AX = AX * BX, BX-- を BX = 1 まで実行。
  - 結果: AX = 5 * 4 * 3 * 2 * 1 = 120。
- **特徴**:
  - モジュール性のためのサブルーチン。
  - レジスタ保存のためのスタック。
  - 逐次およびループ構造。

---

### ベストプラクティス
1. **コードにコメントを付ける**: アセンブリは分かりにくいので、すべてのステップを説明します。
2. **レジスタ使用を最小化**: 不必要な上書きを避けます。
3. **段階的にテスト**: デバッガを使用して実行をトレースします。
4. **エッジケースを処理**: オーバーフロー、ゼロ、負の入力などをチェックします。
5. **最適化**: 命令を減らします (例: MOV AX, 0 の代わりに XOR AX, AX を使用)。

---

### まとめ
- **8086 命令セット**:
  - **データ転送**: データ移動のための MOV, PUSH, POP。
  - **算術演算**: 計算のための ADD, SUB, MUL。
  - **論理演算**: ビット操作のための AND, OR, XOR。
  - **制御フロー**: プログラムフローのための JMP, LOOP, CALL。
- **プログラミング構造**:
  - **逐次**: 単純なタスクのための直線的な実行。
  - **分岐**: 意思決定のための条件付きジャンプ。
  - **ループ**: 繰り返しのための LOOP または Jcc。
  - **サブルーチン**: モジュールコードのための CALL/RET。
- **割り込み**:
  - ISR は IVT を介してイベントを処理。
  - 状態を保存し、IRET で終了。
  - ハードウェア (例: タイマー) およびソフトウェア (例: DOS) 割り込みに使用。

---

### 練習問題
1. メモリ内の文字列を反転するプログラムを作成してください。
2. 数値が素数かどうかをチェックするサブルーチンを実装してください。
3. キー押下をカウントするためのキーボード割り込み (INT 09h) 用の ISR を作成してください。
4. `JMP` と `CALL` の違いを説明してください。
5. このコードを最適化してください: `MOV AX, 0; MOV BX, AX; ADD BX, 5`。

---

このチュートリアルは、8086 アセンブリプログラミングの基本を、実践的なスキルを構築するための例と説明でカバーしています。特定の命令、高度なテクニック（文字列操作など）、またはエミュレーションツールについてさらに探求したい場合は、お知らせください！