---
audio: false
generated: true
image: false
lang: ja
layout: post
model: x-ai/grok-4-fast
title: 設定ファイルは悪い言語へと進化する
translated: true
type: note
---

### 「論理の不滅の法則」と設定ファイルが駄目なプログラミング言語になる理由

この投稿は、コンピューターサイエンス研究者でブロガーのYining Wang（別名Yin Wang）によるものです。プログラミングの伝説的存在であるGuy Steeleの観察を基にした示唆に富む記事です。その観察とは、**設定ファイルが複雑になるにつれて、必然的に駄目なプログラミング言語へと進化する**というものです。Wangは、この現象がほぼ毎回起こる「理由」を説明するために、彼が考案した「論理の不滅の法則」という概念を用いています。これは物理学のエネルギー保存の法則になぞらえた巧妙な比喩です。つまり、論理は消滅せず、単に場所を移動するだけだというのです。

#### 「論理の不滅の法則」とは何か？
Wangはそれを簡潔に次のように定義しています：**人々が表現する必要のある論理は、本質的に同じ形で、常にどこかに現れる。**

- 本質的に、もし何らかの意思決定やルールベースの思考（例えば、「この条件が真ならば、あれを実行する」）がある場合、それはあなたのシステムの*どこかに*現れ*なければならない*。それを隠そうとしたり、押し付けようとしたからといって、消え去ることはない。
- この論理は、メインプログラムのコード、設定ファイル、スプレッドシート、あるいはホワイトボードの落書きにさえ現れる可能性があるが、その核心的な構造は変わらず存続する。
- これが「不滅」なのは、人間のニーズ（例えば、振る舞いをカスタマイズする）がそれを要求するからである。これを無視すると、不自然な回避策が生まれる。

これは、水が必ず水平を見つけるようなものと考えてください：論理は、あなたがそれをどう封じ込めようとしても、必要とされる場所に流れていくのです。

#### これが、設定ファイルが「駄目な言語」に変わることをどう説明するのか？
設定ファイルは、核心となるコードに触れずに設定を調整する方法として、無害なものから始まります。しかし、ニーズが増大するにつれて、それらはより邪悪な何かへと肥大化していきます。以下が、その法則に関連した段階的な分解です：

1.  **単純な始まり：単なる変数**
    最初、設定ファイルは基本的なキーと値のペアです：
    - `enable_optimization = true`
    - `max_requests = 1000`
    これらは、プログラミングにおける「変数」（例: `let x = 5;`）のようなものです。プログラムはこれらを読み、その値を自身の論理に組み込みます。
    *なぜか？* まだ深い論理はありません—単なるプレースホルダーです。しかし、変数は*あらゆる*プログラミング言語の基本的な構成要素です。法則によれば、この論理（値の代入と使用）はすでに設定ファイルに潜り込んでいます。

2.  **浸透：分岐の追加**
    ユーザーがより柔軟性を要求するにつれて（例: 「プレミアムユーザーの場合のみ機能Xを有効にする」）、開発者は設定ファイルに*条件付き論理*を埋め込み始めます：
    - 例えば、`if user_type == "premium" then enable_feature_X else disable` のようなもの。
    これはまさに「if-then-else」分岐—もう一つの核心的なプログラミングの基本要素です。
    *なぜか？* 開発者は、調整を容易にするために、無意識のうちにメインコードから設定ファイルへと論理を移動させます。しかし、法則が発動します：論理はプログラムから消え去るのではなく、単に移行するだけです。今や設定ファイルは単なるデータではなく、意思決定を行っているのです。

3.  **転換点：完全な論理の過負荷**
    時が経つにつれて、設定ファイルはループ、関数、エラー処理、カスタムルールを蓄積していきます。平坦なファイル（YAML、JSONなど）として始まったものが、最終的にはチューリング完全（あらゆる計算を表現可能）な構文を持つものになってしまいます。
    - 結果：強力だがひどい—優れたツールング、エラーメッセージ、デバッグ、またはライブラリを欠いた—「言語」が生まれます。それは、コードの出来の悪い方言でプログラミングしているようなものです。
    *なぜ避けられないのか？* 論理の不滅です。もし論理が存在するなら（そしてそれは現実の問題を解決するために必須です）、それは*どこかに*具現化されます。それをメインコードから追い出すことは、設定ファイルの中にそれを押し込み、そこで腐敗させることになります。

Steeleの警句は核心を突いています：設定ファイルは言語に*なりたい*わけではないが、複雑さがそれを強いるのです。そして、それらは常に「駄目」です。なぜなら、それらは表現力のためではなく、単純さのために設計されているからです。

#### ドメイン特化言語（DSL）との関連
Wangは、この点を拡張するために、自身の以前のエッセイ["The Pitfalls of DSLs"](https://yinwang1.substack.com/p/dsl-misconcepts)（特に「動的論理読み込み」のセクション）を参照しています。多くのDSL（特定のタスクのためのカスタムのミニ言語）は、同じ欲求—再コンパイルせずに実行時にルールや振る舞いを読み込みたい—から生まれます。

- **過ち：** チームは「動的論理」のために特注の言語が必要だと考え、それを作り出します—それはぎこちないラッパーの中にif-then-elseを再発明することになります。
- **修正：** このほとんどは単純な条件分岐に帰着します。既存の言語（例: JavaScriptの`if`文）からのスニペットを設定ファイルに埋め込むだけで十分です。全く新しいDSLは必要ありません—それは過剰であり、同じ「駄目な言語」の罠につながります。
- *法則の作用：* 論理（例: 「Xをチェックし、その後Yを実行する」）はどこかに行かなければなりませんでした。JSのスニペットを使うことで、それを*優れた*言語の中に保ち、設定ファイルの肥大化を避けることができます。

#### なぜこれが重要なのか？
これは単なる理論ではありません—ソフトウェア設計への警告です。これは、KubernetesのYAMLやwebpackの設定などが、コーディングの悪夢のように感じられる理由を説明します。教訓は？論理が栄える場所（適切な言語の中）でそれを受け入れ、設定ファイルに追放することを避けることです。論理を*可視化し管理可能*にするシステムを設計しないと、それは幽霊のような形であなたを悩ませ続けるでしょう。

もっと深く知りたい場合は、完全な投稿がよりニュアンスを含んでいて手軽に読めます。

[元の投稿: Configuration Files and the Logic Indestructibility Law](https://yinwang1.substack.com/p/224)
[関連記事: The Pitfalls of DSLs](https://yinwang1.substack.com/p/dsl-misconceptions)