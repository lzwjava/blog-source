---
audio: false
generated: true
lang: ja
layout: post
title: Javaの型システム
translated: true
type: note
---

Javaの型システムを詳しく見ていきましょう！このチュートリアルでは、基本概念をカバーします。

**型システムとは？**

プログラミングにおいて、型システムは使用できる値の種類とその操作方法を定義します。これにより、プログラムが型安全であること、つまり操作が正しいデータ型に対して実行されることが保証され、予期しないエラーを防ぎ、コードの信頼性を向上させます。

Javaは**強い静的型付け**の型システムを持っています。

* **強い型付け:** Javaは強い型付け言語であり、変数の型はコンパイル時と実行時に厳密に強制されます。一般的に、明示的な変換（キャスト）なしでは互換性のない型に対して操作を実行できません。これにより、開発プロセスの早い段階でエラーを検出できます。
* **静的型付け:** Javaは静的型付け言語であり、変数の型はプログラムが実行される前に宣言されます（または`var`を使用する場合などに推論されます）。コンパイラは実行前にこれらの型の互換性をチェックします。

**Javaの型システムの主要な構成要素:**

Javaの型システムは、大きく2つの主要なカテゴリに分けられます：

1.  **プリミティブ型:** Javaで最も基本的なデータ型です。これらはメモリ内で直接単一の値を表します。
2.  **参照型:** これらの型は、クラスまたはインターフェースのインスタンスであるオブジェクトを表します。参照変数は、オブジェクトのメモリアドレス（参照）を格納します。

それぞれを詳しく見ていきましょう。

**1. プリミティブ型:**

Javaには8つのプリミティブデータ型があります：

| 型       | サイズ (ビット) | 説明                                           | 範囲                                                                     | 例                     |
| -------- | --------------- | ---------------------------------------------- | ------------------------------------------------------------------------ | ---------------------- |
| `byte`   | 8               | 符号付き整数                                   | -128 から 127                                                            | `byte age = 30;`       |
| `short`  | 16              | 符号付き整数                                   | -32,768 から 32,767                                                      | `short count = 1000;`  |
| `int`    | 32              | 符号付き整数                                   | -2,147,483,648 から 2,147,483,647                                        | `int score = 95;`      |
| `long`   | 64              | 符号付き整数                                   | -9,223,372,036,854,775,808 から 9,223,372,036,854,775,807               | `long population = 1000000000L;` ('L'サフィックスに注意) |
| `float`  | 32              | 単精度浮動小数点数 (IEEE 754)                  | 約 ±3.40282347E+38F                                                      | `float price = 19.99F;` ('F'サフィックスに注意) |
| `double` | 64              | 倍精度浮動小数点数 (IEEE 754)                  | 約 ±1.79769313486231570E+308                                             | `double pi = 3.14159;` |
| `char`   | 16              | 単一のUnicode文字                              | '\u0000' (0) から '\uffff' (65,535)                                      | `char initial = 'J';`  |
| `boolean`| 可変            | 論理値を表す                                   | `true` または `false`                                                    | `boolean isVisible = true;` |

**プリミティブ型に関する重要なポイント:**

* これらはメモリに直接格納されます。
* 定義済みのサイズと範囲を持ちます。
* オブジェクトではなく、関連するメソッドはありません（ただし、`Integer`、`Double`などのラッパークラスがオブジェクト表現を提供します）。
* 明示的に初期化されない場合、プリミティブ型のフィールドにはデフォルト値が割り当てられます（例: `int`は0、`boolean`は`false`）。

**2. 参照型:**

参照型は、クラスまたはインターフェースのインスタンスであるオブジェクトを表します。参照型の変数は、ヒープ内のオブジェクトへのメモリアドレス（参照）を保持します。

**一般的な参照型:**

* **クラス:** クラスはオブジェクトを作成するための設計図です。その型のオブジェクトのデータ（フィールド/属性）と振る舞い（メソッド）を定義します。
    ```java
    class Dog {
        String name;
        int age;

        public void bark() {
            System.out.println("Woof!");
        }
    }

    public class Main {
        public static void main(String[] args) {
            Dog myDog = new Dog(); // 'Dog'が参照型
            myDog.name = "Buddy";
            myDog.age = 3;
            myDog.bark();
        }
    }
    ```
* **インターフェース:** インターフェースは、クラスが実装できるメソッドの契約を定義します。これらは一連の振る舞いを表します。
    ```java
    interface Animal {
        void makeSound();
    }

    class Cat implements Animal {
        public void makeSound() {
            System.out.println("Meow!");
        }
    }

    public class Main {
        public static void main(String[] args) {
            Animal myCat = new Cat(); // 'Animal'が参照型
            myCat.makeSound();
        }
    }
    ```
* **配列:** 配列は同じ型の要素のコレクションです。配列の型はその要素の型によって決まります。
    ```java
    int[] numbers = new int[5]; // 'int[]'が参照型
    numbers[0] = 10;

    String[] names = {"Alice", "Bob", "Charlie"}; // 'String[]'が参照型
    ```
* **列挙型 (Enum):** 列挙型は、名前付き定数の固定セットを表します。
    ```java
    enum Day {
        MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
    }

    public class Main {
        public static void main(String[] args) {
            Day today = Day.MONDAY; // 'Day'が参照型
            System.out.println("Today is " + today);
        }
    }
    ```
* **ラッパークラス:** 各プリミティブ型に対して、Javaは対応するラッパークラス（例: `int`に対して`Integer`、`double`に対して`Double`）を提供します。これにより、プリミティブ値をオブジェクトとして扱うことができます。
    ```java
    Integer num = 10; // 'Integer'が参照型
    Double piValue = 3.14; // 'Double'が参照型
    ```

**参照型に関する重要なポイント:**

* これらはヒープ内のオブジェクトへの参照（メモリアドレス）を格納します。
* `null`を取ることができ、これは参照がどのオブジェクトも指していないことを意味します。
* 関連するメソッドとフィールドを持ちます（それらのクラスまたはインターフェースによって定義されます）。
* 初期化されていない参照型フィールドのデフォルト値は`null`です。

**3. `var`による型推論 (Java 10以降):**

Java 10では`var`キーワードが導入され、ローカル変数の型推論が可能になりました。型を明示的に宣言する代わりに、コンパイラが初期化子式に基づいて型を推論します。

```java
var message = "Hello"; // コンパイラは'message'をString型と推論
var count = 100;      // コンパイラは'count'をint型と推論
var prices = new double[]{10.5, 20.3}; // コンパイラは'prices'をdouble[]型と推論
```

**`var`に関する重要な注意点:**

* `var`はメソッド、コンストラクタ、または初期化子内のローカル変数に対してのみ使用できます。
* `var`を使用するときは初期化子を提供する必要があります。コンパイラが型を推論するために必要だからです。
* `var`はJavaの静的型付けを変更しません。型は依然としてコンパイル時に決定されます。

**4. ジェネリクス:**

ジェネリクスを使用すると、型をパラメータ化できます。これは、コンパイル時の型安全性を提供しながら、異なる型で動作するクラス、インターフェース、メソッドを定義できることを意味します。

```java
import java.util.ArrayList;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<String> names = new ArrayList<>(); // Stringのリスト
        names.add("Alice");
        names.add("Bob");

        // names.add(123); // これはコンパイル時エラーを引き起こす

        List<Integer> numbers = new ArrayList<>(); // Integerのリスト
        numbers.add(10);
        numbers.add(20);
    }
}
```

ここで、`<String>`と`<Integer>`は型パラメータです。ジェネリクスは、コンパイル時に型制約を強制することにより、実行時の`ClassCastException`を防ぐのに役立ちます。

**5. 型チェック:**

Javaは、2つの主要な段階で型チェックを実行します：

* **コンパイル時の型チェック:** Javaコンパイラは、コードが実行される前に型エラーをチェックします。型の不一致（例: 明示的なキャストなしで`String`を`int`変数に代入しようとする）がある場合、コンパイラはエラーを報告し、プログラムのコンパイルを妨げます。
* **実行時の型チェック:** 一部の型チェックはプログラムの実行中に行われます。例えば、参照型を別の型にキャストするとき、JVMはオブジェクトが実際にターゲット型のインスタンスであるかどうかをチェックします。そうでない場合、`ClassCastException`がスローされます。

**6. 型変換 (キャスト):**

ある型の値を別の型に変換する必要がある場合があります。Javaは2種類のキャストをサポートしています：

* **暗黙的キャスト (拡大変換):** これは、より小さいプリミティブ型の値をより大きいプリミティブ型の変数に代入するときに自動的に発生します。データ損失は発生しません。
    ```java
    int myInt = 10;
    long myLong = myInt; // intからlongへの暗黙的キャスト
    double myDouble = myLong; // longからdoubleへの暗黙的キャスト
    ```
* **明示的キャスト (縮小変換):** より大きいプリミティブ型の値をより小さいプリミティブ型の変数に代入するときは、キャスト演算子`(targetType)`を使用して手動で行う必要があります。データ損失が発生する可能性があります。
    ```java
    double myDouble = 10.99;
    int myInt = (int) myDouble; // doubleからintへの明示的キャスト (myIntは10になる)
    ```
* **参照型のキャスト:** 参照型間でもキャストできますが、より複雑で、継承とインターフェースが関わります。
    * **アップキャスト:** サブクラスのオブジェクトをそのスーパークラス型にキャストすること。これは常に暗黙的に許可されます。
    * **ダウンキャスト:** スーパークラス型のオブジェクトをそのサブクラス型にキャストすること。これには明示的なキャストが必要であり、オブジェクトが実際にサブクラスのインスタンスでない場合、実行時に`ClassCastException`が発生する可能性があります。

**参照型キャストの例:**

```java
class Animal {}
class Dog extends Animal {
    public void bark() {
        System.out.println("Woof!");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Dog(); // アップキャスト (暗黙的)

        // Dog myDog = myAnimal; // コンパイル時エラー: AnimalからDogへは暗黙的に変換できない
        Dog myDog = (Dog) myAnimal; // ダウンキャスト (明示的)
        myDog.bark(); // これは動作する

        Animal anotherAnimal = new Animal();
        // Dog anotherDog = (Dog) anotherAnimal; // これは実行時にClassCastExceptionをスローする
    }
}
```

**結論:**

Javaの型システムを理解することは、正しく堅牢なコードを書くために不可欠です。プリミティブ型と参照型の違い、ジェネリクスの動作方法、型チェックとキャストのルールを知ることで、一般的なプログラミングエラーを回避し、より信頼性の高いアプリケーションを構築できます。

このチュートリアルは基礎的な理解を提供します。Javaの学習を続けると、継承、ポリモーフィズム、より複雑なジェネリクスのシナリオなど、型に関連するより高度な概念に遭遇するでしょう。理解を確実なものにするために、さまざまな型で練習と実験を続けてください！