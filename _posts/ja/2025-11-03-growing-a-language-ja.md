---
audio: false
generated: true
image: false
lang: ja
layout: post
model: x-ai/grok-4-fast
title: 言語を育てる
translated: true
type: note
---

### 概要
「Growing a Language」と題されたこの講演は、1998年10月19日、カナダのバンクーバーで開催されたOOPSLA '98 (Object-Oriented Programming, Systems, Languages & Applications カンファレンス) において、ガイ・L・スティール・ジュニアによって行われました。これは、言語設計と進化に関する45分間の画期的な講演で、Scheme (Lispの方言) を用いたライブコーディングデモを特徴としています。JavaとSchemeの共同設計者であるスティールは、最小限のプリミティブから始めて機能を層状に積み上げることで、プログラミング言語を段階的に構築する方法を実演し、シンプルさ、表現力、拡張性を重視することを示しました。核となる考え方は、言語はすべてを一度に設計するのではなく、最小限のプリミティブから始め、その上に機能を重ねることで有機的に「成長」するというものです。

この動画はYouTube (ACM SIGPLANによりアーカイブ) で視聴可能であり、関数型言語や組み込みドメイン固有言語 (DSL) を含む、現代の言語設計に関する議論に影響を与えてきました。

### 主なテーマと構成
スティールはこの講演をハンズオンチュートリアルとして構成し、Schemeでライブコーディングを行い、単純な式評価器を本格的な言語へと「成長」させていきます。彼は「ガーデニング」(機能を育む) と「建築」( rigid な設計図) といった比喩を用いて、進化的な設計を支持する主張を行います。主なセクションの内訳は以下の通りです:

1.  **導入: なぜ言語を成長させるのか? (0:00–5:00)**
    スティールは、「ビッグバン」的な言語設計 (例: すべてを事前に規定し、肥大化を招く) を批判することで講演を動機付けます。彼は代わりに「成長」を提案します: 小さく始め、頻繁にテストし、実際の必要性に基づいて拡張する。彼は、言語が評価器のコードから成長したLispの歴史からも着想を得ています。目標: 算術式のための小さな言語を構築し、それがチューリング完全な何かへと進化できるようにする。

2.  **種: 基本評価器 (5:00–10:00)**
    最もシンプルな核から始めます: 原子的な数値を評価する関数 (例: `3` → 3)。
    - コードスニペット (Scheme):
      ```scheme
      (define (eval exp) exp)  ; 原子に対する恒等関数
      ```
    彼はこれをライブで実行し、`(eval 3)` が 3 を返すことを示します。これが「種」です — 純粋で、構文糖衣はありません。

3.  **発芽: 演算の追加 (10:00–20:00)**
    `+` や `*` のような二項演算子を、リストのパターンマッチングによって導入します (例: `(+ 2 3)`)。
    - 評価器を成長させます:
      ```scheme
      (define (eval exp)
        (if (pair? exp)
            (let ((op (car exp))
                  (args (cdr exp)))
              (apply op (map eval args)))
            exp))
      ```
    評価を実演: `(+ (* 2 3) 4)` → 10。シンプルさを保ち、時期尚早な最適化を避けるという、健全性を強調します。

4.  **分岐: 条件分岐と変数 (20:00–30:00)**
    条件分岐のための `if` と、変数を束縛するための `let` を追加し、スコープが自然に出現する様子を示します。
    - 成長の例:
      ```scheme
      (define (eval exp env)
        (if (pair? exp)
            (case (car exp)
              ((quote) (cadr exp))
              ((if) (if (eval (cadr exp) env)
                        (eval (caddr exp) env)
                        (eval (cadddr exp) env)))
              ((let) (eval (cadddr exp) (extend-env env (caadr exp) (eval (cadadr exp) env))))
              (else ...))  ; 関数適用へのフォールバック
            (lookup exp env)))  ; 変数参照
      ```
    ライブデモ: 再帰的な `let` 束縛を用いて階乗を計算し、再帰が反復からどのように「成長」するかを強調します。

5.  **開花: マクロと抽象化 (30:00–40:00)**
    衛生的なマクロを導入し、ドメイン固有の構文 (例: `while` ループ) を追加します。マクロがユーザー自身に言語を「成長」させることを可能にすることを示します。
    - 重要な洞察: 言語はLispのマクロシステムのように、コアをフォークすることなくDSLを可能にする、「拡張」に対して「開かれている」べきです。

6.  **結論: 設計者への教訓 (40:00–45:00)**
    スティールは以下の原則で締めくくります:
    - **漸進主義**: 一度に一つの機能を追加し、即座にテストする。
    - **一様性**: プリミティブを再利用する (例: すべてが式である)。
    - **ユーザーエンパワーメント**: マクロなどによりユーザーが拡張できるようにする。
    彼はこれを現実世界の言語 (Java, Scheme) に関連付け、「機能蔓延」に対して警告します。質疑応答では、パフォーマンスと実装上の課題に触れています。

### 影響と要点
この講演は「言語ワークベンチ」のアイデアを広め、Racket (Schemeを拡張) のようなツールや、RustのマクロやSwiftの拡張機能における概念に影響を与えました。これは、言語を生きているシステムとして考えることに関する実践的、哲学的、そして楽しめる (スティールの乾いたウィットが光る) マスタークラスです。

完全な体験のために、動画を視聴してください: [Growing a Language - OOPSLA '98](https://www.youtube.com/watch?v=_ahvzDzKdB0)。トランスクリプトや要約はほとんどありませんが、コードはスライド (ACM Digital Libraryを通じて入手可能) から再構築可能です。もしプログラミング言語設計に興味があれば、スティールの後の講演「Growing a Pattern Language」(OOPSLA '05) と合わせて視聴することをお勧めします。