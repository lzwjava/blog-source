---
audio: false
generated: true
lang: ja
layout: post
title: IntelliJの構造的置換をマスターする
translated: true
type: note
---

では、IntelliJ IDEAのStructural Replace機能について詳しく見ていきましょう。

IntelliJ IDEAのStructural Replaceは、非常に強力でありながら、十分に活用されていない機能です。この機能は、単なるテキスト検索と置換を超えて、コードの**構造**に基づいてパターンを検索・置換することができます。これにより、大規模なコードベース全体にわたる複雑なリファクタリング、コードスタイルの強制、バグ修正が可能になります。

以下に包括的なガイドを示します：

-----

## IntelliJ IDEA Structural Replace：包括的ガイド

### 1. 構造的検索と置換（SSR）とは？

SSRの核心は、抽象構文木（AST）を操作することにあります。リテラル文字列を検索する代わりに、検索したいコードの構造を記述する*パターン*（構造的検索）と、それをどのように変換したいかを記述する別のパターン（構造的置換）を定義します。

これにより、以下のことが可能になります：

  * **コードのリファクタリング：** メソッドの呼び出し方法の変更、パラメータの並べ替え、フィールドのカプセル化など。
  * **コーディング標準の強制：** 特定の言語構成やAPI呼び出しの一貫した使用を確保。
  * **一般的なバグの修正：** 繰り返し発生する論理エラーを特定して修正。
  * **APIの移行：** ライブラリやフレームワークが変更された際にコードを更新。
  * **非推奨コードのクリーンアップ：** 古いAPIの使用箇所を検索して新しいものに置換。

### 2. 構造的検索と置換へのアクセス

SSRダイアログには2つの方法でアクセスできます：

  * **Edit -> Find -> Search Structurally...** （検索用）
  * **Edit -> Find -> Replace Structurally...** （直接置換用）

両方のダイアログは非常に似ており、「Replace Structurally」には単に「Replace Template」フィールドが追加されています。

### 3. 構造的検索ダイアログの理解

構造的検索ダイアログは、検索パターンを定義する場所です。

#### 3.1. 検索テンプレート

これは最も重要な部分です。検索したい*構造*を表すコードスニペットを記述します。

**主要な概念：**

  * **リテラルコード：** 直接記述したコードは、そのままの文字列としてマッチします。
  * **変数：** コードの可変部分を表すために変数を使用します。変数は特別な構文を使用して定義され、制約で設定されます。
      * **一般的な変数構文：** `$変数名$` （ドル記号で囲む）。
      * **例：** `System.out.println($引数$);` は、任意の `System.out.println` 呼び出しを検索し、`$引数$` は括弧内の任意の内容にマッチします。

#### 3.2. スクリプト制約（変数に対する）

「検索テンプレート」で変数を定義した後、その制約を指定する必要があります。これは、テンプレート内の変数を選択する（またはカーソルを合わせる）ことで行い、「Edit variables」ボタン（テンプレートフィールドの横にある小さな鉛筆アイコン、または「Variables」タブからアクセス可能）を使用します。

一般的な制約：

  * **Text (regexp)：** 変数のテキスト内容が一致しなければならない正規表現。
  * **Type (regexp)：** 変数の型が一致しなければならない正規表現（例：`java.lang.String`, `int[]`）。
  * **Count：** 変数要素が出現できる回数を指定（例：`[0, N]`, `[1, N]`, `[1, 1]`）。これはステートメントのコレクションやメソッドパラメータに特に有用です。
  * **Reference：** 変数が識別子（メソッド名や変数名など）を表す場合、特定の型や宣言を参照するように制約できます。
  * **Within：** 変数を特定のスコープや宣言内に制限します。
  * **Not RegExp：** 正規表現に基づいてマッチを除外します。
  * **Condition (Groovy script)：** これは最も強力な制約です。`true` または `false` に評価されるGroovyスクリプトを記述できます。このスクリプトはマッチした要素とそのプロパティにアクセスでき、非常に複雑なロジックを可能にします。
      * **スクリプト例：** 整数変数の値が10より大きいかチェックする： `_target.text.toInteger() > 10` （`_target` は変数に対するマッチした要素）。

#### 3.3. オプション

テンプレートの下には、検索を絞り込むための様々なオプションがあります：

  * **Context：** 検索のスコープを定義（例：プロジェクト全体、モジュール、ディレクトリ、選択されたファイル、カスタムスコープ）。
  * **File type：** 検索を特定のファイルタイプに制限（Java, Kotlin, XMLなど）。
  * **Case sensitive：** 標準的な大文字小文字の区切り切り替え。
  * **Match case/whole words：** テンプレート内のテキストに適用可能。
  * **Match line breaks：** 複数行パターンに重要。
  * **Save Template：** 現在の検索テンプレートを将来の使用のために保存。

### 4. 構造的置換ダイアログの理解

構造的置換ダイアログは、「検索テンプレート」と「変数」に「Replace Template」フィールドを追加します。

#### 4.1. 置換テンプレート

これは、見つかったコード構造をどのように変換すべきかを定義する場所です。

  * **検索テンプレートからの変数：** 「検索テンプレート」で定義した同じ変数を「置換テンプレート」内で使用できます。検索で変数にマッチした内容が置換テンプレートに挿入されます。
  * **新しいコード：** 新しいコード要素を導入したり、既存の要素を並べ替えたり、一部を削除したりできます。
  * **例：**
      * **検索テンプレート：** `System.out.println($引数$);`
      * **置換テンプレート：** `LOGGER.info($引数$);`
      * これは `System.out.println("Hello");` を `LOGGER.info("Hello");` に変更します。

#### 4.2. 完全修飾名の短縮

このオプション（多くの場合自動的に有効）は、完全修飾クラス名（例：`java.util.ArrayList`）を短い名前（例：`ArrayList`）に置き換え、必要なimport文を追加しようとします。これは読みやすいコードを維持するために重要です。

#### 4.3. フォーマット

IntelliJ IDEAは通常、プロジェクトのコードスタイル設定に従って置換されたコードを再フォーマットします。これは非常に望ましい動作です。

### 5. 実践的な例

いくつかの一般的なシナリオで説明しましょう。

#### 例1: `System.out.println` をLoggerに置換

**目標：** すべての `System.out.println("message");` を `LOGGER.info("message");` に変更（`LOGGER` がstatic finalフィールドと仮定）。

1.  **構造的置換を開く：** `Edit -> Find -> Replace Structurally...`
2.  **検索テンプレート：**
    ```java
    System.out.println($引数$);
    ```
3.  **変数：** 「Edit variables」をクリックするか「Variables」タブに移動。
      * `$引数$` を選択。
      * **Count：** `[1, 1]` （1つの引数）。
      * **Type (regexp)：** `java.lang.String` （文字列リテラルのみ置換したい場合。それ以外は任意の型のために空のままにします）。
4.  **置換テンプレート：**
    ```java
    LOGGER.info($引数$);
    ```
5.  **実行：** 「Find」をクリックして変更をプレビューし、問題がなければ「Replace All」をクリック。

#### 例2: メソッドパラメータの交換

**目標：** `someMethod(paramA, paramB)` を `someMethod(paramB, paramA)` に変更。

1.  **検索テンプレート：**
    ```java
    someMethod($パラメータA$, $パラメータB$);
    ```
2.  **変数：**
      * `$パラメータA$`： `Count: [1,1]`, `Type (regexp): .*` （任意の型）
      * `$パラメータB$`： `Count: [1,1]`, `Type (regexp): .*` （任意の型）
3.  **置換テンプレート：**
    ```java
    someMethod($パラメータB$, $パラメータA$);
    ```

#### 例3: フィールドのカプセル化（単純なケース）

**目標：** `public String name;` のようなpublicフィールドがあり、直接アクセス `obj.name` を `obj.getName()` に置き換えたい場合。（これは簡略化した例です。カプセル化には専用のリファクタリング機能を使用することが多いです）。

1.  **検索テンプレート：**
    ```java
    $オブジェクト$.$フィールド名$;
    ```
2.  **変数：**
      * `$オブジェクト$`： `Count: [1,1]`, `Type (regexp): .*`
      * `$フィールド名$`： `Count: [1,1]`, `Text (regexp): name` （特に `name` フィールドを対象とする）。
3.  **置換テンプレート：**
    ```java
    $オブジェクト$.get$フィールド名$();
    ```
      * **注意：** `get$フィールド名$` が自動的に `name` を `Name` に大文字化しない場合、大文字化を調整する必要があるかもしれません。このためには、置換テンプレート内の `$フィールド名$` に対してGroovyスクリプトを使用できますが、より複雑になります。この特定のケースでは、2つのSSRまたは専用のリファクタリングを使用する方が簡単なアプローチです。 `get$フィールド名$()` の場合、IDEは一般的なゲッターパターンに対して大文字化を通常処理します。

#### 例4: 空の `catch` ブロックの検索

**目標：** 空の（またはコメント/空白のみを含む）すべての `catch` ブロックを検索。

1.  **検索テンプレート：**
    ```java
    try {
        $ステートメント$;
    } catch ($例外タイプ$ $例外変数$) {
        $空のボディ$;
    }
    ```
2.  **変数：**
      * `$ステートメント$`： `Count: [0, N]` （tryブロック内の0個以上のステートメント）
      * `$例外タイプ$`： `Count: [1,1]`
      * `$例外変数$`： `Count: [1,1]`
      * `$空のボディ$`： `Count: [0, 0]` （これが空のボディのキーです）

#### 例5: 高度な条件にGroovyスクリプトを使用

**目標：** 条件が定数 `true` である `if` ステートメントを検索。

1.  **検索テンプレート：**
    ```java
    if ($条件$) {
        $then節$;
    }
    ```
2.  **変数：**
      * `$条件$`： `Count: [1,1]`
          * **Condition (Groovy script)：** `_target.text == "true"` （条件のリテラルテキストをチェックします）。
      * `$then節$`： `Count: [0, N]`

### 6. ヒントとベストプラクティス

  * **シンプルに始める：** 基本的なパターンから始め、徐々に複雑さを追加していきます。
  * **まず `Find` を使用：** 置換の前に常に「Find」（構造的検索）を使用してマッチをプレビューし、パターンが正しいことを確認します。
  * **小さなスコープでテスト：** 大規模な置換を実行する前に、小さな隔離されたファイルセットでパターンをテストします。
  * **テンプレートを保存：** 頻繁に使用する、または複雑なテンプレートを保存して簡単に再利用できます。
  * **既存のテンプレートを活用：** IntelliJ IDEAには多くの事前定義された構造的検索と置換テンプレートが付属しています。これらはSSRダイアログで「虫眼鏡とプラス」アイコンをクリックし、既存のテンプレートを参照することで見つけられます。これらは優れた学習リソースです。
  * **Groovyスクリプトの力：** 非常に特定された、または文脈に依存したマッチには、Groovyスクリプトが貴重です。スクリプト内で要素（`_target`, `_target.parent`, `_target.text`, `_target.type` など）にアクセスする方法の基本を学びましょう。
  * **マッチタイプを理解：** 変数が何にマッチしているか（例：ステートメント、式、型、変数名）を認識します。これは適用できる制約に影響します。
  * **正規表現：** 正規表現の理解が深まると、`Text` および `Type` 制約を定義する能力が大幅に向上します。
  * **デバッグ：** パターンが期待通りにマッチしない場合は、それを簡素化します。マッチし始めるまで制約を1つずつ削除し、問題を特定するためにそれらを再導入します。
  * **コードのバックアップ：** 大規模なコードベースでの大規模な構造的置換操作の前に、バックアップがあること、または変更を簡単に元に戻せるバージョン管理システム内で作業していることを確認します。

### 7. 制限事項

  * **複雑さ：** 非常に複雑な、または高度に文脈に依存した置換は、SSRのみで表現するのが困難または不可能な場合があります。場合によっては、カスタムのIntelliJ IDEAプラグインまたは専用のスクリプトがより適切かもしれません。
  * **パフォーマンス：** 非常に広範または複雑なパターンを非常に大規模なコードベースで実行すると、遅くなる可能性があります。
  * **曖昧さ：** 過度に一般的なパターンには注意してください。意図せずにコードにマッチし、変更してしまう可能性があります。

-----

IntelliJ IDEAの構造的検索と置換を習得することで、コード品質の維持、大規模なリファクタリングの実行、面倒なコード変更の自動化のための強力なツールを手に入れることができます。これは、開発者がプロジェクト全体でより効率的かつ一貫して作業することを真に可能にする機能です。