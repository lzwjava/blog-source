---
audio: false
generated: true
image: false
lang: ja
layout: post
model: x-ai/grok-4-fast
title: 随伴行列の定義と余因子の関係
translated: true
type: note
---

### 随伴行列の定義の明確化（および余因子との関係）

随伴行列が余因子を通じて構築される方法について、あなたの理解はほぼ正しいですが、説明に小さくしかし重要な修正点があります。随伴行列（しばしば `adj(A)` と表記される）は、元の要素 `a(i,j)` に「残りの部分」（i行とj列を削除した部分行列）の符号付き行列式を乗算することで構築されるの**ではありません**。代わりに：

- 要素 `a(i,j)` の**余因子** `C_ij` は、`C_ij = (-1)^{i+j} * det(M_ij)` と定義されます。ここで、`M_ij` はAからi行とj列を削除して得られる部分行列です。これは純粋に**符号付き小行列式**であり、`a(i,j)` 自体による乗算は含まれません。
- **余因子行列** C は、これらの `C_ij` を要素として持ちます。
- **随伴行列**は、この余因子行列の**転置**です: `adj(A) = C^T`。したがって、`adj(A)` の位置 (i,j) の要素は、実際には `C_ji`（インデックスを入れ替えた余因子）となります。

この符号付き小行列式の設定は、行列式を計算するためのラプラス展開に由来します（後述）。あなたの説明は、行列式公式そのもののように聞こえます: `det(A) = jに関する a(i,j) * C_ij の和`（任意の行iに沿って）。これは確かに `a(i,j)` による乗算を含みます。しかし、随伴行列はその乗算をスキップします—それは単にこれらの符号付き小行列式を集め、転置したもので、代数的な恒等式を簡潔に表現できるようにするためです。

簡単な2x2の例で説明しましょう (A = [[a, b], [c, d]] とします):
- 余因子: C_11 = (-1)^{1+1} det([d]) = d; C_12 = (-1)^{1+2} det([c]) = -c; C_21 = (-1)^{2+1} det([b]) = -b; C_22 = (-1)^{2+2} det([a]) = a.
- 余因子行列 C = [[d, -c], [-b, a]].
- 随伴行列 adj(A) = C^T = [[d, -b], [-c, a]].
- 余因子には元の a, b, c, d の乗数が含まれていないことに注意してください—これはすべて「残りの」部分行列に関するものです。

はい、これがまさに随伴行列を計算する方法です：各位置に対して行/列を削除し、残りの部分の行列式を計算し、符号 `(-1)^{i+j}` を適用し、Cを組み立て、そして転置して adj(A) を得ます。これは再帰的です（小行列式はより小さな行列を扱う）。そのため、大きな n x n 行列に対しては計算量が多くなります—これが実践的に逆行列を求める際にしばしばガウスの消去法を使用する理由です。

### なぜ随伴行列が必要なのか？（単なる中間表現以上のもの）

あなたがそれを逆行列計算のための「中間表現」のように感じるのはもっともです—そして多くの計算的な意味では、それはその通りです！鍵となる公式は `A^{-1} = (1 / det(A)) * adj(A)` です（det(A) ≠ 0 と仮定）。これは行操作を必要とせず、部分行列の行列式のみを使用して逆行列を直接与えます。しかし、それは単なる*通過点*ではありません。これが有用で必要な理由は以下の通りです：

1.  **行列の逆行列公式**: 小規模な行列や記号計算（例えば、証明や厳密な算術において）では、これは逆行列を表現する明確で明示的な方法です。これは逆行列がどのようにスケーリングされた余因子に「分解」されるかを浮き彫りにします。

2.  **理論的洞察**: 恒等式 `A * adj(A) = adj(A) * A = det(A) * I`（I は単位行列）は深い構造を明らかにします。これはすべての行列がその随伴行列とスカラー倍を除いて可換であることを示し、特異行列（det(A)=0 ならば A adj(A)=0 なので、零空間が一致する）を理解する基礎となります。

3.  **線形システムに対するクラメルの公式**: Ax = b を解くために、i番目の解の要素は `x_i = det(A_i) / det(A)` です。ここで、A_i はAのi列をbで置き換えたものです。しかし、det(A_i) はbの要素を含む余因子を介して展開されます—本質的には、完全な逆行列計算なしで効率的な計算を行うために、随伴行列を内部で利用しています。

4.  **行列式の展開**: 余因子はラプラス展開（あなたの「det(rest)」の考え方）を可能にし、より小さな問題に分解することで det(A) を計算する上で重要です。歴史的には、これはコンピュータ以前の時代に行列式を扱いやすくしました。

5.  **より広範な応用**: 射影幾何学、コンピュータグラフィックス（変換）、さらには物理学（例えば、インピーダンス行列）においても、随伴行列は特異点の処理や、実数以外の環（多項式環など）における逆行列の導出に現れます。

要するに、行簡約法が数値計算においてより高速である一方で、随伴行列は理論、教育、および明示的な公式が必要な場合に対して「解析的」な道筋を提供します。それは逆行列の背後にある「理由」のようなものであり、単なる手段ではありません。

### 随伴行列はどのようにして発明されたのか？（少しばかりの歴史）

随伴行列は単一の「ひらめき」の瞬間から生まれたわけではありません—それは、行列がまだ形式化されていなかった（「行列」という用語は1850年に登場）18世紀から19世紀の行列式と線形方程式に関する研究の自然な発展です。単一の発明者は称えられていませんが、その道筋は以下の通りです：

-   **行列式のルーツ (1600年代後半–1700年代)**: 行列式は線形システムを解くことから登場しました（例えば、ライプニッツによる1693年の2x2のケース）。1700年代までに、クラメル（1750年）のような数学者は、解決策のために小行列式展開を暗黙的に余因子に触れながら使用しました。

-   **初期の「随伴」の概念 (1760年代–1800年代)**: ジョゼフ＝ルイ・ラグランジュは、1766年頃に微分方程式に対して「随伴方程式」という用語を作り出しました。ここで「随伴」作用素は元の作用素を反映します（行列に対する転置のように）。アーサー・ケイリー（1840年代–50年代）はこれを彼の行列研究において「随伴線形形式」に拡張しました。マキシム・ボッシャーは1900年代初頭に「随伴行列」を形式化しましたが、核心的なアイデアは彼以前にさかのぼります。

-   **ガウスの重要な洞察 (1801年)**: カール・フリードリヒ・ガウスは、彼の『整数論』において、二次形式（例: ax² + 2bxy + cy²）に対する「随伴」を定義しました。彼は、その係数が本質的に元の形式を表す対称行列の符号付き2x2小行列式である同伴形式を構築しました—まさに現代の定義を先取りするものです（符号の規約を除く）。これは数論（二元二次形式）のためのものでしたが、現代の定義を直接予見するものです。ガウスの研究はこの構築を体系的なものにしました。

-   **形式化 (1800年代中期以降)**: 行列論が確固たるものになるにつれて（ケイリー、シルベスター、クロネッカー）、ラプラス（1772年）に由来する余因子展開はこれらのアイデアと融合しました。1850年代から60年代までに、完全な逆行列公式 `A^{-1} = adj(A)/det(A)` が教科書に現れ、「随伴」という用語（ラテン語の "adjugare"（一緒に結びつける）から）は逆行列計算におけるその結びつける役割を強調しました。

この「発明」はおそらく、パターン認識から生じたのでしょう：行列式を展開しながら、数学者たちは余因子の集まりがスケーリングされると行列を「反転」させることに気づきました。それは天才の閃きというよりも、手計算で方程式を解くことからの有機的な進化でした。現代の教科書（例えば、ストラングの『線形代数イントロダクション』）も、直感のためにこの方法で教えています。

もしコードでの例（例えば、NumPy/SymPyを使用したPythonでの計算方法）やガウスの構築に関するより深い考察をご希望でしたら、お知らせください！

[随伴行列 - Wikipedia](https://en.wikipedia.org/wiki/Adjugate_matrix)
[「随伴」の最初の使用法 - History of Science and Mathematics Stack Exchange](https://hsm.stackexchange.com/questions/5908/what-is-the-first-usage-of-the-term-adjoint-and-why-was-this-word-chosen)