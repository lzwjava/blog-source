---
audio: false
date: 2025-09-11
generated: true
image: false
lang: ja
layout: post
model: mistralai/mistral-medium-3.1
title: LibreChat 会話フォークの実装詳細
translated: true
type: note
---

素晴らしい質問です！**LibreChat** (v0.8.0-rc3) には、しばらく前から**会話のフォーク（分岐）**機能があり、OpenAIの最近の実装とは異なる方法で動作します。以下に、LibreChatでの動作方法と、ChatGPTのアプローチとの比較を説明します：

---

### **LibreChatでのフォークの仕組み**
1. **手動分岐**
   - LibreChatでは、**「Fork」**ボタン（通常、分岐させたいメッセージの近くにあります）をクリックすることで、いつでも**明示的に会話をフォーク**できます。
   - これにより、選択したメッセージを起点とする**新しい会話**が作成され、その時点までのすべての以前のコンテキストが保持されます。

2. **独立したパス**
   - フォーク後、新しいブランチでの変更は**元の会話に影響を与えません**。
   - 元のスレッドを失うことなく、さまざまな方向性（例：デバッグのアプローチ、創造的なアイデア）を探ることができます。

3. **自動フォークなし（ChatGPTとは異なる）**
   - LibreChatは、メッセージを編集したときに会話を**自動的にフォークしません**（ChatGPTの最近の「編集時に分岐」機能とは異なります）。
   - フォークするタイミングは**手動で**選択する必要があります。

4. **バックエンドの実装**
   - LibreChatは会話履歴を構造化された方法で（例えば、データベース内で `conversationId` と `parentMessageId` を使用して）保存します。
   - フォーク時には、フォークポイントまでの親メッセージを再利用しながら、新しい `conversationId` を作成します。

---

### **ChatGPTのフォーク機能との比較**

| 機能               | LibreChat (v0.8.0-rc3)       | ChatGPT (最近のアップデート)  |
|-------------------|-----------------------------|-------------------------------|
| **トリガー**        | 手動（「Fork」をクリック）     | 自動（メッセージ編集時）       |
| **ユースケース**     | 代替案の模索                 | 編集からの回復                |
| **UIでの表示**      | 明確なブランチリスト          | 控えめな「編集版を表示」       |
| **永続性**          | DBに保存                    | 一時的（セッションベース？）   |
| **マルチブランチ**   | 可（複数のフォーク）          | 制限あり（単一の編集ブランチ） |

---

### **LibreChatが先行して実装していた理由**
1. **オープンソースの柔軟性**
   - LibreChatはOpenAIなどのAPI上に構築されていますが、独自の**会話管理レイヤー**を追加しています。
   - フォーク機能は、ユーザーが会話履歴を**完全に制御**したいセルフホスト型チャットプラットフォームにとって、自然な機能でした。

2. **ワークフロー向けの設計**
   - LibreChatは、以下の必要性がある**開発者、研究者、チーム**を対象としています：
     - コンテキストを失うことなくさまざまなプロンプトをテストする。
     - AIの応答を並べて比較する。
     - 分岐した議論上で共同作業する。

3. **ベンダーロックインの排除**
   - ChatGPT（フォークをOpenAIのバックエンドに結びつける）とは異なり、LibreChatのフォーク機能は**AIプロバイダーに関係なく**（例：Claude、Gemini、ローカルモデルでも同じように）動作します。

---

### **LibreChatでフォーク機能を使用する方法**
1. **会話をフォークする**：
   - メッセージにホバー → **「Fork」**をクリック（または会話メニューを使用）。
   - その時点までのすべてのメッセージを含む新しいチャットが開きます。

2. **ブランチを管理する**：
   - **サイドバー**を使用して、元の会話とフォークされた会話を切り替えます。
   - 明確にするためにブランチの名前を変更します（例：「デバッグアプローチA」と「アプローチB」）。

3. **コンテキストのマージ（上級者向け）**：
   - LibreChatは自動マージしませんが、ブランチ間で重要なメッセージを**コピー＆ペースト**できます。

---

### **ワークフローの例**
1. AIを使ってPythonスクリプトのデバッグを行っているとします。
2. メッセージ＃5で、**別のアプローチ**を試すためにフォークします。
3. 元のブランチでは、アプローチAを続けます。
4. フォークされたブランチでは、アプローチBをテストします。
5. 後でコンテキストを再入力することなく結果を比較します。

---

### **制限事項**
- **ビジュアルDiffなし**： Gitブランチとは異なり、LibreChatはフォーク間の差分を表示しません（現時点では）。
- **ストレージ**： フォークが多すぎるとデータベースが肥大化する可能性があります（定期的に古いブランチを整理してください）。

---
### **内部の仕組み（技術的詳細）**
LibreChatのフォークは以下に依存しています：
- **MongoDB/PostgreSQL**： `parentMessageId` 参照を使用して会話を保存します。
- **フロントエンドの状態**： ReactがUI内のアクティブなブランチを管理します。
- **APIの抽象化**： すべてのAIプロバイダー（OpenAI、Anthropicなど）で一様に動作します。

---
### **将来の改善点（今後のバージョンで可能性あり）**
- **編集時の自動フォーク**（ChatGPTのように）。
- **ブランチ比較**（並べて表示）。
- **マージ機能**（2つのブランチを結合）。

特定の部分（データベーススキーマ、UIのトリック、セルフホスティングのヒントなど）について、さらに詳しく知りたいですか？