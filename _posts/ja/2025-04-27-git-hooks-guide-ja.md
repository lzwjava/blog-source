---
audio: false
generated: true
image: false
lang: ja
layout: post
model: x-ai/grok-code-fast-1
title: Gitフックガイド：Pre-CommitとPre-Push
translated: true
type: note
---

### Git Hooksの概要
Git hooksは、Gitワークフローの特定のポイントでタスクを自動化するカスタマイズ可能なスクリプトです。クライアントサイド（ローカルマシンで実行）とサーバーサイド（リモートリポジトリで実行）の両方があります。フックはリポジトリの`.git/hooks/`ディレクトリに保存されます。以下では、pre-commit、pre-push、およびプッシュに関連するサーバーサイドフックについて、実行方法を説明します。

### クライアントサイドフック: Pre-CommitとPre-Push
これらのフックは、アクションが確定する前にローカルマシンで実行され、ルールの強制やチェックの実行を可能にします。

- **Pre-Commitフック**:
  - **実行タイミング**: 変更をコミットする直前（例: `git commit`経由）に自動的にトリガーされます。
  - **目的**: リンター、テスト、またはフォーマットツールの実行など、コード品質チェックに役立ちます。フックが失敗すると（非ゼロステータスで終了）、コミットは中止されます。
  - **例**: サンプルのpre-commitフックは、JavaScriptファイルに対して`eslint`を実行する場合があります。エラーがある場合、コミットは停止します。
  - **動作方法**: スクリプトは`.git/hooks/pre-commit`にあります。`chmod +x .git/hooks/pre-commit`で実行可能にします。Husky（Gitフックを管理する人気ライブラリ）のようなツールを使用すると、セットアップが簡素化されます。

- **Pre-Pushフック**:
  - **実行タイミング**: リモートにプッシュする直前（例: `git push`経由）に自動的にトリガーされます。
  - **目的**: テストの実行、コードカバレッジの検証、または変更をリモートに送信する前の互換性の確保などをチェックします。失敗した場合、プッシュはブロックされます。
  - **「prepush」に関する注意**: Gitには標準の「prepush」フックはありません—ハイフン付きの「pre-push」フックを指していると想定します。Huskyのようなツールを使用してカスタムpre-pushスクリプトを作成し、「すべてのテストが合格した場合のみプッシュ」などのルールを強制できます。
  - **例**: pre-pushフックは`npm test`を実行し、テストが失敗した場合にプッシュを中止する場合があります。スキップされた場合（例: `git push --no-verify`）、フックは実行されません。
  - **動作方法**: `.git/hooks/pre-push`に配置されます。実行権限が必要です。リモート名やプッシュされるrefなどの引数を受け取ります。

クライアントサイドフックは、問題を早期に検出し、不良なコミットやプッシュがマシンから出るのを防ぎます。

### プッシュ中のサーバーサイドフック
`git push`を実行すると、プッシュはリモートリポジトリ（例: GitHub、GitLab、またはカスタムサーバー）に送信されます。リモートは、プッシュプロセス中または後に実行される独自のフックを持つことができます。これらはリモートGitリポジトリの`.git/hooks/`ディレクトリに保存され、サーバー管理者によって管理されます。

- **プッシュ中のプロセス**:
  1. **ローカルチェック**: pre-pushフックが最初に実行されます（存在する場合）。
  2. **データ転送**: 変更がリモートに送信されます。
  3. **リモート実行**: サーバーサイドフックはリモートサーバーで実行され、ローカルマシンでは実行されません。

- **Pre-Receiveフック**:
  - **実行タイミング**: リモートサーバー上で、プッシュを受け取った直後、ただしref（ブランチやタグ）が更新される前に実行されます。
  - **目的**: 受信した変更を検証します。コミットメッセージの強制、コードレビュー、またはセキュリティスキャンなどのチェックが失敗した場合、プッシュ全体を拒否できます。
  - **動作方法**: フックが非ゼロステータスで終了すると、プッシュは拒否され、エラーメッセージが表示されます。例: 特定のサイズを超えるファイルを導入するプッシュを拒否します。

- **Updateフック**（Pre-Receiveに類似ですがrefごと）:
  - **実行タイミング**: 更新される各ブランチ/タグに対して、pre-receiveの後に実行されます。
  - **目的**: プッシュが承認されたユーザーからのものか、ブランチが命名規則に従っているかなど、きめ細かい制御を可能にします。
  - **動作方法**: 更新されるrefに関する詳細を受け取ります。

- **Post-Receiveフック**:
  - **実行タイミング**: リモートサーバー上で、プッシュが完全に受け入れられ、refが更新された後に実行されます。
  - **目的**: コードのデプロイ、通知の送信（例: Slackアラート）、または「アプリケーションの再ビルド」などのポストデプロイメントスクリプトの実行など、下流のアクションをトリガーします。
  - **動作方法**: 成功したプッシュ後に確実に実行されます。例: CI/CDパイプラインを自動的にトリガーする、またはWebサーバーを更新します。

サーバーサイドフックは集中管理された強制力を提供するため、ローカルフックがバイパスされた場合でも、リモートはプッシュを検証または反応できます。GitHubなどのプラットフォームは、同様の目的でWebhook（APIベースの同等品）を使用しますが、ベアGitサーバーやセルフホストリポジトリでは、上記のフックが重要です。

### 主な違いとベストプラクティス
- **クライアント vs サーバー**: クライアントフック（pre-commit/pre-pushなど）はローカルで迅速なフィードバックを提供します。サーバーフックはリポジトリ全体のルールを強制します。
- **カスタマイズ**: フックはシェルスクリプト（例: Bash）ですが、Python、Node.jsなどを呼び出すことができます。管理にはpre-commit（フレームワーク）などのツールを使用します。
- **バイパス**: コミットは`--no-verify`で、プッシュは`--no-verify`でバイパスできますが、サーバーフックは管理者アクセスがない限りバイパスできません。
- **セットアップのヒント**: フックはリポジトリ間でコピーされないため、リポジトリのテンプレートに追加するか、ツールを使用してインストールします。

セットアップする場合は、Gitのドキュメントまたはnodeプロジェクト向けのHuskyなどのツールを確認してください。特定のシナリオ（例: コード例）がある場合は、詳細を提供してアドバイスを調整してください！