---
audio: false
generated: true
image: false
lang: ja
layout: post
title: チェリーピックの競合と解決策
translated: true
type: note
---

Git **cherry-pick**は、ブランチ全体の履歴をマージすることなく、あるブランチからコミットを取得して別のブランチに適用するコマンドです。

---

### 仕組み

* `git cherry-pick <commit-hash>` を実行すると、Gitは以下の処理を行います：

  1. 指定されたコミットによって導入された変更（その親コミットとの差分）を特定します。
  2. それらの変更を現在のブランチに再適用し、新しいハッシュを持つ新しいコミットを作成します。
  3. これは、コミットの内容が再利用されることを意味しますが、元のコミットの祖先関係は保持されません。

これは次のように言い換えることができます：
*「この1つのコミットのパッチだけを取って、今いる場所に貼り付けてください。」*

---

### コンフリクトが発生する理由

コンフリクトは、cherry-pickが変更を**元のコンテキストから外れて適用する**ために発生します。主な理由は以下の通りです：

1. **コードの乖離 (Code drift)**
   元のコミット以降にターゲットブランチで同じコード領域が変更されている場合、Gitはパッチをクリーンに適用できません。例：

   * 元のコミットが `fileA` に関数を追加した。
   * ターゲットブランチで、誰かがその関数の名前を変更した、または削除した。
     → cherry-pick時にコンフリクト発生。

2. **依存コミットの欠落**
   コミットが以前のコミット（リファクタリング、変数名の変更など）に依存している場合があります。それらのコミットなしにcherry-pickすると、コンテキストが異なるためコンフリクトが発生します。

3. **変更の重複**
   両方のブランチが（たとえ異なる理由であっても）同じコード行を変更した場合、Gitは自動的に判断できず、手動解決のために停止します。

---

### 具体例

* `feature-branch` にコミット A → B → C がある。
* コミット B を `main` に取り込みたい。
* `git checkout main && git cherry-pick B` を実行する。
* もし `main` が既にコミットBと同じファイル/行を変更していた場合、Gitはコンフリクトを発生させます。ファイルを開き、差分を解決し、`git add` を実行した後、`git cherry-pick --continue` する必要があります。

---

👉 要するに：**Cherry-pickはパッチを新しいコンテキストで再生します。コンフリクトは、そのコンテキストが元のコンテキストから大きく乖離した場合に発生します。**

**cherry-pickのコンフリクトを減らすためのベストプラクティス**（コミットの順序付け、`-x`の使用、または事前のrebaseなど）についても説明しましょうか？