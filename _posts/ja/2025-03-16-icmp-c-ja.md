---
audio: false
generated: true
lang: ja
layout: post
title: C言語によるICMP Pingプログラム
translated: true
type: note
---

ICMP（Internet Control Message Protocol）は、IPネットワークにおける診断およびエラー報告のために使用されるネットワーク層プロトコルです。最も有名な用途は、ホスト間の接続性をテストする`ping`ユーティリティです。ICMPメッセージはIPパケットに直接カプセル化され（TCPやUDP層なし）、タイプ、コード、チェックサム、ペイロードで構成されます。`ping`では、「Echo Request」（タイプ8）と「Echo Reply」（タイプ0）メッセージが重要です。

以下に、ICMPの大まかな動作を説明します：
1. 送信側（例：あなたのマシン）がターゲットIPにICMP Echo Requestを送信します。
2. 到達可能で応答するように設定されているターゲットは、ICMP Echo Replyを返信します。
3. 送信側は、応答が到着するまでの時間に基づいて往復時間（RTT）を測定します。

`libpcap`や`libnet`のようなライブラリを使用せずにC言語で`ping`のようなプログラムを実装するには、生ソケット（`SOCK_RAW`）を使用してICMPパケットを直接作成および送信します。これは、生ソケットが高レベルの抽象化をバイパスするため、root権限（例：`sudo`）を必要とします。

以下は、ICMP Echo Requestを送信し、Echo Replyをリッスンする基本的な`ping`機能を模倣した簡略化されたCプログラムです。

---

### C言語でのICMP Pingプログラム

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>
#include <time.h>
#include <errno.h>

// ICMPチェックサムを計算
unsigned short checksum(void *b, int len) {
    unsigned short *buf = b;
    unsigned int sum = 0;
    unsigned short result;

    for (sum = 0; len > 1; len -= 2) {
        sum += *buf++;
    }
    if (len == 1) {
        sum += *(unsigned char *)buf;
    }
    sum = (sum >> 16) + (sum & 0xFFFF);
    sum += (sum >> 16);
    result = ~sum;
    return result;
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: %s <destination_ip>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    int sock_fd;
    struct sockaddr_in dest_addr;
    char packet[64];  // ICMPヘッダー + データ
    struct icmphdr *icmp;
    char recv_buffer[1024];
    struct timespec start, end;

    // ICMP用の生ソケットを作成
    sock_fd = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);
    if (sock_fd < 0) {
        perror("Socket creation failed (run as root?)");
        exit(EXIT_FAILURE);
    }

    // 宛先アドレスを設定
    dest_addr.sin_family = AF_INET;
    if (inet_pton(AF_INET, argv[1], &dest_addr.sin_addr) <= 0) {
        perror("Invalid IP address");
        close(sock_fd);
        exit(EXIT_FAILURE);
    }

    // ICMP Echo Requestパケットを準備
    memset(packet, 0, sizeof(packet));
    icmp = (struct icmphdr *)packet;
    icmp->type = ICMP_ECHO;        // タイプ8: Echo Request
    icmp->code = 0;
    icmp->un.echo.id = getpid();   // プロセスIDを識別子として使用
    icmp->un.echo.sequence = 1;    // シーケンス番号
    for (int i = sizeof(*icmp); i < 64; i++) {
        packet[i] = i;             // ダミーデータでペイロードを埋める
    }
    icmp->checksum = 0;            // パケット作成後にチェックサムを計算
    icmp->checksum = checksum(packet, 64);

    printf("Pinging %s...\n", argv[1]);

    for (int i = 0; i < 4; i++) { // 4回pingを送信
        // 送信時間を記録
        clock_gettime(CLOCK_MONOTONIC, &start);

        // ICMP Echo Requestを送信
        if (sendto(sock_fd, packet, 64, 0, (struct sockaddr *)&dest_addr, sizeof(dest_addr)) < 0) {
            perror("Send failed");
            close(sock_fd);
            exit(EXIT_FAILURE);
        }

        // ICMP Echo Replyを受信
        struct sockaddr_in from_addr;
        socklen_t from_len = sizeof(from_addr);
        int bytes_received = recvfrom(sock_fd, recv_buffer, sizeof(recv_buffer), 0,
                                      (struct sockaddr *)&from_addr, &from_len);
        if (bytes_received < 0) {
            perror("Receive failed");
            continue;
        }

        // 受信時間を記録
        clock_gettime(CLOCK_MONOTONIC, &end);

        // 受信したIPおよびICMPヘッダーを解析
        struct iphdr *ip = (struct iphdr *)recv_buffer;
        struct icmphdr *icmp_reply = (struct icmphdr *)(recv_buffer + (ip->ihl * 4));
        if (icmp_reply->type == ICMP_ECHOREPLY && icmp_reply->un.echo.id == getpid()) {
            double rtt = (end.tv_sec - start.tv_sec) * 1000.0 +
                         (end.tv_nsec - start.tv_nsec) / 1000000.0;
            printf("%d bytes from %s: seq=%d time=%.2f ms\n",
                   bytes_received - (ip->ihl * 4), argv[1], icmp_reply->un.echo.sequence, rtt);
        } else {
            printf("Unexpected ICMP response: type=%d\n", icmp_reply->type);
        }

        sleep(1); // pingの間に1秒待機
        icmp->un.echo.sequence++; // シーケンス番号をインクリメント
        icmp->checksum = 0;
        icmp->checksum = checksum(packet, 64); // チェックサムを再計算
    }

    close(sock_fd);
    return 0;
}
```

---

### 動作の仕組み

1. **ソケット作成**:
   - `socket(AF_INET, SOCK_RAW, IPPROTO_ICMP)`はICMP用の生ソケットを作成します。これにより、ICMPパケットを手動で作成できます。

2. **ICMPパケット構築**:
   - ICMPヘッダー（`struct icmphdr`）は以下のように設定されます：
     - `type = ICMP_ECHO`（8）でEcho Request。
     - `code = 0`。
     - `id`はpingを識別するためにプロセスIDに設定。
     - `sequence`は個々のリクエストを追跡。
   - ペイロード（ダミーデータ）が追加され、チェックサムがパケット全体に対して計算されます。

3. **送信**:
   - `sendto()`はパケットを宛先IPに送信します。ICMPはトランスポート層より下で動作するため、ポートは不要です。

4. **受信**:
   - `recvfrom()`はICMP Echo Replyを含む生のIPパケットをキャプチャします。
   - IPヘッダー（`ihl * 4`バイト）をスキップしてICMPヘッダーに到達します。
   - それがEcho Reply（タイプ0）であり、私たちの`id`と一致するかどうかを確認します。

5. **タイミング**:
   - `clock_gettime()`はミリ秒単位でRTTを測定します。

6. **チェックサム**:
   - `checksum()`関数は、ICMPで要求される16ビットの1の補数和を計算します。

---

### コンパイルと使用方法
- コンパイル: `gcc ping.c -o ping`
- 実行（root権限）: `sudo ./ping 8.8.8.8`
- 出力例:
  ```
  Pinging 8.8.8.8...
  64 bytes from 8.8.8.8: seq=1 time=12.34 ms
  64 bytes from 8.8.8.8: seq=2 time=11.89 ms
  ...
  ```

---

### 注意点
- **Root権限**: 生ソケットはネットワークパケットを直接操作するため、`sudo`が必要です。
- **ファイアウォール**: ターゲットはICMP Echo Requestに応答する必要があります（一部のホストはこれをブロックします）。
- **簡略化**: このバージョンはすべてのエッジケース（例：タイムアウト、パケットロス、IPオプション）を完全には処理しません。

これは、ユーザースペースでICMPを扱う最も低レベルな方法です。これより下位では、IPスタックと直接対話するためにカーネルレベルのコードが必要になります。さらに調整したい場合はお知らせください！