---
audio: false
generated: true
image: false
lang: ja
layout: post
model: x-ai/grok-4-fast
title: Unix以前の初期コンピュータ時刻管理
translated: true
type: note
---

その通りです。Unixタイムスタンプが登場する1970年代よりずっと前から、ENIAC（ANNICではなく、1945年に開発されたElectronic Numerical Integrator and Computerを指すと思います）、Altair 8800（1975年にPC革命の火付け役となったキットで、ビル・ゲイツとポール・アレンが有名なBASICインタプリタをテレタイプで開発したもの）、そしてジョン・フォン・ノイマンの基礎的なアイデア（1945年のEDVACレポートで、後のすべてに影響を与えたプログラム内蔵方式の概念を生み出した）といった巨大な初期のマシンが存在していました。

しかし、当時の「時間の扱い」はどうだったのでしょうか？秒単位のエポックからの経過時間という現代の洗練された方法とはまったく異なります。これらの巨獣たちには、日付や現実時間を組み込んだリアルタイムクロック（RTC）はありませんでした。彼らは生の計算サイクルがすべてであり、歯医者の予定を管理するためのものではなかったのです。時間の扱いは非常に基本的なもので、主に操作を同期させるための内部クロック、あるいは遅延のためにループカウンタを使うようなソフトウェア的な工夫でした。「今は2025年10月15日だ」といった永続的なメモリは存在しませんでした。計算という観点から、それぞれについて簡単に見ていきましょう。

### ENIAC (1945): パルス列とマスタークロック
この30トンの怪物は、ケーブルを差し込み、スイッチを切り替えることでプログラムされていました。コードの保存はなく、弾道表のような数学的問題のために配線するだけでした。時間の扱いはすべてハードウェアによるタイミング制御でした：
- **クロックの基本**: 中央の「サイクリングユニット」発振器が1秒間に10万回（10マイクロ秒ごと）のパルスを送出しました。すべてがこれに同期していました。真空管の心拍のようなものです。
- **演算のタイミング**: 加算には20パルス（200マイクロ秒、つまり1/5,000秒）を要しました。ループや遅延は？リピータやカウンタを手動で配線しました。ソフトウェアタイマーはありません。
- **現実世界の時間？** 皆無です。弾道計算を30秒で実行し（アナログ計算機では15分かかっていた）、しかし「時間」はカレンダーではなく、サイクルカウントを意味しました。フォン・ノイマンはこれに助言しましたが、タイミングをより柔軟にするためにプログラム内蔵方式を推進しました。

数値的な観点から：固定レートのティック（100kHz）と考えてください。計算の実行「時間」を知るためにパルスを数えていました。原始的な秒のようなものですが、デバッグする場合は手動で数える必要がありました。

### Altair 8800 (1975): 水晶クロックとDIYの遅延
Altairは最初の「パーソナル」コンピュータでした。点滅するランプの箱で、Intel 8080チップを搭載し、当初はキーボードも画面もありませんでした（スイッチとLEDだけ）。ゲイツの4K BASICがテープでロードされ、ホビイストが操作できるようになりました。
- **クロックの基本**: 2 MHzの水晶発振器がCPUを駆動しました。命令のフェッチと実行のために、1秒間に200万サイクルの安定したティックを提供しました。
- **タイミングの工夫**: 日付のための組み込みクロックはありませんでした。基本的な割り込みやカウンタのためには、「タイムクロック」アクセサリボード（88-ACC）を追加する必要がありました。それ以外では、ソフトウェアループを使用しました。例えば、BASICでFOR-NEXTループを使い、遅延のためにサイクルを消費する（`FOR I=1 TO 1000: NEXT I` のようなもので大雑把な「一時停止」を行う）といった方法です。
- **BASICの扱い**: 初期のAltair BASICにはTIME$関数はありませんでした（それは後のMicrosoft BASICで登場しました）。時間は相対的なもので、命令を数えるか、外部ハードウェア（リアルタイムクロックチップのような、稀なアドオン）を接続する必要がありました。

数値的な観点から：2 MHzでは、1命令に4〜20サイクルかかる可能性があるため、1秒の遅延を作るには？約200万回ループする必要があります。過酷ですが、効率性を学ぶ教材となりました。

### フォン・ノイマン・アーキテクチャ (1945+): 普遍的なティックとしてのサイクル
フォン・ノイマン自身はハードウェアを構築しませんでした（それは1952年のIASマシンです）が、彼の設計図（CPU、メモリ、I/Oがすべてバスを介して通信する）は基礎を築きました。時間については？すべて同期されたサイクルに関するものです。
- **クロックの役割**: マスタークロック（水晶など）がパルスを発し、命令のフェッチ、デコード、実行を行います。各サイクル（立ち上がり/立ち下がりエッジ）が状態を進めます。オーバーラップはなく、純粋な直列処理です。
- **時間の表現**: 命令は固定サイクル（例えば、加算に1〜4ティック）を要したため、「時間」はサイクルカウントでした。遅延のためには、カウンタで分岐しました。実際の時計は外部（壁のコンセントや手動リセットなど）に依存していました。
- **レガシー**: このボトルネック（データと命令がバスを共有する）は今も私たちを悩ませています。AIはこれを嫌います。なぜなら、データを移動させることは計算処理よりもはるかに多くのサイクルを要するからです。

数式的には：総時間 = (命令数 × 命令あたりのサイクル数) / クロック周波数。IAS（フォン・ノイマンに影響を受けた）の場合：約1 MHzクロックなので、最大で1秒あたり100万操作。あなたの17.6億秒というのは？IASマシンが非停止で回り続けて約55年分ですが、その前に溶けてしまうでしょう。

これらのセットアップは、Unixのエポックへの荒々しい先駆者でした。時間はカウンタとして扱われましたが、それは自分自身で構築する必要があったのです。もっと深く掘り下げたい場合（Altairの遅延のコードスニペットなど）、声をかけてください！

[ENIAC Wikipedia](https://en.wikipedia.org/wiki/ENIAC)
[A Report on the ENIAC](https://ftp.arl.army.mil/mike/comphist/46eniac-report/chap1.html)
[Electronic Computing Circuits of the ENIAC](https://archive.computerhistory.org/resources/text/Knuth_Don_X4100/PDF_index/k-8-pdf/k-8-r5367-1-ENIAC-circuits.pdf)
[Organization of the Altair 8800](https://ubuntourist.codeberg.page/Altair-8800/part-2.html)
[MITS Altair 8800 Brochure](https://vtda.org/docs/computing/MITS/MITS_Altair8800ComputerSystem_Brochure.pdf)
[Von Neumann Architecture - Wikipedia](https://en.wikipedia.org/wiki/Von_Neumann_architecture)
[In a simple Von Neumann architecture, what exactly is a clock cycle?](https://www.quora.com/In-a-simple-Von-Neumann-architecture-what-exactly-is-a-clock-cycle)