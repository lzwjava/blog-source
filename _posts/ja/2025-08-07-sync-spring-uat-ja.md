---
audio: false
generated: true
image: false
lang: ja
layout: post
title: 同期春期UATブランチとコード
translated: true
type: note
---

以下は、3つのUATブランチを同期させ、履歴をクリーンに保ち、Springアプリで国別コードを扱うためのベストプラクティスとパターンのコレクションです。AIが役立つ場面についても少し紹介します。

---

## 1. ブランチ戦略と同期

1. **トランクベース開発と短命な機能ブランチ**

   * 単一の **main**（または **develop**）ブランチを維持します。
   * 各Jiraチケット（例：FT-103）と国ごとに、次のような名前の機能ブランチを作成します：

     ```
     feature/FT-103-cn
     feature/FT-103-sg
     feature/FT-103-tw
     ```
   * 作業が完了したら **main** にマージし、その後、各 `uat_cn`、`uat_sg`、`uat_tw` にチェリーピックまたはマージします。
   * メリット：mainへのマージは1回で完了し、各国ブランチは必要なものだけを取り込めます。

2. **UATブランチの定期的な同期**

   * 各 `uat_*` ブランチを `main` に毎日（またはビルドごとに）リベースするジョブをスケジュールし、ブランチが大きく乖離しないようにします。
   * CI（例：GitHub Actionで毎夜 `uat_cn` をリベース）で自動化します。

3. **プルリクエストとレビュー強制の活用**

   * 機能ブランチからmainへのすべてのマージにPRを必須とします。
   * ブランチ名とPRのタイトル/説明に「FT-xxx」チケットが含まれていることを確認します。

---

## 2. コミットメッセージ規約とスカッシュ

1. **JIRAキーを使用したコンベンショナルスタイル**

   ```
   FT-103: fix null-pointer in customer lookup
   ```

2. **マイクロコミット → マージ時にスカッシュ**

   * 機能開発中、開発者は随時コミットします：

     ```
     FT-103 #1: initial wiring of service beans
     FT-103 #2: add validation logic
     FT-103 #3: update error handling
     ```
   * PRマージ時には、「Squash and merge」を使用してすべてのFT-103コミットを1つの簡潔なコミットにまとめます：

     ```
     FT-103: customer-service validation and error handling
     ```

3. **チケット内での番号付け**

   * 同じチケット内で異なるステップを追跡する場合、開発中は番号付け（`#1`, `#2`）で問題ありません。
   * マージ後は、すべてを*単一の* FT-103コミットにスカッシュします。これにより履歴が整理され、各チケットが1つの論理的変更として記録されます。

4. **コミットリントの自動化**

   * GitフックまたはCIプラグイン（例：[commitlint](https://commitlint.js.org)）を使用して、すべてのメッセージの先頭に `FT-\d+` が含まれることを強制します。
   * 必要に応じてスコープを強制： `FT-103(sg): …`。

---

## 3. Springでの国別コードの扱い

1. **プロファイルと条件付きBean**

   * 国ごとにSpringプロファイルを定義： `@Profile("cn")`, `@Profile("sg")`, `@Profile("tw")`。
   * `application-cn.yml`、`application-sg.yml` などで、国別のプロパティを設定します。
   * 起動時に `--spring.profiles.active=cn`（またはsg, tw）を渡して、適切なBeanを選択します。

2. **ストラテジーパターン / プラグインモジュール**

   * `PaymentProcessor` インターフェースを作成し、3つの実装（`CnPaymentProcessor` など）を用意します。
   * `@Component` + `@Profile`、または実行時フラグに基づいてBeanを選択するファクトリを使用します。

3. **リソースバンドル / フィーチャーフラグ**

   * 差異が小さい場合（日付形式、エンドポイントURLなど）、コードパスは1つに保ち、差異はプロパティファイルまたはフィーチャーフラグサービスに外部化します。

4. **（大規模な場合の）モジュール分離**

   * ロジックが大きく異なる場合は、サブモジュールに分割します：

     ```
     /core
     /country-cn
     /country-sg
     /country-tw
     ```
   * メインアプリは、ビルド/デプロイ時にアクティブな国モジュールのみを取り込みます。

---

## 4. 担当者別とチケット別のタスク分離

* **担当者別ではなく、チケット別です。** タスクは人物ではなく、*機能*（Jira ID）を単位としてまとめるべきです。
* 複数の開発者がFT-103に取り組む場合、彼らは同じブランチで協力するか、そのブランチからトピックブランチを使用しますが、最終的には単一のFT-103ブランチにマージし戻します。
* 作成者メタデータはコミットのauthorフィールドに残り、作成者ごとにスカッシュする必要はありません。

---

## 5. AIの活用

1. **コミットメッセージ生成**

   * GitHub CopilotやOpenAIなどのツールは、diffからクリーンでコンベンショナルなコミットメッセージを提案できます。
   * `ai-commit --preview` を実行してレビュー用のメッセージ草案を作成するプリコミットフックを統合します。

2. **PR説明と変更履歴**

   * AIアシスタントを使用して、チケット下のすべてのコミットを首尾一貫したPR説明またはリリースノートに要約します：

     > 「feature/FT-103 の変更を箇条書きで要約してください。」

3. **コードレビュー支援**

   * AIを活用したリンター（SonarQube with AI plugins, DeepCode）は、国別コードパス内の問題を指摘できます。

4. **チェリーピック/リベースの自動化**

   * FT-103が `main` にマージされた際、各 `uat_*` に自動的にチェリーピックし、マージコンフリクトが発生した場合はPRを自動発行する、小さなスクリプト（またはローコードプラットフォーム）を作成します。

---

### 全体のまとめ

1.  `feature/FT-XXX-<cn/sg/tw>` で**開発**。
2.  JIRAキーを参照しながら**自由にコミット**（番号付きステップ可）。
3.  mainへの**PRを作成** → **Squash-and-merge**を選択し、各FT-XXXを1つのクリーンなコミットに。
4.  **CIジョブ**がそのコミットを自動的に各 `uat_cn`, `uat_sg`, `uat_tw` にリベース/マージ。
5.  実行時の**Springプロファイル**が正しい国別ロジックを選択 — 3つのブランチでコード重複なし。
6.  **AIツール**がコミットスタイルの強制、PRの要約、マージ管理を支援。

このワークフローは、履歴を整理し、各チケットがすべての環境で単一のコミットに追跡可能であることを保証し、Git履歴ではなく実行時に国別ロジックを分離し、AIを最も価値のある場面で活用します。