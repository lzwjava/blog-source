---
audio: false
generated: true
lang: ja
layout: post
title: DockerとKubernetes
translated: true
type: note
---

DockerとKubernetesはコンテナエコシステムにおいて補完的な技術ですが、異なる目的を果たします。それぞれの違いと関係性について詳しく見ていきましょう。

---

### Docker: コンテナ化プラットフォーム
**機能**: Dockerは、個々のコンテナを作成、実行、管理するためのツールです。コンテナはアプリケーションとその依存関係をパッケージ化した軽量で分離された環境です。

#### 主な特徴
1. **コンテナランタイム**:
   - Dockerはランタイム（例: `containerd` や `runc`）を使用し、Linuxカーネルの名前空間やcgroupsなどの機能に基づいてコンテナを実行します。
   - 単一コンテナのライフサイクル（ビルド、起動、停止など）を担当します。

2. **イメージ管理**:
   - Dockerは`Dockerfile`からイメージをビルドします。これはアプリ、ライブラリ、設定を定義します。
   - イメージはレジストリ（例: Docker Hub）に保存され、コンテナとして実行されます。

3. **シングルホスト焦点**:
   - Dockerは1台のマシン上でのコンテナ管理に優れています。複数のコンテナを実行できますが、複数ホスト間のオーケストレーションは組み込まれていません。

4. **CLI主導**:
   - `docker build`、`docker run`、`docker ps`などのコマンドでコンテナと直接対話できます。

#### ユースケース
- ラップトップやサーバー上で単一のSpring Bootアプリを実行する:
  ```bash
  docker run -p 8080:8080 myapp:latest
  ```

#### 制限
- ネイティブなマルチホストサポートなし。
- 自動スケーリング、自己修復、ロードバランシングなし。
- 多数のコンテナを手動で管理するのは煩雑。

---

### Kubernetes: コンテナオーケストレーションシステム
**機能**: Kubernetes（略してK8s）は、マシンのクラスター全体で複数のコンテナを管理およびオーケストレーションするプラットフォームです。コンテナ化アプリのデプロイ、スケーリング、運用を自動化します。

#### 主な特徴
1. **クラスタ管理**:
   - Kubernetesはノード（物理または仮想マシン）のクラスター上で実行されます。1つのノードが「コントロールプレーン」（クラスターの管理）であり、他は「ワーカーノード」（コンテナの実行）です。

2. **オーケストレーション**:
   - **スケジューリング**: リソースと制約に基づいて各コンテナを実行するノードを決定します。
   - **スケーリング**: コンテナインスタンスの数を自動的に増減します（例: CPU使用率に基づく）。
   - **自己修復**: 失敗したコンテナを再起動し、ノードがダウンした場合に再スケジュールし、望ましい状態が維持されるようにします。
   - **ロードバランシング**: 複数のコンテナインスタンス間でトラフィックを分散します。

3. **抽象化レイヤー**:
   - 最小単位として「Pod」を使用します。Podはストレージとネットワークリソースを共有する1つ以上のコンテナ（通常は1つ）を含むことができます。
   - 宣言型のYAMLファイル（例: デプロイメント、サービスの定義）で管理されます。

4. **マルチホスト焦点**:
   - 分散システム向けに設計され、多数のマシン間でコンテナを調整します。

5. **エコシステム**:
   - サービスディスカバリー、永続ストレージ、シークレット管理、ローリングアップデートなどの機能を含みます。

#### ユースケース
- 10のサービスそれぞれを独自のコンテナに含むマイクロサービスアプリを5台のサーバーにデプロイし、自動スケーリングとフェイルオーバーを実現:
  ```yaml
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: myapp
  spec:
    replicas: 3
    selector:
      matchLabels:
        app: myapp
    template:
      metadata:
        labels:
          app: myapp
      spec:
        containers:
        - name: myapp
          image: myapp:latest
          ports:
          - containerPort: 8080
  ```

#### 制限
- 学習曲線が急峻。
- 1台のマシン上の単純な単一コンテナアプリには過剰。

---

### 主な違い

| 観点                | Docker                              | Kubernetes                          |
|---------------------|-------------------------------------|-------------------------------------|
| **目的**           | コンテナの作成とランタイム      | コンテナオーケストレーション             |
| **スコープ**             | 単一ホスト                         | ホストのクラスター                    |
| **単位**              | コンテナ                           | Pod（1つ以上のコンテナのグループ）        |
| **スケーリング**           | 手動（例: `docker run`を複数回実行） | 自動（レプリカ経由）            |
| **ネットワーキング**        | 基本（ブリッジ、ホスト、オーバーレイ）       | 高度（サービス、Ingress）        |
| **自己修復**      | なし（手動再起動）               | 組み込み（再起動、再スケジュール）    |
| **管理**        | CLIまたは小規模設定用のDocker Compose | YAML設定、`kubectl` CLI         |
| **依存関係**      | スタンドアロン（Docker Engineが必要）    | コンテナランタイム（例: Docker）が必要 |

---

### 連携方法
- **ランタイムとしてのDocker**: Kubernetesはコンテナを直接実行しません。Pod内の個々のコンテナを起動および管理するために、Docker（または`containerd`などの代替手段）のようなコンテナランタイムに依存します。
- **ワークフロー**:
  1. Dockerイメージをビルド（`docker build -t myapp:latest .`）。
  2. レジストリにプッシュ（`docker push myapp:latest`）。
  3. Kubernetesがイメージをプルし、YAML設定に基づいてクラスター全体にデプロイ（`kubectl apply -f deployment.yaml`）。

- **例**: Kubernetesは、異なるノード上で`myapp:latest`の3つのインスタンスをDockerを使用して実行し、ロードバランシングされたサービス経由で公開するかもしれません。

---

### 例え
- **Docker**: キッチンで単一の料理を作るシェフ。シェフに何を作るか（`Dockerfile`）とどのように提供するか（`docker run`）を指示します。
- **Kubernetes**: 多くのキッチン（ノード）にまたがる複数のシェフ（Dockerインスタンス）を監督するレストランマネージャー。マネージャーは料理が時間通りに準備されることを保証し、ラッシュアワーにはスタッフを増員し、病気になったシェフを交代させます。

---

### 使い分け
- **Docker単体**: 開発、テスト、または1台のマシン上の単純なアプリ（例: 単一のSpring Bootアプリ）向け。
- **Kubernetes**: 高可用性、スケーリング、回復力が必要な本番グレードの分散アプリ（例: マイクロサービスアーキテクチャ）向け。

---

この説明で区別は明確になりましたか？KubernetesのセットアップやDocker Composeとの比較など、特定の側面をさらに探求したい場合はお知らせください！