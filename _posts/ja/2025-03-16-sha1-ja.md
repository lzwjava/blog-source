---
audio: false
generated: true
lang: ja
layout: post
title: SHA-1ハッシュ関数
translated: true
type: note
---

指定されたコードスニペット、特に以下の行がどのように動作するのか詳しく見ていきましょう：

```python
hash_obj = hashlib.sha1(piece)
hashes.append(hash_obj.hexdigest())
return hashes
```

ユーザーはライブラリを使用せずに説明するよう求めているので、まず `hashlib` ライブラリを使用したコードの動作を説明し、次に同じ機能をライブラリなしでどのように実現できるかを探ります。

---

### `hashlib` を使用したコードの理解

このスニペットは、データの断片に対するハッシュ値を計算し、それをリストに格納します。以下に、何が起こっているかを段階的に説明します：

1. **`hash_obj = hashlib.sha1(piece)`**
   - **動作**: この行はPythonの `hashlib` モジュールを使用してSHA-1ハッシュオブジェクトを作成します。SHA-1 (Secure Hash Algorithm 1) は、入力（ここでは `piece`）を受け取り、160ビット (20バイト) のハッシュ値を生成する暗号化ハッシュ関数です。
   - **入力**: `piece` は、ファイルや他のソースから読み取られたデータの塊（バイト列）です。
   - **処理**: `hashlib.sha1()` 関数はハッシュオブジェクトを初期化し、`piece` のデータで即座に更新します。データをハッシュ計算機に投入し、数値処理を開始するものと考えてください。

2. **`hashes.append(hash_obj.hexdigest())`**
   - **動作**: `hexdigest()` メソッドは、ハッシュオブジェクトによって計算されたハッシュ値を取得し、16進数文字列（0-9の数字とa-fの文字を使用した人間が読める形式）に変換します。
   - **出力**: SHA-1の場合、この文字列は40文字です。20バイトの各バイトが2桁の16進数で表現されるためです（例：バイト値255は "ff" になります）。
   - **格納**: 結果の文字列は `hashes` というリストに追加されます。このリストは、おそらく複数のデータ片に対するハッシュを集めています。

3. **`return hashes`**
   - **動作**: すべてのデータ片の処理後（このコードがループまたは関数内にあると仮定）、16進数ハッシュ文字列をすべて含むリスト `hashes` が返されます。

**要約**: 各データ `piece` に対して、コードは `hashlib.sha1()` を使用してそのSHA-1ハッシュを計算し、`hexdigest()` でハッシュを16進数文字列に変換し、`hashes` リストに格納します。その後、このリストが返されます。

---

### ライブラリを使用しない場合：スクラッチからのSHA-1計算

ユーザーの指示「ライブラリを使用しない」は、`hashlib` に依存せずにこの機能がどのように動作するかを理解したいことを示唆しています。SHA-1をスクラッチから実装するのは複雑ですが、プロセスを明確に説明し、構築の基盤となる簡略化されたバージョンを提供します。

#### SHA-1とは？
SHA-1は以下のようなハッシュ関数です：
- 任意の入力データ（例: `piece`）を受け取る。
- 固定長160ビット (20バイト) の出力を生成する。
- 入力を変換するために、一連のビット演算、回転、加算を使用する。

`hashlib` なしでは、このアルゴリズムを自分自身で再現する必要があります。指定されたコードに対してどのように動作するかを以下に示します：

#### 段階的なSHA-1プロセス

1. **入力の準備（パディング）**
   - SHA-1はデータを512ビット (64バイト) のブロック単位で処理します。`piece` が正確に64バイトでない場合、パディングを追加します：
     - `1` ビットを追加（例：バイトでは `0x80`）。
     - 長さが512を法として448ビット (56バイト) になるまで十分な `0` ビットを追加。
     - `piece` の元の長さ（ビット単位）を64ビット整数として追加。
   - 簡略化のため、`piece` が64バイト未満の場合は、1ブロックにパディングすると仮定します。

2. **ハッシュ値の初期化**
   - SHA-1は5つの32ビット変数（合計160ビット）を使用し、特定の定数で初期化します：
     - `h0 = 0x67452301`
     - `h1 = 0xEFCDAB89`
     - `h2 = 0x98BADCFE`
     - `h3 = 0x10325476`
     - `h4 = 0xC3D2E1F0`

3. **データブロックの処理**
   - 64バイトブロックを16個の32ビットワード（各4バイト）に分割。
   - 以下の式を使用して、これらを80ワードに拡張：
     ```python
     w[i] = left_rotate(w[i-3] ^ w[i-8] ^ w[i-14] ^ w[i-16], 1)  # for i = 16 to 79
     ```
     ここで `left_rotate` はビットを左にシフトし、ラップアラウンドします。
   - 80ラウンドにわたり、一時変数 `a`, `b`, `c`, `d`, `e` （`h0` から `h4` のコピーとして開始）を更新：
     - ラウンド番号（0-19、20-39など）に基づいて異なる関数と定数を使用。
     - 例（ラウンド0-19）：
       ```python
       f = (b & c) | (~b & d)
       k = 0x5A827999
       temp = (left_rotate(a, 5) + f + e + k + w[i]) & 0xFFFFFFFF
       ```
     - 変数をシフト: `e = d`, `d = c`, `c = left_rotate(b, 30)`, `b = a`, `a = temp`.

4. **ハッシュ値の更新**
   - 80ラウンド後、結果を初期ハッシュ値に加算：
     ```python
     h0 = (h0 + a) & 0xFFFFFFFF
     h1 = (h1 + b) & 0xFFFFFFFF
     # ... h2, h3, h4 についても同様
     ```

5. **16進数出力の生成**
   - `h0` から `h4` を160ビット値として連結し、40文字の16進数文字列に変換。

#### 簡略化されたPython実装

`hashlib` なしでコードを書き換える方法の基本的なバージョンを以下に示します：

```python
def left_rotate(value, shift):
    """32ビット整数を 'shift' ビットだけ左回転します。"""
    return ((value << shift) | (value >> (32 - shift))) & 0xFFFFFFFF

def custom_sha1(piece):
    """'piece' のSHA-1ハッシュを計算し、16進数文字列として返します。"""
    # 簡略化のため、piece が56バイト未満と仮定し、1ブロックにパディング
    message = piece + b'\x80' + (b'\x00' * (55 - len(piece))) + (len(piece) * 8).to_bytes(8, 'big')
    
    # ハッシュ値を初期化
    h0, h1, h2, h3, h4 = (
        0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0
    )
    
    # 16個の32ビットワードに分割
    w = [int.from_bytes(message[i:i+4], 'big') for i in range(0, 64, 4)]
    
    # 80ワードに拡張
    for i in range(16, 80):
        w.append(left_rotate(w[i-3] ^ w[i-8] ^ w[i-14] ^ w[i-16], 1))
    
    # 作業変数を初期化
    a, b, c, d, e = h0, h1, h2, h3, h4
    
    # 80ラウンドの処理
    for i in range(80):
        if 0 <= i < 20:
            f = (b & c) | (~b & d)
            k = 0x5A827999
        elif 20 <= i < 40:
            f = b ^ c ^ d
            k = 0x6ED9EBA1
        elif 40 <= i < 60:
            f = (b & c) | (b & d) | (c & d)
            k = 0x8F1BBCDC
        else:
            f = b ^ c ^ d
            k = 0xCA62C1D6
        
        temp = (left_rotate(a, 5) + f + e + k + w[i]) & 0xFFFFFFFF
        e = d
        d = c
        c = left_rotate(b, 30)
        b = a
        a = temp
    
    # ハッシュ値を更新
    h0 = (h0 + a) & 0xFFFFFFFF
    h1 = (h1 + b) & 0xFFFFFFFF
    h2 = (h2 + c) & 0xFFFFFFFF
    h3 = (h3 + d) & 0xFFFFFFFF
    h4 = (h4 + e) & 0xFFFFFFFF
    
    # 40文字の16進数文字列として返す
    return f"{h0:08x}{h1:08x}{h2:08x}{h3:08x}{h4:08x}"

# hashlib なしで書き換えたコード
def compute_hashes(pieces):
    hashes = []
    for piece in pieces:  # pieces がバイトチャンクのリストであると仮定
        hash_value = custom_sha1(piece)
        hashes.append(hash_value)
    return hashes

# 使用例
pieces = [b"hello", b"world"]
hashes = compute_hashes(pieces)
print(hashes)
```

#### 元のコードとの対応関係
- **`hash_obj = hashlib.sha1(piece)`**: `custom_sha1(piece)` に置き換えられ、SHA-1ハッシュを手動で計算します。
- **`hashes.append(hash_obj.hexdigest())`**: `custom_sha1` 関数は16進数文字列を直接返すので、それを `hashes` に追加します。
- **`return hashes`**: 同じまま、ハッシュ文字列のリストを返します。

---

### 主な違いと注意点
- **簡略化**: この実装は、各 `piece` が1つの512ビットブロック（パディングにより56バイト未満）に収まると仮定しています。完全なSHA-1実装では、複数ブロックを処理します。
- **パフォーマンス**: 手動実装は `hashlib` よりも遅く、最適化されていません。
- **信頼性**: `hashlib` のようなライブラリはテスト済みで安全です。カスタムバージョンは徹底的に検証しない限りバグがある可能性があります。

本質的に、元のコードはSHA-1ハッシュを効率的に計算する近道として `hashlib` を使用していますが、ライブラリなしで行うには、SHA-1アルゴリズム全体を手動でコーディングし、パディングを処理し、結果を16進数形式に変換する必要があります。ロジックは同じままです：各データ片を処理し、そのハッシュを計算し、格納し、コレクションを返します。