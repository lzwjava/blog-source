---
audio: false
generated: true
lang: ja
layout: post
title: データベースデッドロック
translated: true
type: note
---

**データベースデッドロック** は、2つ以上のトランザクションが互いにリソースのロック解除を待ち、循環依存が発生してすべてのトランザクションが進行不能になる状態です。データベース管理システム（DBMS）は通常この状況を検出し、いずれかのトランザクションをロールバックすることで解決します。以下にデッドロックの詳細な例を示します：

---

### 例：2つのトランザクション間のデッドロック
- **シナリオ**：
  - トランザクションT1が `Orders` テーブルの行を更新した後、`Customers` テーブルの行を更新する必要がある。
  - トランザクションT2が `Customers` テーブルの行を更新した後、`Orders` テーブルの行を更新する必要がある。
  - 両トランザクションが異なる順序でリソースをロックするため、デッドロックが発生する。

- **ステップバイステップ**：
  1. T1が `Orders` の行をロック。
  2. T2が `Customers` の行をロック。
  3. T1が `Customers` の行をロックしようとする（T2によってブロックされる）。
  4. T2が `Orders` の行をロックしようとする（T1によってブロックされる）。
  - 結果：どちらのトランザクションも進行不能となり、デッドロックが発生。

- **SQL例**：
  ```sql
  -- トランザクションT1
  BEGIN TRANSACTION;
  UPDATE Orders SET Status = 'Shipped' WHERE OrderID = 100;  -- OrderID 100をロック
  -- （何らかの遅延または処理）
  UPDATE Customers SET LastOrderDate = '2025-03-27' WHERE CustomerID = 1;  -- T2によってブロック

  -- トランザクションT2
  BEGIN TRANSACTION;
  UPDATE Customers SET Balance = Balance - 50 WHERE CustomerID = 1;  -- CustomerID 1をロック
  -- （何らかの遅延または処理）
  UPDATE Orders SET PaymentStatus = 'Paid' WHERE OrderID = 100;  -- T1によってブロック
  ```

- **発生する事象**：
  - T1は `OrderID = 100` の排他ロックを保持し、`CustomerID = 1` を待機。
  - T2は `CustomerID = 1` の排他ロックを保持し、`OrderID = 100` を待機。
  - この循環待機状態がデッドロックとなる。
  - DBMSがこれを検出（例：タイムアウトまたはデッドロック検出アルゴリズム）し、いずれかのトランザクション（例：T2）をロールバックしてT1を完了させる。

---

### デッドロックの視覚的表現
```
T1: Orders(100)ロック --> Customers(1)要求中
   |                               ↑
   |                               |
T2: Orders(100)要求中  <-- Customers(1)ロック
```

- **解決策**：DBMSは以下のようなエラーを出力する可能性がある：
  ```
  トランザクションT2は別のプロセスとロックリソースでデッドロックし、デッドロック被害者として選択されました。トランザクションを再実行してください。
  ```

---

### 発生原因
- **ロック順序**：T1とT2が異なる順序でロックを獲得（T1: Orders → Customers; T2: Customers → Orders）。
- **並行性**：両トランザクションが同時に実行され、重複するリソースを必要とする。
- **排他ロック**：更新には排他ロックが必要であり、他のトランザクションが同じデータにアクセスするのを防ぐ。

---

### デッドロック回避方法
1. **一貫したロック順序**：すべてのトランザクションが同じ順序でロックを獲得することを保証（例：常に `Orders` を `Customers` より先にロック）。
   ```sql
   -- T1とT2の両方がOrdersを最初にロックし、次にCustomersをロックする
   ```
2. **トランザクション時間の短縮**：トランザクション内の遅延を最小化し、重複の可能性を低減。
3. **低い分離レベルを使用**：適切な場合、より厳格でない分離レベル（例：Read Committed）を使用してロック時間を短縮。
4. **タイムアウト設定**：ロックのタイムアウトを短く設定して早期失敗と再試行を実現。

---

特定のDBMS（PostgreSQLやSQL Serverなど）での詳細な例や追加説明が必要な場合はお知らせください！