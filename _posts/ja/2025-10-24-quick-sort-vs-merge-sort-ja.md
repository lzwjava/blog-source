---
audio: false
generated: true
image: false
lang: ja
layout: post
model: x-ai/grok-4-fast
title: クイックソート対マージソート
translated: true
type: note
---

### クイックソートが難しいと感じる理由（そしてマージソートはそうではない）

あなたの感覚は正しいです。参照なしでクイックソートを一から実装するのは、油を塗った豚と格闘するようなものですが、マージソートは洗濯物を畳むようなもの：体系的で予測可能です。マージソートの「分割、統治、結合」の流れは線形的で、再帰もクリーンであり、マージのステップに驚きはありません。一方、クイックソートは*インプレース*で、選んだ基準点「ピボット」を中心に要素を交換する巧妙な分割のトリックに依存しています。最初は混沌と感じるでしょう。なぜならピボットが固定されておらず、ゲーム中にシャッフルされる審判のようなものだからです。しかし、一度直感がつかめれば、優雅で効率的です（平均 O(n log n)、最悪の場合（ピボットの選択が悪いと）O(n²)）。

クイックソートを自然な、物語のようなレンズで紹介しましょう：背の高さで本の乱雑な山を棚に整理することを想像してください。山を半分に分けて、すべてを測定し、マージする（それがマージソート）代わりに、1冊の本を「ベンチマーク」（ピボット）として選び、それより背の低い本をすべてその左に、背の高い本をすべてその右に再配置します。ピボットはその*最終的な*位置に収まり、あなたは左と右のサブ山のみを再帰的に処理します。余分なスペースは必要ありません。棚の上で交換するだけです。これはオランダの「クイックソート」の旗揚げ式（名前の由来）のようなもので、三つのグループ：より短い、ベンチマーク、より長い、に分割します。

### なぜ機能するのか：分割の魔法

クイックソートが機能する理由は、**保証付きの分割統治**だからです：すべての分割ステップで、*少なくとも1つの要素*（ピボット）が正しい最終位置に配置され、その分だけ問題が縮小されます。最良の場合、ピボットは配列を均等に分割し（マージソートの半分にするように）、バランスの取れた再帰をもたらします。最悪の場合（例えば、すでにソート済みの配列でピボット選択が悪い）、バブルソートのようにO(n²)に退化します—しかし、良いピボット選択により、実際には非常に高速になります。

重要な洞察：**分割は不変条件を強制します**。1回の分割後：
- ピボットの左側のすべての要素 ≤ ピボット
- ピボットの右側のすべての要素 ≥ ピボット
- ピボットはこれで永遠にソート済み—再び触れる必要はありません

これは進捗を保証します：再帰木の深さは平均的にせいぜい log n であり、各レベルでは合計 O(n) の作業（走査と交換）が行われます。

### ピボットの選び方（そして比較中にピボットが「移動する」理由）

ピボットは神聖なものではありません—単にベンチマークとして選んだ任意の要素です。悪い選択（例えば常に最初の要素）はバランスを崩す可能性があるため、単純なものから堅牢なものへ、自然な戦略の進展を示します：

1.  **単純：最初（または最後）の要素を選ぶ**
    - コーディングは簡単だが、リスクがある。ソート済み配列 `[1,2,3,4,5]` でピボット=1とすると、左は空、右は4要素—再帰が深く偏る。
    - 「移動」について：分割中、他のすべての要素をこのピボットの値と比較するが、要素はその位置の*周りで*交換する。ピボット自体は、境界がそれを横切るときに所定の位置に交換される。

2.  **より良い：中央の要素を選ぶ**
    - 一時的に最後尾と交換し、それをピボットとして使用。直感的にはよりバランスが取れている（中央値に近い）が、ソート済み/逆ソート入力に対して依然として脆弱。

3.  **実践向け最良：ランダムな要素を選ぶ**
    - 最後尾と交換し、分割する。ランダム性により悪いケースが平均化され、最悪ケースが起こりにくくなる（高い確率で、依然として O(n log n)）。これがほとんどのライブラリで使われている方法。

4.  **凝ったもの（面接用）：三つの中央値 (Median-of-three)**
    - 最初、中央、最後の要素の中央値をピボットとして選ぶ。計算が速く、一般的な落とし穴を回避。

コードでは、多くの場合、ピボットを最初に最後尾と交換して「固定」し、その*値*（位置ではない）を中心に分割し、その後、それが属する位置に戻します。これがピボットが「移動する」と感じられる理由です—それは静的ではなく、分割プロセスが2つのポインタ（左と右）を使って動的にその位置を見つけ出し、それらが互いに向かって跳び蛙のように進み、違反要素を交換するからです。

### 実践例：最後の要素をピボットとして [3, 7, 1, 9, 4] をソート

1回の分割ステップを順を追って見てみましょう。配列: `[3, 7, 1, 9, 4]`。ピボット = 最後 = 4。（必要に応じて交換します。）

- 左ポインタをインデックス0（値3）、右ポインタをインデックス3（値9、ピボットは4にあるため）から開始。
- 左から走査: 3 < 4? はい、そのまま。次、7 > 4? はい、しかし待つ—右側から最初に見つかった>4の要素と交換する。
- 実際には、標準的なLomuto分割（単純な1ポインタスタイル）：
  1. i = -1（< ピボットの境界）。
  2. j を 0 から n-2 まで（ピボットを除く）:
     - もし arr[j] ≤ ピボット (4) なら、arr[++i] と arr[j] を交換。（左側を成長させる。）
  3. 最後に、ピボットと arr[++i] を交換して配置。

ステップバイステップ：
- j=0: 3 ≤4? はい。 i=0, arr[0] と arr[0] を交換（変化なし）。配列: [3,7,1,9,4]
- j=1: 7 ≤4? いいえ。スキップ。
- j=2: 1 ≤4? はい。 i=1, arr[1] (7) と arr[2] (1) を交換。配列: [3,1,7,9,4]
- j=3: 9 ≤4? いいえ。スキップ。
- 終了: ピボット (4 at index 4) と arr[++i=2] (7) を交換。配列: [3,1,4,9,7]

これで：4（インデックス2）の左は [3,1]（両方 ≤4、未ソート）、右は [9,7]（両方 ≥4、未ソート）。ピボット=4は*完了*。左 [3,1] と右 [9,7] を再帰的に処理。

- 左: ピボット=1, 分割して [1,3] に。
- 右: ピボット=7, 分割して [7,9] に。

完全なソート: [1,3,4,7,9]。見えますか？各ステップで進捗が確定し、交換によってピボットが「移動」して所定の位置に収まります。

### 疑似コードのスケッチ（実装を容易にするために）

```
quicksort(arr, low, high):
    if low < high:
        pivot_idx = partition(arr, low, high)
        quicksort(arr, low, pivot_idx-1)
        quicksort(arr, pivot_idx+1, high)

partition(arr, low, high):  # Lomutoスタイル、ピボットはhighの位置
    pivot = arr[high]
    i = low - 1
    for j in low to high-1:
        if arr[j] <= pivot:
            i += 1
            swap arr[i], arr[j]
    swap arr[i+1], arr[high]
    return i+1
```

「移動」はこれらの交換で起こります：要素は互いに通り過ぎるように動き、ピボットが落ち着くまで続きます。紙の上で5-6個の要素で練習してみてください—一度分割が理解できれば、再帰は自然に感じられます。行き詰まったら、本を棚でソートする様子を頭の中でアニメーション化してみてください。

より深く掘り下げるには：  
[クイックソートの可視化](https://visualgo.net/en/sorting?slide=9)  
[CLRS クイックソートの章](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-20.html#%_sec_3.3)