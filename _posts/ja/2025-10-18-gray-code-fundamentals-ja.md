---
audio: false
generated: true
image: false
lang: ja
layout: post
model: x-ai/grok-4-fast
title: グレイコードの基礎と応用
translated: true
type: note
---

### グレイコードとは？

グレイコード（反射バイナリコードとも呼ばれる）は、**連続する（または隣接する）2つの値がちょうど1ビットのみ異なる**ように設計された2進数システムです。この特性により、ある数から次の数へ移動する際に変更が必要なビットが1つだけとなるため、遷移時のエラーを最小限に抑えます。これは以下のようなアプリケーションで特に有用です：
- **ロータリーエンコーダ**（例：ノブやホイールなどの機械的デバイスで、位置が徐々に変化する場合）
- デジタル通信における**エラー検出/訂正**
- ブール代数を簡略化するためのデジタル論理設計における**カルノー図**

隣接する数値が複数のビットで異なる可能性があり（「グリッチ」やエラーの原因となる）、標準的な2進コードとは異なり、グレイコードはスムーズなシングルビット遷移を保証します。

### グレイコードの仕組み
重要なルールは次のとおりです：**連続する2つのコードは、1ビットの位置のみが異なります**。

#### 簡単な例：2ビットグレイコードシーケンス（0から3の数値用）
標準バイナリとグレイコードの比較を以下に示します：

| 10進数 | 標準2進数 | グレイコード | 前からのビット差分                  |
|--------|-----------|--------------|-------------------------------------|
| 0      | 00        | 00           | (開始点)                            |
| 1      | 01        | 01           | 1ビット（最下位ビット）             |
| 2      | 10        | 11           | 1ビット（最下位ビット）             |
| 3      | 11        | 10           | 1ビット（最上位ビット）             |

- **標準2進数**では、1 (01) から 2 (10) への遷移で*2つ*のビットが反転します。これによりエラーが発生する可能性があります。
- **グレイコード**では、すべてのステップで*正確に1つ*のビットが反転します。これは「連続する2つのコードが1つだけ異なる」という記述と一致します。

#### グレイコードの生成
簡単なXOR演算を使用して、2進数をグレイコードに変換できます：
- Gray(n) = n XOR (n >> 1) (>> は1ビット右シフト)

例：
- 2進数 2 (10進数では10): 10 XOR 01 = 11 (2のグレイコード)
- 元に戻すには： Binary(n) = Gray(n) XOR (Gray(n) >> 1)

このパターンは任意のビット数（例：3ビット、4ビットなど）に拡張でき、常にシングルビット差分の特性を維持します。

特定のユースケースがある場合、またはより多くのビットの例が必要な場合は、お知らせください！