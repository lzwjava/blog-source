---
audio: false
generated: true
image: false
lang: ja
layout: post
model: x-ai/grok-4-fast
title: カルノー図による最小化の例
translated: true
type: note
---

### カルノー図の使用例：3変数ブール関数の最小化

カルノー図を使用してブール式を単純化する実践的な例を見てみましょう。出力が最小項 m(1, 2, 4, 7) で 1 となる 3変数関数 (A, B, C) を使用します。これは以下を意味します：

- f(A, B, C) = A'B'C + A'BC' + AB'C' + ABC

目標は、これを可能な限り少ない項（およびリテラル）に最小化することです。これにより、回路内の論理ゲートの数が削減されます。

#### ステップ 1: Kマップの作成
3変数のKマップは 2x4 のグリッドです（行を AB、列を C とします）。行はグレイコード順 (00, 01, 11, 10) でラベル付けされ、隣接するセルが 1 ビットのみ異なることを保証します。最小項に対応するセルに 1 を配置します：

| AB \ C | 0     | 1     |
|--------|-------|-------|
| **00** | 0     | 1 (m1) |
| **01** | 1 (m2) | 0     |
| **11** | 0     | 1 (m7) |
| **10** | 1 (m4) | 0     |

(ここで、m1 = A'B'C, m2 = A'BC', m4 = AB'C', m7 = ABC。)

#### ステップ 2: 隣接する 1 のグループ化
最小化の鍵は、（トーラスのように端を巻き込むことも含む）隣接する 1 の可能な限り大きなグループ（長方形または正方形）を見つけることです。各グループのサイズは 2 の累乗 (1, 2, 4, 8 など) でなければなりません。グループは重複しても構いません。

- **グループ 1**: 左列の 2 つの 1 (m2 と m4) は垂直のペアを形成します。これらは A'B'C' を共有... いや違う—ビットを分析: m2 (010) と m4 (100) は A と B のみが異なりますが、グレイコードでは、行 01 と 10 は隣接しています。このグループは A が変化することをカバーするので、B'C' となります (A はドントケア)。
- **グループ 2**: 右列の 2 つの 1 (m1 と m7) は、巻き込まれた垂直ペアを形成します（行 00 と 11 は直接隣接していません、待って—実際にはこのマップでは、より良いグループ化: m1 (001) と m2 (010) が行 00-01 で水平隣接？いや、修正しましょう。

明確にするために再プロット—実際には、これらの最小項に対する最適なグループ：

- 水平ペア: m1 (行00 列1) と m2 (行01 列0)？いいえ、隣接していません。
これらの最小項に対する標準的なグループ化：
- クワッド？いいえ。ペア：
  - m1 と m2？ m1=001, m2=010 — 2ビット異なり、隣接しない。
  より良い: m2 (010) と m4 (100) — A と B が異なる？ 010 と 100 は A (0 から 1) と B (1 から 0) が異なり、2ビット — 隣接しない。

グループが明確にわかるように、より良い例を選びました。

**明確化のための修正例**: f(A, B, C) = Σ m(0, 1, 2, 4, 5, 6) = A'B'C' + A'B'C + A'BC' + AB'C' + AB'C + ABC' を使用しましょう。

Kマップ：

| AB \ C | 0     | 1     |
|--------|-------|-------|
| **00** | 1 (m0) | 1 (m1) |
| **01** | 1 (m2) | 0 (m3) |
| **11** | 1 (m6) | 0 (m7) |
| **10** | 1 (m4) | 1 (m5) |

最小項: 0(000),1(001),2(010),4(100),5(101),6(110) — はい m3(011)=0, m7(111)=0。

したがって表：

| AB \ C | 0     | 1     |
|--------|-------|-------|
| **00** | 1     | 1     |
| **01** | 1     | 0     |
| **11** | 1     | 0     |
| **10** | 1     | 1     |

#### ステップ 3: グループの識別
1 をグループ化します：

- **大きなグループ (4つの1)**: 左列全体 (C=0): m0, m2, m6, m4。これらはすべて C=0 であり、AB が変化するセルです—列内ですべて隣接しています（行は巻き込まれます）。これは **C'** をカバーします (C が 0 なので、A と B はドントケア)。
- **ペアグループ (2つの1)**: 上行右 (m0 と m1？ m0 列0, m1 列1 — 行 00 の水平ペア: A'B' (C はドントケア)。
- しかし m1 (001) はまだカバーされていませんか？待って、上行: m0 と m1 は水平方向に隣接しており、A'B' (C は変化) をカバーします。
- また、下行右 m5 (101 列1 行10) — しかし m1 と m5 をカバーするには？それらは列1にあり、行 00 と 10 は隣接している（巻き込まれる）ので、列1の垂直ペア: m1 と m5、AC をカバー（待って、ビット: 001 と 101 = A はドントケア、B=0, C=1？ 001 B=0 C=1, 101 A=1 B=0 C=1 — はい B'C。

最小化するために、すべての 1 を最大サイズのグループでカバーする、非重複または最小限のカバーグループを選択します。

最適：
- グループ 1: 列0の4セル垂直: C' をカバー (そこにあるすべての 1: m0,m2,m4,m6 → 項: C')
- グループ 2: 行00の2セル水平: m0 と m1 → A'B'
- グループ 3: 列1 行10 と 00 の巻き込まれた2セル垂直？待って、行 00 と 10 は列1に対して隣接: m1(001) と m5(101) → A のみが異なるので、B'C (A はドントケア)。

m5 はカバーされ、m1 もカバーされます。

注: m0 はグループ1とグループ2の両方に含まれますが、それで構いません—重複は許可されます。

#### ステップ 4: 最小化された式の導出
各グループは積項（共通リテラルのAND）になります：
- グループ 1 (C'): **C'**
- グループ 2 (A'B'): **A' B'**
- グループ 3 (B' C): **B' C**

したがって、最小化されたSOP (積和標準形): f = C' + A'B' + B'C

確認: これは 3 項 (元の 6 に対して)、より少ないリテラル (4 対 12)、より単純な回路 (基本的に 3 つの AND/OR ゲート) です。

真理値表にプロットして、元の 1 と一致することを確認できます。

#### これが最小化される理由
- **隣接ルール**: 変数が 1 ビットのみ変化する場所でのみグループ化し、その項がその変数を無視することを保証します（ドントケア = マップ内の -）。
- **最大優先**: 大きなグループ = 項内の変数が少ない = より単純。
- **すべての 1 をカバー**: 1 を残さない。0 は 0 のままにします（それらをグループ化しない）。
- より多くの変数の場合 (4変数Kマップは 4x4)、プロセスは同じですが、視覚的に難しくなります。

この例は、カルノー図が代数的操作なしで、最小項の和を迅速にコンパクトな形に変換する方法を示しています。4変数以上ではソフトウェアを使用しますが、2-3変数の例で練習することで直感が養われます。

[Digital Logic Design Basics](https://www.allaboutcircuits.com/textbook/digital/chpt-7/karnaugh-mapping/)