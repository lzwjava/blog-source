---
audio: false
generated: true
lang: ja
layout: post
title: スプリングの内部仕組み
translated: true
type: note
---

Spring とその内部動作について詳しく見ていきましょう。Spring は Java アプリケーションを構築するための堅牢なフレームワークであり、お問い合わせの各部分について明確な説明を交えながら順を追って説明します。

### Spring はどのように動作するのか？
Spring は **制御の反転 (IoC)** の原則に基づいて動作します。これは、アプリケーションコードがオブジェクトの作成と管理を制御するのではなく、Spring がその役割を引き受けることを意味します。これは **IoC コンテナ** と呼ばれるコンポーネントを通じて行われます。IoC コンテナは以下の責任を負います：

- オブジェクト（Spring では Bean と呼ばれる）の**インスタンス化**
- 指定に基づいた**設定**
- 依存関係を管理することによる**組み立て**

このアプローチにより、コード内の密結合が減少し、よりモジュール化され、保守が容易になります。

### Spring はどのように Bean を管理するのか？
Spring において、**Bean** とは IoC コンテナによって管理されるオブジェクトです。以下に Spring がそれらを処理する方法を示します：

1.  **定義**: Bean は以下のいずれかで定義します：
    - **XML 設定ファイル**
    - `@Bean`, `@Component`, `@Service` などのアノテーションを使用した **Java ベースの設定**
2.  **作成**: アプリケーション起動時に、IoC コンテナはこれらの定義を読み取り、Bean を作成します。
3.  **依存性の注入 (DI)**: Spring は、必要な場所に依存関係（他の Bean）を自動的に注入します。これには以下を使用します：
    - **コンストラクタインジェクション**
    - **セッターインジェクション**
    - **フィールドインジェクション** (`@Autowired` 経由)

コンテナはこれらの Bean のライフサイクル全体（作成から破棄まで）を管理し、必要とされる時に確実に利用可能にします。

### Service と Controller の違い
**Spring MVC** (Spring の Web フレームワーク) の文脈において、これら 2 つのコンポーネントは異なる目的を果たします：

-   **Controller**:
    - ユーザーからの **HTTP リクエスト** を処理します。
    - 入力を処理し、ビジネスロジックを呼び出し、どの**ビュー**（例：Web ページ）を返すかを決定します。
    - `@Controller` または `@RestController` でアノテーションされます。
    - **Web レイヤー** に存在します。

-   **Service**:
    - アプリケーションの**ビジネスロジック**をカプセル化します。
    - 計算、データ処理、データベースとの連携などのタスクを実行します。
    - `@Service` でアノテーションされます。
    - **ビジネスレイヤー** に存在します。

**例**:
-   コントローラは、ユーザーのプロファイルを表示するリクエストを受け取り、ユーザーデータを取得するためにサービスを呼び出すかもしれません。
-   サービスはデータベースからデータを取得し、それをコントローラに返します。コントローラはそれをビューに送信します。

要約すると：**コントローラは Web インタラクションを管理**し、**サービスは中核的な機能を処理**します。

### Spring は何を提供するのか？
Spring は、エンタープライズアプリケーション向けの幅広いツールを提供する包括的なフレームワークです。主な機能は以下の通りです：

-   **依存性の注入**: オブジェクトの依存関係の管理を簡素化します。
-   **アスペクト指向プログラミング (AOP)**: ロギングやセキュリティなどの横断的関心事を追加します。
-   **トランザクション管理**: 操作全体でのデータの一貫性を保証します。
-   **Spring MVC**: 堅牢な Web アプリケーションを構築します。
-   **Spring Boot**: 事前設定されたデフォルトと組み込みサーバーによるセットアップを簡素化します。
-   **Spring Data**: データベースアクセスを効率化します。
-   **セキュリティ**: 認証および認可ツールを提供します。

Spring のモジュール設計により、必要な機能のみを選択して使用できます。

### Spring はどのようにオブジェクトや Bean を探すのか？
Spring アプリケーションが起動すると：

1.  **IoC コンテナ** が初期化されます。
2.  コンテナは以下の場所で **Bean 定義** をスキャンします：
    - XML ファイル。
    - アノテーションが付いたクラス（例: `@Component`, `@Bean`）。
3.  コンテナは Bean を作成し、それらを名前または型でインデックス化された **マップ** に格納します。
4.  Bean が必要とされると（例：注入または直接取得のために）、コンテナは以下を使用してそれを提供します：
    - **名前による検索**
    - **型による検索**（例: `@Autowired` 経由）

このプロセスにより、Bean がアプリケーション全体で確実に利用可能になります。

### Tomcat や Netty をサーバーとして使用する方法は？
Spring の拡張である Spring Boot は、サーバーをアプリケーションに直接組み込むことでサーバー設定を簡素化します。以下に、**Tomcat** および **Netty** での動作方法を示します：

-   **Tomcat** (Servlet ベース):
    - Spring Boot の `spring-boot-starter-web` 依存関係におけるデフォルトのサーバーです。
    - これを `pom.xml` に追加します：
        ```xml
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        ```
    - Spring Boot は Tomcat を組み込み、アプリケーションはスタンドアロン実行可能 JAR として動作します。

-   **Netty** (非 Servlet ベース):
    - リアクティブ Web アプリケーション（例: Spring WebFlux を使用）で使用されます。
    - Tomcat を除外し、Netty を追加することで置き換えます：
        ```xml
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>
        ```
    - Spring Boot は代わりに Netty を組み込み、非同期の非ブロッキング I/O をサポートします。

サーバーは `application.properties` で設定します（例：ポートを `server.port=8080` で設定）。外部サーバーへのデプロイは不要で、Spring Boot がすべて処理します。

### まとめ
-   **Spring の核心**: オブジェクト管理に IoC コンテナを使用。
-   **Bean 管理**: XML またはアノテーションで定義され、依存関係は自動的に注入。
-   **Service 対 Controller**: サービスはビジネスロジックを処理、コントローラは Web リクエストを管理。
-   **機能**: DI, AOP, Web サポートなどを提供。
-   **Bean 検索**: コンテナが設定から Bean を見つけて提供。
-   **サーバー**: Spring Boot は依存関係を簡単に変更するだけで Tomcat または Netty を組み込む。