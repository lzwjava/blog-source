---
audio: false
generated: true
lang: ja
layout: post
title: 'Prolog: 論理ベース宣言型プログラミング'
translated: true
type: note
---

Prologは「Programming in Logic」の略称であり、Python、Java、C++などの命令型言語とは対照的な**宣言型プログラミング言語**です。コンピューターに問題の解決方法を段階的に指示する代わりに、問題が*何であるか*を記述すると、Prologは組み込みの推論エンジンを使用して解決策を見つけます。

これは**論理、記号的推論、知識表現**を含む問題に特に適しており、人工知能（AI）、自然言語処理、エキスパートシステムの分野における基盤となっています。

### Prologの主要な概念:

1.  **事実:**
    事実は、Prologに提供する世界に関する基本的な真実です。無条件の主張を表します。

      * **構文:** `述語(引数1, 引数2, ...).`
      * **例:**
          * `男性(ジョン).` (ジョンは男性です)
          * `女性(メアリー).` (メアリーは女性です)
          * `親(ジョン, メアリー).` (ジョンはメアリーの親です)
          * `首都(フランス, パリ).` (パリはフランスの首都です)

2.  **規則:**
    規則は、事実間の関係を定義します。ある事実が、他の1つ以上の事実（または条件）が真である場合に真であると述べます。

      * **構文:** `頭部 :- 本体.` (「本体が真ならば頭部は真である」と読む)
          * `頭部`は単一の述語です。
          * `本体`は1つ以上の述語の連言で、カンマ（`,`）で区切られ、「AND」を意味します。
      * **例:**
          * `幸せ(X) :- 好き(X, ピザ).` (Xがピザを好きならば、Xは幸せです)
          * `父親(X, Y) :- 親(X, Y), 男性(X).` (XがYの親であり、かつXが男性ならば、XはYの父親です)
          * `祖父母(G, C) :- 親(G, P), 親(P, C).` (GがPの親であり、かつPがCの親ならば、GはCの祖父母です)

3.  **クエリ:**
    事実と規則（「知識ベース」）を定義した後、クエリと呼ばれる質問をPrologに行うことで、情報を取得したり関係を検証したりできます。

      * **構文:** `?- クエリ.`
      * Prologは、確立された事実と規則に基づいてクエリを真にする変数を見つけることで、クエリを満たそうと試みます。複数の解決策が存在する場合、セミコロン（`;`）を入力することでPrologにさらに多くの解決策を促すことができます。
      * **例:**
          * `?- 男性(ジョン).` (ジョンは男性ですか？)
          * `?- 親(ジョン, X).` (ジョンは誰の親ですか？ - `X`は変数です)
          * `?- 祖父母(エリザベス, ウィリアム).` (エリザベスはウィリアムの祖父母ですか？)

4.  **変数:**
    Prologの変数は未知の値を表すために使用されます。常に大文字またはアンダースコア（`_`）で始まります。命令型言語の変数とは異なり、再代入可能なメモリ位置ではなく、Prologがクエリを満たすために値と統一しようとするプレースホルダーです。

5.  **単一化:**
    これはPrologの核心的なメカニズムです。単一化は、変数に値を割り当てることで2つの項を同一にしようとするパターンマッチングのプロセスです。マッチが見つかると、変数はそれらの値に「束縛」されます。マッチが不可能な場合、単一化は失敗します。

6.  **バックトラック:**
    Prologがクエリを満たそうとするとき、深さ優先で事実と規則を処理します。ある経路が行き止まり（目標が満たされない）に達すると、Prologは以前の選択点まで「バックトラック」し、別の経路を試みます。この体系的な検索により、クエリに対するすべての可能な解決策を見つけることができます。

### Prologの動作（簡略化）:

1.  Prologプログラム（事実と規則の集合）をインタープリターに読み込みます。
2.  クエリを提示します。
3.  Prologは、その事実と規則の頭部に対してクエリを照合することで、クエリを証明しようと試みます。
4.  規則の頭部が一致すると、Prologはその規則の本体にある条件（これらは副目標になります）を証明しようと試みます。
5.  このプロセスは、すべての副目標が事実または正常に証明された規則によって満たされるまで再帰的に続きます。
6.  解決策が見つかると、Prologは変数の束縛を提示します。複数の解決策が存在する場合、バックトラックしてそれらを見つけることができます。

### Prologの利点:

  * **宣言型の性質:** *どのように*解決するかではなく、*何を*解決するかに焦点を当てます。これにより、特定の問題に対してより簡潔で読みやすいコードになる可能性があります。
  * **組み込みの論理と推論:** 論理的推論と検索のための強力なメカニズム。
  * **記号的AIに優れる:** エキスパートシステム、自然言語処理、知識表現、定理証明に理想的です。
  * **パターンマッチングと単一化:** 複雑なデータ操作を簡素化します。
  * **バックトラック:** 解決策の検索を自動化します。これは他の言語では手動でプログラミングする必要があります。

### Prologの欠点:

  * **学習曲線:** 宣言型パラダイムは、命令型プログラミングに慣れている人にとっては困難かもしれません。
  * **パフォーマンス:** 数値計算やI/O集約型タスクでは、命令型言語と比較して効率が劣る可能性があります。
  * **限られたI/Oとグラフィックス:** 複雑なユーザーインターフェースやグラフィカルアプリケーション用には設計されていません。
  * **デバッグ:** バックトラックによる実行フローのトレースは、時に複雑になることがあります。

-----

### Prologコード例:

これらの例を実行するには、Prologインタープリター（無料で広く使用されているSWI-Prologなど）が必要です。通常、コードを`.pl`拡張子（例: `family.pl`）のファイルに保存し、インタープリターに読み込みます。

**例1: 家族関係**

基本的な家族関係を定義してみましょう。

**`family.pl`:**

```prolog
% 事実: 基本的な関係を定義
男性(ジョン).
男性(ジム).
男性(ジョージ).
女性(メアリー).
女性(リサ).
女性(スーザン).

親(ジョン, リサ).   % ジョンはリサの親
親(ジョン, ジム).    % ジョンはジムの親
親(メアリー, リサ).   % メアリーはリサの親
親(メアリー, ジム).    % メアリーはジムの親
親(リサ, ジョージ). % リサはジョージの親
親(ジム, スーザン).   % ジムはスーザンの親

% 規則: 派生した関係を定義
父親(X, Y) :- 親(X, Y), 男性(X).         % XがYの親であり、かつXが男性ならば、XはYの父親。
母親(X, Y) :- 親(X, Y), 女性(X).        % XがYの親であり、かつXが女性ならば、XはYの母親。
子供(X, Y) :- 親(Y, X).                    % YがXの親ならば、XはYの子供。
祖父母(G, C) :- 親(G, P), 親(P, C). % GがPの親であり、かつPがCの親ならば、GはCの祖父母。
兄弟姉妹(X, Y) :- 親(P, X), 親(P, Y), X \= Y. % XとYが同じ親Pを共有し、かつXとYが同じでないならば、XとYは兄弟姉妹。
```

**Prologインタープリター（例: SWI-Prolog）での実行:**

```prolog
?- consult('family.pl').
% family.pl compiled 0.00 sec, 7 clauses
true.

% クエリ:

?- 男性(ジョン).
true.

?- 女性(ジム).
false.

?- 親(ジョン, リサ).
true.

?- 親(X, ジム). % ジムの親は誰ですか？
X = ジョン ;           % さらに解決策を得るには ';' を入力
X = メアリー.
false.

?- 父親(ジョン, リサ).
true.

?- 母親(メアリー, ジム).
true.

?- 祖父母(ジョン, ジョージ).
true.

?- 祖父母(X, スーザン). % スーザンの祖父母は誰ですか？
X = ジョン ;
X = メアリー.
false.

?- 兄弟姉妹(リサ, ジム).
true.

?- 兄弟姉妹(リサ, ジョージ).
false. % なぜなら、彼らは*すべての*親を共有していないから
```

**例2: 簡単な知識ベース（動物）**

**`animals.pl`:**

```prolog
% 動物とその特性に関する事実
動物(犬).
動物(猫).
動物(鳥).
動物(魚).

毛皮がある(犬).
毛皮がある(猫).
飛ぶ(鳥).
泳ぐ(魚).

食べる(犬, 骨).
食べる(猫, 魚).
食べる(鳥, 種).
食べる(魚, プランクトン).

% 規則
哺乳類(X) :- 動物(X), 毛皮がある(X). % 哺乳類とは、動物であり毛皮があるものです。
飛べる(X) :- 動物(X), 飛ぶ(X).     % 飛べるとは、動物であり飛ぶものです。
```

**Prologインタープリターでの実行:**

```prolog
?- consult('animals.pl').
% animals.pl compiled 0.00 sec, 10 clauses
true.

% クエリ:

?- 動物(猫).
true.

?- 毛皮がある(犬).
true.

?- 食べる(猫, X). % 猫は何を食べますか？
X = 魚.

?- 哺乳類(犬).
true.

?- 哺乳類(鳥).
false.

?- 飛べる(X). % どの動物が飛べますか？
X = 鳥.
false.
```

これらの例は、Prologの宣言型の性質を示しています。関係と特性を定義すると、システムがクエリへの答えを推論します。