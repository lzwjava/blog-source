---
audio: false
generated: true
image: false
lang: ja
layout: post
model: x-ai/grok-4-fast
title: 赤黒木の概要
translated: true
type: note
---

### 赤黒木とは？

**赤黒木**は、コンピュータサイエンスにおいてデータを効率的に保存・取得するために使用される、自己平衡二分探索木（BST）の一種です。挿入と削除の後も木がほぼ平衡状態を保つようにすることで、検索、挿入、削除操作の時間計算量を O(log n)（n はノード数）に保証します。

#### 主な特性
赤黒木は、以下の5つの規則を強制することで平衡を保ちます：
1.  **ノードの色**: すべてのノードは赤か黒のいずれかです。
2.  **ルートノード**: ルートは常に黒です。
3.  **リーフノード**: すべての NIL (null) リーフは黒です。
4.  **赤の子規則**: 赤のノードが赤の子を持つことはできません（赤が連続してはいけません）。
5.  **黒高さ規則**: 任意のノードからその子孫のリーフまでのすべての経路は、同じ数の黒ノードを持ちます（これにより平衡が保証されます）。

これらの規則により、木が（連結リストのように）偏って性能が O(n) に劣化するのを防ぎます。

#### 仕組み
-   **挿入**: 標準的な BST の挿入のように開始します。新しいノードが規則に違反する場合（例: 親子がともに赤）、「回転」（左右の回転による再構築）と「色の変更」を実行して修正します。これにより高さが対数的に保たれます。
-   **削除**: 挿入と同様ですがより複雑で、置換ノードを見つけ、色の変更や回転を行って特性を維持します。
-   **検索**: BST と同一です。キーの比較に基づいて左右を走査します。

回転は、BST の特性を保ちながら平衡を修正する局所的な操作です。

#### 視覚的な例
キー 10, 20, 30, 40, 50 に対する平衡な赤黒木の簡単な Markdown 表現です（R = 赤, B = 黒）：

```
       B(30)
      /     \
   B(20)    B(40)
  /   \       \
R(10) R(25)  R(50)
```

#### 利点
-   **AVL 木との比較**: 赤黒木は、挿入/削除時の回転数を少なくするためにわずかな不平衡を許容するため、動的データ（例: Java の TreeMap、Linux カーネルで使用）に対する実践的な速度が速くなります。
-   **トレードオフ**: 完全に平衡な木よりもわずかに高くなりますが、実装は比較的シンプルです。

より深く知りたい場合は、Python (sortedcontainers ライブラリ経由) や C++ (std::set) などの言語での実装を確認してください。コード例や詳細な情報が必要な場合は、お知らせください！