---
audio: false
generated: true
image: false
lang: ja
layout: post
model: x-ai/grok-4-fast
title: KMPアルゴリズムによる効率的な文字列検索
translated: true
type: note
---

### Knuth-Morris-Pratt (KMP) アルゴリズムの理解

あなたの直感は正しいです：KMPは文字列検索において**部分一致を無駄にしない**ことにあります。より長いテキスト（例："ababcabc"）内でパターン（例："abc"）を探すとき、単純な方法では不一致が発生するたびに最初からやり直すため非効率です。KMPは、既にどれだけパターンが一致していたかを「記憶」し、冗長な比較を避けて前方にジャンプします。これにより超高速に—線形時間 O(n + m)（nはテキスト長、mはパターン長）—なります。

簡単な例でステップバイステップで説明します。テキスト `T = "ababababc"` 内でパターン `P = "abab"` を検索します（位置0と2に出現します）。

#### ステップ1: 問題と単純なアプローチ
- **目標**: `T` 内で `P` が完全に一致する開始位置をすべて見つける。
- **単純な方法**: `P` を `T` 上でスライドさせ、文字ごとに比較する。`P` の位置 i で不一致の場合、`P` を1つシフトし、`P` の最初から再試行する。
  - この例の場合:
    - T[0]開始: "a"=="a" (一致), "b"=="b" (一致), "a"=="a" (一致), "b"=="b" (一致) → 0で発見。
    - T[1]にシフト: "b"=="a"? いいえ → `P` を最初から再開。無駄！
    - T[2]: "a"=="a", "b"=="b", "a"=="a", "b"=="b" → 2で発見。
    - T[3]: "a"=="a", "b"=="b", "a"=="a", "b"=="a"? いいえ → 再開。
    - 以下同様。`P` の文字0へのバックトラックが多発。

最悪の場合（例："aaaaa...a" 内で "aaa...ab" を検索）、これは O(n*m) になり得ます。

#### ステップ2: KMPの核心となるアイデア – 接頭辞テーブル（または「失敗関数」）
KMPはパターン `P` に対してテーブル `π` (pi) を事前計算します。このテーブルは、`P` 内の各位置 i について、**`P[0..i]` の最長の真の接頭辞であって接尾辞でもあるもの**を教えます。言い換えると：「ここで不一致が起きた場合、この重複する接頭辞にジャンプすることで、部分一致のどれだけを再利用できるか？」

- **真の接頭辞/接尾辞**: 文字列全体ではない接頭辞/接尾辞（例："aba" の場合、接頭辞 "a" が接尾辞 "a" と一致）。
- なぜか？ これにより、不一致時にパターンを1以上「スライド」させ、再開する代わりに重複部分を再利用できます。

`P = "abab"` の場合:
- `π` を段階的に構築します（すぐにコード化します）。

| 位置 i | P[0..i] | 最長の真の接頭辞 = 接尾辞 | π[i] |
|--------|---------|---------------------------|------|
| 0      | "a"     | なし（単一文字）          | 0    |
| 1      | "ab"    | なし                      | 0    |
| 2      | "aba"   | "a" (接頭辞 "a" == 接尾辞 "a") | 1    |
| 3      | "abab"  | "ab" (接頭辞 "ab" == 接尾辞 "ab") | 2  |

- π[2] = 1 は：「"aba" が一致したが次の文字で不一致の場合、接頭辞 "a"（長さ1）がここまで一致したと見なす」ことを意味します。
- π[3] = 2 は：完全な "abab" に対して、"ab" の重複があることを意味します。

#### ステップ3: 接頭辞テーブル (π) の構築
これは O(m) 時間で行われます。`P` をそれ自身に対して検索するような、類似のロジックを使用します。

擬似コード:
```
def compute_prefix_function(P):
    m = len(P)
    pi = [0] * m
    k = 0  # 現在の接頭辞-接尾辞一致の長さ
    for i in range(1, m):
        while k > 0 and P[k] != P[i]:
            k = pi[k-1]  # 前の重複部分にジャンプ（再利用！）
        if P[k] == P[i]:
            k += 1
        pi[i] = k
    return pi
```

- π[0] = 0 で開始。
- 各 i=1 から m-1 まで:
  - 現在の一致長 k を拡張しようと試みる。
  - 不一致の場合、π[k-1] にフォールバック（無駄にせず—事前の重複部分を再利用）。
  - 一致の場合、k++。

"abab" の場合:
- i=1: P[0]='a' != P[1]='b' → k=0, π[1]=0。
- i=2: P[0]='a' == P[2]='a' → k=1, π[2]=1。
- i=3: P[1]='b' == P[3]='b' → k=2, π[3]=2。

#### ステップ4: 接頭辞テーブルを使用した検索
次に、`T` を `P` と `π` で検索します:
- 変数 `q` = 現在の状態（ここまで一致した接頭辞の長さ）を保持。
- `T` の各文字について:
  - 不一致かつ q>0 の間、q = π[q-1] を設定（賢くジャンプバック）。
  - 一致の場合、q++。
  - q == m の場合、発見！その後 q = π[q-1] として重複部分の継続検索を行う。

擬似コード:
```
def kmp_search(T, P):
    n, m = len(T), len(P)
    if m == 0: return []
    pi = compute_prefix_function(P)
    q = 0
    matches = []
    for i in range(n):
        while q > 0 and P[q] != T[i]:
            q = pi[q-1]
        if P[q] == T[i]:
            q += 1
        if q == m:
            matches.append(i - m + 1)  # 開始位置
            q = pi[q-1]  # 次の検索のための重複部分
    return matches
```

`T = "ababababc"`, `P = "abab"` の場合:
- i=0: 'a'=='a' → q=1
- i=1: 'b'=='b' → q=2
- i=2: 'a'=='a' → q=3
- i=3: 'b'=='b' → q=4 == m → 位置0で一致, q=π[3]=2
- i=4: 現在 q=2, T[4]='a' == P[2]='a' → q=3
- i=5: 'b'=='b' → q=4 == m → 位置2で一致, q=2
- i=6: q=2, 'a'=='a' → q=3
- i=7: q=3, 'b' == P[3]='b' → q=4 == m → 位置4で一致, q=2
- i=8: 'c' != P[q=2]='a'? → while: q=π[1]=0 → P[0]='a' != 'c' → q=0

結果: 一致位置 [0, 2, 4]

ご覧の通り、不一致時（もしあった場合）には、q=0 にする代わりに q=π[q-1] とジャンプします。

#### なぜ魔法のように感じるか
- `T` 内でのバックトラックなし—前方にのみ進む。
- 不一致のための「while」ループは合計で償却 O(1) 回実行される。なぜなら各ジャンプは q を減少させ、q は最大 n 回しか増加しないから。

#### 自分で試してみよう: シンプルなPythonコード
```python
def compute_prefix_function(P):
    m = len(P)
    pi = [0] * m
    k = 0
    for i in range(1, m):
        while k > 0 and P[k] != P[i]:
            k = pi[k - 1]
        if P[k] == P[i]:
            k += 1
        pi[i] = k
    return pi

def kmp_search(T, P):
    n, m = len(T), len(P)
    if m == 0: return []
    pi = compute_prefix_function(P)
    q = 0
    matches = []
    for i in range(n):
        while q > 0 and P[q] != T[i]:
            q = pi[q - 1]
        if P[q] == T[i]:
            q += 1
        if q == m:
            matches.append(i - m + 1)
            q = pi[q - 1]
    return matches

# テスト
T = "ababababc"
P = "abab"
print(kmp_search(T, P))  # 出力: [0, 2, 4]
```

これを実行し—P/Tを変更してqのジャンプを確認してみてください（qのためのprintを追加しても可）。

#### よくある落とし穴とヒント
- π[0] は常に 0。
- 自己重複のないパターン（例："abc"）の場合、π はすべて 0—単純な方法に戻る。
- DNA配列やコードオートコンプリートに最適。
- まだわかりにくい場合、πを「状態機械」として視覚化：各状態は一致した長さ、一致/不一致による遷移。

これで理解できるはずです—事前計算された重複部分による賢いスキップに過ぎません。もしあなたを悩ませている具体的な例があれば、共有してください！

[GeeksforGeeks: KMP Algorithm](https://www.geeksforgeeks.org/dsa/kmp-algorithm-for-pattern-searching/)  
[Wikipedia: Knuth–Morris–Pratt Algorithm](https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm)