---
audio: false
generated: false
image: false
lang: ja
layout: post
title: 機械学習入門 － PyTorch編
translated: true
type: post
---

```markdown
この投稿は元々中国語で書かれました。他の言語への翻訳を容易にするために英語に翻訳されています。

---

## PyTorch

インストールしましょう。これはPythonバージョン`3.9`をサポートしています。

```shell
$ pip install torch torchvision
Collecting torch
  Downloading torch-1.8.0-cp39-none-macosx_10_9_x86_64.whl (120.6 MB)
     |████████████████████████████████| 120.6 MB 224 kB/s
Collecting torchvision
  Downloading torchvision-0.9.0-cp39-cp39-macosx_10_9_x86_64.whl (13.1 MB)
     |████████████████████████████████| 13.1 MB 549 kB/s
Requirement already satisfied: numpy in /usr/local/lib/python3.9/site-packages (from torch) (1.20.1)
Collecting typing-extensions
  Downloading typing_extensions-3.7.4.3-py3-none-any.whl (22 kB)
Requirement already satisfied: pillow>=4.1.1 in /usr/local/lib/python3.9/site-packages (from torchvision) (8.0.1)
Installing collected packages: typing-extensions, torch, torchvision
Successfully installed torch-1.8.0 torchvision-0.9.0 typing-extensions-3.7.4.3
```

動作確認をしましょう。

```python
import torch
x = torch.rand(5, 3)
print(x)
```

エラーが発生しました。

```shell
Traceback (most recent call last):
  File "torch.py", line 1, in <module>
    import torch
  File "torch.py", line 2, in <module>
    x = torch.rand(5, 3)
AttributeError: partially initialized module 'torch' has no attribute 'rand' (most likely due to a circular import)
```

このエラーメッセージを検索したところ、ファイル名が`torch`と同じであったため、名前の競合が発生していたことがわかりました。ファイル名を変更したところ、正常に動作するようになりました。

```shell
tensor([[0.5520, 0.9446, 0.5543],
        [0.6192, 0.0908, 0.8726],
        [0.0223, 0.7685, 0.9814],
        [0.4019, 0.5406, 0.3861],
        [0.5485, 0.6040, 0.2387]])
```

例を見てみましょう。

```python
# -*- coding: utf-8 -*-

import torch
import math
dtype = torch.float
device = torch.device("cpu")
# device = torch.device("cuda:0") # GPUで実行する場合はコメントを外す

# ランダムな入力と出力データを作成
x = torch.linspace(-math.pi, math.pi, 2000, device=device, dtype=dtype)
y = torch.sin(x)

# 重みをランダムに初期化
a = torch.randn((), device=device, dtype=dtype)
b = torch.randn((), device=device, dtype=dtype)
c = torch.randn((), device=device, dtype=dtype)
d = torch.randn((), device=device, dtype=dtype)

learning_rate = 1e-6
for t in range(2000):
    # 順伝播: 予測yを計算
    y_pred = a + b * x + c * x ** 2 + d * x ** 3

    # 損失を計算して表示
    loss = (y_pred - y).pow(2).sum().item()
    if t % 100 == 99:
        print(t, loss)

    # 逆伝播: 損失に対するa, b, c, dの勾配を計算
    grad_y_pred = 2.0 * (y_pred - y)
    grad_a = grad_y_pred.sum()
    grad_b = (grad_y_pred * x).sum()
    grad_c = (grad_y_pred * x ** 2).sum()
    grad_d = (grad_y_pred * x ** 3).sum()

    # 勾配降下法で重みを更新
    a -= learning_rate * grad_a
    b -= learning_rate * grad_b
    c -= learning_rate * grad_c
    d -= learning_rate * grad_d
print(f'結果: y = {a.item()} + {b.item()} x + {c.item()} x^2 + {d.item()} x^3')
```

実行してみましょう。

```shell
99 1273.537353515625
199 849.24853515625
299 567.4786987304688
399 380.30291748046875
499 255.92752075195312
599 173.2559814453125
699 118.2861328125
799 81.72274780273438
899 57.39331817626953
999 41.198158264160156
1099 30.41307830810547
1199 23.227672576904297
1299 18.438262939453125
1399 15.244369506835938
1499 13.113286972045898
1599 11.690631866455078
1699 10.740333557128906
1799 10.105220794677734
1899 9.6804780960083
1999 9.39621353149414
結果: y = -0.011828352697193623 + 0.8360244631767273 x + 0.002040589228272438 x^2 + -0.09038365632295609 x^3
```

`numpy`ライブラリのみを使用したコードを見てみましょう。

```python
# -*- coding: utf-8 -*-
import numpy as np
import math

# ランダムな入力と出力データを作成
x = np.linspace(-math.pi, math.pi, 2000)
y = np.sin(x)

# 重みをランダムに初期化
a = np.random.randn()
b = np.random.randn()
c = np.random.randn()
d = np.random.randn()

learning_rate = 1e-6
for t in range(2000):
    # 順伝播: 予測yを計算
    y_pred = a + b * x + c * x ** 2 + d * x ** 3

    # 損失を計算して表示
    loss = np.square(y_pred - y).sum()
    if t % 100 == 99:
        print(t, loss)

    # 逆伝播: 損失に対するa, b, c, dの勾配を計算
    grad_y_pred = 2.0 * (y_pred - y)
    grad_a = grad_y_pred.sum()
    grad_b = (grad_y_pred * x).sum()
    grad_c = (grad_y_pred * x ** 2).sum()
    grad_d = (grad_y_pred * x ** 3).sum()

    # 重みを更新
    a -= learning_rate * grad_a
    b -= learning_rate * grad_b
    c -= learning_rate * grad_c
    d -= learning_rate * grad_d

print(f'結果: y = {a} + {b} x + {c} x^2 + {d} x^3')
```

これらは計算を実行する2つの異なる方法です。

これらの例では、まずxとyの値のセットが生成されます。次に、3次方程式であると仮定されます。その後、いくつかの方法で係数を反復的に計算します。これらのアルゴリズムは何でしょうか？ループが`2000`回繰り返され、各反復で精度が向上することに注目してください。詳細はここでは触れません。

## 最後に

現在、機械学習の背後にある計算方法を理解していません。しかし、今のところそれは重要ではありません。上記の知識があれば、すでに多くのことができます。機械学習はテキストや音声の処理にも使用できます。何十もの例を探索した後で理論を学んでも遅くはありません。

## 演習

* 生徒は上記のように探索してください。
```