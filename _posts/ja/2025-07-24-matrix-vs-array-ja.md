---
audio: false
generated: true
lang: ja
layout: post
title: 行列と多次元配列
translated: true
type: note
---

プログラマーがこの2つを区別するのに役立つ、簡単なメンタルモデルを紹介します。

---

### 1  共通する核となる考え方

* **グリッド状のストレージ** – 数学的な行列と多次元配列は、どちらも複数の整数インデックス（行/列、または行/列/…/k）によって要素を整理します。
* **インデックスによるアクセス** – `A[i][j]` のような座標の組を使って要素にアクセスします（行列 → 2つのインデックス、一般的な配列 → 任意の数のインデックス）。
* **一括操作** – スカラー値ではなくブロックとして考えることで、ベクトル化されたコードやループベースのコード、キャッシュに優しいメモリレイアウト、GPUの使用などが促進されます。

---

### 2  違いが生じる点

**a. 目的と意味論**

*行列*

* 純粋に**数学的**な概念：すべての要素は体（ℝ, ℂ, …）に属する数値です。
* 組み込みの代数（加算、スカラー倍、行列式、逆行列、固有値など）を持ちます。
* 形状は常に2次元です。「3階のテンソル」は行列とは呼ばれません。

*多次元配列*

* **プログラミングにおけるコンテナ**：数値かどうかに関わらず、任意のデータ型を格納できます。
* 固有の代数はありません。操作は自分でコードを書く（またはライブラリが提供する）ものになります。
* 階数は任意です：1次元（ベクトル）、2次元、5次元… 不規則な構造（ジャグ配列）も可能です。

**b. 実装の詳細**

*行列ライブラリ* (NumPy `ndarray`, MATLAB, Eigen, BLASなど)

* 通常、**行優先順序と列優先順序**に注意を払います。これは代数カーネルのパフォーマンスに影響するためです。
* 先頭次元、ストライド、三角行列/圧縮形式などのメタデータを保持することがあります。
* 演算子をオーバーロードしており、`C = A @ B` が高性能な行列乗算をトリガーします。

*一般的な配列* (C言語の配列, Javaの配列, Rustのスライス, Pythonのリストのリスト)

* メモリレイアウトは言語に依存します：連続的、ポインタの配列、あるいは（Pythonのリストのように）断片化されていることもあります。
* 自動的な代数演算はありません。2つの2次元配列を乗算するには、ネストしたループを書くか、数学ライブラリを呼び出す必要があります。
* 動的型付け言語では、スパース（疎）、ジャグ、または混合型にすることができます。

**c. 典型的な操作**

*行列* – ドット積、LU分解/QR分解、連立一次方程式の求解、特異値分解、機械学習における勾配、グラフィックス変換。

*多次元配列* – 何にでも使用可能：RGBA画像のピクセル、3次元ボクセルの世界、文字列のルックアップテーブル、ゲームの盤面の状態。

---

### 3  コードでの類推

```python
# 行列としての視点 (NumPy)
import numpy as np
A = np.array([[1, 2],
              [3, 4]])          # 2×2 行列
B = np.array([[5, 6],
              [7, 8]])
C = A @ B                       # 行列乗算 (代数を意識)
detA = np.linalg.det(A)         # 行列式

# 純粋な多次元配列としての視点 (標準Python)
table = [[1, 2], [3, 4]]        # リストのリスト
value = table[1][0]             # 3
# 乗算？ 明示的なループまたは内包表記が必要
product = [[sum(table[i][k]*B[k][j] for k in range(2))
           for j in range(2)] for i in range(2)]
```

---

### 4  要約

* **同じ形状、異なる意味:** 行列は、2次元の数値配列「に」線形代数の法則の束が付随したものです。多次元配列は、単なるインデックス付きのコンテナであり、それ以上でもそれ以下でもありません。
* 実際には、行列を多次元配列の「中に」格納し、ライブラリに依存してそれらに行列としての意味論と速度を与えることがよくあります。