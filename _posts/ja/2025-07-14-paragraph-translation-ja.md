---
audio: false
generated: false
image: false
lang: ja
layout: post
title: パラグラフベースのマークダウンを使用した翻訳コストの最適化
translated: true
type: post
---

私のJekyllブログは、段落を書くためにMarkdownを使用しています。英語で書いた後、DeepSeekやMistralのようなAIツールを使って8つの他の言語に翻訳します。それらはすでに安価ですが、改善の余地があります。

時々、単語や段落を編集した後、投稿全体が8つの言語に翻訳されます。この場合、トークン使用量が高くなります。編集した段落だけを再翻訳すれば、トークン使用量は低くなります。特に長い投稿の場合です。

しかし、私はMarkdownを使ってアイデアを記録したいと考えています。データベースを使って投稿を維持・更新するのは不便です。YAMLやJSONを使うのは煩雑かもしれません。

重要なのは、編集前後のテキストの違いを特定することです。段落ベースのアプローチを使う場合、改行文字"\n"でテキストを分割することを意味します。

編集後の段落のうち、どれが変更されたか、どれが変更されていないかを知る必要があります。編集前後のテキスト間で段落の一対一のマッピングを確立する必要があります。

段落ベースのアプローチを使うのは、AIモデルによって作成された翻訳を更新したいからです。文ベースを使うと、正確性が低くなるかもしれません。

Markdownの場合、Markdown要素に基づいて翻訳を同期させるためにMarkdown解析を使用することがより重要かもしれません。

しかし、コードブロックや特殊なMarkdown構文がない場合は、段落ベースのアプローチを使用できます。

簡単な段落ベースのアプローチでは、2つの段落の配列があり、それらがどのように対応するかを知る必要があります。

これらの2つの配列の任意の段落を比較すると、2つの結果が考えられます：同じか、異なるかです。異なる場合、いくつかのケースがあります：両方が新しく追加された、左側が新しく追加された、右側が新しく追加された。

私はコストを削減したいだけなので、トークン使用量を減らすことを目指しています。他には何も必要ありません。各段落を翻訳し、結果をキャッシュし、次回は各段落についてまず翻訳結果を検索します。存在しない場合は、再翻訳する必要があります。

Markdownの場合、少し複雑です。コードブロックを翻訳したくありません。そのため、Markdown解析ライブラリを使用して、コードブロックと通常のテキストを異なる方法で扱うことができます。

数週間後、私はPythonとGrokを使ってこれを実装する予定です。実際の問題なので、解決する必要があります。

キャッシュファイルに関する1つの設計は、キャッシュディレクトリに`lang.json`のようなファイルを保存することです。例えば、`zh.json`などです。