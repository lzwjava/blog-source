---
audio: false
generated: true
image: false
lang: ja
layout: post
model: x-ai/grok-4-fast:free
title: JavaCCのソースとクラスの場所
translated: true
type: note
---

### JavaCC 概要
JavaCC (Java Compiler Compiler) は、文法仕様ファイル (.jj ファイル) から Java ソースコード (例: パーサークラス) を生成するツールです。**直接** バイトコード (.class ファイル) にコンパイルするわけではありません。それは `javac` のような標準の Java コンパイラによって処理されます。プログラム的に JavaCC を使用して (例: IDE やランタイム環境で) 動的コードを生成およびコンパイルする場合、出力場所はその設定方法に依存します。標準的な JavaCC の動作と一般的な使用パターンに基づいて、ステップバイステップで説明します。

### JavaCC がソースファイルを生成する場所
- **デフォルトの出力場所**: JavaCC は生成された `.java` ファイルを**現在の作業ディレクトリ** (指定がない場合は "output" サブディレクトリ) に出力します。これは、コマンドラインオプション `-OUTPUT_DIRECTORY=<パス>` を使用するか、コード内で呼び出す場合は `JavaCCOptions` クラスを介してプログラム的に上書きできます。
- **コマンドライン使用例**:
  ```
  javacc -OUTPUT_DIRECTORY=/path/to/generated MyGrammar.jj
  ```
  これは、`.java` ファイル (例: `Token`, `Parser`, `ParseException`) を `/path/to/generated` に作成します。
- **プログラムでの使用**: Java アプリケーション内から JavaCC を呼び出す場合 (例: `org.javacc.JavaCC.main()` または類似の API を使用)、出力パスを指定するオプションを設定できます。ソースファイルは、さらにコンパイルが必要な単なるプレーンな `.java` ファイルです。

これは、生成されたクラスがバイトコードではなくソースコードとして指定されたディレクトリに出力されると述べている、公式の JavaCC ドキュメント (例: SourceForge 上のレガシー JavaCC プロジェクトや Maven ベースのディストリビューション) と一致しています。

### 生成されたコードをコンパイルした場合のコンパイル済みクラスの保存場所
JavaCC 自体は `.class` ファイルにコンパイルしません。これは手動で行うか、コード内で自動化する必要があります。次に起こることを以下に示します:

- **手動コンパイル**: 生成された `.java` ファイルに対して `javac` を使用します:
  ```
  javac -d /path/to/classes MyGeneratedParser.java
  ```
  - `-d` フラグは `.class` ファイルの出力ディレクトリを指定します。多くの場合、`classes/` フォルダやプロジェクトのビルドターゲット (例: Maven/Gradle の `target/classes/`) です。
  - 一般的な場所: ビルドシステム (例: Ant, Maven) に応じて、`bin/`, `build/classes/`, `target/classes/` など。

- **コード内での動的コンパイル**: ランタイムで JavaCC を使用して動的コード用のパーサーを生成する場合 (例: スクリプト解釈やオンザフライパーシング)、一般的には以下を行います:
  1. プログラム的に `.java` ファイルを生成します (例: `System.getProperty("java.io.tmpdir")` のような一時ディレクトリに書き込みます)。
  2. Java Compiler API (javax.tools.JavaCompiler) や Janino のようなライブラリを使用してそれらをコンパイルします。
     - 例: コンパイル出力を `new File("generated/classes")` のようなカスタムディレクトリに設定します。
     - コンパイルされた `.class` ファイルはそのディレクトリに保存されます。ランタイムでは、カスタム ClassLoader を使用してそこから、またはメモリバッファからそれらをロードします。
  - **JVM デフォルト**: カスタムパスがない場合、クラスはビルドツールを使用している場合はデフォルトの `target/classes` に、またはコンパイルタスクで指定した任意のディレクトリに行く可能性があります。

- **一般的な動的シナリオ**:
  - **メモリ内コンパイル**: Compiler API のようなライブラリは、ディスクに書き込むことなくコンパイルを可能にし、`ClassLoader.defineClass()` を介してバイトコードをメモリに保存します。物理的な保存は発生しません。
  - **一時保存**: 生成されたコードがコンパイルされ永続化される場合、Unix 系システムでは `/tmp/` や一時フォルダに置かれることが多いです。本番アプリでは、プロジェクトのファイルシステム内の専用の `generated/` や `cache/` ディレクトリを使用してください。
  - **フレームワーク**: ANTLR (JavaCC の代替) やカスタムランナーのようなツールはこれを自動化し、クラスを RAM やクラスパスフォルダ (例: `CLASSPATH` エントリ) に保存する可能性があります。

### 主な考慮事項とベストプラクティス
- **ランタイム安全性**: コードを動的にコンパイルすることにはリスク (例: セキュリティ問題) が伴います。ユーザー生成の文法はサンドボックス化されていることを確認してください。
- **ビルドツール統合**: Maven や Gradle を使用する場合、JavaCC プラグイン (例: `javacc-maven-plugin`) は、ソースを `target/generated-sources/javacc/` に、コンパイルされたクラスを `target/classes/` に出力します。これは `pom.xml` や `build.gradle` で設定可能です。
- **デバッグ**: コンパイルが失敗した場合、JavaCC のエラー出力やログを確認してください。生成されたファイルは通常、グローバルではなく、アプリが実行されている場所に保存されます。
- **ドキュメントからの証拠**: JavaCC の公式ガイド (javacc.github.io やレガシードキュメント) によると、出力はディレクトリベースであり、コンパイル後の処理はユーザーが管理します。GitHub リポジトリ内の実際の例 (例: JavaCC 使用法の検索) は、`src/main/generated/` のようなカスタム出力ディレクトリを示しています。

これがあなたの設定 (例: 特定のフレームワークや IDE) と一致しない場合は、コードスニペットや環境などの詳細を提供してください。そうすれば、回答を改良できます！