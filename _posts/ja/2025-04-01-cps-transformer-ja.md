---
audio: false
generated: true
lang: ja
layout: post
title: CPS変換器
translated: true
type: note
---

```scheme
;; 適切な末尾再帰を行い、if式に対してコンテキストの重複を防ぐシンプルなCPS変換器
;; 作者: Yin Wang (yw21@cs.indiana.edu)
(load "pmatch.scm") ; Scheme用パターンマッチングライブラリを読み込み、様々な式構造を扱いやすくする

(define cps
  (lambda (exp)
    (letrec
        ([trivial? (lambda (x) (memq x '(zero? add1 sub1)))] ; 与えられたシンボルが基本演算子（zero?, add1, sub1）かどうかをチェック。これらは変換時に特別扱いされる
         [id (lambda (v) v)] ; 恒等関数。トップレベル式の初期継続として使用
         [ctx0 (lambda (v) `(k ,v))]      ; 末尾コンテキスト。現在の継続'k'を値'v'に適用する継続を作成。現在の呼び出しが末尾位置にある場合に使用
         [fv (let ([n -1]) ; 新規変数名を生成するジェネレータ
               (lambda ()
                 (set! n (+ 1 n))
                 (string->symbol (string-append "v" (number->string n)))))]
         [cps1
          (lambda (exp ctx) ; CPS変換を実行するコア再帰関数。式'exp'と継続'ctx'を引数に取る。継続は'exp'の評価結果をどう処理するかを表す
            (pmatch exp ; パターンマッチングを使用して式の構造を解析
              [,x (guard (not (pair? x))) (ctx x)] ; 基本ケース: 式'x'がペアでない場合（リテラルまたは変数）、すでに値であることを意味する。現在の継続'ctx'をこの値に適用

              [(if ,test ,conseq ,alt) ; test、conseq、altを持つ'if'式にマッチ
               (cps1 test ; test式を再帰的に変換
                     (lambda (t) ; test式の継続。testの結果（真偽値）を't'として受け取る
                       (cond
                        [(memq ctx (list ctx0 id)) ; 現在のコンテキスト'ctx'が末尾コンテキスト'ctx0'または初期恒等コンテキスト'id'の場合、'if'式自体が末尾位置にあることを意味する
                         `(if ,t ,(cps1 conseq ctx) ,(cps1 alt ctx))] ; この場合、'if'式はCPS変換後のコードでも'if'式のまま。conseqとaltは同じコンテキスト'ctx'でCPS変換される。これによりコンテキストの重複を防ぐ
                        [else ; 現在のコンテキストが末尾コンテキストでない場合、'if'式の結果が何らかの計算に渡される必要があることを意味する
                         (let ([u (fv)]) ; 'if'式の結果を保持するための新規変数名'u'を生成
                           `(let ([k (lambda (,u) ,(ctx u))]) ; 結果'u'を受け取り元のコンテキスト'ctx'を適用する新しい継続'k'を作成
                              (if ,t ,(cps1 conseq ctx0) ,(cps1 alt ctx0))))])))] ; 'if'式は新しい継続'k'を導入する'let'でラップされる。conseqとaltは末尾コンテキスト'ctx0'でCPS変換される。それらの結果は直ちに'k'に渡される

              [(lambda (,x) ,body) ; 単一引数'x'と本体bodyを持つラムダ式にマッチ
               (ctx `(lambda (,x k) ,(cps1 body ctx0)))] ; ラムダ式は追加引数'k'（継続）を取る新しいラムダ式に変換される。元のラムダの本体は末尾コンテキスト'ctx0'でCPS変換される。その結果はこの継続'k'に渡される

              [(,op ,a ,b) ; 二項演算子'op'と二つの被演算子'a'、'b'を持つ式にマッチ
               (cps1 a ; 第一被演算子'a'を再帰的に変換
                     (lambda (v1) ; 'a'の継続。結果'v1'を受け取る
                       (cps1 b ; 第二被演算子'b'を再帰的に変換
                             (lambda (v2) ; 'b'の継続。結果'v2'を受け取る
                                   (ctx `(,op ,v1 ,v2))))))] ; 元のコンテキスト'ctx'を演算子'op'とCPS変換された被演算子の結果'v1'、'v2'で形成される式に適用

              [(,rator ,rand) ; ランダ（関数）とランド（引数）を持つ関数適用にマッチ
               (cps1 rator ; ランダを再帰的に変換
                     (lambda (r) ; ランダの継続。結果'r'（関数）を受け取る
                       (cps1 rand ; 被演算子を再帰的に変換
                             (lambda (d) ; 被演算子の継続。結果'd'（引数）を受け取る
                               (cond
                                [(trivial? r) (ctx `(,r ,d))] ; ランダ'r'が自明な演算子（zero?, add1, sub1など）の場合、現在のコンテキスト'ctx'を演算子の被演算子への適用に適用
                                [(eq? ctx ctx0) `(,r ,d k)]  ; 末尾呼び出し。現在のコンテキストが末尾コンテキスト'ctx0'の場合、この関数適用が末尾位置にあることを意味する。CPS変換された関数'r'はCPS変換された引数'd'と現在の継続'k'で呼び出される
                                [else ; 関数適用が末尾位置にない場合
                                 (let ([u (fv)]) ; 結果用の新規変数名'u'を生成
                                   `(,r ,d (lambda (,u) ,(ctx u))))])))))]))]) ; CPS変換された関数'r'はCPS変換された引数'd'と、結果'u'を受け取り元のコンテキスト'ctx'を適用する新しい継続で呼び出される

      (cps1 exp id))));; 入力式'exp'と初期恒等継続'id'で'cps1'を呼び出し、CPS変換を開始

;;; テスト
;; 変数
(cps 'x) ; 変数'x'を変換。結果は'(k x)'となる。初期コンテキストが'id'で、'id'が'x'に適用されるため

(cps '(lambda (x) x)) ; 単純な恒等ラムダ関数を変換。結果は'(lambda (x k) (k x))'となる

(cps '(lambda (x) (x 1))) ; 引数を1に適用するラムダ関数を変換。結果は'(lambda (x k) (x 1 k))'となる

;; ラムダなし（トップレベルに返すための恒等関数が生成される）
(cps '(if (f x) a b)) ; テストが関数呼び出しであるif式を変換

(cps '(if x (f a) b)) ; テストが変数であるif式を変換

;; スタンドアロンのif（末尾）
(cps '(if x (f a) b)) ; ここでは'if'がトップレベルにあるため、末尾コンテキストにある

;; if-test内のif（非末尾）
(cps '(lambda (x) (if (f x) a b))) ; 'if'がラムダ内にあり、その結果がラムダによって使用される（暗黙的に返される）ため、末尾コンテキストにない

(cps '(lambda (x) (if (if x (f a) b) c d))) ; ネストした'if'式。内側の'if'は外側の'if'のテスト内にある

;; 両分岐が自明な場合、さらに最適化を行うべき
(cps '(lambda (x) (if (if x (zero? a) b) c d)))

;; if-branch内のif（末尾）
(cps '(lambda (x) (if t (if x (f a) b) c))) ; 内側の'if'は外側の'if'のconseq分岐内にある。外側の'if'が末尾コンテキストにある場合、内側のも同様になる

;; if-branch内のif、ただし別のif-test内（非末尾）
(cps '(lambda (x) (if (if t (if x (f a) b) c) e w)))

;; 被演算子としてのif（非末尾）
(cps '(lambda (x) (h (if x (f a) b)))) ; 'if'式の結果が'h'の引数として使用される

;; 演算子としてのif（非末尾）
(cps '(lambda (x) ((if x (f g) h) c))) ; 'if'式の結果が呼び出される関数として使用される

;; なぜ二つ以上の名前が必要か
(cps '(((f a) (g b)) ((f c) (g d)))) ; この例は、複雑なネスト式を変換する際に名前衝突を避けるための新規変数名ジェネレータ（'fv'）の必要性を示している

;; 階乗
(define fact-cps
  (cps
   '(lambda (n)
      ((lambda (fact)
         ((fact fact) n))
       (lambda (fact)
         (lambda (n)
           (if (zero? n)
               1
               (* n ((fact fact) (sub1 n))))))))));; CPS変換された関数を表示

(pretty-print fact-cps);; =>
;; '(lambda (n k)
;;    ((lambda (fact k) (fact fact (lambda (v0) (v0 n k))))
;;     (lambda (fact k)
;;       (k
;;        (lambda (n k)
;;          (if (zero? n)
;;            (k 1)
;;            (fact
;;             fact
;;             (lambda (v1) (v1 (sub1 n) (lambda (v2) (k (* n v2))))))))));
;;     k))

((eval fact-cps) 5 (lambda (v) v));; => 120
```

**CPS変換器の説明:**

このSchemeコードは、Scheme言語の単純なサブセットに対する継続渡しスタイル（CPS）変換を実装しています。以下に主要な概念とコードの動作の詳細を示します:

**1. 継続渡しスタイル（CPS）:**

* CPSでは、関数は値を直接返しません。代わりに、**継続**と呼ばれる追加の引数を取ります。
* 継続は、現在の関数の結果で実行される残りの計算を表す関数です。
* CPS関数が計算を終えると、結果を継続に渡して呼び出します。

**CPSを使用する理由:**

* **明示的な制御フロー:** CPSは制御フローを明示的にします。関数呼び出しと返却は継続への呼び出しに置き換えられます。
* **末尾呼び出し最適化:** CPSは適切な末尾呼び出し最適化の実装を容易にします。変換後のコードでは、末尾位置での関数呼び出しは最後の操作となり、スタック深度を増やすことなく効率的な実行が可能になります。
* **高度な制御構造の実装:** CPSは、例外、コルーチン、バックトラッキングなどの機能を実装するためのコンパイラ中間表現として使用できます。

**2. `cps`関数:**

* 変換の主要エントリポイント。入力として式`exp`を取ります。
* 相互再帰するいくつかのヘルパー関数を定義するために`letrec`を使用します。
* 入力式と初期継続としての恒等関数`id`で`cps1`を呼び出すことで変換を初期化します。これは、変換された式の最終結果が直接返されることを意味します。

**3. ヘルパー関数:**

* **`trivial?`:** `zero?`、`add1`、`sub1`などの基本演算子を識別します。これらは変換時に特別に扱われます。
* **`id`:** 恒等関数`(lambda (v) v)`。「値をそのまま返す」ことを意味する初期継続です。
* **`ctx0`:** 「末尾コンテキスト」を作成します。値`v`が与えられると、`(k v)`を返します。ここで`k`は現在の継続です。これは現在の計算が末尾位置にあり、結果が待機中の継続に直接渡されるべきであることを示します。
* **`fv`:** 新規変数名（例: `v0`、`v1`、`v2`、...）を生成します。新しい継続を導入する際の変数捕捉を避けるために重要です。

**4. `cps1`関数（コア変換）:**

* この関数は入力式を再帰的に走査し、CPS形式に変換します。
* 変換する式`exp`と現在の継続`ctx`の二つの引数を取ります。
* 様々な種類の式を扱うために`pmatch`ライブラリを使用したパターンマッチングを行います:

    * **リテラルと変数:** 式がペアでない場合（リテラルまたは変数）、すでに値です。現在の継続`ctx`をこの値に適用します: `(ctx x)`

    * **`if`式:** 末尾呼び出しを扱い、コンテキストの重複を防ぐ変換器の重要な部分です。
        * まず`test`式を、testの結果（`t`）を受け取る継続で変換します。
        * 現在のコンテキスト`ctx`が末尾コンテキスト（`ctx0`）または初期恒等コンテキスト（`id`）の場合、`if`式自体が末尾位置にあることを意味します。この場合、`if`構造は保持され、`conseq`と`alt`分岐は同じコンテキスト`ctx`でCPS変換されます。
        * 現在のコンテキストが末尾コンテキストでない場合、`if`式の結果が後で使用される必要があることを意味します。`if`の結果を受け取り元のコンテキスト`ctx`を適用する新しい継続`k`が作成されます。`conseq`と`alt`分岐は末尾コンテキスト`ctx0`でCPS変換され、`if`式全体は`k`を導入する`let`でラップされます。

    * **`lambda`式:** ラムダ式`(lambda (x) body)`は、追加引数`k`（継続）を取る新しいラムダ式に変換されます: `(lambda (x k) (cps1 body ctx0))`。元のラムダの本体は末尾コンテキスト`ctx0`でCPS変換されます。

    * **二項演算（`op a b`）:** 被演算子`a`と`b`は順次CPS変換されます。`a`の継続はその結果`v1`を受け取り、その後`b`をその結果`v2`を受け取る継続でCPS変換します。最後に、元のコンテキスト`ctx`が演算子`op`とCPS変換された結果`v1`、`v2`で形成される式に適用されます。

    * **関数適用（`rator rand`）:** `rator`（関数）と`rand`（引数）は順次CPS変換されます。
        * `rator`が`trivial?`演算子の場合、現在のコンテキスト`ctx`は演算子の被演算子への適用結果に直接適用されます。
        * 現在のコンテキストが末尾コンテキスト（`ctx0`）の場合、CPS変換された関数`r`はCPS変換された引数`d`と現在の継続`k`で呼び出されます。これにより適切な末尾呼び出しが保証されます。
        * それ以外の場合（非末尾呼び出し）、関数呼び出しの結果を受け取り元のコンテキスト`ctx`を適用する新しい継続が作成されます。CPS変換された関数`r`はCPS変換された引数`d`とこの新しい継続で呼び出されます。

**5. テスト:**

* コードには、変数、ラムダ関数、様々なコンテキストでの`if`式、関数適用など、様々な種類の式の変換を示すいくつかのテストケースが含まれています。

**6. 階乗の例:**

* `fact-cps`定義は、CPS変換器が再帰的階乗関数にどのように適用されるかを示しています。
* `pretty-print`出力は、追加の継続引数`k`を取るようになった階乗関数のCPS変換版を示しています。
* 最後の行は、入力`5`と最終値を単純に返すトップレベル継続`(lambda (v) v)`でCPS変換された階乗関数を評価します。

**要約すると、このコードは以下を目的としたCPS変換を実装しています:**

* 式を継続渡しスタイルに変換する
* 現在の継続を明示的に渡すことで適切な末尾呼び出し最適化を保証する
* `if`式自体が末尾位置にある場合、周囲のコンテキストを重複させずに`if`構造を保持することで`if`式を効率的に扱う。`if`が末尾位置にない場合、結果を処理する新しい継続を導入する