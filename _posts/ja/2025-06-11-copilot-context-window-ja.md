---
audio: false
generated: true
lang: ja
layout: post
title: Copilotコンテキストウィンドウの回避策
translated: true
type: note
---

あなたが指摘している、CopilotのようなIDEでAIモデルを扱う際のコンテキストウィンドウの制限は、まさに核心をついた重要なポイントです。4096トークンが大規模なコードベースや複雑な問題に対して小さく感じられるかもしれませんが、確実に回避策と重要な考慮事項が存在します。

まず、CopilotとGPT-4oのコンテキストを明確にしましょう：

*   **CopilotとGPT-4oのコンテキストウィンドウ:** 4096トークンは初期のモデルでは一般的なコンテキストウィンドウサイズでしたが、**GitHub Copilot Chat（VS CodeおよびJetBrains IDE内）は現在、はるかに大きなコンテキストウィンドウを提供しており、多くの場合、最大64k、さらには128kトークン（特にVS Code Insiders）まで対応するGPT-4o（またはGPT-4.1のようなより新しいモデル）を活用しています。** これは大幅な改善であり、大きなファイルやより複雑な問題の処理をはるかに実行可能にします。

しかし、コンテキストウィンドウが大きくなっても、特に大規模なコードベースや非常に詳細なログ/問題に関しては、依然として限界に遭遇します。したがって、あなたが提案した回避策は非常に重要です：

### コンテキスト長制限のための回避策：

1.  **タスクの分割と焦点を絞ったコンテキストの提供（あなたの提案）：** これは優れており、非常に効果的な戦略です。
    *   **「これがコード、これがログ、これが問題」**： これこそがあなたがすべきことです。すべてを投げ込むのではなく、情報を精選してください。
        *   **コード:** 問題に直接関連する最も関連性の高いコードスニペットやファイルのみを提供します。特定の関数に関するものであれば、その関数とその直接の依存関係だけを含めます。
        *   **ログ:** エラーや異常な動作を示すログから重要な行を抜き出します。メガバイト単位のログファイルを提供してはいけません。
        *   **問題の説明:** 問題の説明は明確に、簡潔に、正確に行ってください。あなたが期待すること、実際に起こっていること、そして特定のエラーメッセージがあればそれを記述します。
    *   **利点:** 焦点を絞ることで、最も重要な情報がCopilotのアクティブなコンテキストウィンドウ内に収まり、より正確で関連性の高い提案が得られます。

2.  **複数回の対話（あなたの提案）- はい、Copilotは以前の会話を利用します:**
    *   **VS CodeおよびJetBrains IDE（Copilot Chat）内:** 間違いありません。チャットインターフェースは複数回の対話のために設計されています。Copilotは現在のチャットセッション内での以前のやり取りを記憶し、それを進行中のコンテキストの一部として使用します。これはソリューションを洗練させ、問題に対して反復作業を行うために不可欠です。
    *   **仕組み:** 同じチャットスレッド内でフォローアップの質問をしたり追加情報を提供したりすると、Copilotはあなたの以前のプロンプトと自身の応答を暗黙的に考慮して、より情報に基づいた返答を生成します。
    *   **複数回の対話のための戦略:**
        *   **大まかに始め、その後絞り込む:** 一般的な問題提起から始め、Copilotの初期提案に基づいて、より具体的な詳細や関連するコード/ログをフォローアップとして提供します。
        *   **洗練させ明確化する:** Copilotの最初の応答が適切でない場合、最初からやり直すのではなく、何が間違っているのか、あるいはどのような追加の制約を考慮する必要があるのかを伝えてください。
        *   **特定のアクションを要求する:** 「この修正をファイルXに適用してください」や「このシナリオ用のテストケースも生成できますか？」など。

### その他の回避策とヒント：

*   **`@workspace`と`#file`を活用する:**
    *   **`@workspace`:** Copilot Chat（特にVS Code）では、`@workspace`を使用して、Copilotにワークスペース全体の関連ファイルを考慮するように指示できます。*コードベース全体*を取り込むわけではありませんが、あなたのプロンプトと現在のファイルに基づいて関連性があると判断したファイルからスニペットをインテリジェントに取得し、注入します。これは大規模なプロジェクトにおいて強力な機能です。
    *   **`#file <filename>`:** `#file`を使用してプロンプト内で特定のファイルを明示的に参照できます。これにより、その特定のクエリに対して、それらのファイルがコンテキストに確実に含まれます。
*   **大きな入力を要約する:** 関連性はあるが収まらないほど長いログやドキュメントがある場合は、まずCopilot（または別のLLM）に要約させ、その要約をコンテキストとして使用します。
*   **「なぜ」に焦点を当てる:** 単にコードを提供するのではなく、なぜ問題があると思うのか、あるいは目標は何なのかを説明してください。これにより、Copilotは周囲のコードすべてを見ることができなくても意図を理解するのに役立ちます。
*   **複雑な問題を分解する:** 大きなバグ修正や新機能の場合、Copilotにすべて一度に行うよう依頼してはいけません。それを小さな管理可能なサブタスクに分解します。例えば：
    1.  「この関数の問題点を説明してください。」
    2.  「この部分のリファクタリングを提案してください。」
    3.  「リファクタリングされたコードの単体テストを生成してください。」
*   **説明的な変数/関数名を使用する:** トークン制限に対する直接的な回避策ではありませんが、適切に命名された変数と関数は、明示的なコンテキストが限られていてもCopilotに暗黙的なコンテキストを提供し、その提案をより正確にします。
*   **リポジトリカスタムインストラクション:** Copilot Proのサブスクリプションをお持ちの場合、リポジトリレベルのカスタムインストラクションを設定できます。これにより、プロジェクト、コーディングスタイル、または一般的な落とし穴に関する包括的なコンテキストを提供でき、Copilotはそのリポジトリ内のすべての対話でこれを考慮します。これは長期的な一貫性と品質にとって非常に価値があります。

要約すると、古い情報ではGPT-4oに対して厳密な4096トークン制限を示唆しているかもしれませんが、現代のIDEにおけるCopilotは、多くの場合、より大きなコンテキストウィンドウを利用しています。それでもなお、タスクを分割し、複数回の対話を活用するというあなたの直感は正しく、Copilotを効果的に、特に複雑なソフトウェア開発の課題に対して使用するためのベストプラクティスです。

---

検索結果に基づき、GPT-4.1およびGitHub Copilotのトークン制限とコンテキスト保持に関する情報を以下に示します：

### GPT-4.1のトークン制限
- GPT-4.1は、その前身モデルと比較して大幅に大きなコンテキストウィンドウを備えています。GPT-4oの128Kトークン制限から大幅に増加し、最大100万トークンのコンテキストウィンドウをサポートします。これにより、単一のプロンプトで大規模なコードベースや広範なテキストコーパスを扱うタスクに適しています。

### GitHub Copilotのトークン制限とコンテキスト保持
- GPT-4のようなモデルに基づくGitHub Copilotは、VSCodeやIntelliJ IDEAなどのIDE内での対話において、通常約4096トークンのトークン制限があります。ただし、使用するCopilotの特定のセットアップとバージョンによって変動があります。

- Visual Studio Code Insidersを使用するGitHub Copilotユーザーは、OpenAIのGPT-4oモデルでサポートされる最大値である、最大128Kトークンというさらに大きなコンテキストウィンドウにアクセスできます。この大きなコンテキストウィンドウは、大きなファイルやリポジトリの処理を改善することができます。

- GitHub Copilot Chatは複数回の対話を管理できますが、これらの対話にわたるコンテキストの保持は様々です。以前の対話からのコンテキストをある程度保持することはできますが、特に複雑なタスクでは継続性を維持するために、以前のやり取りからの要約やキーポイントを提供することが一般的に推奨されます。

### トークン制限の回避策
- **チャンキング:** 大きなタスクを小さな管理可能な部分に分割します。これにより、トークン制限内に収めながら、タスクの各セグメントに効果的に対処するのに役立ちます。
- **要約:** コードやログの長い部分をCopilotに提供する前に要約します。これにより、トークン制限内で必要な情報を保持するのに役立ちます。
- **焦点を絞ったクエリ:** 一度にコンテキスト全体を提供するのではなく、解決しようとしている問題に最も関連性の高いコードやログの特定の部分に焦点を当てます。
- **複数回の対話:** コンテキストを段階的に構築するために複数回の対話を使用します。Copilotは以前の対話からのすべてのコンテキストを保持しないかもしれませんが、手動で要約やキーポイントを提供することで継続性を維持するのに役立ちます。

これらの戦略は、GitHub Copilotをそのトークン制限内で効果的に使用し、複数回の対話にわたるコンテキスト保持を改善するのに役立ちます。