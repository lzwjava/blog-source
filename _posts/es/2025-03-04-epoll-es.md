---
audio: false
generated: true
lang: es
layout: post
title: Uso de epoll en Linux
translated: true
type: note
---

`epoll` es una llamada al sistema de Linux diseñada para monitorizar eficientemente múltiples descriptores de archivo en busca de eventos, como cuando hay datos disponibles para leer o un socket está listo para escribir. Es particularmente útil en programación de redes, donde un servidor podría necesitar manejar muchas conexiones simultáneamente. En comparación con mecanismos más antiguos como `select` o `poll`, `epoll` escala mejor con un gran número de descriptores de archivo porque evita escanear repetidamente todos los descriptores para ver su disponibilidad.

Aquí hay una guía paso a paso para usar `epoll` en Linux, seguida de un ejemplo simple de un servidor que acepta conexiones y devuelve los datos (echo).

---

## Pasos para Usar `epoll`

### 1. **Crear una Instancia Epoll**
Para empezar a usar `epoll`, necesitas crear una instancia epoll, que está representada por un descriptor de archivo. Usa la llamada al sistema `epoll_create1`:

```c
int epoll_fd = epoll_create1(0);
```
- **Parámetro**: Pasa `0` para uso básico (sin banderas especiales). Bandera como `EPOLL_CLOEXEC` pueden usarse para escenarios avanzados.
- **Valor de Retorno**: Retorna un descriptor de archivo (`epoll_fd`) en caso de éxito, o `-1` en caso de error (verifica `errno` para más detalles).

La función más antigua `epoll_create` es similar pero toma una sugerencia de tamaño (ahora ignorada), por lo que se prefiere `epoll_create1`.

### 2. **Añadir Descriptores de Archivo a Monitorizar**
Usa `epoll_ctl` para registrar descriptores de archivo (ej., sockets) con la instancia epoll y especificar los eventos que quieres monitorizar:

```c
struct epoll_event ev;
ev.events = EPOLLIN;  // Monitorizar para legibilidad
ev.data.fd = some_fd; // Descriptor de archivo a monitorizar
epoll_ctl(epoll_fd, EPOLL_CTL_ADD, some_fd, &ev);
```
- **Parámetros**:
  - `epoll_fd`: El descriptor de archivo de la instancia epoll.
  - `EPOLL_CTL_ADD`: Operación para añadir un descriptor de archivo.
  - `some_fd`: El descriptor de archivo a monitorizar (ej., un socket).
  - `&ev`: Puntero a una `struct epoll_event` que define los eventos y datos de usuario opcionales.
- **Eventos Comunes**:
  - `EPOLLIN`: Datos disponibles para leer.
  - `EPOLLOUT`: Listo para escribir.
  - `EPOLLERR`: Error ocurrido.
  - `EPOLLHUP`: Colgado (ej., conexión cerrada).
- **Datos de Usuario**: El campo `data` en `struct epoll_event` puede almacenar un descriptor de archivo (como se muestra) u otros datos (ej., un puntero) para identificar la fuente cuando ocurren eventos.

### 3. **Esperar por Eventos**
Usa `epoll_wait` para bloquear y esperar por eventos en los descriptores de archivo monitorizados:

```c
struct epoll_event events[MAX_EVENTS];
int nfds = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);
```
- **Parámetros**:
  - `epoll_fd`: La instancia epoll.
  - `events`: Array para almacenar eventos activados.
  - `MAX_EVENTS`: Número máximo de eventos a retornar (tamaño del array).
  - `-1`: Tiempo de espera en milisegundos (`-1` significa esperar indefinidamente; `0` retorna inmediatamente).
- **Valor de Retorno**: Número de descriptores de archivo con eventos (`nfds`), o `-1` en caso de error.

### 4. **Manejar Eventos**
Recorre en bucle los eventos retornados por `epoll_wait` y procésalos:

```c
for (int i = 0; i < nfds; i++) {
    if (events[i].events & EPOLLIN) {
        // El descriptor de archivo events[i].data.fd es legible
    }
}
```
- Verifica el campo `events` usando operaciones bit a bit (ej., `events[i].events & EPOLLIN`) para determinar el tipo de evento.
- Usa `events[i].data.fd` para identificar qué descriptor de archivo activó el evento.

### 5. **Gestionar Descriptores de Archivo (Opcional)**
- **Eliminar**: Usa `epoll_ctl` con `EPOLL_CTL_DEL` para dejar de monitorizar un descriptor de archivo:
  ```c
  epoll_ctl(epoll_fd, EPOLL_CTL_DEL, some_fd, NULL);
  ```
- **Modificar**: Ajusta eventos con `EPOLL_CTL_MOD`:
  ```c
  ev.events = EPOLLOUT; // Cambiar para monitorizar escritura
  epoll_ctl(epoll_fd, EPOLL_CTL_MOD, some_fd, &ev);
  ```

---

## Conceptos Clave

### **Nivel Activado vs. Borde Activado**
- **Nivel Activado (Por Defecto)**: `epoll` notifica repetidamente mientras la condición persiste (ej., los datos permanecen sin leer). Más simple para la mayoría de los casos.
- **Borde Activado (`EPOLLET`)**: Notifica solo una vez cuando el estado cambia (ej., llegan nuevos datos). Requiere leer/escribir todos los datos hasta `EAGAIN` para evitar perderse eventos; más eficiente pero más complicado.
- Establece `EPOLLET` en `ev.events` (ej., `EPOLLIN | EPOLLET`) si se usa el modo borde activado.

### **E/S No Bloqueante**
`epoll` se usa a menudo junto con descriptores de archivo no bloqueantes para evitar bloqueos en operaciones de E/S. Establece un socket en modo no bloqueante con:

```c
fcntl(fd, F_SETFL, fcntl(fd, F_GETFL) | O_NONBLOCK);
```

---

## Ejemplo: Servidor de Eco Simple

A continuación se muestra un ejemplo básico de un servidor que usa `epoll` para aceptar conexiones y devolver los datos (echo) a los clientes. Usa el modo nivel activado por simplicidad.

```c
#include <sys/epoll.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>

#define MAX_EVENTS 10
#define PORT 8080

int main() {
    // Crear socket de escucha
    int listen_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (listen_fd == -1) { perror("socket"); exit(1); }

    struct sockaddr_in addr = { .sin_family = AF_INET, .sin_addr.s_addr = INADDR_ANY, .sin_port = htons(PORT) };
    if (bind(listen_fd, (struct sockaddr*)&addr, sizeof(addr)) == -1) { perror("bind"); exit(1); }
    if (listen(listen_fd, 5) == -1) { perror("listen"); exit(1); }

    // Establecer socket de escucha como no bloqueante
    fcntl(listen_fd, F_SETFL, fcntl(listen_fd, F_GETFL) | O_NONBLOCK);

    // Crear instancia epoll
    int epoll_fd = epoll_create1(0);
    if (epoll_fd == -1) { perror("epoll_create1"); exit(1); }

    // Añadir socket de escucha a epoll
    struct epoll_event ev, events[MAX_EVENTS];
    ev.events = EPOLLIN; // Nivel activado
    ev.data.fd = listen_fd;
    if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, listen_fd, &ev) == -1) { perror("epoll_ctl"); exit(1); }

    // Bucle de eventos
    while (1) {
        int nfds = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);
        if (nfds == -1) { perror("epoll_wait"); exit(1); }

        for (int i = 0; i < nfds; i++) {
            int fd = events[i].data.fd;

            if (fd == listen_fd) {
                // Aceptar nueva conexión
                int client_fd = accept(listen_fd, NULL, NULL);
                if (client_fd == -1) { perror("accept"); continue; }

                // Establecer socket del cliente como no bloqueante
                fcntl(client_fd, F_SETFL, fcntl(client_fd, F_GETFL) | O_NONBLOCK);

                // Añadir socket del cliente a epoll
                ev.events = EPOLLIN;
                ev.data.fd = client_fd;
                if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, client_fd, &ev) == -1) {
                    perror("epoll_ctl: client_fd");
                    close(client_fd);
                }
            } else {
                // Manejar datos del cliente
                char buf[1024];
                ssize_t n = read(fd, buf, sizeof(buf));
                if (n <= 0) {
                    // Error o EOF: cerrar y eliminar de epoll
                    if (n == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) continue;
                    close(fd);
                    epoll_ctl(epoll_fd, EPOLL_CTL_DEL, fd, NULL);
                } else {
                    // Devolver datos (echo)
                    write(fd, buf, n); // Nota: En aplicaciones reales, manejar escrituras parciales
                }
            }
        }
    }

    close(epoll_fd);
    close(listen_fd);
    return 0;
}
```

### Notas sobre el Ejemplo
- **Socket de Escucha**: Monitoriza `EPOLLIN` para detectar nuevas conexiones.
- **Sockets de Cliente**: También monitorizan `EPOLLIN` para detectar datos entrantes.
- **Simplificación**: Asume que `write` se completa totalmente. En producción, almacena en búfer los datos y usa `EPOLLOUT` para escrituras parciales.
- **Manejo de Errores**: Cierra sockets en errores o EOF y los elimina de epoll.

---

## Resumen
`epoll` proporciona una manera eficiente de manejar múltiples descriptores de archivo en Linux:
1. Crear una instancia con `epoll_create1`.
2. Registrar descriptores de archivo y eventos con `epoll_ctl`.
3. Esperar por eventos con `epoll_wait`.
4. Procesar eventos en un bucle, ajustando los eventos monitorizados o eliminando descriptores según sea necesario.

Para aplicaciones simples, se recomienda el modo nivel activado. Para necesidades de alto rendimiento, considera el modo borde activado con un manejo cuidadoso de todos los datos disponibles. Siempre usa `epoll` con E/S no bloqueante para obtener los mejores resultados.