---
audio: true
generated: true
lang: es
layout: post
title: Usando SAX (Simple API for XML)
translated: true
---

Para usar el paquete `org.xml.sax` en Java para analizar documentos XML, puedes seguir un proceso sencillo utilizando el enfoque de análisis SAX (Simple API for XML). SAX es un analizador basado en eventos que lee un documento XML secuencialmente y dispara métodos de devolución de llamada a medida que encuentra diversas partes del documento, como elementos o contenido de texto. Esto lo hace eficiente en términos de memoria, especialmente para archivos XML grandes, ya que no carga el documento completo en la memoria como lo hace DOM. A continuación se presenta una guía paso a paso para usar `org.xml.sax`.

---

### Paso 1: Configurar el analizador SAX
Para comenzar a analizar XML con SAX, necesitas crear una instancia de `SAXParser` utilizando la clase `SAXParserFactory`. Esta fábrica te permite configurar el comportamiento del analizador antes de crearlo.

Aquí está cómo crear un `SAXParser`:

```java
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;

public class SAXExample {
    public static void main(String[] args) {
        try {
            // Crear una instancia de SAXParserFactory
            SAXParserFactory factory = SAXParserFactory.newInstance();

            // Opcional: Configurar la fábrica (por ejemplo, habilitar la conciencia de nombrespaces)
            factory.setNamespaceAware(true); // Establecer en true si tu XML usa nombrespaces

            // Crear un SAXParser
            SAXParser parser = factory.newSAXParser();

            // Los siguientes pasos irán aquí
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

- **`SAXParserFactory.newInstance()`**: Crea una nueva instancia de la fábrica.
- **`factory.setNamespaceAware(true)`**: Opcional. Habilita el procesamiento de nombrespaces si tu XML usa nombrespaces. Por defecto, es `false`.
- **`factory.newSAXParser()`**: Crea un `SAXParser`. Esto puede lanzar `ParserConfigurationException` o `SAXException` si el analizador no puede ser configurado o inicializado.

---

### Paso 2: Crear un manejador para eventos XML
El análisis SAX depende de un manejador para procesar los eventos XML que encuentra, como el inicio de un elemento, el final de un elemento o el contenido de texto. La interfaz principal para esto es `ContentHandler`, pero por simplicidad, puedes extender la clase `DefaultHandler`, que proporciona implementaciones vacías de `ContentHandler` y otras interfaces de manejador (`ErrorHandler`, `DTDHandler`, etc.). Solo necesitas sobrescribir los métodos que te importen.

Aquí tienes un ejemplo de un manejador personalizado:

```java
import org.xml.sax.Attributes;
import org.xml.sax.helpers.DefaultHandler;

public class MyHandler extends DefaultHandler {
    // Variable para acumular contenido de texto
    private StringBuilder content = new StringBuilder();

    @Override
    public void startElement(String uri, String localName, String qName, Attributes attributes) {
        // Limpiar el búfer de contenido para el nuevo elemento
        content.setLength(0);
        System.out.println("Inicio del elemento: " + qName);

        // Si el elemento tiene atributos, procesarlos
        for (int i = 0; i < attributes.getLength(); i++) {
            System.out.println("Atributo: " + attributes.getQName(i) + " = " + attributes.getValue(i));
        }
    }

    @Override
    public void characters(char[] ch, int start, int length) {
        // Acumular contenido de texto (puede ser llamado múltiples veces por elemento)
        content.append(ch, start, length);
    }

    @Override
    public void endElement(String uri, String localName, String qName) {
        // Procesar contenido de texto acumulado
        String text = content.toString().trim();
        if (!text.isEmpty()) {
            System.out.println("Contenido: " + text);
        }
        System.out.println("Fin del elemento: " + qName);
        content.setLength(0); // Reiniciar para el siguiente elemento
    }

    @Override
    public void startDocument() {
        System.out.println("Comenzando el análisis del documento");
    }

    @Override
    public void endDocument() {
        System.out.println("Análisis del documento completado");
    }
}
```

- **`startElement`**: Se llama cuando el analizador encuentra el inicio de un elemento. Los parámetros incluyen:
  - `uri`: URI del namespace (si es consciente de nombrespaces).
  - `localName`: Nombre local del elemento (sin prefijo, si es consciente de nombrespaces).
  - `qName`: Nombre cualificado (incluye prefijo, si hay alguno).
  - `attributes`: Lista de los atributos del elemento.
- **`characters`**: Se llama para el contenido de texto dentro de un elemento. Ten en cuenta que esto puede ser llamado múltiples veces para el contenido de un solo elemento, así que usa un `StringBuilder` para acumularlo.
- **`endElement`**: Se llama cuando un elemento termina.
- **`startDocument` y `endDocument`**: Se llaman al principio y al final del documento XML.

---

### Paso 3: Analizar el XML
Con el analizador y el manejador listos, puedes analizar una fuente XML (por ejemplo, un archivo, `InputStream` o cadena) llamando al método `parse` en el `SAXParser` y pasando tu manejador.

Aquí está cómo analizar un archivo XML:

```java
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import java.io.File;

public class SAXExample {
    public static void main(String[] args) {
        try {
            // Crear el analizador
            SAXParserFactory factory = SAXParserFactory.newInstance();
            SAXParser parser = factory.newSAXParser();

            // Crear el manejador
            MyHandler handler = new MyHandler();

            // Analizar un archivo XML
            File xmlFile = new File("example.xml");
            parser.parse(xmlFile, handler);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

- **`parser.parse`**: Toma una fuente XML (por ejemplo, `File`) y un `DefaultHandler`. Puede lanzar `IOException` (para errores de entrada) o `SAXException` (para errores de análisis).

Para una cadena XML en lugar de un archivo, usa `InputSource`:

```java
import org.xml.sax.InputSource;
import java.io.StringReader;

// Dentro del método main
String xml = "<book><title>Análisis XML</title></book>";
InputSource inputSource = new InputSource(new StringReader(xml));
parser.parse(inputSource, handler);
```

---

### Paso 4: Manejar excepciones
El análisis SAX implica varias excepciones que deberías manejar:

- **`ParserConfigurationException`**: Lanzada por `newSAXParser()` si el analizador no puede ser configurado.
- **`SAXException`**: Lanzada por `newSAXParser()` o `parse()` para errores de análisis generales.
- **`IOException`**: Lanzada por `parse()` si hay un problema leyendo la fuente de entrada.

Envuelve tu código en un bloque `try-catch`:

```java
try {
    SAXParserFactory factory = SAXParserFactory.newInstance();
    SAXParser parser = factory.newSAXParser();
    MyHandler handler = new MyHandler();
    parser.parse(new File("example.xml"), handler);
} catch (ParserConfigurationException e) {
    System.err.println("Error de configuración del analizador: " + e.getMessage());
} catch (SAXException e) {
    System.err.println("Error SAX: " + e.getMessage());
} catch (IOException e) {
    System.err.println("Error de E/S: " + e.getMessage());
}
```

---

### Paso 5: Características opcionales
#### Manejo de errores
`DefaultHandler` también implementa `ErrorHandler`. Sobrescribe sus métodos para manejar errores de análisis:

```java
public class MyHandler extends DefaultHandler {
    @Override
    public void error(SAXParseException e) {
        System.err.println("Error de análisis: " + e.getMessage());
    }

    @Override
    public void fatalError(SAXParseException e) throws SAXException {
        System.err.println("Error fatal: " + e.getMessage());
        throw e; // Detener el análisis
    }

    @Override
    public void warning(SAXParseException e) {
        System.out.println("Advertencia: " + e.getMessage());
    }
    // Otros métodos como arriba
}
```

#### Manejo de nombrespaces
Si tu XML usa nombrespaces, establece `factory.setNamespaceAware(true)` y usa `uri` y `localName` en tus métodos de manejador en lugar de `qName` para identificar elementos correctamente.

#### Validación
Para validar XML contra un DTD o esquema, establece `factory.setValidating(true)`. También podrías necesitar un `ErrorHandler` para manejar errores de validación.

---

### Ejemplo de XML y salida
Para un archivo XML `example.xml`:
```xml
<book id="123">
    <title>Análisis XML</title>
    <author>John Doe</author>
</book>
```

Ejecutar el código anterior podría producir:
```
Comenzando el análisis del documento
Inicio del elemento: book
Atributo: id = 123
Inicio del elemento: title
Contenido: Análisis XML
Fin del elemento: title
Inicio del elemento: author
Contenido: John Doe
Fin del elemento: author
Fin del elemento: book
Análisis del documento completado
```

---

### Resumen
Para usar `org.xml.sax`:
1. Crea un `SAXParser` usando `SAXParserFactory`.
2. Implementa un manejador extendiendo `DefaultHandler` y sobrescribiendo métodos como `startElement`, `endElement` y `characters`.
3. Analiza el XML llamando a `parser.parse()` con tu manejador y fuente XML.
4. Maneja excepciones (`SAXException`, `IOException`, `ParserConfigurationException`).
5. Opcionalmente, configura la conciencia de nombrespaces, validación o manejo de errores.

Este enfoque es ideal para analizar eficientemente documentos XML grandes cuando solo necesitas extraer datos específicos sin construir un árbol en memoria.