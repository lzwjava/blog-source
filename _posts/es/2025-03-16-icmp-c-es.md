---
audio: false
generated: true
lang: es
layout: post
title: Programa de Ping ICMP en C
translated: true
type: note
---

ICMP (Internet Control Message Protocol) es un protocolo de capa de red utilizado para propósitos de diagnóstico y reporte de errores en redes IP. Es más conocido por ser utilizado por la utilidad `ping` para probar la conectividad entre hosts. Los mensajes ICMP se encapsulan directamente en paquetes IP (sin capa TCP o UDP) y consisten en un tipo, código, checksum y payload. Para `ping`, los mensajes "Echo Request" (Tipo 8) y "Echo Reply" (Tipo 0) son clave.

Así es como funciona ICMP a alto nivel:
1. Un emisor (por ejemplo, tu máquina) envía un ICMP Echo Request a una IP destino.
2. El destino, si es alcanzable y está configurado para responder, envía de vuelta un ICMP Echo Reply.
3. El emisor mide el tiempo de ida y vuelta (RTT) basándose en cuándo llega la respuesta.

Para implementar un programa similar a `ping` en C sin bibliotecas como `libpcap` o `libnet`, usaremos sockets raw (`SOCK_RAW`) para crear y enviar paquetes ICMP directamente. Esto requiere privilegios de root (por ejemplo, `sudo`) porque los sockets raw omiten las abstracciones de nivel superior.

A continuación se muestra un programa en C simplificado que envía ICMP Echo Requests y escucha Echo Replies, imitando la funcionalidad básica de `ping`.

---

### Programa ICMP Ping en C

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>
#include <time.h>
#include <errno.h>

// Calcular checksum ICMP
unsigned short checksum(void *b, int len) {
    unsigned short *buf = b;
    unsigned int sum = 0;
    unsigned short result;

    for (sum = 0; len > 1; len -= 2) {
        sum += *buf++;
    }
    if (len == 1) {
        sum += *(unsigned char *)buf;
    }
    sum = (sum >> 16) + (sum & 0xFFFF);
    sum += (sum >> 16);
    result = ~sum;
    return result;
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: %s <destination_ip>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    int sock_fd;
    struct sockaddr_in dest_addr;
    char packet[64];  // Cabecera ICMP + algunos datos
    struct icmphdr *icmp;
    char recv_buffer[1024];
    struct timespec start, end;

    // Crear socket raw para ICMP
    sock_fd = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);
    if (sock_fd < 0) {
        perror("Socket creation failed (run as root?)");
        exit(EXIT_FAILURE);
    }

    // Configurar dirección destino
    dest_addr.sin_family = AF_INET;
    if (inet_pton(AF_INET, argv[1], &dest_addr.sin_addr) <= 0) {
        perror("Invalid IP address");
        close(sock_fd);
        exit(EXIT_FAILURE);
    }

    // Preparar paquete ICMP Echo Request
    memset(packet, 0, sizeof(packet));
    icmp = (struct icmphdr *)packet;
    icmp->type = ICMP_ECHO;        // Tipo 8: Echo Request
    icmp->code = 0;
    icmp->un.echo.id = getpid();   // Usar ID de proceso como identificador
    icmp->un.echo.sequence = 1;    // Número de secuencia
    for (int i = sizeof(*icmp); i < 64; i++) {
        packet[i] = i;             // Llenar payload con datos dummy
    }
    icmp->checksum = 0;            // Calcular checksum después de llenar el paquete
    icmp->checksum = checksum(packet, 64);

    printf("Pinging %s...\n", argv[1]);

    for (int i = 0; i < 4; i++) { // Enviar 4 pings
        // Registrar tiempo de envío
        clock_gettime(CLOCK_MONOTONIC, &start);

        // Enviar ICMP Echo Request
        if (sendto(sock_fd, packet, 64, 0, (struct sockaddr *)&dest_addr, sizeof(dest_addr)) < 0) {
            perror("Send failed");
            close(sock_fd);
            exit(EXIT_FAILURE);
        }

        // Recibir ICMP Echo Reply
        struct sockaddr_in from_addr;
        socklen_t from_len = sizeof(from_addr);
        int bytes_received = recvfrom(sock_fd, recv_buffer, sizeof(recv_buffer), 0,
                                      (struct sockaddr *)&from_addr, &from_len);
        if (bytes_received < 0) {
            perror("Receive failed");
            continue;
        }

        // Registrar tiempo de recepción
        clock_gettime(CLOCK_MONOTONIC, &end);

        // Analizar cabeceras IP e ICMP recibidas
        struct iphdr *ip = (struct iphdr *)recv_buffer;
        struct icmphdr *icmp_reply = (struct icmphdr *)(recv_buffer + (ip->ihl * 4));
        if (icmp_reply->type == ICMP_ECHOREPLY && icmp_reply->un.echo.id == getpid()) {
            double rtt = (end.tv_sec - start.tv_sec) * 1000.0 +
                         (end.tv_nsec - start.tv_nsec) / 1000000.0;
            printf("%d bytes from %s: seq=%d time=%.2f ms\n",
                   bytes_received - (ip->ihl * 4), argv[1], icmp_reply->un.echo.sequence, rtt);
        } else {
            printf("Unexpected ICMP response: type=%d\n", icmp_reply->type);
        }

        sleep(1); // Esperar 1 segundo entre pings
        icmp->un.echo.sequence++; // Incrementar número de secuencia
        icmp->checksum = 0;
        icmp->checksum = checksum(packet, 64); // Recalcular checksum
    }

    close(sock_fd);
    return 0;
}
```

---

### Cómo Funciona

1. **Creación del Socket**:
   - `socket(AF_INET, SOCK_RAW, IPPROTO_ICMP)` crea un socket raw para ICMP. Esto nos permite crear paquetes ICMP manualmente.

2. **Construcción del Paquete ICMP**:
   - La cabecera ICMP (`struct icmphdr`) se llena con:
     - `type = ICMP_ECHO` (8) para Echo Request.
     - `code = 0`.
     - `id` establecido al ID del proceso para identificar nuestros pings.
     - `sequence` para rastrear solicitudes individuales.
   - Se añade un payload (datos dummy) y se calcula el checksum sobre todo el paquete.

3. **Envío**:
   - `sendto()` envía el paquete a la IP destino. No se necesita puerto ya que ICMP opera por debajo de la capa de transporte.

4. **Recepción**:
   - `recvfrom()` captura el paquete IP raw que contiene el ICMP Echo Reply.
   - Saltamos la cabecera IP (`ihl * 4` bytes) para llegar a la cabecera ICMP.
   - Verificamos si es un Echo Reply (Tipo 0) y coincide con nuestro `id`.

5. **Temporización**:
   - `clock_gettime()` mide el RTT en milisegundos.

6. **Checksum**:
   - La función `checksum()` calcula la suma de complemento a uno de 16 bits, como lo requiere ICMP.

---

### Compilación y Uso
- Compilar: `gcc ping.c -o ping`
- Ejecutar (como root): `sudo ./ping 8.8.8.8`
- Salida de ejemplo:
  ```
  Pinging 8.8.8.8...
  64 bytes from 8.8.8.8: seq=1 time=12.34 ms
  64 bytes from 8.8.8.8: seq=2 time=11.89 ms
  ...
  ```

---

### Notas
- **Privilegios de Root**: Los sockets raw requieren `sudo` porque manipulan paquetes de red directamente.
- **Firewall**: El destino debe responder a ICMP Echo Requests (algunos hosts los bloquean).
- **Simplificaciones**: Esta versión no maneja todos los casos extremos (por ejemplo, timeouts, pérdida de paquetes completamente u opciones IP).

Esto es lo más bajo nivel que se puede llegar en el espacio de usuario con ICMP. Por debajo de esto, necesitarías código a nivel de kernel para interactuar directamente con la pila IP. ¡Avísame si quieres ajustarlo más!