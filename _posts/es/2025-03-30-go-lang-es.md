---
audio: false
generated: true
lang: es
layout: post
title: Guía Integral del Lenguaje de Programación Go
translated: true
type: note
---

Esta guía tiene como objetivo proporcionar una visión general completa del lenguaje de programación Go, cubriendo sus fundamentos, conceptos principales y características avanzadas. Está diseñada tanto para principiantes con algo de experiencia en programación como para aquellos que buscan hacer la transición desde otros lenguajes.

**I. Introducción a Go**

* **¿Qué es Go?**
    * Go (a menudo referido como Golang) es un lenguaje de programación compilado y tipado estáticamente diseñado en Google por Robert Griesemer, Rob Pike y Ken Thompson.
    * Hace hincapié en la simplicidad, la concurrencia y el rendimiento.
    * Go es de código abierto y tiene una comunidad vibrante y en crecimiento.
* **Características Principales y Principios de Diseño:**
    * **Simplicidad y Legibilidad:** Sintaxis limpia, palabras clave mínimas y un enfoque en hacer una cosa bien.
    * **Concurrencia:** Soporte incorporado para goroutines ligeras y channels, lo que facilita y hace más eficiente la programación concurrente.
    * **Rendimiento:** Lenguaje compilado con gestión eficiente de memoria (recolección de basura) que conduce a una ejecución rápida.
    * **Tipado Fuerte:** Ayuda a detectar errores temprano en el proceso de desarrollo.
    * **Enlace Estático:** Produce ejecutables autocontenidos, simplificando el despliegue.
    * **Recolección de Basura:** La gestión automática de memoria reduce la carga para los desarrolladores.
    * **Librería Estándar:** Una librería estándar rica y completa proporciona herramientas para diversas tareas.
    * **Herramientas:** Excelentes herramientas integradas para formateo (gofmt), linting (golint, staticcheck), testing (go test) y gestión de dependencias (go modules).
* **Casos de Uso:**
    * Programación de Sistemas
    * Programación de Red (APIs, servidores web)
    * Infraestructura en la Nube (Docker, Kubernetes)
    * Herramientas de Línea de Comandos
    * Sistemas Distribuidos
    * Procesamiento de Big Data

**II. Configuración del Entorno de Go**

* **Instalación:**
    * Descarga la distribución de Go apropiada para tu sistema operativo desde el sitio web oficial ([https://go.dev/dl/](https://go.dev/dl/)).
    * Sigue las instrucciones de instalación para tu plataforma.
* **Verificación de la Instalación:**
    * Abre tu terminal o símbolo del sistema y ejecuta `go version`. Esto debería mostrar la versión de Go instalada.
* **Espacio de Trabajo y `GOPATH` (Legado):**
    * Históricamente, los proyectos de Go se organizaban dentro de una variable de entorno `GOPATH`. Aunque aún es compatible, ha sido ampliamente reemplazado por Go Modules.
* **Go Modules (Recomendado):**
    * Go Modules es la solución oficial de gestión de dependencias.
    * Para iniciar un nuevo proyecto con módulos, navega a tu directorio del proyecto en la terminal y ejecuta `go mod init <tu_ruta_de_módulo>` (por ejemplo, `go mod init github.com/tuusuario/miproyecto`).
    * Las dependencias se declaran en el archivo `go.mod`.

**III. Sintaxis Básica y Conceptos de Go**

* **¡Hola, Mundo!**
    ```go
    package main

    import "fmt"

    func main() {
        fmt.Println("Hello, World!")
    }
    ```
    * `package main`: Declara el paquete como el punto de entrada de un programa ejecutable.
    * `import "fmt"`: Importa el paquete "fmt", que proporciona funciones de E/S formateadas.
    * `func main()`: La función main donde comienza la ejecución del programa.
    * `fmt.Println()`: Imprime una línea de texto en la consola.
* **Paquetes e Importaciones:**
    * El código de Go se organiza en paquetes.
    * Los paquetes ayudan en la organización del código, la reutilización y la evitación de conflictos de nombres.
    * Usa la palabra clave `import` para incorporar funcionalidad de otros paquetes (librería estándar o de terceros).
    * Las rutas de importación pueden ser paquetes simples (ej., `"fmt"`) o anidados (ej., `"net/http"`).
    * Alias de importación: `import f "fmt"` (ahora puedes usar `f.Println`).
    * Identificador en blanco (`_`) para efectos secundarios: `import _ "net/http/pprof"` (inicializa los manejadores pprof sin uso directo).
* **Variables:**
    * Declaración:
        * `var nombre tipo` (ej., `var edad int`)
        * `var nombre = valor` (inferencia de tipo, ej., `var nombre = "Alicia"`)
        * `nombre := valor` (declaración corta de variable, solo dentro de funciones, ej., `contador := 0`)
    * Declaraciones múltiples:
        ```go
        var (
            nombre string = "Juan"
            apellido  string = "Pérez"
            edad       int    = 30
        )
        ```
    * Constantes:
        * `const PI float64 = 3.14159`
        * Las constantes deben declararse en tiempo de compilación.
        * Las constantes sin tipo pueden tomar diferentes tipos según su uso.
* **Tipos de Datos:**
    * **Tipos Básicos:**
        * **Enteros:** `int`, `int8`, `int16`, `int32` (`rune` - alias para `int32`), `int64`, `uint`, `uint8` (`byte` - alias para `uint8`), `uint16`, `uint32`, `uint64`, `uintptr` (entero sin signo lo suficientemente grande para contener un puntero).
        * **Números de Punto Flotante:** `float32`, `float64`.
        * **Números Complejos:** `complex64`, `complex128`.
        * **Booleanos:** `bool` (`true`, `false`).
        * **Cadenas:** `string` (secuencia inmutable de bytes, típicamente codificada en UTF-8).
    * **Tipos Compuestos:**
        * **Arrays:** Secuencia de tamaño fijo de elementos del mismo tipo (ej., `[5]int`).
        * **Slices:** Vista de tamaño dinámico y flexible sobre los elementos de un array (el más comúnmente usado).
        * **Maps:** Colección desordenada de pares clave-valor (tablas hash).
        * **Structs:** Tipos de datos compuestos que agrupan cero o más campos con nombre de diferentes tipos.
        * **Punteros:** Contienen la dirección de memoria de un valor.
        * **Funciones:** Ciudadanos de primera clase, pueden asignarse a variables y pasarse como argumentos.
        * **Interfaces:** Definen un conjunto de métodos que un tipo debe implementar.
        * **Channels:** Proporcionan una forma para que las goroutines se comuniquen y sincronicen.
* **Operadores:**
    * **Aritméticos:** `+`, `-`, `*`, `/`, `%`, `++`, `--`.
    * **Comparación:** `==`, `!=`, `>`, `<`, `>=`, `<=`.
    * **Lógicos:** `&&` (AND), `||` (OR), `!` (NOT).
    * **Bit a Bit:** `&` (AND), `|` (OR), `^` (XOR), `&^` (AND NOT), `<<` (Desplazamiento a Izquierda), `>>` (Desplazamiento a Derecha).
    * **Asignación:** `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`.
* **Flujo de Control:**
    * **`if`, `else if`, `else`:** Ejecución condicional.
        ```go
        if edad >= 18 {
            fmt.Println("Adulto")
        } else if edad >= 13 {
            fmt.Println("Adolescente")
        } else {
            fmt.Println("Niño")
        }
        ```
    * **Bucle `for`:** La única construcción de bucle en Go.
        * Bucle `for` básico:
            ```go
            for i := 0; i < 5; i++ {
                fmt.Println(i)
            }
            ```
        * Bucle tipo `while`:
            ```go
            j := 0
            for j < 5 {
                fmt.Println(j)
                j++
            }
            ```
        * Bucle infinito:
            ```go
            for {
                // Hacer algo
            }
            ```
        * Iterando sobre colecciones (`range`):
            ```go
            numeros := []int{1, 2, 3}
            for indice, valor := range numeros {
                fmt.Printf("Índice: %d, Valor: %d\n", indice, valor)
            }

            m := map[string]string{"a": "manzana", "b": "plátano"}
            for clave, val := range m {
                fmt.Printf("Clave: %s, Valor: %s\n", clave, val)
            }
            ```
    * **Sentencia `switch`:** Ejecución condicional múltiple.
        ```go
        calificacion := "B"
        switch calificacion {
        case "A":
            fmt.Println("¡Excelente!")
        case "B":
            fmt.Println("Bien")
        case "C":
            fmt.Println("Promedio")
        default:
            fmt.Println("Necesita mejorar")
        }
        ```
        * No hay paso automático (usa la palabra clave `fallthrough` si es necesario).
        * Los casos pueden tener múltiples valores.
        * Switch sin condición (como `if-else if-else`).
    * **Sentencia `defer`:** Programa una llamada a función para que se ejecute al final de la función que la rodea (a menudo se usa para tareas de limpieza como cerrar archivos).
        ```go
        func ejemplo() {
            f, err := os.Open("archivo.txt")
            if err != nil {
                fmt.Println(err)
                return
            }
            defer f.Close() // f.Close() se llamará cuando ejemplo() retorne

            // ... procesar el archivo ...
        }
        ```
    * **Sentencia `goto`:** Transfiere el control a una sentencia etiquetada (úsala con moderación, puede llevar a código espagueti).
    * **`break` y `continue`:** Controlan la ejecución del bucle.

**IV. Tipos de Datos Compuestos en Detalle**

* **Arrays:**
    * Tamaño fijo, elementos del mismo tipo.
    * Menos comúnmente usados que los slices.
    * Ejemplo: `var a [3]int; a[0] = 1; a[1] = 2; a[2] = 3` o `b := [2]string{"hola", "mundo"}`.
* **Slices:**
    * Tamaño dinámico, respaldados por un array subyacente.
    * Se crean usando literales de slice (ej., `[]int{1, 2, 3}`), la función `make()` (`make([]int, longitud, capacidad)`), o dividiendo un array o slice existente (`miSlice[inicio:fin]`).
    * `len()`: Retorna el número de elementos en el slice.
    * `cap()`: Retorna la capacidad del array subyacente.
    * `append()`: Añade elementos al final de un slice (puede realocar el array subyacente si se alcanza la capacidad).
    * `copy()`: Copia elementos de un slice a otro.
* **Maps:**
    * Colección desordenada de pares clave-valor.
    * Las claves deben ser de un tipo comparable (ej., enteros, cadenas, booleanos, structs que contengan solo campos comparables).
    * Los valores pueden ser de cualquier tipo.
    * Se crean usando literales de map (ej., `map[string]int{"manzana": 1, "plátano": 2}`) o la función `make()` (`make(map[string]string)`).
    * Accediendo a valores: `valor := miMapa["clave"]` (retorna el valor y un booleano indicando si la clave existe).
    * Verificando la existencia de una clave: `valor, ok := miMapa["clave"]` (`ok` es `true` si la clave existe).
    * Añadiendo/actualizando entradas: `miMapa["nuevaClave"] = "nuevoValor"`.
    * Eliminando entradas: `delete(miMapa, "claveAEliminar")`.
* **Structs:**
    * Tipos definidos por el usuario que agrupan campos con nombre de diferentes tipos.
    * Se usan para representar entidades con múltiples atributos.
    * Declaración:
        ```go
        type Persona struct {
            Nombre string
            Apellido  string
            Edad       int
        }
        ```
    * Creando instancias:
        ```go
        var p1 Persona
        p1.Nombre = "Alicia"
        p1.Apellido = "Gómez"
        p1.Edad = 25

        p2 := Persona{Nombre: "Bob", Apellido: "Johnson", Edad: 30}

        p3 := Persona{"Carlos", "Marrón", 20} // El orden importa si se omiten los nombres de los campos
        ```
    * Accediendo a campos: `p1.Nombre`.
    * Structs embebidos (composición).
    * Campos anónimos.
* **Punteros:**
    * Contienen la dirección de memoria de un valor.
    * Se declaran usando el operador `*` (ej., `var ptr *int`).
    * Obtén la dirección de una variable usando el operador `&` (ej., `ptr = &edad`).
    * Desreferencia un puntero para acceder al valor al que apunta usando el operador `*` (ej., `valor := *ptr`).
    * Go no tiene aritmética de punteros explícita.
    * Los punteros son útiles para pasar datos por referencia, modificar valores directamente y trabajar con ciertas estructuras de datos.

**V. Funciones**

* **Declaración de Función:**
    ```go
    func nombreFuncion(nombreParametro1 tipo1, nombreParametro2 tipo2) tipoRetorno {
        // Cuerpo de la función
        return valorRetorno
    }
    ```
    * Múltiples parámetros del mismo tipo pueden declararse juntos: `func sumar(a, b int) int`.
    * Funciones variádicas (aceptan un número variable de argumentos): `func sumar(numeros ...int) int`.
    * Múltiples valores de retorno:
        ```go
        func dividir(a, b float64) (float64, error) {
            if b == 0 {
                return 0, fmt.Errorf("división por cero")
            }
            return a / b, nil
        }

        resultado, err := dividir(10, 2)
        if err != nil {
            fmt.Println("Error:", err)
        } else {
            fmt.Println("Resultado:", resultado)
        }
        ```
    * Valores de retorno con nombre.
* **Funciones de Primera Clase:**
    * Las funciones pueden asignarse a variables, pasarse como argumentos a otras funciones y retornarse desde funciones.
    * Ejemplo:
        ```go
        func sumar(a, b int) int { return a + b }

        func operar(f func(int, int) int, x, y int) int {
            return f(x, y)
        }

        resultado := operar(sumar, 5, 3) // resultado será 8
        ```
* **Funciones Anónimas (Clausuras):**
    * Funciones sin nombre, a menudo usadas como callbacks en línea.
    * Pueden capturar variables de su ámbito circundante (clausuras).
    * Ejemplo:
        ```go
        func multiplicador(factor int) func(int) int {
            return func(x int) int {
                return x * factor
            }
        }

        doble := multiplicador(2)
        fmt.Println(doble(5)) // Salida: 10
        ```

**VI. Métodos**

* **Declaración de Método:**
    * Un método es una función asociada con un tipo receptor específico.
    * Sintaxis:
        ```go
        func (receptor Tipo) nombreMetodo(parametros) tipoRetorno {
            // Cuerpo del método
        }
        ```
    * El receptor puede ser un valor o un puntero.
    * Los receptores de valor operan sobre una copia del receptor.
    * Los receptores de puntero operan sobre el receptor original y pueden modificar su estado.
* **Ejemplo:**
    ```go
    type Circulo struct {
        Radio float64
    }

    func (c Circulo) Area() float64 {
        return math.Pi * c.Radio * c.Radio
    }

    func (c *Circulo) SetRadio(nuevoRadio float64) {
        c.Radio = nuevoRadio
    }

    func main() {
        miCirculo := Circulo{Radio: 5}
        fmt.Println("Área:", miCirculo.Area()) // Llama al método Area en un receptor de valor

        miCirculo.SetRadio(10) // Llama al método SetRadio en un receptor de puntero
        fmt.Println("Nueva Área:", miCirculo.Area())
    }
    ```

**VII. Interfaces**

* **Definición de Interfaz:**
    * Una interfaz define un conjunto de firmas de métodos.
    * Un tipo implementa una interfaz si proporciona implementaciones para todos los métodos definidos en la interfaz.
    * Las interfaces se satisfacen implícitamente (no hay palabra clave `implements` explícita).
    * Sintaxis:
        ```go
        type Writer interface {
            Write(p []byte) (n int, err error)
        }

        type Reader interface {
            Read(p []byte) (n int, err error)
        }

        type ReadWriter interface {
            Reader
            Writer // Incrustando interfaces
            Close() error
        }
        ```
* **Uso de Interfaces:**
    * Permiten el polimorfismo (tratar objetos de diferentes tipos de manera uniforme).
    * Desacoplan el código programando hacia interfaces en lugar de tipos concretos.
    * Ejemplo:
        ```go
        import "io"
        import "os"

        func escribirDatos(w io.Writer, datos []byte) error {
            _, err := w.Write(datos)
            return err
        }

        func main() {
            archivo, err := os.Create("salida.txt")
            if err != nil {
                fmt.Println("Error creando archivo:", err)
                return
            }
            defer archivo.Close()

            datos :=[]byte("¡Hola, interfaces de Go!\n")
            err = escribirDatos(archivo, datos)
            if err != nil {
                fmt.Println("Error escribiendo en archivo:", err)
                return
            }

            // También podemos usar os.Stdout que también implementa io.Writer
            err = escribirDatos(os.Stdout, []byte("Escribiendo a stdout a través de la interfaz.\n"))
            if err != nil {
                fmt.Println("Error escribiendo a stdout:", err)
                return
            }
        }
        ```
* **Interfaz Vacía (`interface{}`):**
    * La interfaz vacía no tiene métodos.
    * Todos los tipos implementan la interfaz vacía.
    * Puede usarse para representar valores de cualquier tipo, pero a menudo se necesitan aserciones de tipo para acceder al valor subyacente.
    ```go
    var i interface{}
    i = 42
    fmt.Println(i)
    i = "hola"
    fmt.Println(i)

    valor, ok := i.(string) // Aserción de tipo a string
    if ok {
        fmt.Println("El valor es una cadena:", valor)
    } else {
        fmt.Println("El valor no es una cadena")
    }
    ```
* **Aserciones de Tipo y Type Switches:**
    * **Aserción de Tipo:** Se usa para extraer el valor concreto subyacente de una variable de interfaz.
        * Sintaxis: `valor, ok := variableInterfaz.(TipoConcreto)`
        * Si la aserción es correcta, `valor` contendrá el valor concreto y `ok` será `true`.
        * Si la aserción es incorrecta y no verificas `ok`, causará un panic.
    * **Type Switch:** Se usa para realizar diferentes acciones basadas en el tipo concreto contenido en una variable de interfaz.
        ```go
        func describir(i interface{}) {
            switch v := i.(type) {
            case int:
                fmt.Printf("El doble de %v es %v\n", v, v*2)
            case string:
                fmt.Printf("%q tiene %v bytes de largo\n", v, len(v))
            default:
                fmt.Printf("¡No sé nada sobre el tipo %T!\n", v)
            }
        }

        func main() {
            describir(42)
            describir("hola")
            describir(true)
        }
        ```

**VIII. Goroutines y Concurrencia**

El modelo de concurrencia de Go se basa en goroutines y channels.

* **Goroutines:**
    * Funciones concurrentes ligeras.
    * Se crean usando la palabra clave `go` seguida de una llamada a función.
    * Las goroutines se ejecutan concurrentemente con otras funciones y goroutines.
    * Mucho más baratas de crear y gestionar que los hilos tradicionales del sistema operativo.
    ```go
    package main

    import (
        "fmt"
        "time"
    )

    func decir(s string) {
        for i := 0; i < 5; i++ {
            time.Sleep(100 * time.Millisecond)
            fmt.Println(s)
        }
    }

    func main() {
        go decir("mundo") // Inicia una nueva goroutine
        decir("hola")    // Se ejecuta en la goroutine principal

        // Espera un poco para ver la salida de la goroutine
        time.Sleep(time.Second)
    }
    ```
* **Channels:**
    * Conductos tipados a través de los cuales las goroutines pueden enviar y recibir valores.
    * Proporcionan una forma segura para que el código concurrente se comunique y sincronice.
    * Se crean usando la sintaxis `make(chan Tipo)`.
    * Enviar a un channel: `canal <- valor`
    * Recibir de un channel: `valor := <-canal`
    ```go
    package main

    import "fmt"

    func sumar(s []int, c chan int) {
        suma := 0
        for _, v := range s {
            suma += v
        }
        c <- suma // Envía la suma al channel
    }

    func main() {
        s := []int{7, 2, 8, -9, 4, 0}

        c := make(chan int)
        go sumar(s[:len(s)/2], c) // Calcula la suma de la primera mitad en una goroutine
        go sumar(s[len(s)/2:], c) // Calcula la suma de la segunda mitad en una goroutine
        x, y := <-c, <-c       // Recibe los resultados del channel

        fmt.Println(x, y, x+y)
    }
    ```
* **Channels con Búfer:**
    * Channels con capacidad para contener un cierto número de valores sin que un receptor esté inmediatamente listo.
    * Se crean usando `make(chan Tipo, capacidad)`.
    * Los envíos a un channel con búfer se bloquearán solo cuando el búfer esté lleno.
    * Las recepciones se bloquearán solo cuando el búfer esté vacío.
* **Dirección del Channel:**
    * Puedes especificar la dirección del flujo de datos en un tipo de channel:
        * `chan<- int`: Channel de solo envío (solo puede enviar enteros).
        * `<-chan int`: Channel de solo recepción (solo puede recibir enteros).
    * Útil para restringir cómo se usan los channels en funciones.
    ```go
    func emisor(out chan<- string) {
        out <- "Hola desde el emisor"
    }

    func receptor(in <-chan string) {
        msg := <-in
        fmt.Println("Recibido:", msg)
    }

    func main() {
        ch := make(chan string)
        go emisor(ch)
        go receptor(ch)
        time.Sleep(time.Second)
    }
    ```
* **Sentencia `select`:**
    * Permite que una goroutine espere en múltiples operaciones de comunicación.
    * Se bloquea hasta que uno de sus casos puede proceder, luego ejecuta ese caso.
    * Si múltiples casos están listos, uno se elige al azar.
    * Puede tener un caso `default` que se ejecuta inmediatamente si ningún otro caso está listo.
    ```go
    package main

    import (
        "fmt"
        "time"
    )

    func main() {
        c1 := make(chan string)
        c2 := make(chan string)

        go func() {
            time.Sleep(1 * time.Second)
            c1 <- "uno"
        }()
        go func() {
            time.Sleep(2 * time.Second)
            c2 <- "dos"
        }()

        for i := 0; i < 2; i++ {
            select {
            case msg1 := <-c1:
                fmt.Println("recibido", msg1)
            case msg2 := <-c2:
                fmt.Println("recibido", msg2)
            }
        }
    }
    ```
* **Primitivas de Sincronización:**
    * **`sync.WaitGroup`:** Espera a que una colección de goroutines termine.
    * **`sync.Mutex`:** Proporciona un bloqueo de exclusión mutua básico.
    * **`sync.RWMutex`:** Proporciona un bloqueo de lector/escritor, permitiendo múltiples lectores o un solo escritor.
    * **`sync.Once`:** Asegura que una función se ejecute solo una vez.

**IX. Manejo de Errores**

Go favorece el manejo explícito de errores usando la interfaz `error`.

* **La Interfaz `error`:**
    * Definida como: `type error interface { Error() string }`
    * Las funciones que pueden fallar típicamente retornan un valor de tipo `error` como último valor de retorno.
    * El valor `nil` indica éxito; un valor `error` no nulo indica fallo.
* **Creando Errores:**
    * Usa la función `errors.New()` del paquete `errors` para crear valores de error simples.
    * Usa `fmt.Errorf()` para crear mensajes de error formateados.
* **Manejando Errores:**
    * Verifica el valor `error` retornado después de llamar a una función que puede fallar.
    * Usa `if err != nil` para manejar el error.
    * Puedes envolver errores para proporcionar más contexto usando librerías como `fmt.Errorf()` con `%w`.
* **Tipos de Error Personalizados:**
    * Puedes crear tus propios tipos de error definiendo un struct que implemente la interfaz `error` (es decir, que tenga un método `Error() string`).
    ```go
    package main

    import (
        "errors"
        "fmt"
        "time"
    )

    type TimeoutError struct {
        duracion time.Duration
    }

    func (e *TimeoutError) Error() string {
        return fmt.Sprintf("la operación agotó el tiempo de espera después de %v", e.duracion)
    }

    func realizarOperacion(timeout time.Duration) error {
        time.Sleep(timeout + 1*time.Second) // Simula una operación larga
        return &TimeoutError{duracion: timeout}
    }

    func main() {
        err := realizarOperacion(2 * time.Second)
        if err != nil {
            fmt.Println("Error:", err)
            if te, ok := err.(*TimeoutError); ok {
                fmt.Printf("Fue un error de timeout de %v\n", te.duracion)
            }
        } else {
            fmt.Println("Operación exitosa")
        }
    }
    ```
* **`panic` y `recover`:**
    * `panic` se usa para señalar un error en tiempo de ejecución del que el programa no puede recuperarse. Detiene la ejecución de la función actual y desenrolla la pila, llamando a cualquier función diferida en el camino.
    * `recover` es una función incorporada que puede recuperar el control de una goroutine en panic. Debe llamarse dentro de una función diferida. `recover` retorna el valor pasado a `panic`, o `nil` si la goroutine no está en panic.
    * `panic` y `recover` deben usarse con moderación, principalmente para errores críticos e irrecuperables. Para la mayoría de los errores esperados, usa la interfaz `error`.
    ```go
    package main

    import "fmt"

    func puedePanic() {
        panic("algo salió mal")
    }

    func funcionRecuperar() {
        if r := recover(); r != nil {
            fmt.Println("Recuperado del panic:", r)
        }
    }

    func main() {
        defer funcionRecuperar()
        fmt.Println("Antes de puedePanic")
        puedePanic()
        fmt.Println("Después de puedePanic (esto no se alcanzará)")
    }
    ```

**X. Paquetes y Módulos**

El código de Go se organiza en paquetes.

* **Paquetes:**
    * Una colección de archivos fuente en el mismo directorio que se compilan juntos.
    * Proporcionan espacios de nombres para evitar conflictos de nombres.
    * Los nombres de los paquetes suelen ser el nombre del directorio.
    * Los programas ejecutables deben tener un paquete `main` con una función `main`.
    * Las librerías pueden tener cualquier nombre de paquete.
* **Importaciones:**
    * Usa la palabra clave `import` para incorporar funcionalidad de otros paquetes.
    * Los paquetes de la librería estándar se importan por su nombre corto (ej., `"fmt"`, `"net/http"`).
    * Los paquetes de terceros típicamente se importan usando su ruta de módulo (ej., `"github.com/gin-gonic/gin"`).
    * **Rutas de Importación:**
        * Importaciones relativas (desaconsejadas y tienen reglas específicas dentro de un módulo).
        * Importaciones absolutas (recomendadas), comenzando con la ruta del módulo.
    * **Alias de Importación:** Puedes dar a un paquete un nombre diferente localmente usando un alias: `import f "fmt"`.
    * **Identificador en Blanco (`_`):** Se usa para importar un paquete únicamente por sus efectos secundarios (ej., inicializar estado interno): `import _ "net/http/pprof"`.
* **Módulos (Go 1.11 y posteriores):**
    * La forma principal de gestionar dependencias en Go.
    * Definidos por un archivo `go.mod` en la raíz de tu proyecto.
    * El archivo `go.mod` rastrea la ruta del módulo y las dependencias de tu proyecto.
    * **`go mod init <ruta_módulo>`:** Inicializa un nuevo módulo.
    * **`go get <paquete>@<versión>`:** Añade o actualiza una dependencia.
    * **`go build`, `go run`, `go test`:** Gestionan automáticamente las dependencias del módulo.
    * **`go.sum`:** Contiene hashes criptográficos de las dependencias para garantizar la integridad.
* **Visibilidad:**
    * Los identificadores (variables, funciones, tipos, etc.) que comienzan con una letra mayúscula se exportan (públicos) y pueden ser accedidos desde otros paquetes.
    * Los identificadores que comienzan con una letra minúscula no se exportan (privados) y solo pueden ser accedidos dentro del mismo paquete.

**XI. Testing**

Go tiene soporte incorporado para testing.

* **Archivos de Test:**
    * Los archivos de test se nombran con el sufijo `_test.go` (ej., `mifuncion_test.go`).
    * Residen en el mismo paquete que el código que se está probando.
* **Funciones de Test:**
    * Las funciones de test tienen nombres que comienzan con `Test` y toman un único argumento de tipo `*testing.T`.
    * Usa métodos en `*testing.T` (ej., `t.Log`, `t.Error`, `t.Errorf`, `t.Fatal`, `t.Fatalf`) para reportar resultados del test.
* **Ejemplo de Test:**
    ```go
    // mifuncion.go
    package mipaquete

    func Sumar(a, b int) int {
        return a + b
    }

    // mifuncion_test.go
    package mipaquete_test

    import "testing"

    func TestSumar(t *testing.T) {
        resultado := Sumar(2, 3)
        esperado := 5
        if resultado != esperado {
            t.Errorf("Sumar(2, 3) retornó %d, esperado %d", resultado, esperado)
        }
    }
    ```
* **Ejecutando Tests:**
    * Usa el comando `go test` en el directorio que contiene tu paquete.
    * `go test -v`: Salida detallada, mostrando el nombre de cada test.
    * `go test ./...`: Ejecuta tests en el directorio actual y todos los subdirectorios.
    * `go test -run <patrón>`: Ejecuta solo los tests cuyos nombres coincidan con la expresión regular dada.
* **Tests de Benchmark:**
    * Miden el rendimiento de tu código.
    * Las funciones de benchmark tienen nombres que comienzan con `Benchmark` y toman un único argumento de tipo `*testing.B`.
    * Usa el bucle `b.N` para ejecutar el código que se está evaluando múltiples veces.
    ```go
    // mifuncion_test.go
    package mipaquete_test

    import (
        "testing"
    )

    func BenchmarkSumar(b *testing.B) {
        for i := 0; i < b.N; i++ {
            Sumar(2, 3)
        }
    }
    ```
    * Ejecuta benchmarks usando `go test -bench=.`
* **Tests de Ejemplo:**
    * Proporcionan ejemplos ejecutables en la documentación de tu paquete.
    * Las funciones de ejemplo tienen nombres que comienzan con `Example`.
    * Se compilan y ejecutan durante el testing, y su salida se compara con un comentario dentro de la función.

Esto concluye la guía completa del lenguaje de programación Go. Recuerda que la práctica y