---
audio: false
generated: true
lang: es
layout: post
title: Función Hash SHA-1
translated: true
type: note
---

Profundicemos en cómo funciona el fragmento de código proporcionado, específicamente las líneas:

```python
hash_obj = hashlib.sha1(piece)
hashes.append(hash_obj.hexdigest())
return hashes
```

El usuario nos ha pedido que expliquemos esto sin usar una librería, así que primero explicaré lo que hace el código con la librería `hashlib`, y luego exploraré cómo se podría lograr la misma funcionalidad sin ella.

---

### Comprendiendo el Código con `hashlib`

Este fragmento calcula un hash para una porción de datos y lo almacena en una lista. Aquí hay un desglose paso a paso de lo que sucede:

1.  **`hash_obj = hashlib.sha1(piece)`**
    *   **Qué hace**: Esta línea utiliza el módulo `hashlib` de Python para crear un objeto hash SHA-1. SHA-1 (Secure Hash Algorithm 1) es una función hash criptográfica que toma una entrada (aquí, `piece`) y produce un valor hash de 160 bits (20 bytes).
    *   **Entrada**: `piece` es un fragmento de datos, probablemente en bytes, leído de un archivo u otra fuente.
    *   **Proceso**: La función `hashlib.sha1()` inicializa un objeto hash y lo actualiza inmediatamente con los datos en `piece`. Piensa en ello como alimentar los datos a una máquina de hashing que comienza a procesar números.

2.  **`hashes.append(hash_obj.hexdigest())`**
    *   **Qué hace**: El método `hexdigest()` recupera el valor hash calculado por el objeto hash y lo convierte en una cadena hexadecimal (un formato legible para humanos que utiliza dígitos 0-9 y letras a-f).
    *   **Salida**: Para SHA-1, esta cadena tiene 40 caracteres de longitud porque cada uno de los 20 bytes se representa con dos dígitos hexadecimales (por ejemplo, un valor de byte 255 se convierte en "ff").
    *   **Almacenamiento**: La cadena resultante se añade a una lista llamada `hashes`, que presumiblemente recopila hashes para múltiples porciones de datos.

3.  **`return hashes`**
    *   **Qué hace**: Después de procesar todas las porciones (asumiendo que este código está en un bucle o función), se devuelve la lista `hashes` que contiene todas las cadenas hash hexadecimales.

**En resumen**: Para cada `piece` de datos, el código calcula su hash SHA-1 usando `hashlib.sha1()`, convierte el hash a una cadena hexadecimal con `hexdigest()`, y lo almacena en la lista `hashes`, que luego se devuelve.

---

### Sin Usar una Librería: Computando SHA-1 desde Cero

La instrucción del usuario "do not use lib" sugiere que quiere entender cómo podría funcionar esto sin depender de `hashlib`. Implementar SHA-1 desde cero es complejo, pero explicaré el proceso claramente y proporcionaré una versión simplificada sobre la que se podría construir.

#### ¿Qué es SHA-1?
SHA-1 es una función hash que:
*   Toma cualquier dato de entrada (por ejemplo, `piece`).
*   Produce una salida fija de 160 bits (20 bytes).
*   Utiliza una serie de operaciones a nivel de bit, rotaciones y sumas para transformar la entrada.

Sin `hashlib`, necesitaríamos replicar este algoritmo nosotros mismos. Así es como podría funcionar para el código dado:

#### Proceso SHA-1 Paso a Paso

1.  **Preparar la Entrada (Relleno/Padding)**
    *   SHA-1 procesa datos en bloques de 512 bits (64 bytes). Si `piece` no tiene exactamente 64 bytes, lo rellenamos:
        *   Añadir un bit `1` (por ejemplo, `0x80` en bytes).
        *   Añadir suficientes bits `0` para que la longitud sea de 448 bits (56 bytes) módulo 512.
        *   Añadir la longitud original de `piece` (en bits) como un entero de 64 bits.
    *   Para simplificar, si `piece` es más pequeño que 64 bytes, podemos rellenarlo a un bloque.

2.  **Inicializar los Valores Hash**
    *   SHA-1 utiliza cinco variables de 32 bits (160 bits en total), inicializadas a constantes específicas:
        *   `h0 = 0x67452301`
        *   `h1 = 0xEFCDAB89`
        *   `h2 = 0x98BADCFE`
        *   `h3 = 0x10325476`
        *   `h4 = 0xC3D2E1F0`

3.  **Procesar el Bloque de Datos**
    *   Dividir el bloque de 64 bytes en 16 palabras de 32 bits (4 bytes cada una).
    *   Expandirlas a 80 palabras usando la fórmula:
        ```python
        w[i] = left_rotate(w[i-3] ^ w[i-8] ^ w[i-14] ^ w[i-16], 1)  # para i = 16 a 79
        ```
        donde `left_rotate` desplaza los bits a la izquierda y los rota.
    *   Durante 80 rondas, actualizar las variables temporales `a`, `b`, `c`, `d`, `e` (comenzando como copias de `h0` a `h4`):
        *   Usar diferentes funciones y constantes basadas en el número de ronda (0-19, 20-39, etc.).
        *   Ejemplo para rondas 0-19:
            ```python
            f = (b & c) | (~b & d)
            k = 0x5A827999
            temp = (left_rotate(a, 5) + f + e + k + w[i]) & 0xFFFFFFFF
            ```
        *   Desplazar variables: `e = d`, `d = c`, `c = left_rotate(b, 30)`, `b = a`, `a = temp`.

4.  **Actualizar los Valores Hash**
    *   Después de las 80 rondas, sumar los resultados a los valores hash iniciales:
        ```python
        h0 = (h0 + a) & 0xFFFFFFFF
        h1 = (h1 + b) & 0xFFFFFFFF
        # ...y así sucesivamente para h2, h3, h4
        ```

5.  **Producir la Salida Hexadecimal**
    *   Concatenar `h0` a `h4` como un valor de 160 bits y convertirlo a una cadena hexadecimal de 40 caracteres.

#### Implementación Python Simplificada

Aquí hay una versión básica de cómo podrías reescribir el código sin `hashlib`:

```python
def left_rotate(value, shift):
    """Rota un entero de 32 bits a la izquierda 'shift' bits."""
    return ((value << shift) | (value >> (32 - shift))) & 0xFFFFFFFF

def custom_sha1(piece):
    """Calcula el hash SHA-1 de 'piece' y lo devuelve como una cadena hexadecimal."""
    # Para simplificar, asumimos que piece es menor de 56 bytes y lo rellenamos a un bloque
    message = piece + b'\x80' + (b'\x00' * (55 - len(piece))) + (len(piece) * 8).to_bytes(8, 'big')
    
    # Inicializar valores hash
    h0, h1, h2, h3, h4 = (
        0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0
    )
    
    # Dividir en 16 palabras de 32 bits
    w = [int.from_bytes(message[i:i+4], 'big') for i in range(0, 64, 4)]
    
    # Expandir a 80 palabras
    for i in range(16, 80):
        w.append(left_rotate(w[i-3] ^ w[i-8] ^ w[i-14] ^ w[i-16], 1))
    
    # Inicializar variables de trabajo
    a, b, c, d, e = h0, h1, h2, h3, h4
    
    # 80 rondas de procesamiento
    for i in range(80):
        if 0 <= i < 20:
            f = (b & c) | (~b & d)
            k = 0x5A827999
        elif 20 <= i < 40:
            f = b ^ c ^ d
            k = 0x6ED9EBA1
        elif 40 <= i < 60:
            f = (b & c) | (b & d) | (c & d)
            k = 0x8F1BBCDC
        else:
            f = b ^ c ^ d
            k = 0xCA62C1D6
        
        temp = (left_rotate(a, 5) + f + e + k + w[i]) & 0xFFFFFFFF
        e = d
        d = c
        c = left_rotate(b, 30)
        b = a
        a = temp
    
    # Actualizar valores hash
    h0 = (h0 + a) & 0xFFFFFFFF
    h1 = (h1 + b) & 0xFFFFFFFF
    h2 = (h2 + c) & 0xFFFFFFFF
    h3 = (h3 + d) & 0xFFFFFFFF
    h4 = (h4 + e) & 0xFFFFFFFF
    
    # Devolver como cadena hexadecimal de 40 caracteres
    return f"{h0:08x}{h1:08x}{h2:08x}{h3:08x}{h4:08x}"

# Código reescrito sin hashlib
def compute_hashes(pieces):
    hashes = []
    for piece in pieces:  # Asumiendo que pieces es una lista de fragmentos de bytes
        hash_value = custom_sha1(piece)
        hashes.append(hash_value)
    return hashes

# Ejemplo de uso
pieces = [b"hello", b"world"]
hashes = compute_hashes(pieces)
print(hashes)
```

#### Cómo Coincide con el Original
*   **`hash_obj = hashlib.sha1(piece)`**: Se reemplaza por `custom_sha1(piece)`, que calcula el hash SHA-1 manualmente.
*   **`hashes.append(hash_obj.hexdigest())`**: La función `custom_sha1` devuelve la cadena hexadecimal directamente, así que la añadimos a `hashes`.
*   **`return hashes`**: Permanece igual, devolviendo la lista de cadenas hash.

---

### Diferencias Clave y Advertencias
*   **Simplificación**: Esta implementación asume que cada `piece` cabe en un bloque de 512 bits (menos de 56 bytes debido al relleno). Una implementación SHA-1 completa manejaría múltiples bloques.
*   **Rendimiento**: Una implementación manual es más lenta y menos optimizada que `hashlib`.
*   **Confiabilidad**: Librerías como `hashlib` están probadas y son seguras; una versión personalizada podría tener errores a menos que se valide exhaustivamente.

En esencia, el código original usa `hashlib` como un atajo para calcular hashes SHA-1 de manera eficiente, mientras que hacerlo sin una librería requiere codificar manualmente todo el algoritmo SHA-1, manejar el relleno y convertir el resultado a formato hexadecimal. La lógica sigue siendo la misma: procesar cada porción, calcular su hash, almacenarlo y devolver la colección.