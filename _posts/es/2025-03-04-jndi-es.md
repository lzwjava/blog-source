---
audio: false
generated: true
lang: es
layout: post
title: Interfaz de Nomenclatura y Directorios de Java
translated: true
type: note
---

### Puntos Clave
- Parece probable que `javax.naming` se utilice para Java Naming and Directory Interface (JNDI) para buscar y gestionar objetos nombrados en servicios como bases de datos.
- La investigación sugiere que necesitas un contexto inicial para comenzar, típicamente configurado por un servidor de aplicaciones Java EE para producción, o manualmente para pruebas.
- La evidencia apunta a usar `InitialContext` para búsquedas, como encontrar un DataSource con nombres como "java:comp/env/jdbc/datasource".

### Cómo Empezar con `javax.naming`
`javax.naming` es parte de JNDI, que ayuda a las aplicaciones Java a interactuar con servicios de nombres y directorios, como buscar conexiones a bases de datos. En un entorno Java EE, el servidor de aplicaciones normalmente configura esto, facilitando encontrar recursos por sus nombres.

### Ejemplo de Uso
Aquí hay una forma simple de buscar un DataSource en una aplicación Java EE:
```java
InitialContext ctx = new InitialContext();
DataSource ds = (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
```
Esto asume que el DataSource ya está configurado en tu servidor. Para pruebas sin un servidor, podrías necesitar bibliotecas adicionales como Simple-JNDI.

### Detalle Inesperado
Podrías no esperar que para aplicaciones independientes, configurar JNDI pueda requerir configurar un contexto personalizado, lo cual puede ser complejo sin herramientas como Simple-JNDI.

---

### Nota de Estudio: Guía Completa para Usar `javax.naming`

Esta nota proporciona una exploración detallada del uso de `javax.naming`, parte de Java Naming and Directory Interface (JNDI), que facilita la interacción con servicios de nombres y directorios en aplicaciones Java. JNDI está diseñado para ser independiente de implementaciones de servicios específicas, permitiendo acceder a varios servicios como bases de datos, LDAP y sistemas de archivos de manera unificada. Esta sección amplía la respuesta directa, ofreciendo una comprensión exhaustiva para desarrolladores, incluyendo configuración, ejemplos y consideraciones para diferentes entornos.

#### Entendiendo `javax.naming` y JNDI
`javax.naming` es el paquete principal para JNDI, introducido como parte de la biblioteca estándar de Java para proporcionar funcionalidad de nombres y directorios. Define la interfaz `Context`, central para las operaciones JNDI, que incluye métodos para buscar, enlazar, desenlazar y renombrar objetos, así como crear y destruir subcontextos. El método `lookup()` se usa comúnmente para recuperar objetos por sus nombres, haciéndolo esencial para el acceso a recursos en aplicaciones empresariales.

JNDI es particularmente útil en entornos Java EE, donde permite a las aplicaciones desacoplarse de detalles de servicios específicos, mejorando la portabilidad y flexibilidad. Por ejemplo, a menudo se usa para acceder a recursos como conexiones de base de datos (DataSources), proveedores JMS y servicios JavaMail, gestionados por el servidor de aplicaciones.

#### Configuración y Uso de JNDI
Para usar `javax.naming`, comienzas creando un contexto inicial, que sirve como punto de entrada para operaciones de nombres. Esto se hace típicamente usando la clase `InitialContext`. La configuración varía según el entorno:

- **En Aplicaciones Java EE:** El servidor de aplicaciones (ej. Tomcat, JBoss, WebSphere) configura el contexto inicial. Puedes buscar recursos usando nombres JNDI estándar, a menudo con prefijos como "java:comp/env/". Por ejemplo, un DataSource podría ser accedido en "java:comp/env/jdbc/datasource".
- **En Aplicaciones Independientes:** Sin un servidor de aplicaciones, necesitas configurar el contexto inicial manualmente, especificando propiedades como el proveedor del servicio de nombres y la URL. Esto puede ser complejo, requiriendo bibliotecas adicionales para pruebas, como Simple-JNDI, que proporciona una implementación en memoria.

Aquí hay una tabla que resume las clases clave y sus roles en `javax.naming`:

| Clase/Interfaz         | Rol                                                                 |
|-------------------------|----------------------------------------------------------------------|
| `Context`              | Interfaz principal para operaciones de nombres como lookup, bind y unbind. |
| `InitialContext`       | Crea el contexto inicial para comenzar operaciones JNDI.            |
| `Name`                 | Representa un nombre genérico, una secuencia ordenada de componentes. |
| `NamingException`      | Clase base para excepciones lanzadas durante operaciones de nombres. |

#### Ejemplos Prácticos
Exploremos ejemplos para escenarios tanto Java EE como independientes:

##### Ejemplo 1: Buscar un DataSource en Java EE
En una aplicación Java EE, podrías buscar un DataSource configurado de la siguiente manera:

```java
import javax.naming.InitialContext;
import javax.sql.DataSource;
import java.sql.*;

public class JNDIExample {
    public static void main(String[] args) throws Exception {
        InitialContext ctx = new InitialContext();
        DataSource ds = (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
        Connection conn = ds.getConnection();
        // Usar la conexión...
        conn.close();
        ctx.close();
    }
}
```

Este ejemplo asume que el DataSource está configurado en el servidor de aplicaciones, típicamente en archivos como `context.xml` para Tomcat. El nombre JNDI "java:comp/env/jdbc/datasource" es una convención estándar, pero puede variar según la configuración del servidor.

##### Ejemplo 2: Enlazar y Buscar un Objeto Personalizado
Para pruebas o uso independiente, podrías querer crear un contexto simple en memoria. Si bien la API estándar no incluye una fábrica de contexto en memoria, bibliotecas como Simple-JNDI pueden ayudar. Aquí hay un ejemplo conceptual asumiendo tal configuración:

```java
import javax.naming.*;

public class JNDIExample {
    public static void main(String[] args) throws NamingException {
        Context ctx = new InitialContext();
        ctx.rebind("myObject", "Hello, World!");
        String value = (String) ctx.lookup("myObject");
        System.out.println(value);
        ctx.close();
    }
}
```

Nota: Este ejemplo independiente requiere configurar el contexto inicial con propiedades apropiadas, lo que podría implicar establecer `java.naming.factory.initial` a una fábrica de contexto personalizada, como una proporcionada por Simple-JNDI.

#### Consideraciones para Diferentes Entornos
- **Producción (Java EE):** En producción, el servidor de aplicaciones maneja la configuración JNDI, haciendo sencillo buscar recursos. Es común usar JNDI para pools de conexiones de base de datos, donde el servidor gestiona las conexiones, mejorando la escalabilidad y seguridad. Por ejemplo, cambiar credenciales de base de datos requiere actualizar solo la configuración del servidor, no el código de la aplicación.
- **Pruebas (Independiente):** Para pruebas unitarias y de integración, a menudo es necesario ejecutar sin un servidor de aplicaciones. Bibliotecas como Simple-JNDI ([Simple-JNDI GitHub](https://github.com/h-thurow/Simple-JNDI)) te permiten simular entornos JNDI, enlazando recursos programáticamente. Esto es crucial para probar código que depende de búsquedas JNDI, asegurando que funciona sin desplegar en un servidor.
- **Seguridad y Mejores Prácticas:** Ten cuidado con las inyecciones JNDI, especialmente en versiones antiguas de Java, ya que pueden llevar a vulnerabilidades de seguridad como ejecución remota de código. Oracle ha abordado muchos de estos problemas, con actualizaciones como Java 8u191 cerrando exploits de vectores LDAP. Siempre valida las entradas y usa las últimas versiones de Java por seguridad.

#### Detalle Inesperado: Complejidad en la Configuración Independiente
Uno podría no esperar la complejidad involucrada en configurar JNDI sin un servidor de aplicaciones. Mientras que Java EE simplifica esto con contextos gestionados por el servidor, las configuraciones independientes requieren configurar fábricas de contexto y propiedades, a menudo necesitando bibliotecas de terceros. Esto puede ser una barrera para desarrolladores nuevos en JNDI, pero herramientas como Simple-JNDI mitigan esto proporcionando implementaciones basadas en memoria.

#### Lecturas Adicionales y Recursos
Para una comprensión más profunda, consulta lo siguiente:
- [Tutoriales de Oracle Java: Descripción General de JNDI](https://docs.oracle.com/en/ java/ tutorial/jndi/ overview/index.html) para documentación oficial.
- [Baeldung: Descripción General de Java Naming and Directory Interface](https://www.baeldung.com/jndi) para ejemplos prácticos y uso moderno.
- [Simple-JNDI GitHub](https://github.com/h-thurow/Simple-JNDI) para probar JNDI sin servidores.

Estos recursos proporcionan ejemplos de código, tutoriales y mejores prácticas, asegurando que puedas implementar JNDI efectivamente en varios escenarios.

#### Citas Clave
- [Tutoriales de Oracle Java Descripción General de JNDI](https://docs.oracle.com/en/ java/ tutorial/jndi/ overview/index.html)
- [Baeldung Java Naming and Directory Interface Overview](https://www.baeldung.com/jndi)
- [Simple-JNDI Access property files via JNDI lookups](https://github.com/h-thurow/Simple-JNDI)