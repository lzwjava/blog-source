---
audio: false
generated: true
lang: es
layout: post
title: Interfaz de Nombres y Directorio de Java (JNDI)
translated: true
---

### Puntos Clave
- Parece probable que `javax.naming` se utilice para la Interfaz de Nombres y Directorios de Java (JNDI) para buscar y gestionar objetos con nombre en servicios como bases de datos.
- La investigación sugiere que necesitas un contexto inicial para empezar, generalmente configurado por un servidor de aplicaciones Java EE para producción, o manualmente para pruebas.
- Las pruebas indican el uso de `InitialContext` para búsquedas, como encontrar un DataSource con nombres como "java:comp/env/jdbc/datasource".

### Empezando con `javax.naming`
`javax.naming` es parte de JNDI, que ayuda a las aplicaciones Java a interactuar con servicios de nombres y directorios, como buscar conexiones de bases de datos. En un entorno Java EE, el servidor de aplicaciones generalmente configura esto, facilitando la búsqueda de recursos por sus nombres.

### Ejemplo de Uso
Aquí hay una forma sencilla de buscar un DataSource en una aplicación Java EE:
```java
InitialContext ctx = new InitialContext();
DataSource ds = (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
```
Esto supone que el DataSource ya está configurado en tu servidor. Para pruebas sin servidor, es posible que necesites bibliotecas adicionales como Simple-JNDI.

### Detalle Inesperado
Es posible que no esperes que para aplicaciones independientes, configurar JNDI pueda requerir configurar un contexto personalizado, lo cual puede ser complejo sin herramientas como Simple-JNDI.

---

### Nota de Encuesta: Guía Completa para Usar `javax.naming`

Esta nota proporciona una exploración detallada del uso de `javax.naming`, parte de la Interfaz de Nombres y Directorios de Java (JNDI), que facilita la interacción con servicios de nombres y directorios en aplicaciones Java. JNDI está diseñado para ser independiente de las implementaciones específicas de servicios, permitiendo el acceso a diversos servicios como bases de datos, LDAP y sistemas de archivos de manera unificada. Esta sección amplía la respuesta directa, ofreciendo una comprensión exhaustiva para desarrolladores, incluyendo configuración, ejemplos y consideraciones para diferentes entornos.

#### Entendiendo `javax.naming` y JNDI
`javax.naming` es el paquete principal para JNDI, introducido como parte de la biblioteca estándar de Java para proporcionar funcionalidad de nombres y directorios. Define la interfaz `Context`, central para las operaciones de JNDI, que incluye métodos para buscar, vincular, desvincular y renombrar objetos, así como crear y destruir subcontexto. El método `lookup()` se utiliza comúnmente para recuperar objetos por sus nombres, haciéndolo esencial para el acceso a recursos en aplicaciones empresariales.

JNDI es particularmente útil en entornos Java EE, donde permite a las aplicaciones desconectarse de los detalles específicos del servicio, mejorando la portabilidad y flexibilidad. Por ejemplo, se utiliza a menudo para acceder a recursos como conexiones de bases de datos (DataSources), proveedores JMS y servicios JavaMail, gestionados por el servidor de aplicaciones.

#### Configuración y Uso de JNDI
Para usar `javax.naming`, comienzas creando un contexto inicial, que sirve como punto de entrada para las operaciones de nombres. Esto generalmente se hace usando la clase `InitialContext`. La configuración varía según el entorno:

- **En Aplicaciones Java EE:** El servidor de aplicaciones (por ejemplo, Tomcat, JBoss, WebSphere) configura el contexto inicial. Puedes buscar recursos usando nombres JNDI estándar, a menudo prefijados con "java:comp/env/". Por ejemplo, un DataSource podría accederse en "java:comp/env/jdbc/datasource".
- **En Aplicaciones Independientes:** Sin un servidor de aplicaciones, necesitas configurar el contexto inicial manualmente, especificando propiedades como el proveedor del servicio de nombres y la URL. Esto puede ser complejo, requiriendo bibliotecas adicionales para pruebas, como Simple-JNDI, que proporciona una implementación en memoria.

Aquí hay una tabla que resume las clases clave y sus roles en `javax.naming`:

| Clase/Interfaz        | Rol                                                                 |
|-------------------------|----------------------------------------------------------------------|
| `Context`              | Interfaz principal para operaciones de nombres como buscar, vincular y desvincular.   |
| `InitialContext`       | Crea el contexto inicial para comenzar operaciones JNDI.             |
| `Name`                 | Representa un nombre genérico, una secuencia ordenada de componentes.         |
| `NamingException`      | Clase base para excepciones lanzadas durante operaciones de nombres.            |

#### Ejemplos Prácticos
Exploremos ejemplos tanto para escenarios Java EE como independientes:

##### Ejemplo 1: Buscar un DataSource en Java EE
En una aplicación Java EE, podrías buscar un DataSource configurado de la siguiente manera:

```java
import javax.naming.InitialContext;
import javax.sql.DataSource;
import java.sql.*;

public class JNDIExample {
    public static void main(String[] args) throws Exception {
        InitialContext ctx = new InitialContext();
        DataSource ds = (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
        Connection conn = ds.getConnection();
        // Usar la conexión...
        conn.close();
        ctx.close();
    }
}
```

Este ejemplo supone que el DataSource está configurado en el servidor de aplicaciones, generalmente en archivos como `context.xml` para Tomcat. El nombre JNDI "java:comp/env/jdbc/datasource" es una convención estándar, pero puede variar según la configuración del servidor.

##### Ejemplo 2: Vincular y Buscar un Objeto Personalizado
Para pruebas o uso independiente, podrías querer crear un contexto en memoria simple. Aunque la API estándar no incluye un factoría de contexto en memoria, bibliotecas como Simple-JNDI pueden ayudar. Aquí hay un ejemplo conceptual asumiendo tal configuración:

```java
import javax.naming.*;

public class JNDIExample {
    public static void main(String[] args) throws NamingException {
        Context ctx = new InitialContext();
        ctx.rebind("myObject", "¡Hola, Mundo!");
        String value = (String) ctx.lookup("myObject");
        System.out.println(value);
        ctx.close();
    }
}
```

Nota: Este ejemplo independiente requiere configurar el contexto inicial con propiedades apropiadas, lo que podría implicar establecer `java.naming.factory.initial` a una factoría de contexto personalizada, como una proporcionada por Simple-JNDI.

#### Consideraciones para Diferentes Entornos
- **Producción (Java EE):** En producción, el servidor de aplicaciones maneja la configuración de JNDI, facilitando la búsqueda de recursos. Es común usar JNDI para grupos de conexiones de bases de datos, donde el servidor gestiona las conexiones, mejorando la escalabilidad y seguridad. Por ejemplo, cambiar las credenciales de la base de datos requiere actualizar solo la configuración del servidor, no el código de la aplicación.
- **Pruebas (Independiente):** Para pruebas unitarias e integradas, a menudo es necesario ejecutar sin un servidor de aplicaciones. Bibliotecas como Simple-JNDI ([Simple-JNDI GitHub](https://github.com/h-thurow/Simple-JNDI)) permiten simular entornos JNDI, vinculando recursos de manera programática. Esto es crucial para probar código que depende de búsquedas JNDI, asegurando que funcione sin desplegar en un servidor.
- **Seguridad y Mejores Prácticas:** Ten cuidado con las inyecciones JNDI, especialmente en versiones antiguas de Java, ya que pueden llevar a vulnerabilidades de seguridad como la ejecución de código remoto. Oracle ha abordado muchos de estos problemas, con actualizaciones como Java 8u191 cerrando vectores de explotación LDAP. Siempre valida las entradas y usa las versiones más recientes de Java para la seguridad.

#### Detalle Inesperado: Complejidad en la Configuración Independiente
Uno podría no esperar la complejidad involucrada en configurar JNDI sin un servidor de aplicaciones. Aunque Java EE simplifica esto con contextos gestionados por el servidor, las configuraciones independientes requieren configurar factorías de contexto y propiedades, a menudo necesitando bibliotecas de terceros. Esto puede ser una barrera para desarrolladores nuevos en JNDI, pero herramientas como Simple-JNDI mitigan esto proporcionando implementaciones basadas en memoria.

#### Lecturas Adicionales y Recursos
Para una comprensión más profunda, consulta los siguientes recursos:
- [Oracle Java Tutorials: JNDI Overview](https://docs.oracle.com/en/java/tutorial/jndi/overview/index.html) para documentación oficial.
- [Baeldung: Java Naming and Directory Interface Overview](https://www.baeldung.com/jndi) para ejemplos prácticos y uso moderno.
- [Simple-JNDI GitHub](https://github.com/h-thurow/Simple-JNDI) para probar JNDI sin servidores.

Estos recursos proporcionan ejemplos de código, tutoriales y mejores prácticas, asegurando que puedas implementar JNDI de manera efectiva en diversos escenarios.

#### Citaciones Clave
- [Oracle Java Tutorials JNDI Overview](https://docs.oracle.com/en/java/tutorial/jndi/overview/index.html)
- [Baeldung Java Naming and Directory Interface Overview](https://www.baeldung.com/jndi)
- [Simple-JNDI Access property files via JNDI lookups](https://github.com/h-thurow/Simple-JNDI)