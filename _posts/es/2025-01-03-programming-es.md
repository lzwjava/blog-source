---
audio: false
generated: false
image: false
lang: es
layout: post
title: 'Filosofía Completa de la Programación: Principios, Prácticas y Crecimiento
  Profesional'
translated: true
---

### Tabla de Contenidos

1. [Programación](#programación)
   - La programación como actividad creativa
   - Desarrollo de proyectos personales
   - Tendencias tecnológicas y aprendizaje por curiosidad
   - Filosofía de depuración y resolución de problemas
   - Desarrollo centrado en el usuario
   - Calidad del código y simplicidad
   - Integración de IA y automatización

2. [Convertirse en un Ingeniero Ilimitado](#convertirse-en-un-ingeniero-ilimitado)
   - Trabajar dentro de las limitaciones corporativas
   - Maximizar los recursos internos
   - Construcción de herramientas en la era de la IA
   - Transformación de mentalidad
   - Romper limitaciones percibidas

3. [Beneficios de Acumular Registros](#beneficios-de-acumular-registros)
   - Gestión de registros en entornos corporativos
   - Contexto histórico y resolución de problemas
   - Estrategias de organización de archivos de registro
   - Mantenimiento de proyectos a largo plazo
   - Preservación y compartición de conocimiento
   - Métodos automatizados de recolección de registros

## Programación

* Está bien hacer programación competitiva siempre que te motive.

* Programar es como escribir. La programación es una actividad creativa.

* Haz tu propio proyecto. Escribe tu blog técnico. Programa para un proyecto que mantendrás durante años, como mantener un blog de 10 años.

* Normalmente, no necesitas seguir lo que está de moda en tecnología, ya que muchas tendencias desaparecerán en unos años.

* Sigue tu curiosidad y programa por tu propio bien.

* Intenta crear programas para ti mismo. No son tareas de trabajo.

* Si a menudo te sientes infeliz al programar, entonces lo estás haciendo mal.

* iOS, Android, Backend, Frontend, IA, todo está bien. Al menos puedes intentar hacer un pequeño proyecto con ellos o aprender sobre ellos durante unos meses.

* Depurar es ser desconfiado. No confíes en cada línea de tu código; puedes pensar en una mejor manera de hacerlo.

* En programación, incluso un carácter o una línea de registro es importante. Te dicen algo.

* Usar la programación para hacer productos que otros usen. Es interesante tener usuarios.

* No necesitas ser severo. Unos cientos de usuarios que realmente aman tu producto es mejor que decenas de miles que solo lo aprecian amablemente.

* Recuerda por qué empezaste a programar y nunca lo olvides.

* Aplica el conocimiento de programación a cada aspecto de la vida. Son lo mismo. Hacer cosas en lotes o una por una. Cómo dividir trabajos en unidades. La tecnología subyacente detrás de cada aplicación. Los detalles matizados detrás de las solicitudes de red.

* La abstracción y el pensamiento lógico. El pensamiento orientado a los detalles. El pensamiento detrás de cada solución.

* La verdad es la verdad. Normalmente, la computadora no se equivoca. El circuito eléctrico no se equivoca. El compilador no se equivoca. No te sientas mal cuando hay un error.

* Busca soluciones elegantes y simples. La simplicidad es la máxima sofisticación. Debes pensar mucho para dejar lo esencial y eliminar lo extra.

* Para lenguajes de programación, los que cumplen el trabajo están bien. Personalmente recomiendo Java y Python.

* Sigue a Yin Wang en [https://www.yinwang.org](https://www.yinwang.org). Es uno de los pocos genios en programación, aunque él dice que los genios nunca existen.

* El conocimiento y los principios de programación se pueden aplicar fácilmente al aprendizaje de idiomas, reparación de hardware, life hacking e investigación científica.

* Para la mayoría de las tareas de programación, no necesitas matemáticas avanzadas más allá de las matemáticas de secundaria.

* Reflexiona sobre tu código antiguo después de años o mantén un proyecto de código durante mucho tiempo. Te enseñará mucho.

* Si pierdes la pasión por programar, simplemente haz otras cosas por un tiempo.

* El momento de las pruebas es importante. Hazlo naturalmente. A menudo no necesitas escribir pruebas para tu proyecto. Intenta no escribir pruebas, escribir pruebas unitarias, pruebas de integración, pruebas de API. Compáralas sabiamente.

* Prueba editores de código con IA. Usa ChatGPT u otros chatbots con frecuencia. Como las herramientas de IA son fáciles de usar ahora, puedes concentrarte en partes más creativas o importantes.

* Al depurar, verifica si estás usando la última versión de las bibliotecas. Si una biblioteca no se mantiene, busca clones o bifurcaciones activamente mantenidos.

* Al mejorar algo como la velocidad de red o el tiempo de ejecución del programa, debe haber una métrica cuantitativa. De lo contrario, no sabrás exactamente si hubo una mejora trivial o un deterioro.

* Para proyectos personales, está bien no escribir código de prueba, pero es mejor hacer pruebas locales después de cambiar una cantidad significativa de código. Considera el código afectado, cuánto tiempo se ejecutará en la nube y con qué frecuencia podría generar errores, y luego escribe el código de prueba en consecuencia. Usa métodos que permitan pruebas fáciles sin afectar negativamente la experiencia del usuario.

* Escribe código simple y elegante. Minimiza la duplicación, aunque a veces la duplicación lleva a una solución más simple. Minimiza los casos especiales. Haz que sea fácil de probar. Refactoriza para usar funciones o procesos comunes, usa recursión o bucles, y busca patrones.

* Maneja los errores correctamente. Piensa en la causa raíz, la responsabilidad y si podemos cambiarlo o si es un error externo. Considera el método de rescate, el alcance del impacto, dónde manejarlo, si debemos categorizar los errores, la probabilidad de que ocurra y los peores escenarios.

* La diferencia entre usar replace o usar startWith seguido de slice es que el primero ignora la posición de la cadena. Aplica un pensamiento similar a cada detalle de la programación.

* Minimiza los valores posibles para un elemento; usa solo un valor para un caso. No uses null si ya tenemos false. Si tenemos una bandera traducida verdadera o falsa, debemos asegurarnos de que cada vez que tengamos una bandera traducida, no tratemos la no existencia de una bandera traducida como falsa.

* Usa GitHub o Sourcetree para revisar bloques de código cambiados con frecuencia. Son más convenientes para leer código.

* En programación, a menudo no hay cosas triviales. Cada carácter, el orden de los elementos de la lista, cada cadena, cada número y cada nombre de variable importan. Cada orden de ejecución y cada registro importan.

* Haz las cosas que más te emocionen. No hay necesidad de preocuparse por no seguir la corriente.

* Usa comandos con frecuencia, ya que pueden ayudar a automatizar tareas o asistir con LLMs. Las operaciones de interfaz de usuario son más difíciles de automatizar.

* Guarda los registros de un programa, incluidos los registros locales, UAT, microservicios y registros de tuberías, en un directorio. En programación, estos registros contienen numerosas conexiones. Busca en ellos para identificar relaciones, recolectando datos o contexto relevantes.

* Con los registros recolectados, cuando encuentres un problema, es más fácil determinar si lo has encontrado antes. A partir de registros anteriores, podrías saber cómo solucionarlo. Los registros proporcionan una mejor comprensión de cómo funciona todo y cómo las computadoras ejecutan programas. A diferencia del código, los registros están relacionados con el tiempo y ofrecen más información sobre el estado de ejecución. También son más ligeros para depurar.

* La depuración muestra mucha información, incluidos los valores de las variables circundantes, nombres de hilos y pilas de funciones.

* Automatiza todo, como actualizaciones de proxy y selección del mejor servidor proxy. Usa Python para escribir scripts extensivamente.

* Mantén las cosas simples, haz funciones pequeñas y archivos pequeños. Esto los hace fáciles de probar, verificar y verificar con una muestra.

* Es la era de la IA, así que usa herramientas de IA para hacer pruebas exhaustivas y todo lo más perfecto posible. Genera excepciones antes. Agrega pruebas para el código y ejecútalas en la tubería todos los días. Los errores están bien, pero no cometas el mismo error dos veces. Evítalo con revisión de código.

---

## Convertirse en un Ingeniero Ilimitado

- Las grandes empresas aplican políticas estrictas de seguridad de datos donde los empleados o contratistas reciben laptops en la primera semana y las devuelven al irse.

- Los proyectos involucran muchos detalles, pero los empleados a menudo olvidan información durante su trabajo, especialmente después de irse por un año o más.

- Los recuerdos de la experiencia incluyen esquemas de proyectos, interacciones del equipo y conexiones de LinkedIn, pero no quedan registros documentados debido a estrictos controles de información.

- La primera experiencia de contratación en tales empresas puede ser frustrante, haciendo la ingeniería de software más desafiante y afectando significativamente el trabajo.

- Recientemente, descubrí cómo hacer que el ambiente se sienta ilimitado aprovechando los recursos internos, incluso si no es verdaderamente ilimitado.

- Hay miles de opciones de software disponibles, especialmente compiladores en Windows, que permiten la creación de scripts y pequeñas herramientas.

- Aprende tantas bibliotecas y lenguajes de programación como sea posible; maximiza el uso de lo que se proporciona internamente.

- Existe soporte para lenguajes como Go, Rust, herramientas de compilación C/C++, JavaScript con npm y C#, aumentando la flexibilidad con más conocimiento.

- En la era de la IA, construye herramientas personalizadas como Postman usando scripts de Python o escribe scripts de base de datos si las herramientas carecen de funciones.

- Usa IA para automatizar tareas, como scripts de Selenium para pruebas o scripts de pruebas de rendimiento.

- Los sentimientos iniciales de limitación en grandes empresas surgieron de la mentalidad, ya que las políticas no impiden construir cosas o trabajar efectivamente.

- En la vida, las limitaciones percibidas a menudo surgen de no pensar lo suficiente; intentar más puede llevar a ideas únicas.

- Convertirse en un ingeniero ilimitado en grandes empresas significa convertirse en una persona ilimitada en general.

---

## Beneficios de Acumular Registros

Cuando trabajé como contratista para un banco antes, usamos una plataforma de aplicaciones multicloud para servir los microservicios. En ese momento, comencé a acumular registros mientras trabajaba en la empresa.

Varios años han pasado, y todavía pienso que es una de las mejores maneras de ayudarme a trabajar o hacer ingeniería de software. Con el tiempo, en mi directorio de registros, hay cientos de archivos de registro.

No tengo subdirectorios específicos o nombres formales de archivos de registro para esos. A veces, solo uso el nombre de esa tarea JIRA como prefijo del nombre de mi archivo de registro o esa característica. Y luego agrego un número como sufijo. Es como mutual-fund-1.log, mutual-fund-2.log, etc. Significa que en el microservicio de fondos mutuos, tengo ese registro al ejecutar ese microservicio.

A veces, cuando trabajo en proyectos que sirven a múltiples regiones, agregaré ese país como sufijo, como mutual-fund-cn-1.log, mutual-fund-sg-1.log. Los nombres de los archivos de registro son algo casuales. Porque en ese momento, necesitaba concentrarme en los rastreos de errores o las llamadas de funciones circundantes.

Los registros de los programas importan. Todos lo saben. Sin embargo, quiero recalcar la importancia de acumular registros en lugar de solo verlos en la consola y dejarlos ir. Sabrás más comodidad a medida que el proyecto avanza. Tienes más tiempo para encontrar registros anteriores. Puede que necesites saber si una llamada similar a un procedimiento almacenado de base de datos ocurrió antes. Puede que necesites saber si el mismo error ocurrió antes. Puede que necesites recordar cómo solucionaste este problema la última vez.

Hay toneladas de detalles en un gran proyecto o decenas de microservicios. Y los errores, excepciones o problemas ocurren una y otra vez. El registro es como el documento en ejecución de un programa. Y son generados por el programa automáticamente sin que los humanos escriban. Y para los desarrolladores, estos registros son legibles. Entonces, al comenzar una nueva tarea o corregir un nuevo error, tienes cientos de registros en tus manos para solucionar este nuevo error. No estás solo.

¿Por qué los acumulamos? Porque las cosas o el conocimiento se olvidan fácilmente.

Hubo progreso en la civilización humana cuando se inventó el papel. Y cuando se inventaron las computadoras, hubo otro nivel de civilización humana. Tomar notas en papel es como acumular registros en computadoras.

No solo para los humanos, sino para los chatbots de IA, las herramientas LLM, estos registros son cada vez más importantes. GreptimeDB, una base de datos para la recolección y análisis unificado de datos de observabilidad (métricas, registros y trazas) establecida en 2022 no es una coincidencia.

¿Por qué no lo hice antes? Después de trabajar como contratista para grandes bancos, necesitaba hacer más colaboración y trabajar en proyectos más grandes. Antes de eso, la mayor parte del tiempo en la startup o mi período de startup, trabajé solo. Cuando trabajé en LeanCloud antes, trabajé en la aplicación IM LeanChat como la mitad del tiempo.

Y cuando entré en el mundo corporativo más formal, el desarrollo de los proyectos era diferente de mi proyecto personal o proyecto de startup. Tienen entornos de prueba SIT, UAT. Y el entorno de producción a menudo solo está abierto a ciertos compañeros de equipo pequeños. Obtener los registros de ellos y solucionar problemas se vuelve largo y algo tedioso. Y ejecutar un proyecto lleva tiempo, y la tubería de Jenkins a menudo necesita media hora para ejecutarse.

Así que no puedo ejecutar o probar el programa como una mosca. No puedo hacer una implementación simplemente escribiendo un comando en mi computadora personal y cargando código al servidor para ejecutarlo.

Entonces, de alguna manera, me hace acumular registros para tener más contexto para manejar tareas. Es mejor solucionar problemas al primer intento. Es mejor verificar nuestra solución en solo unas pocas veces. No podemos obtener fácilmente los registros del programa que se ejecuta en una nube o el servidor de la empresa, así que es mejor copiarlo y guardarlo en la laptop local, para hacer análisis.

Y ahora, para mis proyectos personales, también acumularé los registros. Se convierte en un hábito. Después de trabajar en grandes empresas por algunos años, de alguna manera tengo más paciencia o estrategia para hacer que mis proyectos sean más grandes y largos. Así que sé que necesitaré estos registros con el tiempo.

Alguien podría decir que solo necesitas tener código elegante y un proyecto funcional. No necesitas acumular los registros o trazas de errores. Está bien. Cuando tenemos un error o una nueva característica, podemos ejecutar el programa para obtener los registros actuales. No necesitamos los registros del proceso de desarrollo. Son como los registros detallados de experimentos científicos. A primera vista, parece bien. Pero a largo plazo, si un día quieres trabajar en ello nuevamente, o quieres compartirlo, o dejar que otros lo tomen, puede que no sea bueno.

Creo que podría haber buenas oportunidades aquí. En las empresas, ¿por qué no animamos a cada desarrollador a compartir sus registros acumulados? En proyectos de código abierto, también deberíamos tener eso. No encontramos los registros de otros atractivos porque no los conocemos. Perdemos el contexto al guardar esos registros. Y dentro de ellos, parecen haber toneladas de mensajes no relacionados o triviales.

Pero el esfuerzo por acumular registros es trivial. Es solo copiar y pegar cada vez que vemos algunos registros, especialmente esos registros de error. ¿Y qué tal si lo hacemos de manera automatizada? Es una buena idea registrar los registros en un directorio cada vez que ejecutamos un proyecto, como esos proyectos Spring Boot.

El mundo se vuelve cada vez más digital, por lo que acumular registros de programas digitales es como acumular libros en un mundo físico.