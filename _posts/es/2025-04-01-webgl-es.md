---
audio: false
generated: true
lang: es
layout: post
title: Guía de WebGL
translated: true
type: note
---

Adentrémonos en una guía completa sobre WebGL (Web Graphics Library). Cubrirá qué es, cómo funciona, por qué es útil, cómo empezar y su contexto más amplio, perfecto para entender su papel en herramientas como Figma y más allá. ¡Abróchense los cinturones!

---

### **1. ¿Qué es WebGL?**
WebGL es una API de JavaScript que lleva gráficos 2D y 3D acelerados por hardware a la web. Está basado en OpenGL ES (Embedded Systems), un subconjunto del estándar OpenGL usado en aplicaciones nativas, adaptado para navegadores. Con WebGL, puedes renderizar gráficos directamente en un elemento `<canvas>` usando la GPU, evitando el renderizado más lento basado en CPU del HTML/CSS tradicional.

- **Características Clave:**
  - **Aceleración por Hardware:** Aprovecha la GPU para un renderizado rápido.
  - **Multiplataforma:** Funciona en todos los navegadores principales (Chrome, Firefox, Safari, Edge).
  - **Programable:** Usa shaders (pequeños programas) para definir cómo se ven y se mueven las cosas.
  - **Sin Plugins:** Nativo del navegador, a diferencia de Flash o tecnologías antiguas.

- **Historia:**
  - Introducido en 2011 por el Khronos Group (la gente detrás de OpenGL).
  - WebGL 1.0 está basado en OpenGL ES 2.0; WebGL 2.0 (2017) se basa en OpenGL ES 3.0.

- **Casos de Uso:**
  - Juegos (por ejemplo, títulos 3D basados en navegador).
  - Visualización de datos (por ejemplo, gráficos o mapas interactivos).
  - Herramientas creativas (por ejemplo, el renderizado de vectores de Figma).
  - Simulaciones (por ejemplo, motores de física o modelado 3D).

---

### **2. ¿Cómo funciona WebGL?**
WebGL opera dándote acceso de bajo nivel a la GPU a través de una API de JavaScript. Está construido alrededor de un **pipeline de renderizado**—una serie de pasos que convierten el código en píxeles en la pantalla.

1. **Configuración:**
   - Creas un elemento `<canvas>` en HTML.
   - Obtienes un contexto WebGL: `canvas.getContext('webgl')` (o `'webgl2'` para 2.0).

2. **Shaders:**
   - **Vertex Shader:** Define la posición de los puntos (vértices) en el espacio 3D.
   - **Fragment Shader:** Colorea cada píxel entre los vértices.
   - Escritos en GLSL (OpenGL Shading Language), se compilan en tiempo de ejecución.

3. **Buffers:**
   - Los datos (por ejemplo, posiciones de vértices, colores) se almacenan en la memoria de la GPU a través de buffers.
   - Ejemplo: Las tres esquinas de un triángulo se envían como un array de coordenadas.

4. **Renderizado:**
   - Enlazas buffers, configuras shaders y emites una llamada de dibujo (por ejemplo, `gl.drawArrays()`).
   - La GPU procesa esto en paralelo, enviando la salida al canvas.

- **Sistema de Coordenadas:** WebGL usa un espacio 3D normalizado (-1 a 1 en los ejes x, y, z), que transformas con matrices (por ejemplo, para perspectiva o rotación).

- **Máquina de Estados:** WebGL no tiene estado—configuras parámetros (por ejemplo, texturas, blending) antes de cada llamada de dibujo.

---

### **3. ¿Por qué usar WebGL?**
- **Rendimiento:** La aceleración por GPU supera al renderizado por CPU para gráficos complejos.
- **Flexibilidad:** Los shaders te permiten personalizar los visuals hasta el nivel del píxel.
- **Integración Web:** Funciona perfectamente con JavaScript, eventos DOM y otras APIs.
- **Sin Instalación:** Funciona dondequiera que lo haga un navegador.

**Contrapartidas:**
- Curva de aprendizaje pronunciada—es de bajo nivel comparado con HTML5 Canvas 2D.
- Depurar es complicado (los errores de GLSL son crípticos).
- La compatibilidad del navegador puede variar (especialmente con WebGL 2.0).

---

### **4. Cómo empezar con WebGL**
Rendericemos un simple triángulo coloreado para ver WebGL en acción.

#### **Paso 1: Configuración HTML**
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
</head>
<body>
    <canvas id="glCanvas" width="400" height="400"></canvas>
    <script>
        // JavaScript va aquí
    </script>
</body>
</html>
```

#### **Paso 2: Conceptos Básicos de JavaScript**
Añade esto dentro de la etiqueta `<script>`:
```javascript
// Obtener canvas y contexto
const canvas = document.getElementById('glCanvas');
const gl = canvas.getContext('webgl');
if (!gl) {
    alert('¡WebGL no es compatible!');
}

// Código fuente del vertex shader (GLSL)
const vsSource = `
    attribute vec2 a_position;
    void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
    }
`;

// Código fuente del fragment shader (GLSL)
const fsSource = `
    void main() {
        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); // Rojo
    }
`;

// Compilar shaders
function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
    }
    return shader;
}

const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);

// Enlazar en un programa
const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);
if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error(gl.getProgramInfoLog(program));
}

// Datos de vértices (un triángulo)
const positions = new Float32Array([
    0.0,  0.5,  // Arriba
   -0.5, -0.5,  // Abajo-izquierda
    0.5, -0.5   // Abajo-derecha
]);

// Configuración del buffer
const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

// Decirle a WebGL cómo leer el buffer
const positionLocation = gl.getAttribLocation(program, 'a_position');
gl.enableVertexAttribArray(positionLocation);
gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

// Limpiar y dibujar
gl.clearColor(0.0, 0.0, 0.0, 1.0); // Fondo negro
gl.clear(gl.COLOR_BUFFER_BIT);
gl.useProgram(program);
gl.drawArrays(gl.TRIANGLES, 0, 3); // Dibujar 3 vértices
```

#### **Paso 3: Probar**
- Guárdalo como `index.html`, sírvelo (por ejemplo, `python -m http.server 8080`) y ábrelo en un navegador.
- Verás un triángulo rojo sobre un fondo negro.

---

### **5. Conceptos Básicos**
- **Shaders:** Los vertex shaders posicionan la geometría; los fragment shaders la colorean. GLSL es similar a C pero específico para GPU.
- **Buffers:** Almacenan datos de vértices (posiciones, normales, colores) en la memoria de la GPU.
- **Textures:** Imágenes 2D mapeadas sobre objetos 3D (por ejemplo, `gl.texImage2D()`).
- **Matrices:** Se usan para transformaciones (traslación, rotación, escala) a través de bibliotecas como `glMatrix`.
- **Llamadas de Dibujo:** `gl.drawArrays()` para formas simples; `gl.drawElements()` para geometría indexada.

**Adiciones de WebGL 2.0:**
- Mejores texturas (por ejemplo, texturas 3D).
- Múltiples render targets.
- Características mejoradas de shaders (por ejemplo, uniform buffer objects).

---

### **6. Ecosistema y Herramientas**
- **Bibliotecas:**
  - **Three.js:** Framework 3D de alto nivel (oculta la complejidad de WebGL puro).
  - **Babylon.js:** Motor 3D enfocado en juegos.
  - **PixiJS:** Renderizado 2D con respaldo WebGL.
  - **glMatrix:** Utilidades matemáticas para transformaciones.

- **Soporte del Navegador:**
  - WebGL 1.0: Casi universal.
  - WebGL 2.0: La mayoría de navegadores modernos (consulta caniuse.com).

- **Depuración:**
  - Herramientas de desarrollo del navegador (por ejemplo, Chrome's WebGL Inspector).
  - Extensiones como Spector.js.

---

### **7. WebGL en el Mundo Real**
- **Figma:** Usa WebGL para el renderizado de gráficos vectoriales, combinado con WebAssembly para el cómputo.
- **Juegos:** Unity y Unreal Engine exportan a WebGL para jugar en el navegador.
- **Mapas:** Google Maps y Mapbox lo usan para un zoom suave y terreno 3D.

---

### **8. El Futuro**
- **WebGPU:** La API de próxima generación (basada en Vulkan/Metal) está emergiendo, prometiendo mejor rendimiento y características modernas. No es un reemplazo aún, sino un complemento.
- **Adopción Más Amplia:** WebGL sigue siendo dominante por ahora, especialmente con las mejoras de WebGL 2.0.

---

### **9. Recursos**
- **Oficial:** [webglfundamentals.org](https://webglfundamentals.org/)—tutoriales excelentes para principiantes.
- **MDN:** [WebGL Docs](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API).
- **Libros:** “WebGL Programming Guide” por Kouichi Matsuda.
- **Publicaciones en X:** Busca #WebGL para ejemplos y consejos de la comunidad.

---

### **Resumen**
WebGL es tu puerta de entrada a los gráficos potenciados por GPU en el navegador. Es de bajo nivel, potente y un poco intimidante, pero con práctica (y bibliotecas), puedes construir cualquier cosa, desde simples animaciones hasta mundos 3D completos. ¿Quieres probar un proyecto específico o profundizar en los shaders? ¡Házmelo saber