---
audio: false
generated: true
lang: de
layout: post
title: Verwendung von epoll unter Linux
translated: true
type: note
---

`epoll` ist ein Linux-Systemaufruf, der für die effiziente Überwachung mehrerer Dateideskriptoren auf Ereignisse konzipiert ist, z. B. wenn Daten zum Lesen verfügbar sind oder ein Socket bereit zum Schreiben ist. Es ist besonders nützlich in der Netzwerkprogrammierung, wo ein Server viele Verbindungen gleichzeitig handhaben muss. Im Vergleich zu älteren Mechanismen wie `select` oder `poll` skaliert `epoll` besser mit einer großen Anzahl von Dateideskriptoren, da es das wiederholte Scannen aller Deskriptoren auf Bereitschaft vermeidet.

Hier ist eine Schritt-für-Schritt-Anleitung zur Verwendung von `epoll` in Linux, gefolgt von einem einfachen Beispiel eines Servers, der Verbindungen akzeptiert und Daten zurückschickt.

---

## Schritte zur Verwendung von `epoll`

### 1. **Eine Epoll-Instanz erstellen**
Um `epoll` zu verwenden, müssen Sie eine Epoll-Instanz erstellen, die durch einen Dateideskriptor dargestellt wird. Verwenden Sie den Systemaufruf `epoll_create1`:

```c
int epoll_fd = epoll_create1(0);
```
- **Parameter**: Übergeben Sie `0` für die grundlegende Verwendung (keine speziellen Flags). Flags wie `EPOLL_CLOEXEC` können für erweiterte Szenarien verwendet werden.
- **Rückgabewert**: Gibt bei Erfolg einen Dateideskriptor (`epoll_fd`) zurück, oder `-1` bei einem Fehler (prüfen Sie `errno` für Details).

Die ältere Funktion `epoll_create` ist ähnlich, benötigt aber eine Größenangabe (die jetzt ignoriert wird), daher ist `epoll_create1` vorzuziehen.

### 2. **Dateideskriptoren zur Überwachung hinzufügen**
Verwenden Sie `epoll_ctl`, um Dateideskriptoren (z. B. Sockets) bei der Epoll-Instanz zu registrieren und die zu überwachenden Ereignisse anzugeben:

```c
struct epoll_event ev;
ev.events = EPOLLIN;  // Auf Lesbarkeit überwachen
ev.data.fd = some_fd; // Dateideskriptor, der überwacht werden soll
epoll_ctl(epoll_fd, EPOLL_CTL_ADD, some_fd, &ev);
```
- **Parameter**:
  - `epoll_fd`: Der Dateideskriptor der Epoll-Instanz.
  - `EPOLL_CTL_ADD`: Operation zum Hinzufügen eines Dateideskriptors.
  - `some_fd`: Der zu überwachende Dateideskriptor (z. B. ein Socket).
  - `&ev`: Zeiger auf eine `struct epoll_event`, die die Ereignisse und optional Benutzerdaten definiert.
- **Häufige Ereignisse**:
  - `EPOLLIN`: Daten sind verfügbar zum Lesen.
  - `EPOLLOUT`: Bereit zum Schreiben.
  - `EPOLLERR`: Ein Fehler ist aufgetreten.
  - `EPOLLHUP`: Verbindungsabbruch (z. B. Verbindung geschlossen).
- **Benutzerdaten**: Das Feld `data` in `struct epoll_event` kann einen Dateideskriptor (wie gezeigt) oder andere Daten (z. B. einen Zeiger) speichern, um die Quelle zu identifizieren, wenn Ereignisse auftreten.

### 3. **Auf Ereignisse warten**
Verwenden Sie `epoll_wait`, um zu blockieren und auf Ereignisse bei den überwachten Dateideskriptoren zu warten:

```c
struct epoll_event events[MAX_EVENTS];
int nfds = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);
```
- **Parameter**:
  - `epoll_fd`: Die Epoll-Instanz.
  - `events`: Array zum Speichern der ausgelösten Ereignisse.
  - `MAX_EVENTS`: Maximale Anzahl der zurückzugebenden Ereignisse (Größe des Arrays).
  - `-1`: Timeout in Millisekunden (`-1` bedeutet unendlich warten; `0` gibt sofort zurück).
- **Rückgabewert**: Anzahl der Dateideskriptoren mit Ereignissen (`nfds`), oder `-1` bei einem Fehler.

### 4. **Ereignisse behandeln**
Durchlaufen Sie die von `epoll_wait` zurückgegebenen Ereignisse und verarbeiten Sie sie:

```c
for (int i = 0; i < nfds; i++) {
    if (events[i].events & EPOLLIN) {
        // Dateideskriptor events[i].data.fd ist lesbar
    }
}
```
- Überprüfen Sie das Feld `events` mithilfe von Bitweise-Operationen (z. B. `events[i].events & EPOLLIN`), um den Ereignistyp zu bestimmen.
- Verwenden Sie `events[i].data.fd`, um zu identifizieren, welcher Dateideskriptor das Ereignis ausgelöst hat.

### 5. **Dateideskriptoren verwalten (Optional)**
- **Entfernen**: Verwenden Sie `epoll_ctl` mit `EPOLL_CTL_DEL`, um die Überwachung eines Dateideskriptors zu beenden:
  ```c
  epoll_ctl(epoll_fd, EPOLL_CTL_DEL, some_fd, NULL);
  ```
- **Ändern**: Passen Sie Ereignisse mit `EPOLL_CTL_MOD` an:
  ```c
  ev.events = EPOLLOUT; // Ändern, um Schreibbarkeit zu überwachen
  epoll_ctl(epoll_fd, EPOLL_CTL_MOD, some_fd, &ev);
  ```

---

## Wichtige Konzepte

### **Level-Triggered vs. Edge-Triggered**
- **Level-Triggered (Standard)**: `epoll` benachrichtigt wiederholt, solange der Zustand anhält (z. B. Daten bleiben ungelesen). Einfacher für die meisten Fälle.
- **Edge-Triggered (`EPOLLET`)**: Benachrichtigt nur einmal, wenn sich der Zustand ändert (z. B. neue Daten ankommen). Erfordert das Lesen/Schreiben aller Daten bis `EAGAIN`, um Ereignisse nicht zu verpassen; effizienter, aber schwieriger.
- Setzen Sie `EPOLLET` in `ev.events` (z. B. `EPOLLIN | EPOLLET`), wenn Sie den Edge-Triggered-Modus verwenden.

### **Nicht-blockierende E/A**
`epoll` wird oft mit nicht-blockierenden Dateideskriptoren kombiniert, um Blockieren bei E/A-Operationen zu verhindern. Setzen Sie einen Socket in den nicht-blockierenden Modus mit:

```c
fcntl(fd, F_SETFL, fcntl(fd, F_GETFL) | O_NONBLOCK);
```

---

## Beispiel: Einfacher Echo-Server

Unten ist ein einfaches Beispiel eines Servers, der `epoll` verwendet, um Verbindungen zu akzeptieren und Daten an Clients zurückzuschicken. Er verwendet den Level-Triggered-Modus der Einfachheit halber.

```c
#include <sys/epoll.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>

#define MAX_EVENTS 10
#define PORT 8080

int main() {
    // Erstelle lauschenden Socket
    int listen_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (listen_fd == -1) { perror("socket"); exit(1); }

    struct sockaddr_in addr = { .sin_family = AF_INET, .sin_addr.s_addr = INADDR_ANY, .sin_port = htons(PORT) };
    if (bind(listen_fd, (struct sockaddr*)&addr, sizeof(addr)) == -1) { perror("bind"); exit(1); }
    if (listen(listen_fd, 5) == -1) { perror("listen"); exit(1); }

    // Setze lauschenden Socket auf nicht-blockierend
    fcntl(listen_fd, F_SETFL, fcntl(listen_fd, F_GETFL) | O_NONBLOCK);

    // Erstelle Epoll-Instanz
    int epoll_fd = epoll_create1(0);
    if (epoll_fd == -1) { perror("epoll_create1"); exit(1); }

    // Füge lauschenden Socket zu epoll hinzu
    struct epoll_event ev, events[MAX_EVENTS];
    ev.events = EPOLLIN; // Level-triggered
    ev.data.fd = listen_fd;
    if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, listen_fd, &ev) == -1) { perror("epoll_ctl"); exit(1); }

    // Ereignisschleife
    while (1) {
        int nfds = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);
        if (nfds == -1) { perror("epoll_wait"); exit(1); }

        for (int i = 0; i < nfds; i++) {
            int fd = events[i].data.fd;

            if (fd == listen_fd) {
                // Akzeptiere neue Verbindung
                int client_fd = accept(listen_fd, NULL, NULL);
                if (client_fd == -1) { perror("accept"); continue; }

                // Setze Client-Socket auf nicht-blockierend
                fcntl(client_fd, F_SETFL, fcntl(client_fd, F_GETFL) | O_NONBLOCK);

                // Füge Client-Socket zu epoll hinzu
                ev.events = EPOLLIN;
                ev.data.fd = client_fd;
                if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, client_fd, &ev) == -1) {
                    perror("epoll_ctl: client_fd");
                    close(client_fd);
                }
            } else {
                // Verarbeite Client-Daten
                char buf[1024];
                ssize_t n = read(fd, buf, sizeof(buf));
                if (n <= 0) {
                    // Fehler oder EOF: Schließen und aus epoll entfernen
                    if (n == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) continue;
                    close(fd);
                    epoll_ctl(epoll_fd, EPOLL_CTL_DEL, fd, NULL);
                } else {
                    // Echo Daten zurück
                    write(fd, buf, n); // Hinweis: In echten Anwendungen partielle Schreibvorgänge handhaben
                }
            }
        }
    }

    close(epoll_fd);
    close(listen_fd);
    return 0;
}
```

### Anmerkungen zum Beispiel
- **Lauschender Socket**: Überwacht `EPOLLIN`, um neue Verbindungen zu erkennen.
- **Client-Sockets**: Überwachen ebenfalls `EPOLLIN`, um eingehende Daten zu erkennen.
- **Vereinfachung**: Nimmt an, dass `write` vollständig abgeschlossen wird. In der Produktion sollten Daten gepuffert und `EPOLLOUT` für partielle Schreibvorgänge verwendet werden.
- **Fehlerbehandlung**: Schließt Sockets bei Fehlern oder EOF und entfernt sie aus epoll.

---

## Zusammenfassung
`epoll` bietet eine effiziente Möglichkeit, mehrere Dateideskriptoren in Linux zu handhaben:
1. Erstellen Sie eine Instanz mit `epoll_create1`.
2. Registrieren Sie Dateideskriptoren und Ereignisse mit `epoll_ctl`.
3. Warten Sie auf Ereignisse mit `epoll_wait`.
4. Verarbeiten Sie Ereignisse in einer Schleife und passen Sie überwachte Ereignisse an oder entfernen Sie Deskriptoren nach Bedarf.

Für einfache Anwendungen wird der Level-Triggered-Modus empfohlen. Für hohe Leistungsanforderungen sollten Sie den Edge-Triggered-Modus in Betracht ziehen, mit sorgfältiger Behandlung aller verfügbaren Daten. Kombinieren Sie `epoll` immer mit nicht-blockierender E/A für die besten Ergebnisse.