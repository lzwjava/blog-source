---
audio: false
generated: false
image: false
lang: de
layout: post
title: Einführung in Machine Learning – PyTorch
translated: true
type: post
---

```markdown
Dieser Beitrag wurde ursprünglich auf Chinesisch verfasst. Er wurde ins Englische übersetzt, um weitere Übersetzungen in andere Sprachen zu erleichtern.

---

## PyTorch

Lassen Sie uns es installieren. Dies unterstützt Python-Version `3.9`.

```shell
$ pip install torch torchvision
Collecting torch
  Downloading torch-1.8.0-cp39-none-macosx_10_9_x86_64.whl (120.6 MB)
     |████████████████████████████████| 120.6 MB 224 kB/s
Collecting torchvision
  Downloading torchvision-0.9.0-cp39-cp39-macosx_10_9_x86_64.whl (13.1 MB)
     |████████████████████████████████| 13.1 MB 549 kB/s
Requirement already satisfied: numpy in /usr/local/lib/python3.9/site-packages (from torch) (1.20.1)
Collecting typing-extensions
  Downloading typing_extensions-3.7.4.3-py3-none-any.whl (22 kB)
Requirement already satisfied: pillow>=4.1.1 in /usr/local/lib/python3.9/site-packages (from torchvision) (8.0.1)
Installing collected packages: typing-extensions, torch, torchvision
Successfully installed torch-1.8.0 torchvision-0.9.0 typing-extensions-3.7.4.3
```

Lassen Sie uns es überprüfen.

```python
import torch
x = torch.rand(5, 3)
print(x)
```

Es ist ein Fehler aufgetreten.

```shell
Traceback (most recent call last):
  File "torch.py", line 1, in <module>
    import torch
  File "torch.py", line 2, in <module>
    x = torch.rand(5, 3)
AttributeError: partially initialized module 'torch' has no attribute 'rand' (most likely due to a circular import)
```

Nach einer Google-Suche nach dieser Fehlermeldung stellt sich heraus, dass unsere Datei ebenfalls `torch` hieß, was zu einem Namenskonflikt führte. Nach dem Umbenennen funktioniert es korrekt.

```shell
tensor([[0.5520, 0.9446, 0.5543],
        [0.6192, 0.0908, 0.8726],
        [0.0223, 0.7685, 0.9814],
        [0.4019, 0.5406, 0.3861],
        [0.5485, 0.6040, 0.2387]])
```

Lassen Sie uns ein Beispiel suchen.

```python
# -*- coding: utf-8 -*-

import torch
import math
dtype = torch.float
device = torch.device("cpu")
# device = torch.device("cuda:0") # Entfernen Sie den Kommentar, um auf der GPU auszuführen

# Erstellen von zufälligen Eingabe- und Ausgabedaten
x = torch.linspace(-math.pi, math.pi, 2000, device=device, dtype=dtype)
y = torch.sin(x)

# Zufällige Initialisierung der Gewichte
a = torch.randn((), device=device, dtype=dtype)
b = torch.randn((), device=device, dtype=dtype)
c = torch.randn((), device=device, dtype=dtype)
d = torch.randn((), device=device, dtype=dtype)

learning_rate = 1e-6
for t in range(2000):
    # Vorwärtsdurchlauf: Berechnung des vorhergesagten y
    y_pred = a + b * x + c * x ** 2 + d * x ** 3

    # Berechnung und Ausgabe des Verlusts
    loss = (y_pred - y).pow(2).sum().item()
    if t % 100 == 99:
        print(t, loss)

    # Rückwärtspropagation zur Berechnung der Gradienten von a, b, c, d in Bezug auf den Verlust
    grad_y_pred = 2.0 * (y_pred - y)
    grad_a = grad_y_pred.sum()
    grad_b = (grad_y_pred * x).sum()
    grad_c = (grad_y_pred * x ** 2).sum()
    grad_d = (grad_y_pred * x ** 3).sum()

    # Aktualisierung der Gewichte mithilfe des Gradientenabstiegs
    a -= learning_rate * grad_a
    b -= learning_rate * grad_b
    c -= learning_rate * grad_c
    d -= learning_rate * grad_d
print(f'Ergebnis: y = {a.item()} + {b.item()} x + {c.item()} x^2 + {d.item()} x^3')
```

Lassen Sie uns es ausführen.

```shell
99 1273.537353515625
199 849.24853515625
299 567.4786987304688
399 380.30291748046875
499 255.92752075195312
599 173.2559814453125
699 118.2861328125
799 81.72274780273438
899 57.39331817626953
999 41.198158264160156
1099 30.41307830810547
1199 23.227672576904297
1299 18.438262939453125
1399 15.244369506835938
1499 13.113286972045898
1599 11.690631866455078
1699 10.740333557128906
1799 10.105220794677734
1899 9.6804780960083
1999 9.39621353149414
Ergebnis: y = -0.011828352697193623 + 0.8360244631767273 x + 0.002040589228272438 x^2 + -0.09038365632295609 x^3
```

Schauen wir uns den Code an, der nur die `numpy`-Bibliothek verwendet.

```python
# -*- coding: utf-8 -*-
import numpy as np
import math

# Erstellen von zufälligen Eingabe- und Ausgabedaten
x = np.linspace(-math.pi, math.pi, 2000)
y = np.sin(x)

# Zufällige Initialisierung der Gewichte
a = np.random.randn()
b = np.random.randn()
c = np.random.randn()
d = np.random.randn()

learning_rate = 1e-6
for t in range(2000):
    # Vorwärtsdurchlauf: Berechnung des vorhergesagten y
    # y = a + b x + c x^2 + d x^3
    y_pred = a + b * x + c * x ** 2 + d * x ** 3

    # Berechnung und Ausgabe des Verlusts
    loss = np.square(y_pred - y).sum()
    if t % 100 == 99:
        print(t, loss)

    # Rückwärtspropagation zur Berechnung der Gradienten von a, b, c, d in Bezug auf den Verlust
    grad_y_pred = 2.0 * (y_pred - y)
    grad_a = grad_y_pred.sum()
    grad_b = (grad_y_pred * x).sum()
    grad_c = (grad_y_pred * x ** 2).sum()
    grad_d = (grad_y_pred * x ** 3).sum()

    # Aktualisierung der Gewichte
    a -= learning_rate * grad_a
    b -= learning_rate * grad_b
    c -= learning_rate * grad_c
    d -= learning_rate * grad_d

print(f'Ergebnis: y = {a} + {b} x + {c} x^2 + {d} x^3')
```

Beachten Sie, dass dies zwei verschiedene Wege sind, um Berechnungen durchzuführen.

In diesen Beispielen wird zunächst ein Satz von x- und y-Werten generiert. Dann wird angenommen, dass es sich um eine kubische Gleichung handelt. Anschließend werden einige Methoden verwendet, um iterativ die Koeffizienten zu berechnen. Was sind diese Algorithmen? Beachten Sie, dass die Schleife `2000`-mal durchlaufen wird und mit jeder Iteration präziser wird. Auf die Details wird hier nicht näher eingegangen.

## Abschließend

Aktuell verstehen wir nicht, wie die Berechnungen des maschinellen Lernens im Hintergrund funktionieren. Das ist jedoch im Moment nicht wichtig. Mit dem oben genannten Wissen können wir bereits viele Dinge tun. Maschinelles Lernen kann auch zur Verarbeitung von Texten, Audiodateien und vielem mehr verwendet werden. Nach dem Durcharbeiten von Dutzenden von Beispielen ist es nicht zu spät, die Theorie zu lernen.

## Übungen

* Die Studierenden sollten wie oben gezeigt explorieren.
```