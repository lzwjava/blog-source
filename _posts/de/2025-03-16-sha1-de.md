---
audio: false
generated: true
lang: de
layout: post
title: SHA-1-Hashfunktion
translated: true
type: note
---

Lassen Sie uns untersuchen, wie der gegebene Codeausschnitt funktioniert, insbesondere die Zeilen:

```python
hash_obj = hashlib.sha1(piece)
hashes.append(hash_obj.hexdigest())
return hashes
```

Der Benutzer hat uns gebeten, dies ohne Verwendung einer Bibliothek zu erklären. Daher werde ich zunächst erklären, was der Code mit der `hashlib`-Bibliothek tut, und dann untersuchen, wie dieselbe Funktionalität ohne sie erreicht werden könnte.

---

### Den Code mit `hashlib` verstehen

Dieser Ausschnitt berechnet einen Hash für ein Datenstück und speichert ihn in einer Liste. Hier ist eine schrittweise Aufschlüsselung dessen, was passiert:

1.  **`hash_obj = hashlib.sha1(piece)`**
    *   **Funktion**: Diese Zeile verwendet das `hashlib`-Modul von Python, um ein SHA-1-Hash-Objekt zu erstellen. SHA-1 (Secure Hash Algorithm 1) ist eine kryptografische Hash-Funktion, die eine Eingabe (hier `piece`) nimmt und einen 160-Bit (20-Byte) Hash-Wert erzeugt.
    *   **Eingabe**: `piece` ist ein Datenblock, wahrscheinlich Bytes, die aus einer Datei oder einer anderen Quelle gelesen wurden.
    *   **Prozess**: Die Funktion `hashlib.sha1()` initialisiert ein Hash-Objekt und aktualisiert es sofort mit den Daten in `piece`. Man kann es sich wie das Einfüttern der Daten in eine Hashing-Maschine vorstellen, die beginnt, Zahlen zu verarbeiten.

2.  **`hashes.append(hash_obj.hexdigest())`**
    *   **Funktion**: Die Methode `hexdigest()` ruft den vom Hash-Objekt berechneten Hash-Wert ab und wandelt ihn in einen Hexadezimal-String um (ein menschenlesbares Format, das die Ziffern 0-9 und die Buchstaben a-f verwendet).
    *   **Ausgabe**: Für SHA-1 ist dieser String 40 Zeichen lang, da jedes der 20 Bytes durch zwei hexadezimale Ziffern dargestellt wird (z.B. wird ein Byte-Wert von 255 zu "ff").
    *   **Speicherung**: Der resultierende String wird an eine Liste namens `hashes` angehängt, die vermutlich die Hashes für mehrere Datenstücke sammelt.

3.  **`return hashes`**
    *   **Funktion**: Nach der Verarbeitung aller Stücke (angenommen, dieser Code befindet sich in einer Schleife oder Funktion) wird die Liste `hashes`, die alle hexadezimalen Hash-Strings enthält, zurückgegeben.

**Zusammenfassend**: Für jedes Daten-`piece` berechnet der Code seinen SHA-1-Hash mit `hashlib.sha1()`, wandelt den Hash mit `hexdigest()` in einen hexadezimalen String um und speichert ihn in der `hashes`-Liste, die dann zurückgegeben wird.

---

### Ohne Verwendung einer Bibliothek: SHA-1 von Grund auf berechnen

Die Anweisung des Benutzers "do not use lib" deutet darauf hin, dass er verstehen möchte, wie dies ohne die Verwendung von `hashlib` funktionieren könnte. SHA-1 von Grund auf zu implementieren ist komplex, aber ich werde den Prozess klar erklären und eine vereinfachte Version bereitstellen, auf der man aufbauen könnte.

#### Was ist SHA-1?
SHA-1 ist eine Hash-Funktion, die:
*   Beliebige Eingabedaten (z.B. `piece`) nimmt.
*   Einen festen 160-Bit (20-Byte) Ausgabewert erzeugt.
*   Eine Reihe von bitweisen Operationen, Rotationen und Additionen verwendet, um die Eingabe zu transformieren.

Ohne `hashlib` müssten wir diesen Algorithmus selbst replizieren. So könnte es für den gegebenen Code funktionieren:

#### Schritt-für-Schritt SHA-1 Prozess

1.  **Eingabe vorbereiten (Padding)**
    *   SHA-1 verarbeitet Daten in 512-Bit (64-Byte) Blöcken. Wenn `piece` nicht genau 64 Bytes lang ist, füllen wir es auf:
        *   Ein `1`-Bit anhängen (z.B. `0x80` in Bytes).
        *   Genug `0`-Bits hinzufügen, um die Länge auf 448 Bits (56 Bytes) modulo 512 zu bringen.
        *   Die ursprüngliche Länge von `piece` (in Bits) als 64-Bit Integer anhängen.
    *   Der Einfachheit halber nehmen wir an, dass `piece` kleiner als 64 Bytes ist und füllen es auf einen Block auf.

2.  **Hash-Werte initialisieren**
    *   SHA-1 verwendet fünf 32-Bit Variablen (160 Bits insgesamt), die mit spezifischen Konstanten initialisiert werden:
        *   `h0 = 0x67452301`
        *   `h1 = 0xEFCDAB89`
        *   `h2 = 0x98BADCFE`
        *   `h3 = 0x10325476`
        *   `h4 = 0xC3D2E1F0`

3.  **Datenblock verarbeiten**
    *   Teile den 64-Byte Block in 16 32-Bit Wörter (je 4 Bytes) auf.
    *   Erweitere diese auf 80 Wörter mit der Formel:
        ```python
        w[i] = left_rotate(w[i-3] ^ w[i-8] ^ w[i-14] ^ w[i-16], 1)  # für i = 16 bis 79
        ```
        wobei `left_rotate` Bits nach links verschiebt und sie herumwickelt.
    *   Aktualisiere für 80 Runden die temporären Variablen `a`, `b`, `c`, `d`, `e` (beginnend als Kopien von `h0` bis `h4`):
        *   Verwende unterschiedliche Funktionen und Konstanten basierend auf der Rundennummer (0-19, 20-39, etc.).
        *   Beispiel für Runden 0-19:
            ```python
            f = (b & c) | (~b & d)
            k = 0x5A827999
            temp = (left_rotate(a, 5) + f + e + k + w[i]) & 0xFFFFFFFF
            ```
        *   Variablen verschieben: `e = d`, `d = c`, `c = left_rotate(b, 30)`, `b = a`, `a = temp`.

4.  **Hash-Werte aktualisieren**
    *   Nach 80 Runden addiere die Ergebnisse zu den initialen Hash-Werten:
        ```python
        h0 = (h0 + a) & 0xFFFFFFFF
        h1 = (h1 + b) & 0xFFFFFFFF
        # ...und so weiter für h2, h3, h4
        ```

5.  **Hexadezimale Ausgabe erzeugen**
    *   Füge `h0` bis `h4` zu einem 160-Bit Wert zusammen und wandle ihn in einen 40-stelligen hexadezimalen String um.

#### Vereinfachte Python-Implementierung

Hier ist eine grundlegende Version, wie man den Code ohne `hashlib` umschreiben könnte:

```python
def left_rotate(value, shift):
    """Rotate a 32-bit integer left by 'shift' bits."""
    return ((value << shift) | (value >> (32 - shift))) & 0xFFFFFFFF

def custom_sha1(piece):
    """Compute SHA-1 hash of 'piece' and return it as a hex string."""
    # For simplicity, assume piece is less than 56 bytes and pad to one block
    message = piece + b'\x80' + (b'\x00' * (55 - len(piece))) + (len(piece) * 8).to_bytes(8, 'big')
    
    # Initialize hash values
    h0, h1, h2, h3, h4 = (
        0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0
    )
    
    # Split into 16 32-bit words
    w = [int.from_bytes(message[i:i+4], 'big') for i in range(0, 64, 4)]
    
    # Expand to 80 words
    for i in range(16, 80):
        w.append(left_rotate(w[i-3] ^ w[i-8] ^ w[i-14] ^ w[i-16], 1))
    
    # Initialize working variables
    a, b, c, d, e = h0, h1, h2, h3, h4
    
    # 80 rounds of processing
    for i in range(80):
        if 0 <= i < 20:
            f = (b & c) | (~b & d)
            k = 0x5A827999
        elif 20 <= i < 40:
            f = b ^ c ^ d
            k = 0x6ED9EBA1
        elif 40 <= i < 60:
            f = (b & c) | (b & d) | (c & d)
            k = 0x8F1BBCDC
        else:
            f = b ^ c ^ d
            k = 0xCA62C1D6
        
        temp = (left_rotate(a, 5) + f + e + k + w[i]) & 0xFFFFFFFF
        e = d
        d = c
        c = left_rotate(b, 30)
        b = a
        a = temp
    
    # Update hash values
    h0 = (h0 + a) & 0xFFFFFFFF
    h1 = (h1 + b) & 0xFFFFFFFF
    h2 = (h2 + c) & 0xFFFFFFFF
    h3 = (h3 + d) & 0xFFFFFFFF
    h4 = (h4 + e) & 0xFFFFFFFF
    
    # Return as 40-character hex string
    return f"{h0:08x}{h1:08x}{h2:08x}{h3:08x}{h4:08x}"

# Rewritten code without hashlib
def compute_hashes(pieces):
    hashes = []
    for piece in pieces:  # Assuming pieces is a list of byte chunks
        hash_value = custom_sha1(piece)
        hashes.append(hash_value)
    return hashes

# Example usage
pieces = [b"hello", b"world"]
hashes = compute_hashes(pieces)
print(hashes)
```

#### Wie es dem Original entspricht
*   **`hash_obj = hashlib.sha1(piece)`**: Ersetzt durch `custom_sha1(piece)`, das den SHA-1-Hash manuell berechnet.
*   **`hashes.append(hash_obj.hexdigest())`**: Die Funktion `custom_sha1` gibt den Hex-String direkt zurück, also hängen wir ihn an `hashes` an.
*   **`return hashes`**: Bleibt gleich und gibt die Liste der Hash-Strings zurück.

---

### Wichtige Unterschiede und Einschränkungen
*   **Vereinfachung**: Diese Implementierung nimmt an, dass jedes `piece` in einen 512-Bit Block passt (weniger als 56 Bytes aufgrund des Paddings). Eine vollständige SHA-1-Implementierung würde mehrere Blöcke handhaben.
*   **Leistung**: Eine manuelle Implementierung ist langsamer und weniger optimiert als `hashlib`.
*   **Zuverlässigkeit**: Bibliotheken wie `hashlib` sind getestet und sicher; eine benutzerdefinierte Version könnte Fehler enthalten, sofern sie nicht gründlich validiert wurde.

Im Wesentlichen verwendet der ursprüngliche Code `hashlib` als Abkürzung, um SHA-1-Hashes effizient zu berechnen, während dies ohne Bibliothek das manuelle Codieren des gesamten SHA-1-Algorithmus, das Handhaben des Paddings und das Konvertieren des Ergebnisses in das Hexadezimalformat erfordert. Die Logik bleibt dieselbe: Verarbeite jedes Stück, berechne seinen Hash, speichere ihn und gib die Sammlung zurück.