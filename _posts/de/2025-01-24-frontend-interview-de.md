---
audio: false
generated: false
lang: de
layout: post
title: Interview als Frontend-Entwickler
translated: true
type: note
---

Beginnend mit HTML:

1. Semantische Tags: Verstehen und verwenden von `<article>`, `<section>`, `<header>`, `<footer>`, `<nav>`.
2. Formulare: Implementierung von Validierung, Umgang mit `<input>`, `<textarea>`, `<select>`, `<button>`.
3. Tabellen: Erstellen von barrierefreien Tabellen mit `<table>`, `<thead>`, `<tbody>`, `<tfoot>`.
4. Metadaten: Verwenden von `<meta>`-Tags für Zeichensatz, Viewport und SEO.
5. Links und Anker: Verstehen von `<a>`-Tags, `href`, `target` und `download` Attributen.
6. Medienelemente: Korrektes Verwenden von `<img>`, `<video>`, `<audio>` mit Attributen wie `src`, `alt`, `controls`.
7. Listen: Erstellen von geordneten `<ol>` und ungeordneten `<ul>` Listen, einschließlich verschachtelter Listen.
8. Überschriften: Verwenden einer korrekten Überschriftenhierarchie von `<h1>` bis `<h6>`.
9. Einbettung von Inhalten: Verwenden von `<iframe>`, `<embed>` und `<object>` zum Einbetten externer Inhalte.
10. HTML5 APIs: Vertrautheit mit Geolocation, Web Storage und der Fetch API.

Nun, CSS:

11. Box-Modell: Verstehen von Margin, Padding, Border und wie sie das Layout beeinflussen.
12. Flexbox: Beherrschung von Ausrichtung, Umbruch und Reihenfolge mit Flexbox-Eigenschaften.
13. Grid Layout: Erstellen komplexer Layouts mit CSS Grid.
14. Responsive Design: Verwenden von Media Queries, Viewport Meta-Tag und responsiven Bildern.
15. CSS-Präprozessoren: Kenntnisse der Syntax und Funktionen von Sass, Less oder Stylus.
16. CSS-in-JS: Verstehen von Frameworks wie styled-components oder emotion.
17. Animation und Übergänge: Implementieren flüssiger Übergänge und Keyframe-Animationen.
18. Styling von Formularen: Anpassen von Formularelementen und Verbessern ihres Erscheinungsbildes.
19. CSS Reset und Normalize: Wissen, wann und warum man sie verwendet.
20. CSS Grid vs. Flexbox: Die Unterschiede verstehen und das richtige Werkzeug für die Aufgabe wählen.

JavaScript:

21. ES6+ Features: Verwenden von Pfeilfunktionen, Destrukturierung, Spread/Rest-Operatoren und Template Literals.
22. DOM-Manipulation: Elemente auswählen, das DOM modifizieren und Events behandeln.
23. Asynchrones JavaScript: Verstehen von Promises, async/await und der Fetch API.
24. Event Loop: Erklären, wie der Event Loop in JavaScript funktioniert.
25. Closures: Closures verstehen und effektiv einsetzen.
26. Prototypische Vererbung: Erklären, wie die prototypische Vererbung in JavaScript funktioniert.
27. Module: Verwenden von ES6-Modulen mit `import` und `export`.
28. Fehlerbehandlung: Verwenden von try/catch-Blöcken und Verstehen von nicht behandelten Promise-Rejections.
29. JavaScript Performance: Code für bessere Performance optimieren.
30. Browser-Konsole: Verwenden der Browser-Developer-Tools zum Debuggen.

Frameworks:

31. React.js: Verstehen von Komponenten, JSX, State, Props und Hooks.
32. Vue.js: Verstehen der Vue-Instanz, Direktiven, Komponenten und Reaktivität.
33. Angular: Verstehen von Komponenten, Services, Dependency Injection und Routing.
34. State Management: Verwenden von Redux, Vuex oder Context API für das State Management.
35. Routing: Implementieren von Client-seitigem Routing mit React Router, Vue Router, etc.
36. Komponentenbasierte Architektur: Verstehen und Implementieren von wiederverwendbaren Komponenten.
37. Lifecycle-Methoden: Kennen der React Lifecycle-Methoden oder Vue Hooks.
38. UI-Bibliotheken: Verwenden von Bibliotheken wie Bootstrap, Tailwind oder Material-UI.
39. Testing-Frameworks: Schreiben von Tests mit Jest, Jasmine oder Cypress.
40. Build-Tools: Verwenden von Webpack, Babel oder Parcel zum Bauen von Projekten.

Tools und Versionskontrolle:

41. Git: Verwenden von Git für Versionskontrolle, inklusive Branching, Merging und Rebasing.
42. npm/yarn: Verwalten von Projektabhängigkeiten und Skripten.
43. Package.json: Verstehen von Skripten, dependencies und devDependencies.
44. Task-Runner: Verwenden von Gulp oder Grunt zur Automatisierung von Aufgaben.
45. Linting: Verwenden von ESLint oder Prettier für Code-Qualität.
46. Browsersync: Verwenden für Live-Reloading während der Entwicklung.
47. Figma/Adobe XD: Verstehen von Design-Handoff und Zusammenarbeit mit Designern.
48. API-Integration: Abrufen von Daten von RESTful oder GraphQL APIs.
49. Umgebungsvariablen: Verwalten von umgebungsspezifischen Konfigurationen.
50. Continuous Integration: Einrichten von CI/CD-Pipelines mit GitHub Actions oder Jenkins.

Performance-Optimierung:

51. Code-Splitting: Implementieren von Code-Splitting mit Webpack oder dynamischen Imports.
52. Lazy Loading: Lazy Loading von Bildern, Komponenten und Skripten.
53. Minifizierung: Minifizieren von CSS-, JavaScript- und HTML-Dateien.
54. Caching-Strategien: Verwenden von HTTP-Caching-Headern und Service Workern.
55. Bildoptimierung: Komprimieren und Optimieren von Bildern für die Webnutzung.
56. Critical CSS: Inline-Einbinden von kritischem CSS für schnellere Seitenladezeiten.
57. Web-Performance-Metriken: Verstehen von Lighthouse, GTmetrix und PageSpeed Insights.
58. Schriftarten-Laden: Optimieren des Schriftartenladens mit WebFont Loader oder Self-Hosting.
59. Vermeidung von render-blocking Resources: Sicherstellen, dass Skripte und Styles das Rendern nicht blockieren.
60. Performance-Budgets: Festlegen und Einhalten von Performance-Budgets.

Barrierefreiheit:

61. ARIA-Rollen: Verwenden von ARIA-Rollen, -Zuständen und -Eigenschaften für bessere Barrierefreiheit.
62. Semantisches HTML: Auswählen semantischer Elemente zur Verbesserung der Barrierefreiheit.
63. Alt-Texte für Bilder: Bereitstellen von aussagekräftigen Alt-Texten für Bilder.
64. Tastaturnavigation: Sicherstellen, dass die Seite nur mit der Tastatur navigierbar ist.
65. Farbkontrast: Verwenden von Tools zum Überprüfen und Verbessern des Farbkontrasts.
66. Screenreader-Tests: Testen mit Screenreadern wie NVDA oder VoiceOver.
67. Fokus-Management: Sicherstellen eines korrekten Fokus-Managements bei interaktiven Elementen.
68. Barrierefreiheits-Richtlinien: Befolgen der WCAG 2.1 Richtlinien.
69. Barrierefreiheit von Formularen: Korrektes Verwenden von Labels, Placeholdern und Validierung.
70. EPub und AODA Compliance: Grundlegende Compliance-Standards verstehen.

Best Practices:

71. Code-Organisation: Pflegen sauberer und modularer Code-Strukturen.
72. Dokumentation: Schreiben klarer Dokumentation für Komponenten und APIs.
73. Cross-Browser-Testing: Testen auf mehreren Browsern und Geräten.
74. Progressive Enhancement: Erstellen von Websites, die für alle Nutzer funktionieren, unabhängig von der Browserunterstützung.
75. Sicherheit: Verhindern von XSS-Angriffen, Verwenden von Content Security Policy und Absichern von APIs.
76. SEO Best Practices: Optimieren für Suchmaschinen mit Meta-Tags, Überschriften und Alt-Texten.
77. Versionierung: Verwenden von semantischer Versionierung für Bibliotheken und Abhängigkeiten.
78. Kollaborationstools: Verwenden von GitHub, GitLab oder Bitbucket für Teamzusammenarbeit.
79. Code-Reviews: Teilnehmen an Code-Reviews und konstruktives Feedback geben.
80. Lernressourcen: Auf dem Laufenden bleiben mit MDN, Blogs und Online-Kursen.

Fortgeschrittene Themen:

81. WebSockets: Implementieren von Echtzeit-Kommunikation mit WebSockets.
82. PWA (Progressive Web Apps): Verstehen von Service Workern, Offline-Unterstützung und Push-Benachrichtigungen.
83. Canvas und SVG: Erstellen von Grafiken mit Canvas- und SVG-Elementen.
84. CSS Grid und Flexbox Layouts: Implementieren komplexer Layouts mit CSS Grid und Flexbox.
85. Custom Elements: Erstellen benutzerdefinierter HTML-Elemente mit Web Components.
86. Shadow DOM: Verstehen und Verwenden des Shadow DOM zur Kapselung.
87. CSS-Variablen: Verwenden benutzerdefinierter Eigenschaften für Theming und dynamische Styles.
88. JavaScript-Design-Patterns: Implementieren von Entwurfsmustern wie Singleton, Observer und Factory.
89. Internationalisierung (i18n): Implementieren von Sprachunterstützung und Lokalisierung.
90. Performance-Profiling: Verwenden von Tools wie Chrome DevTools für das Profiling von JavaScript- und DOM-Performance.

Fachübergreifende Fähigkeiten:

91. User Experience (UX): Verstehen von UX-Prinzipien und Zusammenarbeit mit UX-Designern.
92. User Interface (UI): Erstellen visuell ansprechender und benutzerfreundlicher Oberflächen.
93. Projektmanagement: Verwenden von Agile-Methodologien, Scrum oder Kanban für das Projektmanagement.
94. Kommunikationsfähigkeiten: Effektive Kommunikation mit Teammitgliedern und Stakeholdern.
95. Problemlösungsfähigkeiten: Methodisches Herangehen an Probleme und Finden optimaler Lösungen.
96. Anpassungsfähigkeit: Schnelles Erlernen und Anpassen an neue Technologien und Tools.
97. Teamzusammenarbeit: Gute Zusammenarbeit im Team, Wissensaustausch und Mentoring anderer.
98. Zeitmanagement: Priorisieren von Aufgaben und effektives Zeitmanagement.
99. Kreativität: Einbringen kreativer Lösungen für Design- und Coding-Herausforderungen.
100. Lernleidenschaft: Neugierig bleiben und kontinuierlich die eigenen Fähigkeiten verbessern.