---
audio: false
generated: false
image: true
lang: de
layout: post
title: Komplettes KI-Werkzeuge-Ökosystem
translated: true
---

### Inhaltsverzeichnis

1. [Jina AI](#jina-ai)
   - Python-Skript für Jina AI-Integration
   - Abrufen von URL-Inhalten mit `r.jina.ai`
   - Verarbeitung von Suchanfragen mit `s.jina.ai`
   - Base64-Kodierung und API-Authentifizierung

2. [Tavily AI](#tavily-ai)
   - KI-Such-API speziell für LLM-Anwendungen
   - Einrichtung und API-Schlüssel-Registrierung
   - Python-Client-Implementierung
   - Beispiele für Suchanfragen und Nutzung

3. [Open WebUI](#open-webui)
   - Installation der lokalen KI-Oberfläche
   - Server-Einrichtung und Konfiguration
   - Ollama-Integration für lokale Modelle
   - Installationszeit und Anforderungen

4. [Tableau, Scale und Power BI](#tableau-scale-und-power-bi)
   - Vergleich von Business-Intelligence-Plattformen
   - Tableau-13-Tage-Testversion
   - Überblick über die Scale-Datenplattform
   - Funktionen von Microsoft Power BI

5. [Verwendung von OpenRouter](#verwendung-von-openrouter)
   - Akzeptanz von China-Visa-Kreditkarten
   - Modellrankings und Trendanalyse
   - LLM-Nutzungskategorien und Anwendungen
   - VPN-Anforderung für Anthropic-API in Hongkong

6. [ElevenLabs AI](#elevenlabs-ai)
   - Text-zu-Sprache-API-Integration
   - Stimmklon-Fähigkeiten
   - Mehrsprachige Audioerzeugung
   - Python-Skript für Audio-Konvertierung

## Jina AI

Dieses Python-Skript interagiert mit Jina AI-Diensten unter Verwendung von API-Schlüsseln und Befehlszeilenargumenten. Es unterstützt zwei Hauptaufgaben: Das Abrufen von Inhalten von einer URL und das Durchführen einer Suchanfrage. Das Skript holt den Jina-API-Schlüssel aus den Umgebungsvariablen, um einen sicheren Zugang zu den Diensten zu gewährleisten. Es verwendet die `requests`-Bibliothek für HTTP-Anfragen und `base64` zum Dekodieren der Suchanfrage. Anschließend gibt das Skript die Antwort des Jina AI-Dienstes aus.

```python 
import os
import requests
from dotenv import load_dotenv
import argparse
import base64

load_dotenv()

api_key = os.environ.get("JINA_API_KEY")
if not api_key:
    raise ValueError("JINA_API_KEY environment variable not set.")

parser = argparse.ArgumentParser()
parser.add_argument("--job", type=str, choices=['url', 'search'], help="Job to execute (url or search)", required=True)
parser.add_argument("--input", type=str, help="Input for the job", required=True)
args = parser.parse_args()

if args.job == 'url':
    url = f'https://r.jina.ai/{args.input}'
    headers = {'Authorization': f'Bearer {api_key}'}
    print(f"URL: {url}")
    print(f"Headers: {headers}")
    response = requests.get(url, headers=headers)
    print(response.text)

elif args.job == 'search':
    question = base64.b64decode(args.input).decode('utf-8', errors='ignore')
    url = f'https://s.jina.ai/{question}'
    headers = {
        'Authorization': f'Bearer {api_key}',
        'X-Engine': 'direct',
        'X-Retain-Images': 'none'
    }
    print(f"URL: {url}")
    print(f"Headers: {headers}")
    response = requests.get(url, headers=headers)
    print(response.text)

else:
    print("Please specify --job url or --job search")

```

---

## Tavily AI

[Tavily](https://tavily.com) ist eine KI-Such-API, die speziell für LLM-Anwendungen entwickelt wurde. Sie liefert hochrelevante Suchergebnisse durch die Kombination von Websuche und KI-Verarbeitung.

Um Tavily zu nutzen, müssen Sie:

1. Einen API-Schlüssel auf [tavily.com](https://tavily.com) registrieren.
2. Das Python-Paket installieren.


```python
import os
from tavily import TavilyClient

# API-Schlüssel aus der Umgebungsvariable abrufen
TAVILY_API_KEY = os.getenv('TAVILY_API_KEY')

if TAVILY_API_KEY is None:
    raise ValueError("API-Schlüssel nicht gefunden. Bitte setzen Sie die TAVILY_API_KEY-Umgebungsvariable.")

# TavilyClient mit dem abgerufenen API-Schlüssel initialisieren
tavily_client = TavilyClient(api_key=TAVILY_API_KEY)

# Eine Suchanfrage stellen
response = tavily_client.search("Wer ist Leo Messi?")

# Die Antwort ausgeben
print(response)

```

---

## Open WebUI

- Open WebUI ist ein hervorragendes Tool.

- Um den Server zu starten, führen Sie diese Befehle aus: `pip install open-webui` und `open-webui serve`.

- Der Installationsprozess kann etwas Zeit in Anspruch nehmen (etwa 10 Minuten oder mehr).

- Open WebUI funktioniert gut mit Ollama.

---

## Tableau, Scale und Power BI

### Tableau

[https://tableau.com](https://tableau.com)

Nach der Registrierung wurde mir mitgeteilt, dass ich 13 Tage Zeit habe, den Service zu testen.

{: .centered }
![](assets/images/tsp/tableau.jpg)
*Quelle: tableau.com*{: .caption }

### Scale

[https://scale.com](https://scale.com)

{: .centered }
![](assets/images/tsp/scale.jpg)
*Quelle: scale.com*{: .caption }

### Power BI

[https://powerbi.microsoft.com](https://powerbi.microsoft.com)

---

## Verwendung von OpenRouter

- China-ausgestellte Visa-Kreditkarten werden akzeptiert.

- Die Rankings-Seite ist interessant, um die beliebtesten und trendigen Modelle zu sehen.

- Sie können sehen, wie Menschen LLM-Modelle in Kategorien wie Rollenspiel, Programmierung, Marketing, Marketing/SEO und Technologie verwenden.

- Für Nutzer in Hongkong ist weiterhin ein VPN erforderlich, um auf die Anthropic-API zuzugreifen.

---

## ElevenLabs AI

* Großartig. Ich habe 5 US-Dollar verwendet, um den Service zu testen.

* Stimmklon ist fantastisch.

* Audio-Beispiele unten:

* [Englisch](assets/audios/ElevenLabs.mp3)

* [Japanisch](assets/audios/ElevenLabs_1.mp3)

* [Spanisch](assets/audios/ElevenLabs_2.mp3)

```python
import os
import requests
from dotenv import load_dotenv
import argparse
import re

load_dotenv()

api_key = os.environ.get("ELEVENLABS_API_KEY")
if not api_key:
    raise ValueError("ELEVENLABS_API_KEY environment variable not set.")

parser = argparse.ArgumentParser()
parser.add_argument("--file", type=str, help="Markdown-Datei zur Konvertierung in Sprache", required=False)
parser.add_argument("--text", type=str, help="Text zur Konvertierung in Sprache", required=False)
parser.add_argument("--output", type=str, help="Ausgabedateiname", required=True)
parser.add_argument("--voice_id", type=str, default="21m00Tcm4TlvDq8iK2G8", help="Zu verwendende Stimmen-ID")

args = parser.parse_args()

if args.file:
    try:
        with open(args.file, 'r') as f:
            content = f.read()
            # Front Matter entfernen
            content = re.sub(r'---.*?---', '', content, flags=re.DOTALL)
            text = content.strip()
    except FileNotFoundError:
        print(f"Fehler: Datei nicht gefunden: {args.file}")
        exit(1)
    except Exception as e:
        print(f"Fehler beim Lesen der Datei: {e}")
        exit(1)
elif args.text:
    text = args.text
else:
    print("Fehler: Entweder --file oder --text muss angegeben werden.")
    exit(1)


url = f"https://api.elevenlabs.io/v1/text-to-speech/{args.voice_id}"

headers = {
  "Accept": "audio/mpeg",
  "Content-Type": "application/json",
  "xi-api-key": api_key
}

data = {
  "text": text,
  "model_id": "eleven_flash_v2_5",
  "voice_settings": {
    "stability": 0.5,
    "similarity_boost": 0.5
  }
}

response = requests.post(url, json=data, headers=headers)

if response.status_code == 200:
    with open(args.output, 'wb') as f:
        f.write(response.content)
    print(f"Audio gespeichert unter {args.output}")
else:
    print(f"Fehler: {response.status_code} - {response.text}")

```