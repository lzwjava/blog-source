---
audio: false
generated: true
lang: de
layout: post
title: Java Naming and Directory Interface (JNDI)
translated: true
---

### Wichtige Punkte
- Es scheint wahrscheinlich, dass `javax.naming` für die Java Naming and Directory Interface (JNDI) verwendet wird, um benannte Objekte in Diensten wie Datenbanken zu suchen und zu verwalten.
- Die Forschung deutet darauf hin, dass Sie einen Anfangskontext benötigen, um zu beginnen, der in der Regel von einem Java EE-Anwendungsserver für die Produktion oder manuell für Tests eingerichtet wird.
- Die Beweise sprechen dafür, `InitialContext` für Suchvorgänge zu verwenden, wie z.B. das Finden einer DataSource mit Namen wie "java:comp/env/jdbc/datasource".

### Einstieg in `javax.naming`
`javax.naming` ist Teil von JNDI, das Java-Anwendungen hilft, mit Naming- und Verzeichnisdiensten zu interagieren, wie z.B. das Suchen von Datenbankverbindungen. In einer Java EE-Umgebung richtet der Anwendungsserver dies in der Regel ein, was es einfach macht, Ressourcen anhand ihrer Namen zu finden.

### Beispielhafte Verwendung
Hier ist eine einfache Möglichkeit, eine DataSource in einer Java EE-Anwendung zu suchen:
```java
InitialContext ctx = new InitialContext();
DataSource ds = (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
```
Dies setzt voraus, dass die DataSource bereits auf Ihrem Server konfiguriert ist. Für Tests ohne Server benötigen Sie möglicherweise zusätzliche Bibliotheken wie Simple-JNDI.

### Unerwartetes Detail
Man könnte nicht erwarten, dass für eigenständige Anwendungen die Einrichtung von JNDI das Konfigurieren eines benutzerdefinierten Kontexts erfordern kann, was ohne Tools wie Simple-JNDI komplex sein kann.

---

### Umfragehinweis: Umfassender Leitfaden zur Verwendung von `javax.naming`

Diese Notiz bietet eine detaillierte Untersuchung der Verwendung von `javax.naming`, einem Teil der Java Naming and Directory Interface (JNDI), die die Interaktion mit Naming- und Verzeichnisdiensten in Java-Anwendungen erleichtert. JNDI ist so gestaltet, dass es unabhängig von spezifischen Dienstimplementierungen ist, was den Zugriff auf verschiedene Dienste wie Datenbanken, LDAP und Dateisysteme auf einheitliche Weise ermöglicht. Dieser Abschnitt erweitert die direkte Antwort und bietet ein umfassendes Verständnis für Entwickler, einschließlich Einrichtung, Beispiele und Überlegungen für verschiedene Umgebungen.

#### Verständnis von `javax.naming` und JNDI
`javax.naming` ist das Kernpaket für JNDI, das als Teil der Java-Standardbibliothek eingeführt wurde, um Naming- und Verzeichnisfunktionen bereitzustellen. Es definiert die `Context`-Schnittstelle, die zentral für JNDI-Vorgänge ist und Methoden für das Suchen, Binden, Löschen und Umbenennen von Objekten sowie das Erstellen und Löschen von Unterkontexten enthält. Die `lookup()`-Methode wird häufig verwendet, um Objekte anhand ihrer Namen abzurufen, was für den Ressourcenzugriff in Unternehmensanwendungen unerlässlich ist.

JNDI ist besonders nützlich in Java EE-Umgebungen, wo es Anwendungen ermöglicht, sich von spezifischen Dienstdetails zu entkoppeln, was die Portabilität und Flexibilität erhöht. Zum Beispiel wird es oft verwendet, um auf Ressourcen wie Datenbankverbindungen (DataSources), JMS-Anbieter und JavaMail-Dienste zuzugreifen, die vom Anwendungsserver verwaltet werden.

#### Einrichtung und Verwendung von JNDI
Um `javax.naming` zu verwenden, erstellen Sie einen Anfangskontext, der als Einstiegspunkt für Naming-Vorgänge dient. Dies wird in der Regel mit der `InitialContext`-Klasse durchgeführt. Die Einrichtung variiert je nach Umgebung:

- **In Java EE-Anwendungen:** Der Anwendungsserver (z.B. Tomcat, JBoss, WebSphere) konfiguriert den Anfangskontext. Sie können Ressourcen mit Standard-JNDI-Namen suchen, die oft mit "java:comp/env/" beginnen. Zum Beispiel könnte eine DataSource unter "java:comp/env/jdbc/datasource" abgerufen werden.
- **In eigenständigen Anwendungen:** Ohne Anwendungsserver müssen Sie den Anfangskontext manuell konfigurieren und Eigenschaften wie den Naming-Dienstanbieter und die URL angeben. Dies kann komplex sein und erfordert möglicherweise zusätzliche Bibliotheken für Tests, wie Simple-JNDI, das eine In-Memory-Implementierung bietet.

Hier ist eine Tabelle, die die wichtigsten Klassen und ihre Rollen in `javax.naming` zusammenfasst:

| Klasse/Schnittstelle | Rolle                                                                 |
|-------------------------|----------------------------------------------------------------------|
| `Context`              | Kernschnittstelle für Naming-Vorgänge wie Suchen, Binden und Löschen.   |
| `InitialContext`       | Erstellt den Anfangskontext für den Start von JNDI-Vorgängen.             |
| `Name`                 | Stellt einen generischen Namen dar, eine geordnete Folge von Komponenten.         |
| `NamingException`      | Basisklasse für Ausnahmen, die während Naming-Vorgängen ausgelöst werden.            |

#### Praktische Beispiele
Lassen Sie uns Beispiele für sowohl Java EE als auch eigenständige Szenarien durchgehen:

##### Beispiel 1: Suchen einer DataSource in Java EE
In einer Java EE-Anwendung könnten Sie eine konfigurierte DataSource wie folgt suchen:

```java
import javax.naming.InitialContext;
import javax.sql.DataSource;
import java.sql.*;

public class JNDIExample {
    public static void main(String[] args) throws Exception {
        InitialContext ctx = new InitialContext();
        DataSource ds = (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
        Connection conn = ds.getConnection();
        // Verwenden Sie die Verbindung...
        conn.close();
        ctx.close();
    }
}
```

Dieses Beispiel setzt voraus, dass die DataSource im Anwendungsserver konfiguriert ist, in der Regel in Dateien wie `context.xml` für Tomcat. Der JNDI-Name "java:comp/env/jdbc/datasource" ist eine Standardkonvention, kann aber je nach Serverkonfiguration variieren.

##### Beispiel 2: Binden und Suchen eines benutzerdefinierten Objekts
Für Tests oder eigenständige Verwendung möchten Sie möglicherweise einen einfachen In-Memory-Kontext erstellen. Während die Standard-API keinen In-Memory-Kontext-Factory enthält, können Bibliotheken wie Simple-JNDI helfen. Hier ist ein Konzeptbeispiel, das eine solche Einrichtung voraussetzt:

```java
import javax.naming.*;

public class JNDIExample {
    public static void main(String[] args) throws NamingException {
        Context ctx = new InitialContext();
        ctx.rebind("myObject", "Hello, World!");
        String value = (String) ctx.lookup("myObject");
        System.out.println(value);
        ctx.close();
    }
}
```

Hinweis: Dieses eigenständige Beispiel erfordert die Konfiguration des Anfangskontexts mit entsprechenden Eigenschaften, was das Setzen von `java.naming.factory.initial` auf eine benutzerdefinierte Kontext-Factory, wie sie von Simple-JNDI bereitgestellt wird, umfassen könnte.

#### Überlegungen für verschiedene Umgebungen
- **Produktion (Java EE):** In der Produktion richtet der Anwendungsserver die JNDI-Einrichtung ein, was es einfach macht, auf Ressourcen zuzugreifen. Es ist üblich, JNDI für Datenbankverbindungs-Pools zu verwenden, bei denen der Server Verbindungen verwaltet, was die Skalierbarkeit und Sicherheit verbessert. Zum Beispiel erfordert das Ändern von Datenbankanmeldeinformationen nur die Aktualisierung der Serverkonfiguration, nicht des Anwendungscodes.
- **Tests (Eigenständig):** Für Unit- und Integrationstests ist es oft notwendig, ohne Anwendungsserver zu arbeiten. Bibliotheken wie Simple-JNDI ([Simple-JNDI GitHub](https://github.com/h-thurow/Simple-JNDI)) ermöglichen es Ihnen, JNDI-Umgebungen zu simulieren und Ressourcen programmgesteuert zu binden. Dies ist entscheidend für das Testen von Code, der auf JNDI-Suchvorgängen basiert, und stellt sicher, dass er ohne Bereitstellung auf einem Server funktioniert.
- **Sicherheit und Best Practices:** Seien Sie vorsichtig mit JNDI-Injektionen, insbesondere in älteren Java-Versionen, da sie zu Sicherheitslücken wie der Ausführung von Remote-Code führen können. Oracle hat viele solcher Probleme behoben, mit Updates wie Java 8u191, die LDAP-Vektor-Exploits schließen. Validieren Sie immer Eingaben und verwenden Sie die neuesten Java-Versionen für die Sicherheit.

#### Unerwartetes Detail: Komplexität bei eigenständiger Einrichtung
Man könnte die Komplexität, die mit der Einrichtung von JNDI ohne Anwendungsserver verbunden ist, nicht erwarten. Während Java EE dies mit servergesteuerten Kontexten vereinfacht, erfordern eigenständige Setups das Konfigurieren von Kontext-Factories und Eigenschaften, oft unter Verwendung von Drittanbieter-Bibliotheken. Dies kann eine Hürde für Entwickler sein, die neu bei JNDI sind, aber Tools wie Simple-JNDI mildern dies, indem sie speicherbasierte Implementierungen bereitstellen.

#### Weitere Lektüre und Ressourcen
Für ein tieferes Verständnis konsultieren Sie bitte die folgenden:
- [Oracle Java Tutorials: JNDI Overview](https://docs.oracle.com/en/java/tutorial/jndi/overview/index.html) für die offizielle Dokumentation.
- [Baeldung: Java Naming and Directory Interface Overview](https://www.baeldung.com/jndi) für praktische Beispiele und moderne Nutzung.
- [Simple-JNDI GitHub](https://github.com/h-thurow/Simple-JNDI) für das Testen von JNDI ohne Server.

Diese Ressourcen bieten Codebeispiele, Tutorials und Best Practices, die sicherstellen, dass Sie JNDI effektiv in verschiedenen Szenarien implementieren können.

#### Wichtige Zitate
- [Oracle Java Tutorials JNDI Overview](https://docs.oracle.com/en/java/tutorial/jndi/overview/index.html)
- [Baeldung Java Naming and Directory Interface Overview](https://www.baeldung.com/jndi)
- [Simple-JNDI Access property files via JNDI lookups](https://github.com/h-thurow/Simple-JNDI)