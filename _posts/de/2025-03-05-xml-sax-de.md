---
audio: false
generated: true
lang: de
layout: post
title: Verwenden von SAX (Simple API for XML)
translated: true
type: note
---

Um das Paket `org.xml.sax` in Java zum Parsen von XML-Dokumenten zu verwenden, können Sie einem einfachen Prozess mit dem SAX-Parsing-Ansatz (Simple API for XML) folgen. SAX ist ein ereignisgesteuerter Parser, der ein XML-Dokument sequenziell liest und Callback-Methoden auslöst, wenn er auf verschiedene Teile des Dokuments stößt, wie Elemente oder Textinhalte. Dies macht ihn speichereffizient, besonders für große XML-Dateien, da er im Gegensatz zu DOM nicht das gesamte Dokument in den Speicher lädt. Nachfolgend finden Sie eine Schritt-für-Schritt-Anleitung zur Verwendung von `org.xml.sax`.

---

### Schritt 1: SAX-Parser einrichten
Um mit SAX zu beginnen, müssen Sie eine `SAXParser`-Instanz mit der Klasse `SAXParserFactory` erstellen. Diese Factory ermöglicht es Ihnen, das Verhalten des Parsers zu konfigurieren, bevor Sie ihn erstellen.

So erstellen Sie einen `SAXParser`:

```java
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;

public class SAXExample {
    public static void main(String[] args) {
        try {
            // SAXParserFactory-Instanz erstellen
            SAXParserFactory factory = SAXParserFactory.newInstance();

            // Optional: Factory konfigurieren (z.B. Namespace-Awareness aktivieren)
            factory.setNamespaceAware(true); // Auf true setzen, wenn Ihr XML Namespaces verwendet

            // SAXParser erstellen
            SAXParser parser = factory.newSAXParser();

            // Nächste Schritte folgen hier
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

- **`SAXParserFactory.newInstance()`**: Erstellt eine neue Factory-Instanz.
- **`factory.setNamespaceAware(true)`**: Optional. Aktiviert die Namespace-Verarbeitung, wenn Ihr XML Namespaces verwendet. Standardmäßig ist der Wert `false`.
- **`factory.newSAXParser()`**: Erstellt einen `SAXParser`. Dies kann `ParserConfigurationException` oder `SAXException` auslösen, wenn der Parser nicht konfiguriert oder initialisiert werden kann.

---

### Schritt 2: Einen Handler für XML-Ereignisse erstellen
Beim SAX-Parsing wird ein Handler benötigt, um die XML-Ereignisse zu verarbeiten, auf die der Parser stößt, wie den Start eines Elements, das Ende eines Elements oder Textinhalte. Die primäre Schnittstelle hierfür ist `ContentHandler`, aber der Einfachheit halber können Sie die Klasse `DefaultHandler` erweitern, die leere Implementierungen von `ContentHandler` und anderen Handler-Schnittstellen (`ErrorHandler`, `DTDHandler` usw.) bereitstellt. Sie müssen nur die Methoden überschreiben, die für Sie relevant sind.

Hier ist ein Beispiel für einen benutzerdefinierten Handler:

```java
import org.xml.sax.Attributes;
import org.xml.sax.helpers.DefaultHandler;

public class MyHandler extends DefaultHandler {
    // Variable zum Sammeln von Textinhalten
    private StringBuilder content = new StringBuilder();

    @Override
    public void startElement(String uri, String localName, String qName, Attributes attributes) {
        // Inhalts-Puffer für das neue Element leeren
        content.setLength(0);
        System.out.println("Start element: " + qName);

        // Wenn das Element Attribute hat, diese verarbeiten
        for (int i = 0; i < attributes.getLength(); i++) {
            System.out.println("Attribute: " + attributes.getQName(i) + " = " + attributes.getValue(i));
        }
    }

    @Override
    public void characters(char[] ch, int start, int length) {
        // Textinhalt sammeln (kann mehrmals pro Element aufgerufen werden)
        content.append(ch, start, length);
    }

    @Override
    public void endElement(String uri, String localName, String qName) {
        // Gesammelten Textinhalt verarbeiten
        String text = content.toString().trim();
        if (!text.isEmpty()) {
            System.out.println("Content: " + text);
        }
        System.out.println("End element: " + qName);
        content.setLength(0); // Für das nächste Element zurücksetzen
    }

    @Override
    public void startDocument() {
        System.out.println("Document parsing started");
    }

    @Override
    public void endDocument() {
        System.out.println("Document parsing completed");
    }
}
```

- **`startElement`**: Wird aufgerufen, wenn der Parser auf den Start eines Elements stößt. Parameter umfassen:
  - `uri`: Namespace-URI (wenn namespace-aware).
  - `localName`: Lokaler Name des Elements (ohne Präfix, wenn namespace-aware).
  - `qName`: Qualifizierter Name (enthält Präfix, falls vorhanden).
  - `attributes`: Liste der Attribute des Elements.
- **`characters`**: Wird für Textinhalte innerhalb eines Elements aufgerufen. Beachten Sie, dass dies mehrmals für den Inhalt eines einzelnen Elements aufgerufen werden kann, verwenden Sie daher einen `StringBuilder`, um ihn zu sammeln.
- **`endElement`**: Wird aufgerufen, wenn ein Element endet.
- **`startDocument` und `endDocument`**: Werden am Anfang und Ende des XML-Dokuments aufgerufen.

---

### Schritt 3: Das XML parsen
Wenn Parser und Handler bereit sind, können Sie eine XML-Quelle (z.B. eine Datei, `InputStream` oder Zeichenkette) parsen, indem Sie die `parse`-Methode auf dem `SAXParser` aufrufen und Ihren Handler übergeben.

So parsen Sie eine XML-Datei:

```java
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import java.io.File;

public class SAXExample {
    public static void main(String[] args) {
        try {
            // Parser erstellen
            SAXParserFactory factory = SAXParserFactory.newInstance();
            SAXParser parser = factory.newSAXParser();

            // Handler erstellen
            MyHandler handler = new MyHandler();

            // Eine XML-Datei parsen
            File xmlFile = new File("example.xml");
            parser.parse(xmlFile, handler);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

- **`parser.parse`**: Nimmt eine XML-Quelle (z.B. `File`) und einen `DefaultHandler` entgegen. Es kann `IOException` (bei Eingabefehlern) oder `SAXException` (bei Parsing-Fehlern) auslösen.

Für eine XML-Zeichenkette anstelle einer Datei verwenden Sie `InputSource`:

```java
import org.xml.sax.InputSource;
import java.io.StringReader;

// In der main-Methode
String xml = "<book><title>XML Parsing</title></book>";
InputSource inputSource = new InputSource(new StringReader(xml));
parser.parse(inputSource, handler);
```

---

### Schritt 4: Ausnahmen behandeln
Beim SAX-Parsing können verschiedene Ausnahmen auftreten, die Sie behandeln sollten:

- **`ParserConfigurationException`**: Wird von `newSAXParser()` ausgelöst, wenn der Parser nicht konfiguriert werden kann.
- **`SAXException`**: Wird von `newSAXParser()` oder `parse()` für allgemeine Parsing-Fehler ausgelöst.
- **`IOException`**: Wird von `parse()` ausgelöst, wenn es ein Problem beim Lesen der Eingabequelle gibt.

Umschließen Sie Ihren Code mit einem `try-catch`-Block:

```java
try {
    SAXParserFactory factory = SAXParserFactory.newInstance();
    SAXParser parser = factory.newSAXParser();
    MyHandler handler = new MyHandler();
    parser.parse(new File("example.xml"), handler);
} catch (ParserConfigurationException e) {
    System.err.println("Parser configuration error: " + e.getMessage());
} catch (SAXException e) {
    System.err.println("SAX error: " + e.getMessage());
} catch (IOException e) {
    System.err.println("IO error: " + e.getMessage());
}
```

---

### Schritt 5: Optionale Funktionen
#### Fehlerbehandlung
`DefaultHandler` implementiert auch `ErrorHandler`. Überschreiben Sie seine Methoden, um Parsing-Fehler zu behandeln:

```java
public class MyHandler extends DefaultHandler {
    @Override
    public void error(SAXParseException e) {
        System.err.println("Parsing error: " + e.getMessage());
    }

    @Override
    public void fatalError(SAXParseException e) throws SAXException {
        System.err.println("Fatal error: " + e.getMessage());
        throw e; // Parsing stoppen
    }

    @Override
    public void warning(SAXParseException e) {
        System.out.println("Warning: " + e.getMessage());
    }
    // Andere Methoden wie oben
}
```

#### Namespace-Behandlung
Wenn Ihr XML Namespaces verwendet, setzen Sie `factory.setNamespaceAware(true)` und verwenden Sie `uri` und `localName` in Ihren Handler-Methoden anstelle von `qName`, um Elemente korrekt zu identifizieren.

#### Validierung
Um XML gegen eine DTD oder ein Schema zu validieren, setzen Sie `factory.setValidating(true)`. Sie benötigen möglicherweise auch einen `ErrorHandler`, um Validierungsfehler zu verwalten.

---

### Beispiel-XML und Ausgabe
Für eine XML-Datei `example.xml`:
```xml
<book id="123">
    <title>XML Parsing</title>
    <author>John Doe</author>
</book>
```

Die Ausführung des obigen Codes könnte folgende Ausgabe erzeugen:
```
Document parsing started
Start element: book
Attribute: id = 123
Start element: title
Content: XML Parsing
End element: title
Start element: author
Content: John Doe
End element: author
End element: book
Document parsing completed
```

---

### Zusammenfassung
So verwenden Sie `org.xml.sax`:
1. Erstellen Sie einen `SAXParser` mit `SAXParserFactory`.
2. Implementieren Sie einen Handler, indem Sie `DefaultHandler` erweitern und Methoden wie `startElement`, `endElement` und `characters` überschreiben.
3. Parsen Sie das XML, indem Sie `parser.parse()` mit Ihrem Handler und der XML-Quelle aufrufen.
4. Behandeln Sie Ausnahmen (`SAXException`, `IOException`, `ParserConfigurationException`).
5. Konfigurieren Sie optional Namespace-Awareness, Validierung oder Fehlerbehandlung.

Dieser Ansatz ist ideal für das effiziente Parsen großer XML-Dokumente, wenn Sie nur bestimmte Daten extrahieren müssen, ohne einen In-Memory-Baum aufzubauen.