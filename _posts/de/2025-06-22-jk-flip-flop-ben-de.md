---
audio: false
generated: true
lang: de
layout: post
title: SR-Latch und Flip-Flop-Modifikationen von Ben Eater
translated: true
type: note
---

In einem vorherigen Video habe ich das SR-Latch besprochen, und ich empfehle Ihnen, dieses Video anzuschauen, falls Sie nicht damit vertraut sind. Um es zusammenzufassen: Das SR-Latch hat zwei Eingänge: **R** (Reset) und **S** (Set). Wenn der Reset-Eingang high geht, geht der Ausgang **Q** auf low (aus), was das Latch zurücksetzt. Wenn der Set-Eingang high geht, geht der Ausgang **Q** auf high (ein), was das Latch setzt. Es gibt auch einen komplementären Ausgang, **Q̅** (Q-quer), der stets das Gegenteil von **Q** ist, außer in einem Fall: wenn sowohl der **R**- als auch der **S**-Eingang gleichzeitig high sind. In diesem Szenario gehen sowohl **Q** als auch **Q̅** auf low, was als ungültiger Zustand betrachtet wird, da man das Latch nicht gleichzeitig setzen und zurücksetzen sollte. Wenn beide Eingänge losgelassen werden, wird der Zustand des Latches unvorhersehbar, da er davon abhängt, welcher Eingang zuerst losgelassen wird. Im Allgemeinen bleibt das SR-Latch in einem seiner beiden stabilen Zustände verriegelt.

In diesem Video werde ich Modifikationen der grundlegenden SR-Latch-Schaltung besprechen. Die erste Modifikation ist das **SR-Latch mit Enable**. Diese Version fügt **AND-Gatter** sowohl zum **R**- als auch zum **S**-Eingang hinzu, die durch ein **Enable**-Signal gesteuert werden. Wenn das Enable-Signal high (1) ist, lassen die AND-Gatter die **R**- und **S**-Eingänge unverändert passieren. Wenn beispielsweise **Enable** 1 und **Reset** 1 ist, gibt das AND-Gatter eine 1 aus; wenn **Reset** 0 ist, gibt es eine 0 aus. Wenn jedoch das **Enable**-Signal low (0) ist, sind die Ausgänge der AND-Gatter immer 0, unabhängig von den **R**- und **S**-Eingängen. Dies bewirkt, dass das Latch in seinem letzten Zustand bleibt und die Eingänge effektiv ignoriert. Somit erlaubt das Enable-Signal, das Latch entweder zu aktivieren, damit es auf seine **R**- und **S**-Eingänge reagiert, oder es zu deaktivieren, um seinen aktuellen Zustand zu halten.

Als Nächstes können wir dieses Konzept erweitern, um ein **SR-Flip-Flop** zu erstellen. Der entscheidende Unterschied zwischen einem Latch und einem Flip-Flop ist, dass sich die Ausgänge eines Latches immer dann ändern, wenn sich seine Eingänge ändern, während sich die Ausgänge eines Flip-Flops nur bei einem spezifischen Trigger ändern, typischerweise einem Taktimpuls. Bei einem SR-Flip-Flop steuert ein **Clock**-Eingang (dargestellt durch ein Dreieckssymbol in Schaltplänen), wann die Ausgänge aktualisiert werden. Konkret ändern sich die Ausgänge **Q** und **Q̅** nur, wenn der Takt von low zu high wechselt (eine steigende Flanke). Zu allen anderen Zeiten werden die Eingänge **R** und **S** ignoriert, und das Flip-Flop behält seinen vorherigen Zustand bei.

Das SR-Flip-Flop erreicht dies mithilfe eines Kondensators in der Taktschaltung. Wenn der Takt von low zu high wechselt, fließt ein kurzer Strom durch den Kondensator, während dieser sich auflädt, und erzeugt einen kurzen Spannungsimpuls an den Eingängen der AND-Gatter. Dieser Impuls aktiviert das SR-Latch mit Enable effektiv nur für diesen Moment und erlaubt es den **R**- und **S**-Eingängen, die Ausgänge **Q** und **Q̅** zu beeinflussen. Sobald der Kondensator vollständig geladen ist, stoppt der Impuls, und das Flip-Flop ignoriert weitere Eingangsänderungen bis zur nächsten steigenden Taktflanke.

So verhält sich das SR-Flip-Flop während einer steigenden Taktflanke:
- Wenn **R** high und **S** low ist, geht **Q** auf low (Reset) und **Q̅** geht auf high.
- Wenn **S** high und **R** low ist, geht **Q** auf high (Set) und **Q̅** geht auf low.
- Wenn sowohl **R** als auch **S** low sind, bleibt das Flip-Flop in seinem vorherigen Zustand.
- Wenn sowohl **R** als auch **S** high sind (der ungültige Zustand des SR-Latch), ist das Verhalten unvorhersehbar. Ähnlich wie beim SR-Latch können sowohl **Q** als auch **Q̅** während des Impulses auf low gehen, aber wenn die Eingänge losgelassen werden, pendelt sich das Flip-Flop in dem einen oder anderen Zustand ein, basierend darauf, welcher Eingang zuerst abfällt. Dies macht den Ausgang unsicher, da er von Timing-Unterschieden (z.B. ein paar Nanosekunden) abhängt, was diesen zu einem ungültigen und unvorhersehbaren Zustand macht.

Um diese Unvorhersehbarkeit zu beheben, können wir ein **JK-Flip-Flop** verwenden, das dem SR-Flip-Flop ähnelt, aber ein Feedback von den Ausgängen **Q** und **Q̅** zu den Eingängen beinhaltet. Das JK-Flip-Flop verwendet AND-Gatter mit drei Eingängen, die **J** (analog zu **S**), **K** (analog zu **R**) und die Feedback-Signale **Q** und **Q̅** einbeziehen. Die Buchstaben **J** und **K** sind beliebig und stehen nicht für spezifische Begriffe, aber sie unterscheiden diese Schaltung vom SR-Flip-Flop.

Das JK-Flip-Flop funktioniert wie folgt:
- Wenn sowohl **J** als auch **K** 0 sind, sind die AND-Gatter-Ausgänge 0, also bleibt das Flip-Flop in seinem vorherigen Zustand, selbst während eines Taktimpulses.
- Wenn das Latch aktuell gesetzt ist (**Q** = 1, **Q̅** = 0) und Sie es zurücksetzen wollen (**K** = 1, **J** = 0), gibt das mit **K** verbundene AND-Gatter während des Taktimpulses eine 1 aus (da **Q** = 1), was das Flip-Flop zurücksetzt (**Q** = 0, **Q̅** = 1).
- Wenn das Latch bereits zurückgesetzt ist (**Q** = 0, **Q̅** = 1) und **K** = 1, **J** = 0, bleiben die AND-Gatter-Ausgänge 0, also bleibt das Flip-Flop zurückgesetzt, was das gewünschte Verhalten ist.
- Ähnlich, wenn das Latch zurückgesetzt ist (**Q** = 0, **Q̅** = 1) und Sie es setzen wollen (**J** = 1, **K** = 0), gibt das mit **J** verbundene AND-Gatter während des Taktimpulses eine 1 aus (da **Q̅** = 1), was das Flip-Flop setzt (**Q** = 1, **Q̅** = 0).
- Wenn das Latch bereits gesetzt ist und **J** = 1, **K** = 0, bleibt es gesetzt, wie erwartet.

Die einzigartige Eigenschaft des JK-Flip-Flops tritt auf, wenn sowohl **J** als auch **K** 1 sind. Aufgrund des Feedbacks kann nur ein AND-Gatter gleichzeitig aktiv sein (da **Q** und **Q̅** nicht beide 1 sein können). Wenn **Q** 1 ist, ist das AND-Gatter für **K** aktiv, und das Flip-Flop setzt sich beim nächsten Taktimpuls zurück (**Q** = 0, **Q̅** = 1). Wenn **Q** 0 ist, ist das AND-Gatter für **J** aktiv, und das Flip-Flop setzt sich beim nächsten Taktimpuls (**Q** = 1, **Q̅** = 0). Dies erzeugt ein **Toggle**-Verhalten: wenn **J** = **K** = 1, schaltet das Flip-Flop seinen Zustand bei jedem Taktimpuls (**Q** wechselt von 0 zu 1 oder 1 zu 0). Dieses vorhersehbare Toggeln beseitigt den ungültigen, unvorhersehbaren Zustand des SR-Flip-Flops und macht das JK-Flip-Flop robuster und vielseitiger.