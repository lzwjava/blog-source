---
audio: false
generated: true
lang: de
layout: post
title: ICMP-Ping-Programm in C
translated: true
type: note
---

ICMP (Internet Control Message Protocol) ist ein Protokoll der Vermittlungsschicht, das für Diagnose- und Fehlermeldungszwecke in IP-Netzwerken verwendet wird. Es ist am bekanntesten für die Verwendung durch das `ping`-Utility, um die Verbindung zwischen Hosts zu testen. ICMP-Nachrichten werden direkt in IP-Pakete gekapselt (keine TCP- oder UDP-Schicht) und bestehen aus einem Typ, Code, Prüfsumme und Nutzdaten. Für `ping` sind die "Echo Request" (Typ 8) und "Echo Reply" (Typ 0) Nachrichten entscheidend.

So funktioniert ICMP auf hoher Ebene:
1.  Ein Sender (z.B. Ihr Rechner) sendet eine ICMP Echo Request an eine Ziel-IP.
2.  Das Ziel sendet, wenn erreichbar und konfiguriert zu antworten, eine ICMP Echo Reply zurück.
3.  Der Sender misst die Round-Trip-Zeit (RTT) basierend auf dem Zeitpunkt des Eintreffens der Antwort.

Um ein `ping`-ähnliches Programm in C ohne Bibliotheken wie `libpcap` oder `libnet` zu implementieren, verwenden wir Raw Sockets (`SOCK_RAW`), um ICMP-Pakete direkt zu erstellen und zu senden. Dies erfordert Root-Rechte (z.B. `sudo`), weil Raw Sockets höhere Abstraktionen umgehen.

Unten finden Sie ein vereinfachtes C-Programm, das ICMP Echo Requests sendet und auf Echo Replies lauscht und so grundlegende `ping`-Funktionalität nachahmt.

---

### ICMP Ping-Programm in C

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>
#include <time.h>
#include <errno.h>

// ICMP-Prüfsumme berechnen
unsigned short checksum(void *b, int len) {
    unsigned short *buf = b;
    unsigned int sum = 0;
    unsigned short result;

    for (sum = 0; len > 1; len -= 2) {
        sum += *buf++;
    }
    if (len == 1) {
        sum += *(unsigned char *)buf;
    }
    sum = (sum >> 16) + (sum & 0xFFFF);
    sum += (sum >> 16);
    result = ~sum;
    return result;
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: %s <destination_ip>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    int sock_fd;
    struct sockaddr_in dest_addr;
    char packet[64];  // ICMP-Header + einige Daten
    struct icmphdr *icmp;
    char recv_buffer[1024];
    struct timespec start, end;

    // Raw Socket für ICMP erstellen
    sock_fd = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);
    if (sock_fd < 0) {
        perror("Socket-Erstellung fehlgeschlagen (als root ausführen?)");
        exit(EXIT_FAILURE);
    }

    // Zieladresse einrichten
    dest_addr.sin_family = AF_INET;
    if (inet_pton(AF_INET, argv[1], &dest_addr.sin_addr) <= 0) {
        perror("Ungültige IP-Adresse");
        close(sock_fd);
        exit(EXIT_FAILURE);
    }

    // ICMP Echo Request Paket vorbereiten
    memset(packet, 0, sizeof(packet));
    icmp = (struct icmphdr *)packet;
    icmp->type = ICMP_ECHO;        // Typ 8: Echo Request
    icmp->code = 0;
    icmp->un.echo.id = getpid();   // Prozess-ID als Identifikator verwenden
    icmp->un.echo.sequence = 1;    // Sequenznummer
    for (int i = sizeof(*icmp); i < 64; i++) {
        packet[i] = i;             // Nutzdaten mit Dummy-Daten füllen
    }
    icmp->checksum = 0;            // Prüfsumme nach dem Füllen des Pakets berechnen
    icmp->checksum = checksum(packet, 64);

    printf("Pinge %s an...\n", argv[1]);

    for (int i = 0; i < 4; i++) { // Sende 4 Pings
        // Sendezeit aufzeichnen
        clock_gettime(CLOCK_MONOTONIC, &start);

        // ICMP Echo Request senden
        if (sendto(sock_fd, packet, 64, 0, (struct sockaddr *)&dest_addr, sizeof(dest_addr)) < 0) {
            perror("Senden fehlgeschlagen");
            close(sock_fd);
            exit(EXIT_FAILURE);
        }

        // ICMP Echo Reply empfangen
        struct sockaddr_in from_addr;
        socklen_t from_len = sizeof(from_addr);
        int bytes_received = recvfrom(sock_fd, recv_buffer, sizeof(recv_buffer), 0,
                                      (struct sockaddr *)&from_addr, &from_len);
        if (bytes_received < 0) {
            perror("Empfang fehlgeschlagen");
            continue;
        }

        // Empfangszeit aufzeichnen
        clock_gettime(CLOCK_MONOTONIC, &end);

        // Empfangene IP- und ICMP-Header parsen
        struct iphdr *ip = (struct iphdr *)recv_buffer;
        struct icmphdr *icmp_reply = (struct icmphdr *)(recv_buffer + (ip->ihl * 4));
        if (icmp_reply->type == ICMP_ECHOREPLY && icmp_reply->un.echo.id == getpid()) {
            double rtt = (end.tv_sec - start.tv_sec) * 1000.0 +
                         (end.tv_nsec - start.tv_nsec) / 1000000.0;
            printf("%d bytes von %s: seq=%d time=%.2f ms\n",
                   bytes_received - (ip->ihl * 4), argv[1], icmp_reply->un.echo.sequence, rtt);
        } else {
            printf("Unerwartete ICMP-Antwort: type=%d\n", icmp_reply->type);
        }

        sleep(1); // 1 Sekunde zwischen Pings warten
        icmp->un.echo.sequence++; // Sequenznummer erhöhen
        icmp->checksum = 0;
        icmp->checksum = checksum(packet, 64); // Prüfsumme neu berechnen
    }

    close(sock_fd);
    return 0;
}
```

---

### So funktioniert es

1.  **Socket-Erstellung**:
    - `socket(AF_INET, SOCK_RAW, IPPROTO_ICMP)` erstellt einen Raw Socket für ICMP. Dies ermöglicht uns, ICMP-Pakete manuell zu erstellen.

2.  **ICMP-Paket-Konstruktion**:
    - Der ICMP-Header (`struct icmphdr`) wird gefüllt mit:
        - `type = ICMP_ECHO` (8) für Echo Request.
        - `code = 0`.
        - `id` auf die Prozess-ID gesetzt, um unsere Pings zu identifizieren.
        - `sequence` zur Verfolgung einzelner Anfragen.
    - Eine Nutzlast (Dummy-Daten) wird hinzugefügt und die Prüfsumme über das gesamte Paket berechnet.

3.  **Senden**:
    - `sendto()` sendet das Paket an die Ziel-IP. Es wird kein Port benötigt, da ICMP unterhalb der Transportschicht arbeitet.

4.  **Empfangen**:
    - `recvfrom()` fängt das rohe IP-Paket, das die ICMP Echo Reply enthält, ab.
    - Wir überspringen den IP-Header (`ihl * 4` Bytes), um zum ICMP-Header zu gelangen.
    - Prüfen, ob es sich um eine Echo Reply (Typ 0) handelt und ob sie unserer `id` entspricht.

5.  **Zeitmessung**:
    - `clock_gettime()` misst die RTT in Millisekunden.

6.  **Prüfsumme**:
    - Die `checksum()`-Funktion berechnet die 16-Bit-Einerkomplement-Summe, wie von ICMP gefordert.

---

### Kompilierung und Verwendung
- Kompilieren: `gcc ping.c -o ping`
- Ausführen (als root): `sudo ./ping 8.8.8.8`
- Beispielausgabe:
  ```
  Pinge 8.8.8.8 an...
  64 bytes von 8.8.8.8: seq=1 time=12.34 ms
  64 bytes von 8.8.8.8: seq=2 time=11.89 ms
  ...
  ```

---

### Hinweise
-   **Root-Rechte**: Raw Sockets erfordern `sudo`, weil sie Netzwerkpakete direkt manipulieren.
-   **Firewall**: Das Ziel muss auf ICMP Echo Requests antworten (einige Hosts blockieren diese).
-   **Vereinfachungen**: Diese Version behandelt nicht alle Randfälle (z.B. Timeouts, Paketverlust vollständig oder IP-Optionen).

Das ist so low-level, wie man im User Space mit ICMP arbeiten kann. Darunter bräuchte man Kernel-Level-Code, um direkt mit dem IP-Stack zu interagieren. Lassen Sie mich wissen, wenn Sie es weiter anpassen möchten!