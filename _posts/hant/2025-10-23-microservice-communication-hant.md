---
audio: false
generated: true
image: false
lang: hant
layout: post
model: x-ai/grok-4-fast
title: 微服務通訊：同步與事件驅動
translated: true
type: note
---

### 微服務中的同步與事件驅動通訊

在微服務架構中，服務間的通訊主要有兩種方式：**同步**（直接主動呼叫，如 HTTP/REST API）或**非同步/事件驅動**（使用如 Kafka 等工具發布和消費事件）。您的問題點出了一個常見的取捨：為何不直接將邏輯集中在單一服務（「呼叫方」）中，讓它主動呼叫下游服務（「被呼叫方」），甚至修改呼叫方以將呼叫分散至多個被呼叫方？反而要使用像 Kafka 這樣的工具透過事件來解耦它們？

簡短回答：採用 Kafka 的事件驅動架構能促進**鬆散耦合、可擴展性與韌性**，讓系統更易於構建、維護和擴展——尤其是在複雜度增長時。直接呼叫在簡單設定下運作良好，但在分散式、高流量的環境中會出現問題。讓我們深入分析。

#### 為何不直接從單一位置主動呼叫服務（或修改呼叫方）？
這種方法——讓中央「協調者」服務（或原始呼叫方）透過 API 直接呼叫下游服務——起初很直接。您甚至可以更新呼叫方以「新增被呼叫方」（例如，依序或並行地分散呼叫至多個服務）。但以下是它不足的原因：

- **緊密耦合**：呼叫方必須知道每個被呼叫方的確切位置（URL/端點）、結構描述和可用性。如果下游服務變更其 API、當機或重新命名，您必須更新*每個*呼叫方。這會形成難以重構的依賴網絡。
  
- **同步阻塞**：呼叫是阻塞的——您的呼叫方會等待回應。如果一個被呼叫方變慢或失敗，整個鏈條會停頓（級聯故障）。在分散呼叫的情境中（呼叫方呼叫多個被呼叫方），單一超時可能延遲所有作業。

- **可擴展性限制**：高流量意味著呼叫方成為瓶頸。它必須處理所有協調、重試和錯誤處理。新增更多被呼叫方？您會讓呼叫方充滿邏輯，違反單一職責原則。

- **可靠性問題**：沒有內建的佇列或重試機制。故障會立即傳播，如果服務在呼叫中途當機，您會遺失事件/資料。

本質上，這就像一個每個人都直接撥號的電話樹：對 3-4 人有效，對 100 人則是混亂。

#### 為何採用 Kafka 的事件驅動？（讓下游消費事件）
Kafka 是一個分散式事件串流平台，充當持久、有序的事件日誌。生產者（上游服務）將事件發布至主題（例如「user-registered」），而消費者（下游服務）則獨立訂閱並處理它們。這將模式從「推送/拉取協調」轉變為「發布/訂閱」（pub/sub）。

值得轉變的關鍵優勢：

1. **鬆散耦合與靈活性**：
   - 服務無需相互了解。生產者僅發布帶有相關資料的事件（例如 `{userId: 123, action: "registered"}`）。任意數量的消費者可以訂閱該主題，而生產者無需關心。
   - 想新增下游服務（例如通知郵件、更新分析）？只需讓它消費事件——無需變更生產者或現有程式碼。移除一個？取消訂閱即可。這對演進中的系統極為重要。

2. **非同步與非阻塞**：
   - 生產者發送後即忘：發布事件後立即繼續。無需等待下游處理。
   - 提升整體系統響應性——您的用戶面對服務不會因背景任務（如記錄或通知）而停滯。

3. **可擴展性與吞吐量**：
   - Kafka 處理大規模：跨分割區每秒數百萬事件。多個消費者可以並行處理*相同*事件（例如一個用於快取，一個用於搜尋索引）。
   - 水平擴展很容易——新增更多消費者實例，無需觸碰生產者。

4. **韌性與持久性**：
   - 事件在 Kafka 日誌中持久保存數天/數週。如果消費者當機或延遲，它會從最後的偏移量（檢查點）重新播放事件。
   - 恰一次語意（透過適當配置）防止重複。內建重試、死信佇列和容錯能力勝過在呼叫方中的自訂程式碼。

5. **事件溯源與可審計性**：
   - 將資料視為不可變事件串流，允許重新播放以進行除錯、合規或重建狀態（例如「重新播放所有用戶事件以修復錯誤」）。
   - 非常適合即時分析、ML 管道或 CQRS（命令查詢職責分離）模式。

#### 何時適用？（取捨）
- **最適合**：高流量、分散式系統（例如電商訂單處理、物聯網資料串流、用戶活動動態）。如果您的應用有 10+ 服務或不可預測的負載，Kafka 可防止「大泥球」架構。
- **缺點**：增加複雜度（學習 Kafka、管理主題/分割區、最終一致性）。除錯事件流可能比直接呼叫更棘手。從同步開始用於原型，隨擴展遷移至事件驅動。
- **Kafka 的替代方案**：RabbitMQ（用於更簡單的佇列）、AWS SNS/SQS（託管）、或 Pulsar（如果需要多租戶）。但 Kafka 的串流 + 佇列組合使其成為首選。

#### 程式碼範例（虛擬碼）
**同步呼叫方（脆弱）**：
```python
def process_user_registration(user_data):
    # 呼叫方直接呼叫多個服務
    email_service.send_welcome(user_data)  # 若變慢則阻塞
    analytics_service.log_event(user_data)  # 失敗？整個過程失敗
    cache_service.invalidate(user_data)     # 新增更多？在此更新
```

**採用 Kafka 的事件驅動（靈活）**：
```python
# 生產者（上游）
from kafka import KafkaProducer
producer = KafkaProducer(bootstrap_servers='localhost:9092')
producer.send('user-events', value={'userId': 123, 'action': 'registered'})

# 消費者 1（郵件服務，獨立）
from kafka import KafkaConsumer
consumer = KafkaConsumer('user-events', bootstrap_servers='localhost:9092')
for msg in consumer:
    if msg.value['action'] == 'registered':
        send_welcome(msg.value)  # 可獨立擴展/重試

# 消費者 2（分析，訂閱相同主題——無需變更生產者）
# ... 類似，但記錄至資料庫
```

總而言之，修改呼叫方以「新增被呼叫方」是一種擴展性差且耦合一切的快速修補方法。採用 Kafka 的事件驅動讓服務獨立演進，將您的偽單體轉變為真正的模組化系統。如果您正在構建特定系統，分享更多細節以獲得量身定制的建議！

**參考資料**：
- [Kafka 文件：簡介](https://kafka.apache.org/intro)
- [Martin Fowler：事件驅動架構](https://martinfowler.com/articles/201701-event-driven.html)
- [ThoughtWorks：微服務模式（第 11 章：事件協作）](https://www.oreilly.com/library/view/microservices-patterns/9781492034018/ch11.html)