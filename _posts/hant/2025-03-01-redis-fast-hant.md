---
audio: false
generated: true
lang: hant
layout: post
title: 為何 Redis 如此快速
translated: true
type: note
---

### 重點摘要
- ByteByteGo 的 YouTube 影片《系統設計：為何單線程的 Redis 如此快速？》很可能解釋了 Redis 的高速效能歸因於記憶體儲存、I/O 多工處理及高效資料結構。
- 研究顯示，儘管 Redis 在請求處理上採用單線程模式，這些因素使其每秒能處理高達 100,000 次查詢。
- 證據傾向於近期 Redis 版本已針對特定任務加入多線程支援，但其核心仍維持單線程架構。

---

### 引言
本篇網誌內容基於 ByteByteGo 的 YouTube 影片《系統設計：為何單線程的 Redis 如此快速？》，該影片屬於其系統設計系列的一部分。Redis 以其高效能著稱，能在單一機器上每秒處理高達 100,000 次查詢，對於單線程系統而言表現令人驚艷。讓我們深入探討其背後的運作原理及 Redis 如此快速的原因。

### Redis 高速效能的關鍵因素
Redis 的高速效能可歸因於以下幾個關鍵因素，影片中很可能涵蓋這些內容：

- **記憶體儲存**：Redis 將資料儲存於 RAM 中，其讀取速度遠超過磁碟儲存。由於記憶體存取時間僅需納秒級，而磁碟存取則需毫秒級，此設計有效降低延遲並提升吞吐量。

- **I/O 多工處理與單線程執行**：透過 I/O 多工處理技術（如在 Linux 系統使用 epoll），單一線程能高效處理多個客戶端連線。這避免了上下文切換的開銷，且單線程循環架構透過消除同步問題簡化了操作流程。

- **高效資料結構**：Redis 採用經過優化的資料結構，如雜湊表（O(1) 查詢時間）、鏈結串列和跳躍串列，透過最小化記憶體使用量及加速操作來提升效能。

### 擴展與演進
為因應高併發場景，Redis 可透過橫向擴展使用多個實例或集群模式。值得關注的是，雖然核心請求處理仍保持單線程，但自 4.0 版起已針對特定任務（如背景物件刪除）引入多線程處理，在維持主要架構不變的前提下進一步提升效能。

---

### 調查筆記：Redis 單線程效能深度解析

本節基於 ByteByteGo 的 YouTube 影片《系統設計：為何單線程的 Redis 如此快速？》及相關研究，對 Redis 單線程架構的高效能表現進行全面分析。該影片於 2022 年 8 月 13 日發布，屬於專注於系統設計的系列內容，由暢銷書《系統設計面試》作者製作。考量該頻道的專業定位，影片很可能提供適合技術面試與系統設計討論的深度解析。

#### 背景與情境
Redis 作為開源記憶體鍵值儲存系統，廣泛應用於快取、訊息代理和串流處理引擎。它支援多種資料結構，包含字串、列表、集合、雜湊表、有序集合及概率型結構如 Bloom Filter 與 HyperLogLog。影片標題暗示將探討為何 Redis 在單線程請求處理的架構下仍能維持高效能，這正是其設計核心所在。

根據相關文章資料，Redis 在單一機器上可處理高達每秒 100,000 次查詢，此數字常出現於效能基準測試中。這種速度在單線程模型下顯得格外突出，但研究指出其歸功於多項架構設計選擇。

#### 促成 Redis 高速效能的關鍵要素

1. **記憶體儲存**  
   Redis 將資料儲存於 RAM 中，其隨機存取速度至少比磁碟快 1000 倍。這種設計消除了磁碟 I/O 的延遲問題，RAM 存取時間約為 100-120 納秒，而 SSD 需 50-150 微秒，HDD 更需 1-10 毫秒。影片極可能將此列為主要因素，因這符合頻道對系統設計基礎的重視。

   | 面向                 | 詳細說明                                     |
   |----------------------|----------------------------------------------|
   | 儲存媒介             | RAM（記憶體）                                |
   | 存取時間             | 約 100-120 納秒                             |
   | 與磁碟比較           | 比隨機磁碟存取快 1000 倍                    |
   | 對效能影響           | 降低延遲，提升吞吐量                         |

2. **I/O 多工處理與單線程執行循環**  
   I/O 多工處理技術讓單一線程能透過系統呼叫（如 `select`、`poll`、`epoll`（Linux）、`kqueue`（Mac OS）或 `evport`（Solaris））同時監控多個 I/O 串流。這對於無阻塞處理多客戶端連線至關重要，影片中很可能詳述此點。單線程執行循環避免了上下文切換與同步開銷，簡化了開發與除錯流程。

   | 機制                 | 說明                                         |
   |----------------------|----------------------------------------------|
   | epoll/kqueue         | 適用高併發場景，非阻塞式                     |
   | select/poll          | 舊版技術，擴展性較差，O(n) 複雜度           |
   | 影響                 | 降低連線開銷，實現管道化處理                 |

   然而，如 `BLPOP` 或 `BRPOP 等客戶端阻塞命令可能延遲流量處理，相關文章提及此潛在缺點。影片可能會討論這種設計選擇如何平衡簡潔性與效能。

3. **底層高效資料結構**  
   Redis 運用雜湊表實現 O(1) 鍵值查詢、鏈結串列處理列表操作、跳躍串列維護有序集合。這些結構針對記憶體操作優化，最小化記憶體使用並最大化速度。影片很可能包含圖表或範例，例如雜湊表如何實現快速鍵值操作，這是系統設計面試的常見主題。

   | 資料結構             | 應用場景                                     | 時間複雜度       |
   |----------------------|----------------------------------------------|------------------|
   | 雜湊表               | 鍵值儲存                                    | O(1) 平均        |
   | 鏈結串列             | 列表操作，兩端操作高效                      | O(1) 於兩端      |
   | 跳躍串列             | 有序集合，排序儲存                          | O(log n)         |

   此優化至關重要，因多數 Redis 操作基於記憶體，瓶頸通常出現於記憶體或網路頻寬，而非 CPU 運算。

#### 其他考量與演進
雖然核心請求處理維持單線程，但近期 Redis 版本已針對特定任務引入多線程技術。自 Redis 4.0 起實作非同步記憶體釋放（lazy-free），6.0 版後更在高併發情境下為協定解析加入多線程支援。這些改進很可能在影片中提及，它們在保持主操作單線程模型不變的前提下強化了效能表現。

為突破單實例限制，Redis 支援集群模式與多實例運行策略，這在討論因應高併發需求時可能被提及。此面向對於系統設計至關重要，符合該頻道對大型系統架構的關注焦點。

#### 潛在缺點與比較
單線程模型具備無鎖競爭與簡化除錯等優勢，但在高負載下可能面臨阻塞操作與記憶體/網路瓶頸的挑戰。相關文章指出，對於 CPU 密集型任務，多線程資料庫可能表現更佳，但在 Redis 的典型應用場景中，單線程設計仍是最佳選擇。

#### 結論
ByteByteGo 的影片《系統設計：為何單線程的 Redis 如此快速？》很可能涵蓋記憶體儲存、I/O 多工處理及高效資料結構作為 Redis 高速效能的關鍵成因。這些要素使其能處理高 QPS，且近期版本透過針對性多線程強化效能。本分析提供全面理解框架，適合技術學習者與系統設計專業人士參考。

---

### 主要參考文獻
- [Why is redis so fast blog post](https://blog.bytebytego.com/p/why-is-redis-so-fast)
- [Why is Redis So Fast Despite Being Single-Threaded article](https://medium.com/@aditimishra_541/why-is-redis-so-fast-despite-being-single-threaded-dc06ba33fc75)
- [Interview on Redis thread model article](https://medium.com/javarevisited/interview-why-is-redis-so-fast-even-though-it-is-single-threaded-bfe663dabe08)
- [Why is single threaded Redis so fast article](https://www.pixelstech.net/article/1677580861-Why-is-single-threaded-Redis-so-fast)