---
lang: hant
layout: post
title: Web编程入门
---

上期我们讲述了如何将斐波那契数列功能改写成面向对象的版本，并实现了一个终端接口。

`server.py`：

```python
class 基礎處理器:
  def 處理(self, 請求:str):
    pass
```

class Server:
  def __init__(self, handlerClass):
    self.handlerClass = handlerClass

```python
  def run(self):    
    while True:
      request = input()
      self.handlerClass().handle(request)
```

翻譯成繁體中文：

```python
  def run(self):    
    while True:
      request = input()
      self.handlerClass().handle(request)
```

這段程式碼的功能是持續運行，等待用戶輸入請求，然後使用 `handlerClass` 的實例來處理該請求。

`fib_handle.py`：

```python
from fib import f
from server import BaseHandler, Server
```

翻譯成繁體中文：

```python
從 fib 導入 f
從 server 導入 BaseHandler, Server
```

class FibHandler(BaseHandler):
  def handle(self, request:str):
    n = int(request)
    print('f(n)=', f(n))
    pass

```python
server = Server(FibHandler)
server.run()
```
## 简易 Web 服务器

那如何改成`Web`接口呢？

我们把上面的`Server`换成`HTTP协议`的`Server`就行了。先来看看Python中的`HTTP服务器`是怎样的。

Python 的标准库中包含了一个网页服务器。

```
python -m http.server
```

（此命令用于启动一个简单的HTTP服务器，通常在当前目录下提供文件服务。在命令行中运行此命令后，可以通过浏览器访问 `http://localhost:8000` 来查看当前目录下的文件列表。）

在終端中運行它。

```shell
$ python -m http.server
正在 :: 端口 8000 上提供 HTTP 服務 (http://[::]:8000/) ...
```

在瀏覽器中打開即可看到效果。

<img src="/assets/images/web/webserver.png" alt="網頁伺服器" style="zoom:50%;" />

这把当前目录列举出来了。接着当浏览这个网页时，再回去看终端。这会，很有意思。

```shell
$ python -m http.server
正在提供 HTTP 服務於 :: 端口 8000 (http://[::]:8000/) ...
::1 - - [07/Mar/2021 15:30:35] "GET / HTTP/1.1" 200 -
::1 - - [07/Mar/2021 15:30:35] 代碼 404, 訊息 文件未找到
::1 - - [07/Mar/2021 15:30:35] "GET /favicon.ico HTTP/1.1" 404 -
::1 - - [07/Mar/2021 15:30:35] 代碼 404, 訊息 文件未找到
::1 - - [07/Mar/2021 15:30:35] "GET /apple-touch-icon-precomposed.png HTTP/1.1" 404 -
::1 - - [07/Mar/2021 15:30:35] 代碼 404, 訊息 文件未找到
::1 - - [07/Mar/2021 15:30:35] "GET /apple-touch-icon.png HTTP/1.1" 404 -
::1 - - [07/Mar/2021 15:30:38] "GET / HTTP/1.1" 200 -
```

這是網頁訪問日誌。其中`GET`表示網頁服務的一種數據訪問操作。`HTTP/1.1`表示使用了`HTTP`的`1.1`版本的協議。

如何利用它来构建我们的斐波那契数列服务。首先，在网上寻找一些示例代码，稍作修改，编写一个最简单的Web服务器：

```python
from http.server import SimpleHTTPRequestHandler, HTTPServer
```

class Handler(SimpleHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.send_header('Content-type', 'text')
        self.end_headers()
        self.wfile.write(bytes("你好", "utf-8"))

server = HTTPServer(("127.0.0.1", 8000), Handler)

```python
server.serve_forever()
```

這些是不是很眼熟？幾乎跟上面我們使用`Server`是一樣的。注意到`SimpleHTTPRequestHandler`不是基礎類，還有一個叫`BaseHTTPRequestHandler`。`SimpleHTTPRequestHandler`相對於多處理了一些內容。這些加上斐波那契數列處理功能是容易的。

这里的`127.0.0.1`代表本机的地址，而`8000`则是本机的端口。端口可以这样理解：它就像家中的一个窗户，是家庭与外界交流的一个通道。`bytes`意味着将字符串转换为字节。`utf-8`是一种字符串编码方式。`send_response`、`send_header`和`end_headers`这些函数都在输出一些内容，以符合`HTTP`协议的规定，使得浏览器能够理解这些信息。因此，我们在网页中看到了`hi`。

<img src="/assets/images/web/hi.png" alt="嗨" style="zoom:50%;" />

接着尝试从请求中获取参数。

```python
from http.server import SimpleHTTPRequestHandler, HTTPServer
from fib import f
from urllib.parse import urlparse, parse_qs
```

```python
class Handler(SimpleHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.send_header('Content-type', 'text')      
        self.end_headers()
        parsed = urlparse(self.path)
        qs = parse_qs(parsed.query)      
        result = ""
        if len(qs) > 0:
            ns = qs[0]
            if len(ns) > 0:          
                n = int(ns)
                result = str(f(n))
        self.wfile.write(bytes(result, "utf-8"))
```

```python
class 處理程序(SimpleHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.send_header('Content-type', 'text')      
        self.end_headers()
        parsed = urlparse(self.path)
        qs = parse_qs(parsed.query)      
        result = ""
        if len(qs) > 0:
            ns = qs[0]
            if len(ns) > 0:          
                n = int(ns)
                result = str(f(n))
        self.wfile.write(bytes(result, "utf-8"))
```

server = HTTPServer(("127.0.0.1", 8000), Handler)

```python
server.serve_forever()
```

<img src="/assets/images/web/n10.png" alt="n10" style="zoom:50%;" />

有点复杂吧。这里就是在解析一些参数。

```shell
self.path=/?n=3
parsed=ParseResult(scheme='', netloc='', path='/', params='', query='n=3', fragment='')
qs={'n': ['3']}
ns=['3']
n=3
```

翻譯如下：

```shell
self.path=/?n=3
parsed=解析結果(scheme='', netloc='', path='/', params='', query='n=3', fragment='')
qs={'n': ['3']}
ns=['3']
n=3
```

在這個翻譯中，我保留了程式碼的結構和變數名稱，因為這些通常是國際通用的。我將 `ParseResult` 翻譯為「解析結果」，這是一個常見的技術術語翻譯。其他部分如 `scheme`, `netloc`, `path`, `params`, `query`, `fragment` 等通常不需要翻譯，因為它們是程式設計中的標準術語。

## 递归进阶

让我们稍微重构一下代码。

```python
from http.server import SimpleHTTPRequestHandler, HTTPServer
from fib import f
from urllib.parse import urlparse, parse_qs
```

类 处理器(简单HTTP请求处理器):

```python
    def parse_n(self, s):
      parsed = urlparse(s)
      qs = parse_qs(parsed.query)
      if len(qs) > 0:
        ns = qs['n']
        if len(ns) > 0:
          n = int(ns[0])
          return n
      return None
      
    def do_GET(self):
      self.send_response(200)
      self.send_header('Content-type', 'text')
      self.end_headers()
```

翻譯成繁體中文：

```python
    def parse_n(self, s):
      parsed = urlparse(s)
      qs = parse_qs(parsed.query)
      if len(qs) > 0:
        ns = qs['n']
        if len(ns) > 0:
          n = int(ns[0])
          return n
      return None
      
    def do_GET(self):
      self.send_response(200)
      self.send_header('Content-type', 'text')
      self.end_headers()
```

這段程式碼的功能是解析URL中的查詢參數`n`，並將其轉換為整數返回。如果沒有找到`n`參數，則返回`None`。`do_GET`方法則是用於處理HTTP GET請求，設置響應狀態碼為200，並設置內容類型為`text`。

```python
result = ""
n = self.parse_n(self.path)
if n is not None:
    result = str(f(n))
              
self.wfile.write(bytes(result, "utf-8"))
self.wfile.write(bytes(result, "utf-8"))
```

翻譯成繁體中文：

```python
result = ""
n = self.parse_n(self.path)
if n is not None:
    result = str(f(n))
              
self.wfile.write(bytes(result, "utf-8"))
self.wfile.write(bytes(result, "utf-8"))
```

這段程式碼的功能是將一個函數 `f` 應用於從路徑解析出的值 `n`，並將結果轉換為字符串後，通過 `wfile` 寫入兩次。

server = HTTPServer(("127.0.0.1", 8000), Handler)

```python
server.serve_forever()
```

引入 `parse_n` 函数，将從請求路徑中解析得到的 `n` 封裝在一起。

目前程序存在这样的问题：小王请求了斐波那契数列的第10000位，过了几天后，小明又请求了斐波那契数列的第10000位。两次请求中，小王和小明都等待了很长时间才得到结果。我们该如何提高这个`Web服务`的效率呢？

为了提高效率，可以考虑以下几种方法：

1. **缓存结果**：将已经计算过的斐波那契数列的结果缓存起来。当有新的请求时，首先检查缓存中是否已经存在该结果。如果存在，则直接返回缓存中的结果，避免重复计算。

2. **预计算**：如果知道某些斐波那契数列的值会被频繁请求，可以提前计算并存储这些值。这样在请求到来时，可以直接返回预计算的结果。

3. **优化算法**：使用更高效的算法来计算斐波那契数列。例如，使用矩阵快速幂算法或动态规划算法，这些算法可以显著减少计算时间。

4. **并行计算**：如果计算斐波那契数列的过程可以并行化，可以利用多核处理器或分布式计算资源来加速计算。

5. **异步处理**：将计算任务放入后台异步处理，避免阻塞主线程。这样用户可以在等待结果的同时继续使用其他功能。

通过以上方法，可以显著提高`Web服务`的效率，减少用户等待时间。

注意到如果`n`相同，`f(n)`的值总是一样的。我们进行了一番实验。

```shell
127.0.0.1 - - [10/Mar/2021 00:33:01] "GET /?n=1000 HTTP/1.1" 200 -
----------------------------------------
處理來自 ('127.0.0.1', 50783) 的請求時發生異常
回溯（最近一次調用最後）：
    ...
    if v[n] != -1:
IndexError: 列表索引超出範圍
```

原来数组不够大，那就把v数组改成10000吧。

```python
v = []
for x in range(10000):
   v.append(-1)
```

翻譯成繁體中文：

```python
v = []
for x in range(10000):
   v.append(-1)
```

這段程式碼的意思是：創建一個空列表 `v`，然後通過迴圈將數字 `-1` 添加 10000 次到這個列表中。

然而當n為`2000`時，出現了遞迴深度溢出錯誤：

```shell
127.0.0.1 - - [10/Mar/2021 00:34:00] "GET /?n=2000 HTTP/1.1" 200 -
----------------------------------------
在处理来自 ('127.0.0.1', 50821) 的请求时发生异常
回溯（最近一次调用最后）：
    ...
    if v[n] != -1:
递归错误：在比较中超过了最大递归深度
```

然而，这一切进展得相当迅速。

为什么。因为从`f(1)`到`f(1000)`，每个值只需要计算一次。这意味着在计算`f(1000)`时，`+`运算可能只执行了大约1000次。我们知道`Python`的递归深度大约在1000左右。这意味着我们可以这样优化程序：如果要计算`2000`，那我先计算`1000`。不，这样还是可能会出现`递归深度溢出错误`。如果要计算2000，先计算1200吧。如果要计算1200，先计算400吧。

这样计算完400和1200之后，再接着计算2000，递归的深度大约维持在800左右，这样就不会发生递归深度溢出的错误了。

```python
v = []
for x in range(1000000):
   v.append(-1)
```

```python
def fplus(n):
   if n > 800:         
      fplus(n-800)
      return f(n)
   else:
      return f(n)
```

```python
def f(n):
   if v[n] != -1:
      return v[n]
   else:
      a = 0
      if n < 2:
         a = n
      else:
         a = f(n-1) + f(n-2)
      v[n] = a
      return v[n]
```

增加了`fplus`函数。

然而，不禁让人思考，如果`fplus`被递归调用`1000`次会怎样。1000 * 800 = 800000。当我将n设为80万后，再次遇到了递归深度错误。进一步试探后，发现事情变得更加复杂。不过，经过这样的优化后，计算2000已经变得非常轻松了。

## 文件读写

似乎把話題岔開了。回到Web開發的話題上。第一次請求`f(400)`，第二次請求`f(600)`。那麼第二次請求時，第一次請求所產生的`v`數組的值，我們是能用上的。然而當我們把程序退出。再啟動就用不上了。按我們的方法，斐波那契數列計算是很快的。然而設想，如果很慢怎麼辦。尤其就如當我們沒有引入v數組的時候，有著大量重複的計算。這時我們希望能把好不容易得到的結果保存起來。

这时，就引入了`缓存`的概念。`v`数组在这里就是一个缓存。不过，它仅存在于程序的生命周期内。一旦程序关闭，它就会消失。那么，该如何解决这个问题呢？很自然地，我们会想到将其存储到文件中。

如何将v数组保存到文件呢。

```shell
0 0
1 1
2 1
3 2
4 3
...
```

我们的`v`数组可以这样保存。每一行保存为`n f(n)`。既然`n`是自然增长的，或许我们可以只保存`f(n)`值。

```shell
0
1
1
2
3
...
``` 

（注：此序列为斐波那契数列的开头部分，每个数字都是前两个数字之和。由于要求直接翻译，而数字本身无需翻译，故保持原样。若需继续扩展数列，下一个数字应为5，接着是8，依此类推。）

来试试看吧。

```python
f = open("demofile2.txt", "a")
f.write("現在文件有了更多內容！")
f.close()
```

# 打開並讀取追加內容後的文件：
f = open("demofile2.txt", "r")
print(f.read())
```

`open`函数的第二个参数可以是`a`，表示内容会追加到文件末尾；或者是`w`，表示会覆盖掉文件原有内容。

```python
file = open('fib_v', 'a')
file.write('hi')
file.close()
```

這段程式碼的繁體中文解釋如下：

```python
# 開啟名為 'fib_v' 的檔案，並以附加模式 ('a') 開啟
file = open('fib_v', 'a')

# 在檔案中寫入字串 'hi'
file.write('hi')

# 關閉檔案
file.close()
```

這段程式碼的作用是打開一個名為 `fib_v` 的檔案，並在檔案的末尾附加字串 `'hi'`，最後關閉檔案。如果檔案不存在，它會自動創建一個新的檔案。

運行一下，果然有文件`fib_v`。

`fib_v`：

```shell
你好
```

当我们再次运行时，结果变成了这样。

```shell
你好
```

如何換行呢？

```python
file = open('fib_v', 'a')
file.write('hi\n')
file.close()
```

這會打印一次，出現了`hihihi`，沒看見換行呢。然而再打印一次，換行了。可見第一次已經打印了換行符，只是在末尾，看不見。

如何讀取呢。

```python
file = open('fib_v', 'r')
print(file.read())
```

```shell
$ python fib.py
嗨嗨嗨
嗨
```

接下来，修改我们的斐波那契程序。

```python
v = []
for x in range(1000000):
   v.append(-1)
```

翻譯成繁體中文：

```python
v = []
for x in range(1000000):
   v.append(-1)
```

這段程式碼的意思是：創建一個空列表 `v`，然後通過一個迴圈，將數字 `-1` 添加 1,000,000 次到列表 `v` 中。

def read():
   file = open('fib_v', 'r')
   s = file.read()
   if len(s) > 0:
      lines = s.split('\n')
      if (len(lines) > 0):
        for i in range(len(lines)):
           v[i] = int(lines[i])

翻譯成繁體中文：

```python
def read():
   file = open('fib_v', 'r')
   s = file.read()
   if len(s) > 0:
      lines = s.split('\n')
      if (len(lines) > 0):
        for i in range(len(lines)):
           v[i] = int(lines[i])
```

這段程式碼的功能是讀取一個名為 `fib_v` 的檔案，並將其內容轉換為整數後存儲在列表 `v` 中。

```python
def save():
    file = open('fib_v', 'w')
    s = ''
    start = True
    for vv in v:
        if vv == -1:
            break      
        if start == False:
            s += '\n'
        start = False   
        s += str(vv)
    file.write(s)
    file.close()
```

def fcache(n):
   x = fplus(n)
   save()
   return x

翻譯成繁體中文：

def fcache(n):
   x = fplus(n)
   save()
   return x

（注：此代码为Python函数定义，其功能与语言无关，因此直接保留原样。）

```python
def fplus(n):
   if n > 800:         
      fplus(n-800)
      return f(n)
   else:
      return f(n)
```

翻譯成繁體中文：

```python
def fplus(n):
   if n > 800:         
      fplus(n-800)
      return f(n)
   else:
      return f(n)
```

這段程式碼的功能是：如果 `n` 大於 800，則遞迴呼叫 `fplus(n-800)`，然後返回 `f(n)` 的值；否則，直接返回 `f(n)` 的值。

def f(n):
   if v[n] != -1:
      return v[n]
   else:
      a = 0
      if n < 2:
         a = n
      else:
         a = f(n-1) + f(n-2)
      v[n] = a
      return v[n]

```plaintext
讀取()
快取(10)
儲存()
```

终于，我们完成了程序的编写。程序运行后，`fib_v`文件的内容如下。

`fib_v`：

```shell
0
1
1
2
3
5
8
13
21
34
55
```

看到上面的解析有点麻烦。`\n`是换行符。有没有更简单统一的解析方式呢？于是，人们发明了`JSON`这种数据格式。

## JSON

JSON的全名是`JavaScript Object Notation`。以下是`JSON`的例子。

```json
{"name":"約翰", "age":31, "city":"紐約"}
```

以上这样来表示一种映射。

JSON具有以下基本元素：

1. 數字或字串
2. 列表
3. 映射

这些基本元素还可以任意嵌套。也就是说，列表中可以包含列表，映射中也可以包含列表，以此类推。

```json
{
  "name":"約翰",
  "age":30,
  "cars":[ "福特", "寶馬", "飛雅特" ]
}
```

写成一行，和这样写得好看点，在意义上是有差别的。或许我们可以想象它们的计算图。空格不会影响它们的计算图。

接着我们要把v数组转换成`json`格式的字符串。

```python
import json
```

v = []
for x in range(1000000):
   v.append(-1)

```python
def fplus(n):
   if n > 800:         
      fplus(n-800)
      return f(n)
   else:
      return f(n)
```

翻譯成繁體中文：

```python
def fplus(n):
   if n > 800:         
      fplus(n-800)
      return f(n)
   else:
      return f(n)
```

這段程式碼的功能是：如果 `n` 大於 800，則遞迴呼叫 `fplus(n-800)`，然後返回 `f(n)` 的值；否則，直接返回 `f(n)` 的值。

def f(n):
   if v[n] != -1:
      return v[n]
   else:
      a = 0
      if n < 2:
         a = n
      else:
         a = f(n-1) + f(n-2)
      v[n] = a
      return v[n]

```python
fplus(100)
s = json.dumps(v)
file = open('fib_j', 'w')
file.write(s)
file.close()
```

這段代碼的功能是將變量 `v` 轉換為 JSON 格式的字符串，然後將其寫入名為 `fib_j` 的文件中。以下是代碼的解釋：

1. `fplus(100)`：這行代碼調用了函數 `fplus` 並傳入參數 `100`。具體功能取決於 `fplus` 函數的實現。

2. `s = json.dumps(v)`：這行代碼將變量 `v` 轉換為 JSON 格式的字符串，並將結果賦值給變量 `s`。`json.dumps` 是 Python 中將 Python 對象轉換為 JSON 字符串的函數。

3. `file = open('fib_j', 'w')`：這行代碼以寫入模式（`'w'`）打開名為 `fib_j` 的文件，並將文件對象賦值給變量 `file`。如果文件不存在，它將被創建；如果文件已存在，它將被覆蓋。

4. `file.write(s)`：這行代碼將 JSON 字符串 `s` 寫入到文件中。

5. `file.close()`：這行代碼關閉文件，確保所有數據都已寫入並釋放系統資源。

這段代碼的整體作用是將變量 `v` 的內容以 JSON 格式保存到文件 `fib_j` 中。

当我们这样写的时候，出现了错误：`TypeError: dump() missing 1 required positional argument: 'fp'`。在`VSCode`上，你可以通过以下方式来查看函数的定义。

![json](assets/images/web/json.png)

只需將鼠標移動到`dump`上即可。很方便吧。

```python
fplus(10)
file = open('fib_j', 'w')
json.dump(v, file)
file.close()
```

翻譯成繁體中文：

```python
fplus(10)
file = open('fib_j', 'w')
json.dump(v, file)
file.close()
```

這段程式碼的功能是將變數 `v` 的內容以 JSON 格式寫入名為 `fib_j` 的檔案中。

计算到100显示的数字有点多，這裡改為10。原來dump的第二個參數傳入`file`對象即可。

這樣可以看到文件：

```json
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, -1, -1, -1]
``` 

（该序列为斐波那契数列的一部分，后接三个-1，可能表示序列的结束或无效值。）

注意後面省略了很多`-1`。

```python
def read():
    # 打開名為 'fib_j' 的文件進行讀取
    file = open('fib_j', 'r')
    # 讀取文件內容
    s = file.read()
    # 將讀取的字符串轉換為 JSON 對象
    sv = json.loads(s)
    # 遍歷 JSON 對象中的每個元素
    for i in range(len(sv)):
        # 如果元素值不等於 -1，則將其賦值給 v 列表中的相應位置
        if sv[i] != -1:
            v[i] = sv[i]
def save():
    # 打開名為 'fib_j' 的文件進行寫入
    file = open('fib_j', 'w')
    # 將 v 列表轉換為 JSON 格式並寫入文件
    json.dump(v, file)
    # 關閉文件
    file.close()
```

读取()

```python
for vv in v:
    if vv != -1:
        print(vv)
```

當這樣時，可見打印出了：

```shell
0
1
1
2
3
5
8
13
21
34
55
```

这几个函数一起检查一下：

1. **函数A**：负责数据的输入验证。
2. **函数B**：处理数据的逻辑运算。
3. **函数C**：将处理后的数据存储到数据库中。
4. **函数D**：生成报告并输出结果。

请确保每个函数的功能正确无误，并且它们之间的数据传递和依赖关系也正确无误。

```python
def read():
    # 打开名为'fib_j'的文件，模式为读取
    file = open('fib_j', 'r')
    # 读取文件内容到字符串s
    s = file.read()
    # 将字符串s解析为JSON格式的数据，存储在sv中
    sv = json.loads(s)
    # 遍历sv中的每个元素
    for i in range(len(sv)):
        # 将sv中的每个元素赋值给v的对应位置
        v[i] = sv[i]
```

def save():
    sv = []
    for i in range(len(v)):
        if v[i] != -1:
            sv.append(v[i])
        else:
            break        
    file = open('fib_j', 'w')
    json.dump(sv, file)
    file.close()

# 翻译为中文

def 保存():
    保存值 = []
    对于 范围(len(数列)) 中的 i:
        如果 数列[i] != -1:
            保存值.append(数列[i])
        否则:
            跳出循环        
    文件 = 打开('fib_j', 'w')
    json.转储(保存值, 文件)
    文件.关闭()

```plaintext
讀取()
加100()
保存()
```

然后到文件查看，果然保存了正确的值，而且排列得很整齐。

```json
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073, 4807526976, 7778742049, 12586269025, 20365011074, 32951280099, 53316291173, 86267571272, 139583862445, 225851433717, 365435296162, 591286729879, 956722026041, 1548008755920, 2504730781961, 4052739537881, 6557470319842, 10610209857723, 17167680177565, 27777890035288, 44945570212853, 72723460248141, 117669030460994, 190392490709135, 308061521170129, 498454011879264, 806515533049393, 1304969544928657, 2111485077978050, 3416454622906707, 5527939700884757, 8944394323791464, 14472334024676221, 23416728348467685, 37889062373143906, 61305790721611591, 99194853094755497, 160500643816367088, 259695496911122585, 420196140727489673, 679891637638612258, 1100087778366101931, 1779979416004714189, 2880067194370816120, 4660046610375530309, 7540113804746346429, 12200160415121876738, 19740274219868223167, 31940434634990099905, 51680708854858323072, 83621143489848422977, 135301852344706746049, 218922995834555169026, 354224848179261915075]
```

## 数据库

如果数据量庞大且结构复杂，采用文件保存的方式会变得既缓慢又繁琐。这时，`数据库`的概念便应运而生。它相当于一个可编程的`Excel`表格，能够通过代码轻松实现数据的增加、删除、修改和查询操作，极大地提升了数据管理的效率和灵活性。

在官方文件找到範例。

```python
import sqlite3
con = sqlite3.connect('example.db')
``` 

這段程式碼的繁體中文翻譯如下：

```python
import sqlite3
con = sqlite3.connect('example.db')
```

這段程式碼的功能是導入 `sqlite3` 模組，並連接到名為 `example.db` 的 SQLite 資料庫。

```python
cur = con.cursor()
```

# 創建表格
cur.execute('''CREATE TABLE stocks
               (日期 text, 交易類型 text, 股票代號 text, 數量 real, 價格 real)''')

# 插入一行數據
cur.execute("INSERT INTO stocks VALUES ('2006-01-05','BUY','RHAT',100,35.14)")

# 保存（提交）更改
con.commit()

# 如果我们完成了操作，也可以关闭连接。
# 只需确保所有更改都已提交，否则它们将会丢失。
con.close()
```

```python
for row in cur.execute('SELECT * FROM stocks ORDER BY price'):
        print(row)
```

翻譯成繁體中文：

```python
for row in cur.execute('SELECT * FROM stocks ORDER BY price'):
        print(row)
```

這段程式碼的意思是：從 `stocks` 表中選取所有資料，並按照 `price` 欄位進行排序，然後逐行印出每一筆資料。

`cursor` 表示游標，就像光標一樣。上面是連接數據庫、建立表格、插入數據、提交更改、關閉連接的意思。最後面的例子則是查詢數據的一個示例。

```python
import sqlite3
```

v = []
for x in range(1000000):
   v.append(-1)

def create_table(cur: sqlite3.Connection):
    cur.execute('CREATE TABLE vs(v text)')

def 读取():
    pass

```python
def save():
    con = sqlite3.connect('fib.db')
    cur = con.cursor()
    create_table(cur)
    for vv in v:
        if vv != -1:
            cur.execute('INSERT INTO vs VALUES(' + str(vv) + ')')
        else:
            break
    con.commit()
    con.close()
```

將上述程式碼翻譯成繁體中文如下：

```python
def 儲存():
    con = sqlite3.connect('fib.db')
    cur = con.cursor()
    建立表格(cur)
    for vv in v:
        if vv != -1:
            cur.execute('INSERT INTO vs VALUES(' + str(vv) + ')')
        else:
            break
    con.commit()
    con.close()
```

在這個翻譯中，我將函數名稱 `save` 翻譯為 `儲存`，並將 `create_table` 翻譯為 `建立表格`，以符合繁體中文的語境。其他部分保持不變，因為它們是程式碼的結構和邏輯部分，不需要翻譯。

fplus(10)
保存()
```

寫好了。試試看。

我電腦上已經有`sqlite3`了。

```shell
$ sqlite3
SQLite 版本 3.32.3 2020-06-18 14:16:19
輸入 ".help" 以獲取使用提示。
已連接到一個臨時的內存數據庫。
使用 ".open 文件名" 重新打開一個持久數據庫。
```

```sqlite
sqlite> .help
.auth ON|OFF             顯示授權回調
.backup ?DB? FILE        備份DB（默認為"main"）到FILE
.bail on|off             遇到錯誤後停止。默認OFF
.binary on|off           開啟或關閉二進制輸出。默認OFF
.cd DIRECTORY            更改工作目錄到DIRECTORY
.changes on|off          顯示SQL更改的行數
.check GLOB              如果自.testcase以來的輸出不匹配，則失敗
.clone NEWDB             從現有數據庫克隆數據到NEWDB
.databases               列出附加數據庫的名稱和文件
.dbconfig ?op? ?val?     列出或更改sqlite3_db_config()選項
.dbinfo ?DB?             顯示數據庫的狀態信息
.dump ?TABLE?            將數據庫內容呈現為SQL
.echo on|off             開啟或關閉命令回顯
.eqp on|off|full|...     啟用或禁用自動EXPLAIN QUERY PLAN
.excel                   將下一個命令的輸出顯示在電子表格中
.exit ?CODE?             以返回碼CODE退出程序
.expert                  實驗性功能。為查詢建議索引
.explain ?on|off|auto?   更改EXPLAIN格式化模式。默認：auto
.filectrl CMD ...        運行各種sqlite3_file_control()操作
.fullschema ?--indent?   顯示模式和sqlite_stat表的內容
.headers on|off          開啟或關閉標題顯示
.help ?-all? ?PATTERN?   顯示PATTERN的幫助文本
.import FILE TABLE       從FILE導入數據到TABLE
.imposter INDEX TABLE    在索引INDEX上創建偽裝表TABLE
.indexes ?TABLE?         顯示索引的名稱
.limit ?LIMIT? ?VAL?     顯示或更改SQLITE_LIMIT的值
.lint OPTIONS            報告潛在的模式問題
.log FILE|off            開啟或關閉日誌記錄。FILE可以是stderr/stdout
.mode MODE ?TABLE?       設置輸出模式
.nullvalue STRING        使用STRING代替NULL值
.once ?OPTIONS? ?FILE?   僅將下一個SQL命令的輸出發送到FILE
.open ?OPTIONS? ?FILE?   關閉現有數據庫並重新打開FILE
.output ?FILE?           將輸出發送到FILE或stdout（如果省略FILE）
.parameter CMD ...       管理SQL參數綁定
.print STRING...         打印字面量STRING
.progress N              每N個操作碼後調用進度處理程序
.prompt MAIN CONTINUE    替換標準提示
.quit                    退出此程序
.read FILE               從FILE讀取輸入
.recover                 從損壞的數據庫中恢復盡可能多的數據
.restore ?DB? FILE       從FILE恢復DB（默認為"main"）的內容
.save FILE               將內存數據庫寫入FILE
.scanstats on|off        開啟或關閉sqlite3_stmt_scanstatus()指標
.schema ?PATTERN?        顯示匹配PATTERN的CREATE語句
.selftest ?OPTIONS?      運行SELFTEST表中定義的測試
.separator COL ?ROW?     更改列和行的分隔符
.session ?NAME? CMD ...  創建或控制會話
.sha3sum ...             計算數據庫內容的SHA3哈希
.shell CMD ARGS...       在系統shell中運行CMD ARGS...
.show                    顯示各種設置的當前值
.stats ?on|off?          顯示統計信息或開啟/關閉統計信息
.system CMD ARGS...      在系統shell中運行CMD ARGS...
.tables ?TABLE?          列出匹配LIKE模式TABLE的表名
.testcase NAME           開始將輸出重定向到'testcase-out.txt'
.testctrl CMD ...        運行各種sqlite3_test_control()操作
.timeout MS              嘗試打開鎖定的表MS毫秒
.timer on|off            開啟或關閉SQL計時器
.trace ?OPTIONS?         在運行時輸出每個SQL語句
.vfsinfo ?AUX?           有關頂層VFS的信息
.vfslist                 列出所有可用的VFS
.vfsname ?AUX?           打印VFS堆棧的名稱
.width NUM1 NUM2 ...     設置"column"模式的列寬
```

可以看到有很多的命令。其中`.quit`表示退出。

如果没有的话，可以前往官网下载，或者运行`brew install sqlite`命令来安装。

```shell
$ sqlite3 fib.db
```

```sqlite
sqlite> 显示表格
   ...> ;
错误：在“显示”附近：语法错误
sqlite> 表格;
错误：在“表格”附近：语法错误
sqlite> .schema
CREATE TABLE vs(v 文本);
```

一开始我以为像`MySQL`一样，可以用`show tables`来查看有哪些表。后来发现`SQLite`的操作方式不同。`MySQL`是另一种数据库，也是我们未来要学习的。

```sqlite
sqlite> select * from vs;
0
1
1
2
3
5
8
13
21
34
55
```

果然，我们正确写入了数据。注意我们使用的是`text`类型，因为我们的数字很大，可能数据库的整数类型无法保存。

```python
import sqlite3
```

v = []
for x in range(1000000):
   v.append(-1)

```python
def fplus(n):
   if n > 800:         
      fplus(n-800)
      return f(n)
   else:
      return f(n)
```

翻譯成繁體中文：

```python
def fplus(n):
   if n > 800:         
      fplus(n-800)
      return f(n)
   else:
      return f(n)
```

這段程式碼的功能是：如果 `n` 大於 800，則遞迴調用 `fplus(n-800)`，然後返回 `f(n)` 的值；否則，直接返回 `f(n)` 的值。

def f(n):
   if v[n] != -1:
      return v[n]
   else:
      a = 0
      if n < 2:
         a = n
      else:
         a = f(n-1) + f(n-2)
      v[n] = a
      return v[n]

def create_table(cur: sqlite3.Connection):
    cur.execute('CREATE TABLE vs(v text)')

def read():
    con = sqlite3.connect('fib.db')
    cur = con.cursor()    
    create_table(cur)
    i = 0
    for row in cur.execute('SELECT * from vs'):
         v[i] = int(row)
    con.close()

翻譯成繁體中文：

```python
def read():
    con = sqlite3.connect('fib.db')
    cur = con.cursor()    
    create_table(cur)
    i = 0
    for row in cur.execute('SELECT * from vs'):
         v[i] = int(row)
    con.close()
```

在這個函數中，我們首先連接到名為 `fib.db` 的 SQLite 資料庫，然後創建一個游標對象。接著，我們調用 `create_table` 函數來創建表格（如果尚未存在）。然後，我們遍歷 `vs` 表中的每一行，並將其轉換為整數後存儲在數組 `v` 中。最後，我們關閉資料庫連接。

def save():
    con = sqlite3.connect('fib.db')
    cur = con.cursor()
    create_table(cur)
    for vv in v:
        if vv != -1:
            cur.execute('INSERT INTO vs VALUES(' + str(vv) + ')')
        else:
            break
    con.commit()
    con.close()

```python
read()
for i in range(10):
    print(v[i])
```

我们继续添加`read`函数。然而，运行后出现了错误。

```python
$ python fib_db.py
  ...
  文件 "fib_db.py", 第 27 行, 在 create_table 函数中
    cur.execute('CREATE TABLE vs(v text)')
sqlite3.OperationalError: 表 vs 已经存在
```

我们无法再创建表，因为该表已经存在。请稍微调整一下语法。

```python
def create_table(cur: sqlite3.Connection):
    cur.execute('CREATE TABLE IF NOT EXISTS vs(v text)')
```

翻譯成繁體中文：

```python
def create_table(cur: sqlite3.Connection):
    cur.execute('CREATE TABLE IF NOT EXISTS vs(v text)')
```

這段程式碼的功能是創建一個名為 `vs` 的表格，如果該表格尚未存在的話。表格中有一個名為 `v` 的欄位，其資料類型為文字（`text`）。

然而出現了錯誤。

```shell
    v[i] = int(row)
TypeError: int() 參數必須是字符串、字節類對象或數字，而不是 'tuple'
```

`tuple` 是什么。意思是 `row` 返回了 `tuple`。让我们打印一下。

```python
    for row in cur.execute('SELECT * from vs'):
        print(row)
        v[i] = int(row)
```

翻譯成繁體中文：

```python
    for row in cur.execute('SELECT * from vs'):
        print(row)
        v[i] = int(row)
```

這段程式碼的功能是從資料庫中選取所有資料，並將每一行的資料轉換為整數後存儲在陣列 `v` 中。

結果為：

```shell
('0',)
```

其實`tuple`和數組差不多。只不過它的元素可以是彼此不一樣的，不像數組裡的元素都得是同一類型。

```python
def read():
    con = sqlite3.connect('fib.db')
    cur = con.cursor()    
    create_table(cur)
    i = 0
    for row in cur.execute('SELECT * from vs'):
        v[i] = int(row[0])
    con.close()
```

這段程式碼的功能是從名為 `fib.db` 的 SQLite 資料庫中讀取數據，並將其存儲在一個名為 `v` 的陣列中。以下是程式碼的逐步解釋：

1. **連接資料庫**：使用 `sqlite3.connect('fib.db')` 連接到名為 `fib.db` 的 SQLite 資料庫，並將連接對象存儲在變數 `con` 中。

2. **創建游標**：通過 `con.cursor()` 創建一個游標對象 `cur`，用於執行 SQL 語句。

3. **創建表格**：調用 `create_table(cur)` 函數來創建表格（假設這個函數已經定義）。

4. **讀取數據**：使用 `cur.execute('SELECT * from vs')` 執行 SQL 查詢，從名為 `vs` 的表格中選取所有數據。然後，遍歷查詢結果的每一行，將每一行的第一個值轉換為整數並存儲在陣列 `v` 中。

5. **關閉連接**：最後，使用 `con.close()` 關閉資料庫連接。

這段程式碼的主要目的是從資料庫中讀取數據並將其存儲在陣列中，以便後續處理。

這麼改。然而很奇怪。輸出是這樣：

```shell
55
-1
-1
-1
-1
-1
-1
-1
-1
-1
```

原来是我们的`i`没有自增。

```python
    for row in cur.execute('SELECT * from vs'):
        v[i] = int(row[0])
        i += 1
```

這段程式碼的繁體中文解釋如下：

```python
    # 遍歷執行 SQL 查詢 'SELECT * from vs' 所得到的每一行結果
    for row in cur.execute('SELECT * from vs'):
        # 將每一行的第一個欄位轉換為整數，並存入陣列 v 的第 i 個位置
        v[i] = int(row[0])
        # 將索引 i 加 1，以便處理下一行數據
        i += 1
```

這樣就對了。

```shell
0
1
1
2
3
5
8
13
21
34
```

然而我们注意到，当数字很大时，在数据库中保存的形态是这样的：

```shell
4660046610375530309
7540113804746346429
1.22001604151219e+19
1.97402742198682e+19
3.19404346349901e+19
```

這些數字在繁體中文中保持不變，因為它們是數值數據，不涉及語言轉換。如果需要將這些數字轉換為中文的讀法，可以這樣表示：

```shell
4660046610375530309
7540113804746346429
1.22001604151219e+19 （即 12,200,160,415,121,900,000）
1.97402742198682e+19 （即 19,740,274,219,868,200,000）
3.19404346349901e+19 （即 31,940,434,634,990,100,000）
```

請注意，科學記數法中的數字已經轉換為完整的數字形式，以便更清晰地理解其大小。

再次运行后，结果如下。

```shell
$ python fib_db.py
回溯（最近一次调用最后）：
  文件 "fib_db.py"，第 35 行，在 read 函数中
    v[i] = int(row[0])
ValueError: 无效的整数字面量，基数为 10：'1.22001604151219e+19'
```

修改为：

```python
cur.execute("INSERT INTO vs VALUES('" + str(vv) + "')")
``` 

這段程式碼的作用是將變數 `vv` 的值插入到名為 `vs` 的資料表（table）中。具體來說，它使用了 SQL 的 `INSERT INTO` 語句來將 `vv` 的值作為一個新的記錄插入到 `vs` 表中。

### 注意：
1. 這種直接拼接字串的方式容易受到 SQL 注入攻擊（SQL Injection），建議使用參數化查詢來避免安全風險。
2. 如果 `vv` 的值包含單引號（'），可能會導致 SQL 語句錯誤。

### 改進建議：
使用參數化查詢來提高安全性：

```python
cur.execute("INSERT INTO vs VALUES(?)", (str(vv),))
```

這樣可以避免 SQL 注入問題，並且更安全地處理輸入值。

原來注意到這裡我們把`INSERT`語句兩邊的單引號改成了雙引號，同時給我們的數字字符串加了引號。如果之前這樣寫，數據庫把我們的字符串當成了數字，而如今，這樣用引號括起來，則表示是字符串。

然後就正確了。然而如何把之前的錯誤數據清空掉。

```sqlite
$ sqlite3 fib.db
SQLite 版本 3.32.3 2020-06-18 14:16:19
输入 ".help" 获取使用提示。
sqlite> delete * from vs;
```

接下來可以試試其他語句。`增刪改查`。我們這裡舉了`增刪查`的例子。

## 练习

* 学生像上面这样类似地探索一遍。