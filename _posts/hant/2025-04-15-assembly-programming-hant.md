---
audio: false
generated: true
lang: hant
layout: post
title: 組合語言編程
translated: true
type: note
---

以下是**第二部分：組合語言程式設計**的全面教學，涵蓋以下主題：*8086指令集（資料傳輸、算術、邏輯及控制流程指令）、組合語言程式設計（順序、分支及迴圈結構）以及中斷服務程式*。本教學建立在微電腦基礎知識（例如8086/8088架構）之上，假設已具備CPU暫存器與記憶體定址的基本概念，內容詳盡、易於理解且實用性強。

---

## 第二部分：組合語言程式設計

組合語言是一種低階程式設計語言，能直接控制微處理器的操作。對於Intel 8086/8088而言，組合語言讓程式設計師能夠撰寫與機器碼緊密對應的指令，從而對暫存器、記憶體及I/O裝置等硬體資源進行細粒度控制。

### 1. 8086指令集

8086指令集是CPU能理解的一組命令，按其功能可分為：**資料傳輸**、**算術**、**邏輯**及**控制流程**。每條指令皆對暫存器、記憶體或立即值進行操作，並使用8086的定址模式（例如暫存器定址、直接定址、間接定址）。

#### a. 資料傳輸指令
這些指令用於在暫存器、記憶體及立即值之間移動資料。

- **MOV（移動）**：
  - 語法：`MOV 目標, 來源`
  - 功能：將資料從來源複製到目標。
  - 範例：`MOV AX, BX`（將BX複製到AX）；`MOV AX, [1234h]`（將記憶體位址DS:1234h的資料複製到AX）。
  - 注意：不影響旗標；來源與目標必須大小相同（8位元或16位元）。
- **XCHG（交換）**：
  - 語法：`XCHG 目標, 來源`
  - 功能：交換來源與目標的內容。
  - 範例：`XCHG AX, BX`（交換AX與BX）。
- **PUSH（推入堆疊）**：
  - 語法：`PUSH 來源`
  - 功能：將16位元資料推入堆疊，SP減2。
  - 範例：`PUSH AX`（將AX儲存至堆疊）。
- **POP（從堆疊彈出）**：
  - 語法：`POP 目標`
  - 功能：從堆疊彈出16位元資料至目標，SP加2。
  - 範例：`POP BX`（從堆疊恢復BX）。
- **LEA（載入有效位址）**：
  - 語法：`LEA 目標, 來源`
  - 功能：將記憶體運算元的位址載入暫存器。
  - 範例：`LEA BX, [SI+4]`（將DS:SI+4的位址載入BX）。
- **IN/OUT**：
  - 語法：`IN 目標, 埠`；`OUT 埠, 來源`
  - 功能：與I/O埠之間傳輸資料。
  - 範例：`IN AL, 60h`（讀取鍵盤埠）；`OUT 61h, AL`（寫入揚聲器埠）。

#### b. 算術指令
這些指令執行數學運算，並根據結果更新旗標（例如ZF、CF、SF、OF）。

- **ADD（加法）**：
  - 語法：`ADD 目標, 來源`
  - 功能：將來源加到目標，結果儲存於目標。
  - 範例：`ADD AX, BX`（AX = AX + BX）。
- **SUB（減法）**：
  - 語法：`SUB 目標, 來源`
  - 功能：從目標減去來源。
  - 範例：`SUB CX, 10`（CX = CX - 10）。
- **INC（遞增）**：
  - 語法：`INC 目標`
  - 功能：將目標加1。
  - 範例：`INC BX`（BX = BX + 1）。
- **DEC（遞減）**：
  - 語法：`DEC 目標`
  - 功能：將目標減1。
  - 範例：`DEC CX`（CX = CX - 1）。
- **MUL（乘法，無符號）**：
  - 語法：`MUL 來源`
  - 功能：將AL（8位元）或AX（16位元）乘以來源，結果儲存於AX或DX:AX。
  - 範例：`MUL BX`（DX:AX = AX * BX）。
- **DIV（除法，無符號）**：
  - 語法：`DIV 來源`
  - 功能：將AX（8位元）或DX:AX（16位元）除以來源，商儲存於AL/AX，餘數儲存於AH/DX。
  - 範例：`DIV BX`（AX = DX:AX / BX，DX = 餘數）。
- **ADC（帶進位加法）**與**SBB（帶借位減法）**：
  - 功能：利用進位旗標處理多字組算術。
  - 範例：`ADC AX, BX`（AX = AX + BX + CF）。

#### c. 邏輯指令
這些指令執行位元運算並操作二進位資料。

- **AND（位元AND）**：
  - 語法：`AND 目標, 來源`
  - 功能：執行位元AND，結果儲存於目標。
  - 範例：`AND AX, 0FFh`（清除AX的高位元組）。
- **OR（位元OR）**：
  - 語法：`OR 目標, 來源`
  - 功能：執行位元OR。
  - 範例：`OR BX, 1000h`（設定BX的第12位元）。
- **XOR（位元XOR）**：
  - 語法：`XOR 目標, 來源`
  - 功能：執行位元XOR。
  - 範例：`XOR AX, AX`（將AX清零）。
- **NOT（位元NOT）**：
  - 語法：`NOT 目標`
  - 功能：反轉目標的所有位元。
  - 範例：`NOT BX`（BX = ~BX）。
- **SHL/SHR（左移/右移）**：
  - 語法：`SHL 目標, 計數`；`SHR 目標, 計數`
  - 功能：將位元左移/右移，以0（SHR）或符號位元（SAL/SAR）填充。
  - 範例：`SHL AX, 1`（AX = AX * 2）。
- **ROL/ROR（左旋轉/右旋轉）**：
  - 功能：旋轉位元，透過進位旗標循環。
  - 範例：`ROL BX, 1`（將BX左旋轉1位元）。

#### d. 控制流程指令
這些指令改變程式的執行順序，實現跳躍、迴圈及副程式。

- **JMP（跳躍）**：
  - 語法：`JMP 標籤`
  - 功能：無條件跳躍至標籤。
  - 範例：`JMP start`（跳至標籤`start`）。
  - 變體：
    - 短跳躍（±127位元組）。
    - 近跳躍（同一段內）。
    - 遠跳躍（不同段）。
- **條件跳躍**：
  - 語法：`Jcc 標籤`（例如JZ、JNZ、JC、JNC）
  - 功能：根據旗標狀態跳躍。
  - 範例：
    - `JZ loop_end`（若零旗標設定則跳躍）。
    - `JC error`（若進位旗標設定則跳躍）。
    - 常見條件：JZ（零）、JNZ（非零）、JS（符號）、JO（溢位）。
- **LOOP（迴圈）**：
  - 語法：`LOOP 標籤`
  - 功能：將CX減1，若CX ≠ 0則跳躍至標籤。
  - 範例：`LOOP process`（重複直至CX = 0）。
  - 變體：
    - `LOOPE/LOOPZ`：若CX ≠ 0且ZF = 1則迴圈。
    - `LOOPNE/LOOPNZ`：若CX ≠ 0且ZF = 0則迴圈。
- **CALL（呼叫副程式）**：
  - 語法：`CALL 標籤`
  - 功能：將返回位址推入堆疊，跳躍至副程式。
  - 範例：`CALL compute_sum`（呼叫副程式）。
- **RET（返回）**：
  - 語法：`RET`
  - 功能：從堆疊彈出返回位址，恢復執行。
  - 範例：`RET`（從副程式返回）。
- **INT（中斷）**：
  - 語法：`INT 編號`
  - 功能：觸發軟體中斷，呼叫中斷服務程式（ISR）。
  - 範例：`INT 21h`（DOS系統呼叫）。
- **IRET（中斷返回）**：
  - 功能：從ISR返回，恢復旗標及返回位址。

---

### 2. 組合語言程式設計

組合語言程式以人類可讀的指令撰寫，並組譯為機器碼。8086使用**分段記憶體模型**，需明確定義程式碼段、資料段及堆疊段。

#### a. 程式結構
典型的8086組合語言程式包含：
- **指示詞**：給組譯器的指令（例如NASM、MASM）。
  - `SEGMENT`：定義程式碼、資料或堆疊段。
  - `ORG`：設定起始位址。
  - `DB/DW`：定義位元組/字組資料。
- **指令**：CPU操作（例如MOV、ADD）。
- **標籤**：標記跳躍或資料的位置。
- **註釋**：解釋程式碼（例如`; 註釋`）。

**程式結構範例（MASM語法）**：
```asm
.model small
.stack 100h
.data
    message db 'Hello, World!$'
.code
main proc
    mov ax, @data    ; 初始化DS
    mov ds, ax
    mov dx, offset message ; 載入訊息位址
    mov ah, 09h      ; DOS列印字串功能
    int 21h          ; 呼叫DOS中斷
    mov ah, 4Ch      ; 結束程式
    int 21h
main endp
end main
```

#### b. 順序結構
順序程式碼按順序執行指令，無跳躍或迴圈。

**範例：兩數相加**
```asm
mov ax, 5        ; AX = 5
mov bx, 10       ; BX = 10
add ax, bx       ; AX = AX + BX (15)
mov [result], ax ; 將結果儲存至記憶體
```
- 指令逐一執行。
- 常用於簡單計算或資料初始化。

#### c. 分支結構
分支利用條件/無條件跳躍，根據條件改變程式流程。

**範例：比較與分支**
```asm
mov ax, 10       ; AX = 10
cmp ax, 15       ; 比較AX與15
je equal         ; 若AX == 15則跳躍
mov bx, 1        ; 否則，BX = 1
jmp done
equal:
    mov bx, 0    ; 若相等則BX = 0
done:
    ; 繼續程式
```
- **CMP**：根據減法（AX - 15）設定旗標。
- **JE**：若ZF = 1（相等）則跳躍。
- 適用於if-then-else邏輯。

#### d. 迴圈結構
迴圈重複執行指令直至條件滿足，常使用`LOOP`或條件跳躍。

**範例：求和1至10**
```asm
mov cx, 10       ; 迴圈計數器 = 10
mov ax, 0        ; 總和 = 0
sum_loop:
    add ax, cx   ; 將CX加到總和
    loop sum_loop ; CX減1，若CX ≠ 0則迴圈
    ; AX = 55 (1 + 2 + ... + 10)
```
- `LOOP`簡化基於計數器的迭代。
- 替代方案：使用`CMP`與`JNZ`自訂條件。

**條件迴圈範例**
```asm
mov ax, 0        ; 計數器
mov bx, 100      ; 上限
count_up:
    inc ax       ; AX++
    cmp ax, bx   ; 與100比較
    jle count_up ; 若AX <= 100則跳躍
```
- 適用於非計數器基礎的迴圈。

#### e. 副程式
副程式透過`CALL`與`RET`模組化程式碼，實現重複使用。

**範例：計算數字的平方**
```asm
main:
    mov ax, 4    ; 輸入
    call square  ; 呼叫副程式
    ; AX = 16
    jmp exit
square:
    push bx      ; 儲存BX
    mov bx, ax   ; 複製AX
    mul bx       ; AX = AX * BX
    pop bx       ; 恢復BX
    ret          ; 返回
exit:
    ; 結束程式
```
- **PUSH/POP**：儲存/恢復暫存器以避免副作用。
- 堆疊自動管理返回位址。

---

### 3. 中斷服務程式（ISR）

中斷讓CPU能回應外部或內部事件（例如鍵盤輸入、計時器滴答），暫停當前程式並執行ISR。

#### 中斷機制
- **中斷向量表（IVT）**：
  - 位於記憶體0000:0000h–0000:03FFh。
  - 儲存256種中斷類型（0–255）的ISR位址。
  - 每個項目：段:偏移（4位元組）。
- **類型**：
  - **硬體中斷**：由裝置觸發（例如IRQ）。
  - **軟體中斷**：由`INT`指令觸發（例如INT 21h用於DOS）。
  - **異常**：CPU錯誤（例如除零）。
- **流程**：
  1. 中斷發生。
  2. CPU將旗標、CS及IP儲存至堆疊。
  3. 透過IVT跳躍至ISR。
  4. ISR執行，以`IRET`結束以恢復狀態。

#### 撰寫ISR
ISR必須：
- 保留暫存器（PUSH/POP）。
- 快速處理中斷。
- 以`IRET`結束。

**範例：自訂計時器ISR**
```asm
.data
old_vec dw 2 dup(0) ; 儲存舊中斷向量
.code
install_isr:
    cli             ; 停用中斷
    mov ax, 0
    mov es, ax      ; ES = 0（IVT段）
    mov bx, 1Ch*4   ; 計時器中斷（1Ch）
    mov ax, es:[bx] ; 儲存舊向量
    mov old_vec, ax
    mov ax, es:[bx+2]
    mov old_vec+2, ax
    mov ax, offset my_isr ; 設定新向量
    mov es:[bx], ax
    mov ax, cs
    mov es:[bx+2], ax
    sti             ; 啟用中斷
    ret
my_isr:
    push ax
    inc word ptr [counter] ; 遞增計數器
    pop ax
    iret            ; 從中斷返回
```
- 掛鉤計時器中斷（1Ch，約18.2 Hz）。
- 遞增計數器變數。
- 保留暫存器並使用`IRET`。

**範例：DOS中斷（INT 21h）**
```asm
mov ah, 09h      ; 列印字串功能
mov dx, offset msg ; 以'$'結尾的字串位址
int 21h          ; 呼叫DOS
```
- INT 21h提供作業系統服務（例如I/O、檔案處理）。
- AH指定功能代碼。

#### 實務注意事項
- **保存狀態**：ISR必須保留所有暫存器，避免損毀主程式。
- **優先順序**：硬體中斷可能中斷其他中斷（由PIC管理）。
- **除錯**：使用DEBUG.COM或現代模擬器（例如DOSBox、Bochs）。

---

### 範例程式：階乘計算
此程式使用迴圈與副程式計算數字的階乘（例如5! = 120）。

```asm
.model small
.stack 100h
.data
    num dw 5        ; 輸入數字
    result dw ?     ; 儲存結果
.code
main proc
    mov ax, @data
    mov ds, ax      ; 初始化DS
    mov ax, num     ; 載入數字
    call factorial  ; 計算階乘
    mov result, ax  ; 儲存結果
    mov ah, 4Ch     ; 結束
    int 21h
main endp
factorial proc
    push bx
    mov bx, ax      ; BX = n
    mov ax, 1       ; AX = 結果
fact_loop:
    cmp bx, 1
    jle done        ; 若BX <= 1，結束
    mul bx          ; AX = AX * BX
    dec bx          ; BX--
    jmp fact_loop
done:
    pop bx
    ret
factorial endp
end main
```
- **邏輯**：
  - 輸入：num = 5。
  - 迴圈：AX = AX * BX，BX--直至BX = 1。
  - 結果：AX = 5 * 4 * 3 * 2 * 1 = 120。
- **特點**：
  - 副程式實現模組化。
  - 堆疊用於暫存器保存。
  - 順序與迴圈結構。

---

### 最佳實踐
1. **註釋程式碼**：組合語言難以理解，需逐步解釋。
2. **最小化暫存器使用**：避免不必要的覆寫。
3. **增量測試**：使用除錯器追蹤執行。
4. **處理邊界情況**：檢查溢位、零或負數輸入。
5. **最佳化**：減少指令（例如使用XOR AX, AX取代MOV AX, 0）。

---

### 總結
- **8086指令集**：
  - **資料傳輸**：MOV、PUSH、POP用於移動資料。
  - **算術**：ADD、SUB、MUL用於計算。
  - **邏輯**：AND、OR、XOR用於位元操作。
  - **控制流程**：JMP、LOOP、CALL用於程式流程控制。
- **程式設計結構**：
  - **順序**：線性執行簡單任務。
  - **分支**：條件跳躍實現決策。
  - **迴圈**：LOOP或Jcc實現重複。
  - **副程式**：CALL/RET實現模組化程式碼。
- **中斷**：
  - ISR透過IVT處理事件。
  - 保存狀態，以IRET結束。
  - 用於硬體（例如計時器）與軟體（例如DOS）中斷。

---

### 練習問題
1. 撰寫程式反轉記憶體中的字串。
2. 實作副程式檢查數字是否為質數。
3. 為鍵盤中斷（INT 09h）建立ISR以計算按鍵次數。
4. 解釋`JMP`與`CALL`的區別。
5. 最佳化此程式碼：`MOV AX, 0; MOV BX, AX; ADD BX, 5`。

---

本教學涵蓋8086組合語言程式設計的核心內容，透過範例與解釋培養實務技能。若想深入探討特定指令、進階技巧（例如字串操作）或模擬工具，請隨時告知！