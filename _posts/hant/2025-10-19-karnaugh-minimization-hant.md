---
audio: false
generated: true
image: false
lang: hant
layout: post
model: x-ai/grok-4-fast
title: 卡諾圖化簡範例
translated: true
type: note
---

### 卡諾圖應用範例：最小化三變數布林函數

讓我們透過一個實際範例來說明如何使用卡諾圖簡化布林表達式。我們將使用一個三變數函數（A、B、C），當最小項 m(1, 2, 4, 7) 時輸出為 1。這表示：

- f(A, B, C) = A'B'C + A'BC' + AB'C' + ABC

目標是將此表達式最小化為最少的項數（和字面量），從而減少電路中的邏輯閘數量。

#### 步驟 1：建立卡諾圖
三變數卡諾圖是一個 2x4 網格（或 4x2，但我們將使用 AB 作為行、C 作為列）。行標籤採用格雷碼順序（00、01、11、10），以確保相鄰儲存格僅有一位元差異。在對應最小項的儲存格中填入 1：

| AB \ C | 0     | 1     |
|--------|-------|-------|
| **00** | 0     | 1 (m1) |
| **01** | 1 (m2) | 0     |
| **11** | 0     | 1 (m7) |
| **10** | 1 (m4) | 0     |

（此處 m1 = A'B'C，m2 = A'BC'，m4 = AB'C'，m7 = ABC。）

#### 步驟 2：分組相鄰的 1
最小化的關鍵在於找出最大可能的相鄰 1 群組（矩形或正方形，包括環繞邊緣，如環面結構）。每個群組的大小必須是 2 的冪次（1、2、4、8 等）。群組可以重疊。

- **群組 1**：左欄的兩個 1（m2 和 m4）形成垂直對。它們共享 A'B'C'... 等等不對 — 分析位元：m2 (010) 和 m4 (100) 僅在 A 和 B 上不同，但在格雷碼中，行 01 和 10 是相鄰的。此群組涵蓋 A 的變化，因此是 B'C'（A 為無關項）。
- **群組 2**：右欄的兩個 1（m1 和 m7）形成垂直對，可環繞（行 00 和 11 並非直接相鄰，等等 — 實際上對於此圖，更好的分組方式是：注意 m1 (001) 和 m2 (010) 在行 00-01 是水平相鄰嗎？等等，讓我們修正。

等等，為清晰起見重新繪製 — 實際上，此函數的最佳群組：

- 水平對：m1 (行00 列1) 和 m2 (行01 列0)？不，不相鄰。
這些最小項的標準分組：
- 四格組？沒有。成對：
  - m1 和 m2？m1=001，m2=010 — 兩位元不同，不相鄰。
  更好：m2 (010) 和 m4 (100) — 在 A 和 B 上不同？010 和 100 在 A (0 到 1) 和 B (1 到 0) 上不同，兩位元 — 不相鄰。

我選了一個不良範例 — 讓我們選擇一個具有清晰群組的更好範例來說明。

**為清晰起見修訂範例**：讓我們使用 f(A, B, C) = Σ m(0, 1, 2, 4, 5, 6) = A'B'C' + A'B'C + A'BC' + AB'C' + AB'C + ABC'

卡諾圖：

| AB \ C | 0     | 1     |
|--------|-------|-------|
| **00** | 1 (m0) | 1 (m1) |
| **01** | 1 (m2) | 0 (m3) |
| **11** | 1 (m6) | 0 (m7) |
| **10** | 1 (m4) | 1 (m5) |

最小項：0(000)、1(001)、2(010)、4(100)、5(101)、6(110) — 是的 m3(011)=0、m7(111)=0。

所以表格：

| AB \ C | 0     | 1     |
|--------|-------|-------|
| **00** | 1     | 1     |
| **01** | 1     | 0     |
| **11** | 1     | 0     |
| **10** | 1     | 1     |

#### 步驟 3：識別群組
現在，將 1 分組：

- **大群組（4 個 1）**：整個左欄（C=0）：m0、m2、m6、m4。這些都是 C=0 的儲存格，且 AB 變化 — 在欄中全部相鄰（行可環繞）。這涵蓋 **C'**（因為 C 是 0，A 和 B 為無關項）。
- **成對群組（2 個 1）**：頂行右側（m0 和 m1？m0 列0、m1 列1 — 在行 00 的水平對：A'B'（C 為無關項）。
- 但 m1 (001) 尚未涵蓋？等等，頂行：m0 和 m1 水平相鄰，涵蓋 A'B'（C 變化）。
- 還有，底行右側 m5 (101 列1 行10) — 但要涵蓋 m1 和 m5？它們在列1，行 00 和 10，這兩行是相鄰的（環繞），所以列1 的垂直對：m1 和 m5，涵蓋 AC（等等，位元：001 和 101 = A 無關項，B=0，C=1？001 B=0 C=1，101 A=1 B=0 C=1 — 是的 B'C。

為最小化，我們選擇覆蓋所有 1 的最大尺寸非重疊或最小覆蓋群組。

最佳：
- 群組 1：列0 的 4 格垂直群組：涵蓋 C'（所有該處的 1：m0、m2、m4、m6 → 項：C'）
- 群組 2：行00 的 2 格水平群組：m0 和 m1 → A'B'
- 群組 3：列1 行10 和 00 的環繞垂直對？等等，行 00 和 10 在列1 是相鄰的：m1(001) 和 m5(101) → 僅在 A 上不同，所以 B'C（A 無關項）。

m5 已涵蓋，m1 已涵蓋。

注意：m0 同時在群組1 和群組2 中，但沒關係 — 允許重疊。

#### 步驟 4：推導最小化表達式
每個群組成為一個乘積項（共同字面量的 AND）：
- 群組 1 (C')：**C'**
- 群組 2 (A'B')：**A' B'**
- 群組 3 (B' C)：**B' C**

因此，最小化 SOP（乘積之和）：f = C' + A'B' + B'C

驗證：此式有 3 個項（原始為 6 個），更少的字面量（4 對 12），更簡單的電路（基本上 3 個 AND/OR 閘）。

您可以在真值表上繪製此式以確認它符合原始的 1。

#### 為何這能最小化？
- **相鄰規則**：僅在變數變化一位元處分組，確保該項忽略該變數（無關項 = 圖中的 -）。
- **最大優先**：更大的群組 = 項中更少的變數 = 更簡單。
- **覆蓋所有 1**：沒有 1 被遺漏；0 必須保持為 0（不將它們分組）。
- 對於更多變數（4 變數卡諾圖為 4x4），過程相同，但視覺上更困難。

此範例顯示卡諾圖如何將最小項之和快速轉換為緊湊形式，無需代數操作。對於 4+ 變數，請使用軟體，但透過 2-3 變數範例練習可建立直覺。

[數位邏輯設計基礎](https://www.allaboutcircuits.com/textbook/digital/chpt-7/karnaugh-mapping/)