---
audio: false
generated: true
lang: hant
layout: post
title: 理解 Git Fetch
translated: true
type: note
---

讓我逐步解釋這個 Git 指令 `/usr/bin/git -c protocol.version=2 fetch --no-tags --prune --no-recurse-submodules --depth=5 origin`。這個指令用於從遠端 Git 儲存庫獲取更新，並透過特定選項控制獲取資料的內容和範圍。以下是詳細分解：

### 指令分解

1. **`/usr/bin/git`**  
   這是系統上 Git 可執行檔案的路徑。它告訴系統執行 Git 程式，並使用後續的選項和指令。

2. **`-c protocol.version=2`**  
   這為此特定 Git 指令設定配置選項，強制其在與遠端儲存庫通訊時使用通訊協定版本 2。通訊協定版本 2 是 Git 通訊協定的新版本，相較於舊的版本 1，可提供更好的效能或功能。

3. **`fetch`**  
   `fetch` 指令從遠端儲存庫檢索更新（例如新的提交和分支）。與 `pull` 不同，它不會將這些變更合併到你的本地分支 — 它只更新你的*遠端追蹤分支*（例如 `origin/main`），讓你可以看到遠端的新內容。

4. **`--no-tags`**  
   通常，`fetch` 也會檢索標籤（標記特定提交的標籤，例如發布的版本號）。此選項告訴 Git*不要*從遠端儲存庫獲取標籤，讓你的本地儲存庫保持不含這些標記。

5. **`--prune`**  
   此選項會清理本地的遠端追蹤分支。如果遠端儲存庫中的某個分支已被刪除，`--prune` 會從你的本地儲存庫中移除對應的遠端追蹤分支（例如 `origin/old-branch`），保持整潔。

6. **`--no-recurse-submodules`**  
   子模組是嵌套在主儲存庫中的獨立儲存庫。預設情況下，`fetch` 可能也會獲取這些子模組的更新。此選項阻止這種行為，因此只獲取主儲存庫的資料，忽略任何子模組。

7. **`--depth=5`**  
   此選項建立*淺層獲取*，將每個分支的歷史記錄限制在最後 5 個提交。這樣會下載截斷版本的歷史記錄，而不是完整的提交歷史，從而節省時間和磁碟空間 — 如果你不需要完整歷史記錄，這非常有用。

8. **`origin`**  
   這是你從中獲取更新的遠端儲存庫名稱。`origin` 是當你克隆專案時，Git 賦予主要遠端儲存庫的預設名稱，因此此指令是從該來源獲取更新。

### 這個指令總體上做了什麼？

這個 Git 指令從 `origin` 遠端儲存庫獲取更新，並帶有幾個限制：

- 它使用通訊協定版本 2 進行通訊。
- 它只檢索每個分支的最後 5 個提交（`--depth=5`）。
- 它跳過獲取標籤（`--no-tags`）。
- 它刪除遠端已不存在的任何本地遠端追蹤分支（`--prune`）。
- 它忽略子模組（`--no-recurse-submodules`）。

總之，這是一種輕量級的方式來更新你對遠端儲存庫的本地視圖，專注於最近的變更，並避免像標籤、子模組或完整歷史記錄這樣的額外資料。這可能用於節省頻寬、加速過程或保持你的本地儲存庫最小化。

### 範例情境
假設你正在處理一個大型儲存庫的專案，你只需要從 `main` 分支獲取最新變更來快速檢查某些內容。執行此指令將會：
- 使用最後 5 個提交更新 `origin/main`。
- 移除任何過時的分支（例如，如果 `origin/feature-x` 在遠端被刪除）。
- 跳過標籤和子模組，使你的獲取快速且專注。

就是這樣！這個指令完全是關於在與遠端儲存庫同步時的效率和控制。