---
lang: hant
layout: post
title: Python 编程之网上刷题
---

这里我们使用在线评测系统来练习编程题目。如果英文水平较好，可以选择`Codeforces`和`LeetCode`。对于中文用户，计蒜客和力扣是不错的选择。这里我选择了`LeetCode`进行练习。我已经完成了10道题目，并且在最后一道题中尝试了多种方法，将程序的效率从仅超过10%的提交提升到了超过99%。

![cf](assets/images/oj/cf.png)

![jsk](assets/images/oj/jsk.png)

![LeetCode](assets/images/oj/leetcode.png)

## 1480. 一维数组的动态和

> 给定一个数组 `nums`。我们定义一个数组的「运行和」为 `runningSum[i] = sum(nums[0]…nums[i])`。
>
> 返回 `nums` 的运行和。

**示例 1：**

```
输入：nums = [1,2,3,4]
输出：[1,3,6,10]
解释：运行和计算过程如下：
[1, 1+2, 1+2+3, 1+2+3+4]
```

**示例 2：**

```
输入：nums = [1,1,1,1,1]
输出：[1,2,3,4,5]
解释：运行和计算过程如下：
[1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1]
```

**示例 3：**

```
输入：nums = [3,1,2,10,1]
输出：[3,4,6,16,17]
```

**提示：**

- `1 <= nums.length <= 1000`
- `-10^6 <= nums[i] <= 10^6`

**解题思路：**

1. 初始化一个空数组 `result` 用于存储运行和。
2. 使用一个变量 `sum` 来记录当前的和。
3. 遍历数组 `nums`，对于每个元素 `nums[i]`，将其加到 `sum` 上，并将 `sum` 添加到 `result` 中。
4. 最后返回 `result`。

**代码实现：**

```python
def runningSum(nums):
    result = []
    sum = 0
    for num in nums:
        sum += num
        result.append(sum)
    return result
```

**复杂度分析：**

- 时间复杂度：O(n)，其中 n 是数组 `nums` 的长度。我们只需要遍历一次数组。
- 空间复杂度：O(1)，除了返回的数组 `result` 外，我们只使用了常数空间。

```python
class Solution:
    def runningSum(self, nums: [int]) -> [int]:         
        累加結果 = []
        當前總和 = 0
        for 數字 in nums:
            當前總和 += 數字
            累加結果.append(當前總和)
      
        return 累加結果
```

```python
#print(Solution().runningSum([1,2,3,4]))
```

![ac](assets/images/oj/ac.png)

第一题通过。

## 1108. IP 地址无效化

### 题目描述

给定一个有效的（IPv4）IP 地址，返回该 IP 地址的无效化版本。

所谓无效化 IP 地址，就是用 `"[.]"` 替换每个点 `"."`。

**示例 1：**

```
输入：address = "1.1.1.1"
输出："1[.]1[.]1[.]1"
```

**示例 2：**

```
输入：address = "255.100.50.0"
输出："255[.]100[.]50[.]0"
```

**提示：**

- 给定的 `address` 是一个有效的 IPv4 地址。

### 解题思路

要将一个有效的 IPv4 地址无效化，只需将地址中的每个点 `"."` 替换为 `"[.]"`。这可以通过字符串的替换操作来实现。

### 代码实现

```python
def defangIPaddr(address: str) -> str:
    return address.replace('.', '[.]')
```

### 复杂度分析

- **时间复杂度**：O(n)，其中 n 是字符串 `address` 的长度。字符串替换操作需要遍历整个字符串。
- **空间复杂度**：O(n)，存储替换后的字符串需要额外的空间。

### 总结

本题要求将 IPv4 地址中的每个点替换为 `"[.]"`，通过简单的字符串替换操作即可实现。代码简洁且高效，适用于处理各种有效的 IPv4 地址。

> 给定一个有效的（IPv4）IP `地址`，返回该 IP 地址的脱敏版本。
>
> *脱敏 IP 地址* 会将每个句点 `"."` 替换为 `"[.]"`。

```python
class Solution:
    def defangIPaddr(self, address: str) -> str:
        return address.replace('.', '[.]')
```

# 打印(Solution().defangIPaddr('1.1.1.1'))
```

## 1431. 拥有最多糖果的孩子

### 题目描述

给你一个数组 `candies` 和一个整数 `extraCandies`，其中 `candies[i]` 代表第 `i` 个孩子拥有的糖果数目。

对每一个孩子，检查是否存在一种方案，将 `extraCandies` 分配给这个孩子后，这个孩子拥有的糖果数目会变成所有孩子中最多的。

返回一个布尔数组 `result`，其中 `result[i]` 是 `true` 的话，表示第 `i` 个孩子通过分配 `extraCandies` 可以成为拥有最多糖果的孩子；否则为 `false`。

**示例 1：**

```
输入：candies = [2,3,5,1,3], extraCandies = 3
输出：[true,true,true,false,true] 
解释：
孩子 1 有 2 个糖果，如果他得到所有额外的 3 个糖果，那么他将有 5 个糖果，成为拥有最多糖果的孩子。
孩子 2 有 3 个糖果，如果他得到至少 2 个额外的糖果，那么他将拥有最多糖果。
孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。
孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有最多糖果的孩子。
孩子 5 有 3 个糖果，如果他得到至少 2 个额外的糖果，那么他将拥有最多糖果。
```

**示例 2：**

```
输入：candies = [4,2,1,1,2], extraCandies = 1
输出：[true,false,false,false,false] 
解释：只有 1 个额外的糖果，所以只有孩子 1 可以成为拥有最多糖果的孩子。
```

**示例 3：**

```
输入：candies = [12,1,12], extraCandies = 10
输出：[true,false,true]
```

**提示：**

- `2 <= candies.length <= 100`
- `1 <= candies[i] <= 100`
- `1 <= extraCandies <= 50`

### 解题思路

要解决这个问题，我们需要确定每个孩子是否可以通过分配额外的糖果成为拥有最多糖果的孩子。具体步骤如下：

1. **找出最大值**：首先，找出数组中最大的糖果数量，记为 `maxCandies`。
2. **判断每个孩子**：对于每个孩子，检查他们当前的糖果数量加上 `extraCandies` 是否大于或等于 `maxCandies`。如果是，则这个孩子可以通过分配额外的糖果成为拥有最多糖果的孩子。
3. **返回结果**：根据上述判断，生成一个布尔数组并返回。

### 代码实现

```python
def kidsWithCandies(candies, extraCandies):
    maxCandies = max(candies)
    result = []
    for candy in candies:
        if candy + extraCandies >= maxCandies:
            result.append(True)
        else:
            result.append(False)
    return result
```

### 复杂度分析

- **时间复杂度**：O(n)，其中 `n` 是 `candies` 数组的长度。我们需要遍历数组两次，一次找出最大值，一次生成结果。
- **空间复杂度**：O(n)，用于存储结果数组。

### 总结

这个问题通过简单的遍历和比较就可以解决。关键在于找出最大值，然后判断每个孩子是否可以通过分配额外的糖果达到或超过这个最大值。这种方法既直观又高效，适用于大多数类似的问题。

> 给定数组 `candies` 和整数 `extraCandies`，其中 `candies[i]` 代表第 ***i\*** 个孩子拥有的糖果数目。
>
> 对于每一个孩子，检查是否存在一种分配 `extraCandies` 的方式，使得他或她能够拥有**最多**的糖果。注意，多个孩子可以同时拥有**最多**的糖果数目。

```python
class Solution:
    def kidsWithCandies(self, candies: [int], extraCandies: int) -> [bool]:
        max_candies = 0
        for candy in candies:
            if candy > max_candies:
                max_candies = candy
        greatests = []
        for candy in candies:
            if candy + extraCandies >= max_candies:
                greatests.append(True)
            else:
                greatests.append(False)
        return greatests
```

# print(Solution().kidsWithCandies([2,3,5,1,3], 3))
```

## 1672. 最富有客户的资产总量

> 给定一个 `m x n` 的整数网格 `accounts`，其中 `accounts[i][j]` 是第 `i` 位客户在第 `j` 家银行的存款金额。返回 *最富有客户所拥有的 **财富** 总量*。
>
> 客户的 **财富** 是指他们在所有银行账户中的存款总额。最富有的客户是指拥有最大 **财富** 的客户。

### 示例

**示例 1:**

```
输入: accounts = [[1,2,3],[3,2,1]]
输出: 6
解释:
第 1 位客户的财富 = 1 + 2 + 3 = 6
第 2 位客户的财富 = 3 + 2 + 1 = 6
两位客户都是最富有的，财富总量均为 6，所以返回 6。
```

**示例 2:**

```
输入: accounts = [[1,5],[7,3],[3,5]]
输出: 10
解释: 
第 1 位客户的财富 = 6
第 2 位客户的财富 = 10 
第 3 位客户的财富 = 8
第 2 位客户是最富有的，财富总量为 10。
```

**示例 3:**

```
输入: accounts = [[2,8,7],[7,1,3],[1,9,5]]
输出: 17
```

### 提示

- `m == accounts.length`
- `n == accounts[i].length`
- `1 <= m, n <= 50`
- `1 <= accounts[i][j] <= 100`

### 解题思路

要解决这个问题，我们需要计算每位客户在所有银行账户中的总存款，然后找出其中的最大值。具体步骤如下：

1. **遍历每位客户**：对于 `accounts` 数组中的每一位客户，计算其所有银行账户的存款总和。
2. **计算财富**：将每位客户的所有银行账户的存款相加，得到该客户的财富。
3. **找出最大值**：在所有客户的财富中，找出最大的一个，即为最富有客户的财富。

### 代码实现

```python
def maximumWealth(accounts):
    max_wealth = 0
    for customer in accounts:
        current_wealth = sum(customer)
        if current_wealth > max_wealth:
            max_wealth = current_wealth
    return max_wealth
```

### 复杂度分析

- **时间复杂度**：O(m * n)，其中 `m` 是客户的数量，`n` 是每位客户的银行账户数量。我们需要遍历每位客户的每个银行账户来计算财富。
- **空间复杂度**：O(1)，我们只使用了常数个额外的变量来存储最大财富和当前客户的财富。

### 总结

这个问题通过简单的遍历和求和操作就可以解决。关键在于如何高效地计算每位客户的财富，并找出其中的最大值。通过上述方法，我们可以在合理的时间内找到最富有客户的财富。

```python
class Solution:
    def maximumWealth(self, accounts: [[int]]) -> int:
        max_wealth = 0      
        for account in accounts:
            wealth = sum(account) 
            if max_wealth < wealth:
                max_wealth = wealth
        return max_wealth
```

# 打印(Solution().maximumWealth([[1,2,3],[3,2,1]]))

## 1470. 重新排列数组

### 问题描述

给定一个数组 `nums`，它由 `2n` 个元素组成，形式为 `[x1,x2,...,xn,y1,y2,...,yn]`。

请返回数组 `[x1,y1,x2,y2,...,xn,yn]` 的形式。

**示例 1：**

```
输入：nums = [2,5,1,3,4,7], n = 3
输出：[2,3,5,4,1,7]
解释：由于 x1=2, x2=5, x3=1, y1=3, y2=4, y3=7，所以答案为 [2,3,5,4,1,7]
```

**示例 2：**

```
输入：nums = [1,2,3,4,4,3,2,1], n = 4
输出：[1,4,2,3,3,2,4,1]
```

**示例 3：**

```
输入：nums = [1,1,2,2], n = 2
输出：[1,2,1,2]
```

**提示：**

- `1 <= n <= 500`
- `nums.length == 2n`
- `1 <= nums[i] <= 10^3`

### 解题思路

要将数组 `nums` 重新排列为 `[x1,y1,x2,y2,...,xn,yn]` 的形式，可以按照以下步骤进行：

1. **分割数组**：将数组 `nums` 分成两部分，前 `n` 个元素为 `x` 部分，后 `n` 个元素为 `y` 部分。
2. **交替插入**：创建一个新的数组，依次从 `x` 部分和 `y` 部分取出元素，交替插入到新数组中。

具体步骤如下：

1. 初始化一个空数组 `result` 用于存储结果。
2. 使用一个循环，从 `0` 到 `n-1` 遍历：
   - 将 `x` 部分的元素 `nums[i]` 添加到 `result` 中。
   - 将 `y` 部分的元素 `nums[n + i]` 添加到 `result` 中。
3. 返回 `result` 作为最终结果。

### 代码实现

```python
def shuffle(nums, n):
    result = []
    for i in range(n):
        result.append(nums[i])
        result.append(nums[n + i])
    return result
```

### 复杂度分析

- **时间复杂度**：O(n)，其中 `n` 是数组长度的一半。我们只需要遍历一次数组即可完成重新排列。
- **空间复杂度**：O(n)，需要额外的空间来存储结果数组。

### 示例解析

以示例 1 为例：

```
输入：nums = [2,5,1,3,4,7], n = 3
```

- `x` 部分为 `[2,5,1]`，`y` 部分为 `[3,4,7]`。
- 按照交替插入的方式，结果为 `[2,3,5,4,1,7]`。

### 总结

通过将数组分割为两部分并交替插入，我们可以轻松地将数组重新排列为所需的形式。这种方法简单直观，且时间复杂度较低，适用于大多数情况。

> 给定一个包含 `2n` 个元素的数组 `nums`，其形式为 `[x1,x2,...,xn,y1,y2,...,yn]`。
>
> *返回数组的形式为* `[x1,y1,x2,y2,...,xn,yn]`。

### 示例

**输入:** nums = [2,5,1,3,4,7], n = 3  
**输出:** [2,3,5,4,1,7]  
**解释:** 由于 x1=2, x2=5, x3=1, y1=3, y2=4, y3=7，所以答案为 [2,3,5,4,1,7]。

### 解题思路

1. **分割数组**：将数组 `nums` 分成两部分，前 `n` 个元素为 `x` 部分，后 `n` 个元素为 `y` 部分。
2. **交替合并**：创建一个新数组，依次从 `x` 部分和 `y` 部分取出元素，交替放入新数组中。
3. **返回结果**：最终返回新数组。

### 代码实现

```python
def shuffle(nums, n):
    result = []
    for i in range(n):
        result.append(nums[i])
        result.append(nums[i + n])
    return result
```

### 复杂度分析

- **时间复杂度**：O(n)，其中 `n` 是数组长度的一半。我们只需要遍历一次数组即可完成操作。
- **空间复杂度**：O(n)，需要额外的空间来存储结果数组。

### 总结

这个问题通过简单的数组分割和交替合并即可解决。关键在于如何高效地将两个部分合并成一个新的数组。

```python
class Solution:
  def shuffle(self, nums: [int], n: int) -> [int]:
    ns1 = nums[:n]  # 取前n個元素
    ns2 = nums[n:]  # 取剩下的元素
    ns = []  # 初始化結果列表
    for i in range(n):
      ns.append(ns1[i])  # 添加前n個元素中的第i個
      ns.append(ns2[i])  # 添加後n個元素中的第i個
    return ns  # 返回重組後的列表
```

# 打印(Solution().shuffle([2,5,1,3,4,7], 3))
```

## 1512. 好数对的数目

### 问题描述

给定一个整数数组 `nums`，如果一组下标 `(i, j)` 满足 `i < j` 且 `nums[i] == nums[j]`，则称这组下标为**好数对**。请返回数组中好数对的总数。

### 示例

**示例 1：**

```
输入：nums = [1,2,3,1,1,3]
输出：4
解释：有 4 组好数对，分别是 (0,3), (0,4), (3,4), (2,5)。
```

**示例 2：**

```
输入：nums = [1,1,1,1]
输出：6
解释：数组中的每一对下标都是好数对。
```

**示例 3：**

```
输入：nums = [1,2,3]
输出：0
解释：没有满足条件的好数对。
```

### 提示

- `1 <= nums.length <= 100`
- `1 <= nums[i] <= 100`

### 解题思路

要计算好数对的总数，我们可以利用组合数学中的组合数公式。对于数组中每个出现次数为 `k` 的元素，其可以形成的好数对数量为 `C(k, 2)`，即 `k * (k - 1) / 2`。因此，我们只需要统计数组中每个元素的出现次数，然后计算每个元素的组合数并累加即可。

具体步骤如下：

1. 使用一个哈希表（或字典）来统计数组中每个元素的出现次数。
2. 遍历哈希表，对于每个出现次数 `k`，计算 `C(k, 2)` 并累加到结果中。
3. 返回最终的结果。

### 代码实现

```python
def numIdenticalPairs(nums):
    from collections import defaultdict

    count = defaultdict(int)
    for num in nums:
        count[num] += 1

    result = 0
    for key in count:
        k = count[key]
        result += k * (k - 1) // 2

    return result
```

### 复杂度分析

- **时间复杂度**：O(n)，其中 n 是数组 `nums` 的长度。我们需要遍历数组一次来统计每个元素的出现次数，然后遍历哈希表一次来计算好数对的数量。
- **空间复杂度**：O(n)，哈希表在最坏情况下需要存储所有不同的元素。

### 总结

通过统计每个元素的出现次数，并利用组合数公式计算好数对的数量，我们可以高效地解决这个问题。这种方法的时间复杂度和空间复杂度都是线性的，适用于题目中给定的数据范围。

> 给定一个整数数组 `nums`。
>
> 如果一对 `(i,j)` 满足 `nums[i]` == `nums[j]` 且 `i` < `j`，则称这对为*好*对。
>
> 返回*好*对的数量。

```python
class Solution:
    def numIdenticalPairs(self, nums: [int]) -> int:
        j = 1
        n = len(nums)
        p = 0
        while j < n:
            for i in range(j):
                if nums[i] == nums[j]:
                    p += 1
            j += 1
        return p
```

# 打印(Solution().numIdenticalPairs([1,2,3,1,1,3]))
```

## 771. 宝石与石头

> 给定字符串 `jewels` 代表你拥有的宝石的类型，`stones` 代表你拥有的石头。`stones` 中的每个字符代表了一种你拥有的石头类型。你想知道你拥有的石头中有多少是宝石。
>
> 字母区分大小写，因此 `"a"` 和 `"A"` 被视为不同类型的石头。

### 示例

**示例 1:**

```
输入: jewels = "aA", stones = "aAAbbbb"
输出: 3
```

**示例 2:**

```
输入: jewels = "z", stones = "ZZ"
输出: 0
```

### 提示

- `1 <= jewels.length, stones.length <= 50`
- `jewels` 和 `stones` 仅由英文字母组成。
- `jewels` 中的所有字符都是唯一的。

### 解题思路

1. **遍历石头**：遍历 `stones` 中的每一个字符。
2. **检查是否为宝石**：对于每一个字符，检查它是否存在于 `jewels` 中。
3. **计数**：如果存在，则计数器加一。
4. **返回结果**：最后返回计数器的值。

### 代码实现

```python
def numJewelsInStones(jewels: str, stones: str) -> int:
    jewel_set = set(jewels)
    count = 0
    for stone in stones:
        if stone in jewel_set:
            count += 1
    return count
```

### 复杂度分析

- **时间复杂度**：O(n + m)，其中 n 是 `stones` 的长度，m 是 `jewels` 的长度。我们需要遍历 `stones` 一次，并且对于每个字符，检查它是否在 `jewels` 中，这个检查操作的时间复杂度是 O(1)。
- **空间复杂度**：O(m)，我们需要一个集合来存储 `jewels` 中的字符。

### 总结

这道题目通过简单的遍历和集合查找，可以高效地计算出拥有的石头中有多少是宝石。关键在于利用集合的 O(1) 查找特性来优化时间复杂度。

```python
class Solution:
    def numJewelsInStones(self, jewels: str, stones: str) -> int:
        n = 0
        for i in range(len(jewels)):
            js = jewels[i:i+1]
            n += stones.count(js)
        return n
```

# 打印(Solution().numJewelsInStones("aA", "aAAbbbb"))
```

## 1603. 设计停车系统

### 题目描述

请你给一个停车场设计一个停车系统。停车场有三种不同大小的停车位：大、中、小，每种大小分别有固定数目的车位。

请你实现 `ParkingSystem` 类：

- `ParkingSystem(int big, int medium, int small)` 初始化 `ParkingSystem` 类，三个参数分别对应每种停车位的数目。
- `bool addCar(int carType)` 检查是否有 `carType` 对应的停车位。`carType` 有三种类型：大、中、小，分别用数字 `1`、`2` 和 `3` 表示。一辆车只能停在对应大小的停车位上。如果没有可用的停车位，请返回 `false`，否则将该车停入停车位并返回 `true`。

### 示例

```plaintext
输入：
["ParkingSystem", "addCar", "addCar", "addCar", "addCar"]
[[1, 1, 0], [1], [2], [3], [1]]
输出：
[null, true, true, false, false]

解释：
ParkingSystem parkingSystem = new ParkingSystem(1, 1, 0);
parkingSystem.addCar(1); // 返回 true，因为有 1 个大车位
parkingSystem.addCar(2); // 返回 true，因为有 1 个中车位
parkingSystem.addCar(3); // 返回 false，因为没有小车位
parkingSystem.addCar(1); // 返回 false，因为没有大车位了
```

### 提示

- `0 <= big, medium, small <= 1000`
- `carType` 取值为 `1`、`2` 或 `3`
- 最多会调用 `addCar` 函数 `1000` 次

### 解题思路

我们需要设计一个停车系统，能够根据车辆的类型（大、中、小）来分配对应的停车位。每种类型的停车位数量是固定的，当有车辆请求停车时，我们需要检查是否有对应的停车位可用。

1. **初始化**：在 `ParkingSystem` 的构造函数中，我们接收三种停车位的初始数量，并将其存储在类的成员变量中。
2. **添加车辆**：在 `addCar` 方法中，我们根据车辆的类型来检查对应的停车位数量是否大于 0。如果大于 0，则减少该类型停车位的数量并返回 `true`；否则返回 `false`。

### 代码实现

```python
class ParkingSystem:
    def __init__(self, big: int, medium: int, small: int):
        self.big = big
        self.medium = medium
        self.small = small

    def addCar(self, carType: int) -> bool:
        if carType == 1:
            if self.big > 0:
                self.big -= 1
                return True
            else:
                return False
        elif carType == 2:
            if self.medium > 0:
                self.medium -= 1
                return True
            else:
                return False
        elif carType == 3:
            if self.small > 0:
                self.small -= 1
                return True
            else:
                return False
        else:
            return False
```

### 复杂度分析

- **时间复杂度**：`addCar` 方法的时间复杂度为 O(1)，因为我们只是简单地检查并减少对应的停车位数量。
- **空间复杂度**：O(1)，我们只使用了常数空间来存储停车位的数量。

### 总结

这道题目主要考察了类的设计和基本的条件判断。通过合理地使用类的成员变量和方法，我们可以轻松地实现一个简单的停车系统。

> 设计一个停车场系统。停车场有三种停车位：大、中、小，每种尺寸的停车位数量固定。
>
> 实现 `ParkingSystem` 类：
>
> - `ParkingSystem(int big, int medium, int small)` 初始化 `ParkingSystem` 类的对象。每种停车位的数量作为构造函数的一部分给出。
> - `bool addCar(int carType)` 检查是否有对应 `carType` 的停车位可供车辆进入停车场。`carType` 可以是三种类型之一：大、中、小，分别用 `1`、`2` 和 `3` 表示。**车辆只能停放在与其** `carType` **对应的停车位上**。如果没有可用的停车位，返回 `false`，否则将车停入该尺寸的停车位并返回 `true`。

```python
class ParkingSystem:
    def __init__(self, big: int, medium: int, small: int):
        self.spaces = {1: big, 2: medium, 3: small}

    def addCar(self, carType: int) -> bool:
        if self.spaces[carType] > 0:
            self.spaces[carType] -= 1
            return True
        else:
            return False
```

### 解释

1. **构造函数 `__init__`**:
   - 接受三个参数 `big`, `medium`, `small`，分别表示大、中、小三种停车位的数量。
   - 使用一个字典 `self.spaces` 来存储每种停车位的剩余数量，键为 `1`、`2`、`3`，分别对应大、中、小三种停车位。

2. **方法 `addCar`**:
   - 接受一个参数 `carType`，表示车辆的类型。
   - 检查对应类型的停车位是否还有剩余（即 `self.spaces[carType] > 0`）。
   - 如果有剩余停车位，则将对应类型的停车位数量减一，并返回 `True`。
   - 如果没有剩余停车位，则返回 `False`。

### 示例

```python
parkingSystem = ParkingSystem(1, 1, 0)
print(parkingSystem.addCar(1))  # 返回 true，因为有 1 个大停车位
print(parkingSystem.addCar(2))  # 返回 true，因为有 1 个中停车位
print(parkingSystem.addCar(3))  # 返回 false，因为没有小停车位
print(parkingSystem.addCar(1))  # 返回 false，因为大停车位已经被占用
```

### 复杂度分析

- **时间复杂度**:
  - `addCar` 方法的时间复杂度为 O(1)，因为字典的查找和更新操作都是常数时间复杂度。

- **空间复杂度**:
  - 空间复杂度为 O(1)，因为只使用了固定大小的字典来存储停车位的数量。

```python
class ParkingSystem:
    slots = [0, 0, 0]
```

    def __init__(self, big: int, medium: int, small: int):
      self.slots[0] = big
      self.slots[1] = medium
      self.slots[2] = small

```python
    def addCar(self, carType: int) -> bool:
      if self.slots[carType - 1] > 0:
        self.slots[carType - 1] -=1
        return True
      else:
        return False
```

翻譯成繁體中文：

```python
    def 添加汽車(self, 汽車類型: int) -> bool:
      if self.停車位[汽車類型 - 1] > 0:
        self.停車位[汽車類型 - 1] -=1
        return True
      else:
        return False
```

# 停車系統 = 停車系統(1, 1, 0)
# 打印(停車系統.添加汽車(1))
# 打印(停車系統.添加汽車(2))
# 打印(停車系統.添加汽車(3))
# 打印(停車系統.添加汽車(1))
```

## 1773. 统计匹配检索规则的物品数量

### 问题描述

给定一个数组 `items`，其中每个 `items[i] = [typei, colori, namei]` 表示第 `i` 件物品的类型、颜色和名称。另外给定一个字符串 `ruleKey` 和一个字符串 `ruleValue`，表示检索规则。

你需要统计并返回满足以下条件的物品数量：

- 如果 `ruleKey == "type"`，则检查 `typei == ruleValue`。
- 如果 `ruleKey == "color"`，则检查 `colori == ruleValue`。
- 如果 `ruleKey == "name"`，则检查 `namei == ruleValue`。

### 示例

**示例 1:**

```
输入：items = [["phone","blue","pixel"],["computer","silver","lenovo"],["phone","gold","iphone"]], ruleKey = "color", ruleValue = "silver"
输出：1
解释：只有一件物品满足条件，即 ["computer","silver","lenovo"]。
```

**示例 2:**

```
输入：items = [["phone","blue","pixel"],["computer","silver","phone"],["phone","gold","iphone"]], ruleKey = "type", ruleValue = "phone"
输出：2
解释：有两件物品满足条件，即 ["phone","blue","pixel"] 和 ["phone","gold","iphone"]。注意，["computer","silver","phone"] 不满足条件，因为它的类型是 "computer"。
```

### 提示

- `1 <= items.length <= 10^4`
- `1 <= typei.length, colori.length, namei.length, ruleValue.length <= 10`
- `ruleKey` 是 `"type"`、`"color"` 或 `"name"` 中的一个。
- 所有字符串仅由小写字母组成。

### 解题思路

我们可以根据 `ruleKey` 的值来确定需要检查 `items[i]` 中的哪个属性。具体来说：

- 如果 `ruleKey == "type"`，则检查 `items[i][0]` 是否等于 `ruleValue`。
- 如果 `ruleKey == "color"`，则检查 `items[i][1]` 是否等于 `ruleValue`。
- 如果 `ruleKey == "name"`，则检查 `items[i][2]` 是否等于 `ruleValue`。

然后，我们遍历 `items` 数组，统计满足条件的物品数量即可。

### 代码实现

```python
def countMatches(items, ruleKey, ruleValue):
    count = 0
    index = 0
    if ruleKey == "type":
        index = 0
    elif ruleKey == "color":
        index = 1
    elif ruleKey == "name":
        index = 2
    
    for item in items:
        if item[index] == ruleValue:
            count += 1
    return count
```

### 复杂度分析

- **时间复杂度**：O(n)，其中 n 是 `items` 的长度。我们需要遍历 `items` 数组一次。
- **空间复杂度**：O(1)，只使用了常数级别的额外空间。

### 总结

这道题目主要考察了对数组的遍历和条件判断。通过根据 `ruleKey` 确定需要检查的属性，我们可以高效地统计满足条件的物品数量。

> 给定一个数组 `items`，其中每个 `items[i] = [typei, colori, namei]` 描述了第 `i` 个物品的类型、颜色和名称。同时给定一个由两个字符串 `ruleKey` 和 `ruleValue` 表示的规则。
>
> 如果第 `i` 个物品满足以下条件之一，则认为该物品匹配给定的规则：
>
> - `ruleKey == "type"` 且 `ruleValue == typei`。
> - `ruleKey == "color"` 且 `ruleValue == colori`。
> - `ruleKey == "name"` 且 `ruleValue == namei`。
>
> 返回*匹配给定规则的物品数量*。

```python
class Solution:
    def countMatches(self, items: [[str]], ruleKey: str, ruleValue: str) -> int:
        i = 0
        if ruleKey == "type":
            i = 0
        elif ruleKey == "color":
            i = 1
        else:
            i = 2
        n = 0
        for item in items:
            if item[i] == ruleValue:
                n += 1
        return n
```

# print(Solution().countMatches([["phone","blue","pixel"],["computer","silver","lenovo"],["phone","gold","iphone"]], "color", "silver"))
        
```

## 1365. 有多少小于当前数字的数字

> 给定数组 `nums`，对于每个 `nums[i]`，找出数组中有多少个数比它小。也就是说，对于每个 `nums[i]`，你需要计算满足 `j != i` **且** `nums[j] < nums[i]` 的有效 `j` 的数量。
>
> 以数组形式返回答案。

> ```
> 输入: nums = [8,1,2,2,3]
> 输出: [4,0,1,1,3]
> 解释: 
> 对于 nums[0]=8，有四个比它小的数（1, 2, 2 和 3）。
> 对于 nums[1]=1，没有比它小的数。
> 对于 nums[2]=2，有一个比它小的数（1）。
> 对于 nums[3]=2，有一个比它小的数（1）。
> 对于 nums[4]=3，有三个比它小的数（1, 2 和 2）。
> ```

```python
class Solution:
    def smallerNumbersThanCurrent(self, nums: [int]) -> [int]:
        ns = []
        l = len(nums)
        for i in range(l):
            n = 0
            for j in range(l):
                if i != j:
                    if nums[j] < nums[i]:
                        n += 1
            ns.append(n)
        return ns
```

# 打印(Solution().smallerNumbersThanCurrent([8,1,2,2,3]))
```

用时528毫秒，击败了11.81%的程序。需要优化一下。

```python
class Solution:
    def smallerNumbersThanCurrent(self, nums: [int]) -> [int]:
        l = len(nums)
```

        sort_nums = nums.copy()  # 将nums列表复制到sort_nums

        ins = list(range(l))
        for i in range(l):          
          for j in range(i+1, l):
            if sort_nums[i] > sort_nums[j]:
              a = sort_nums[i]
              sort_nums[i] = sort_nums[j]
              sort_nums[j] = a
              
              a = ins[i]
              ins[i] = ins[j]
              ins[j] = a
        
        smalls = [0]
        for i in range(1, l):
          if sort_nums[i-1] == sort_nums[i]:
            smalls.append(smalls[i-1])
          else:
            smalls.append(i)

        # 打印排序後的數字列表
        # 打印較小的數字列表

        r_is = list(range(l))
        for i in ins:
          r_is[ins[i]] = i
    
        ns = []
        for i in range(l):          
          ns.append(smalls[r_is[i]])
        return ns

# 打印(Solution().smallerNumbersThanCurrent([8,1,2,2,3]))
```

这次测试用时`284毫秒`，比之前的`528毫秒`要少。

用系统函数简写一下。

```python
class Solution:
    def smallerNumbersThanCurrent(self, nums: [int]) -> [int]:
        # 複製原始數組並進行排序
        sort_nums = nums.copy()
        sort_nums.sort()
        
        # 初始化結果列表
        ns = []
        # 遍歷原始數組中的每個數字
        for num in nums:
            # 將排序後數組中該數字的索引加入結果列表
            ns.append(sort_nums.index(num))
        return ns
```

# 打印(Solution().smallerNumbersThanCurrent([8,1,2,2,3]))
```

这次仅需`64毫秒`，超越了`71%`的提交记录。

```python
class Solution:
    def smallerNumbersThanCurrent(self, nums: [int]) -> [int]:
        l = len(nums)
        ns = [0] * l
        for i in range(l):
          for j in range(i+1, l):
            if nums[i] > nums[j]:
              ns[i] +=1
            elif nums[i] < nums[j]:
              ns[j] +=1
            else:
              pass
        return ns
```

# 打印(Solution().smallerNumbersThanCurrent([8,1,2,2,3]))
```

又想出一種解法。用時`400ms`。

```python
class Solution:
    def smallerNumbersThanCurrent(self, nums: [int]) -> [int]:        
        ss = sorted((e, i) for i, e in enumerate(nums))
```

        l = len(nums)
        smalls = [0]
        for i in range(1, l):
          (e0, j0) = ss[i-1]
          (e1, j1) = ss[i]
          if e0 == e1:
            smalls.append(smalls[i-1])
          else:
            smalls.append(i)

        ns = [0]*l
        for i in range(l):
          (e,j) = ss[i]
          ns[j] = smalls[i]
        return ns

# 打印(Solution().smallerNumbersThanCurrent([8,1,2,2,3]))
```

> 运行时间：52毫秒，快于91.45%的Python3在线提交的“有多少数字小于当前数字”问题。
>
> 内存使用：14.6 MB，少于15.18%的Python3在线提交的“有多少数字小于当前数字”问题。

終於成功了！這個方法又更快了，打敗了`91.45%`的提交。

继续简化。

```python
class Solution:
    def smallerNumbersThanCurrent(self, nums: [int]) -> [int]:
        ss = sorted((e, i) for i, e in enumerate(nums))
```

        l = len(nums)
        smalls = [0]
        ns = [0]*l
        for i in range(1, l):
          (e0, j0) = ss[i-1]
          (e1, j1) = ss[i]
          if e0 == e1:
            smalls.append(smalls[i-1])
          else:
            smalls.append(i)

        ns[j1] = smalls[i]
        return ns

# 打印(Solution().smallerNumbersThanCurrent([8,1,2,2,3]))
```

继续。

```python
class Solution:
    def smallerNumbersThanCurrent(self, nums: [int]) -> [int]:
        ss = sorted((e, i) for i, e in enumerate(nums))
```

        l = len(nums)
        last = 0
        ns = [0]*l
        for i in range(1, l):
          (e0, j0) = ss[i-1]
          (e1, j1) = ss[i]
          if e0 == e1:
            pass
          else:
            last = i

        ns[j1] = last
        return ns

# 打印(Solution().smallerNumbersThanCurrent([8,1,2,2,3]))
```

此时，我们的程序运行时间缩短至`40毫秒`，超越了`99.81%`的同类程序。

> 运行时间：40毫秒，快于99.81%的Python3在线提交，用于“有多少数字小于当前数字”问题。
>
> 内存使用：14.4 MB，少于15.18%的Python3在线提交，用于“有多少数字小于当前数字”问题。

再來一種解法。

```python
class Solution:
    def smallerNumbersThanCurrent(self, nums: [int]) -> [int]:
        l = len(nums)
        n = [0] * 101
        max_num = 0
        for num in nums:
            n[num] += 1
            if num > max_num:
                max_num = num
```

```python
sm = [0] * (max_num + 1)  # 创建一个大小为max_num + 1的数组，初始值为0
sum = 0  # 初始化累加和为0
for i in range(max_num + 1):  # 遍历从0到max_num的所有数
    sm[i] = sum  # 将当前的累加和赋值给sm数组的第i个元素
    sum += n[i]  # 将n数组的第i个元素加到累加和中

ns = [0] * l  # 创建一个大小为l的数组，初始值为0
for i in range(l):  # 遍历从0到l-1的所有索引
    ns[i] = sm[nums[i]]  # 将sm数组中对应nums[i]的值赋值给ns数组的第i个元素
```

    返回 ns

# 打印(Solution().smallerNumbersThanCurrent([8,1,2,2,3]))
```

来个稍微复杂点的。

```python
class Solution:
    def smallerNumbersThanCurrent(self, nums: [int]) -> [int]:
        l = len(nums)
        n = [0] * 101
        max_num = 0
        for num in nums:
            n[num] += 1
            if num > max_num:
                max_num = num
```

```python
short_n = []
short_num = [] * l
zn = [0] * 101
j = 0
for i in range(max_num + 1):
    if n[i] > 0:
        zn[i] = j
        short_n.append(n[i])
        short_num.append(num)
        j += 1
```

將上述代碼翻譯成繁體中文如下：

```python
short_n = []
short_num = [] * l
zn = [0] * 101
j = 0
for i in range(max_num + 1):
    if n[i] > 0:
        zn[i] = j
        short_n.append(n[i])
        short_num.append(num)
        j += 1
```

這段代碼的主要功能是遍歷一個範圍內的數字，並根據條件將某些值添加到不同的列表中。具體來說，它會檢查`n[i]`是否大於0，如果是，則更新`zn`列表中的對應位置，並將`n[i]`和`num`分別添加到`short_n`和`short_num`列表中。同時，變量`j`會遞增，用於記錄滿足條件的次數。

```python
sm = [0] * j
sum = 0
for i in range(j):
    sm[i] = sum
    sum += short_n[i]

ns = [0] * l
for i in range(l):
    ns[i] = sm[zn[nums[i]]]
return ns
```

翻譯成繁體中文：

```python
sm = [0] * j
sum = 0
for i in range(j):
    sm[i] = sum
    sum += short_n[i]

ns = [0] * l
for i in range(l):
    ns[i] = sm[zn[nums[i]]]
return ns
```

這段程式碼的功能是計算一個累加數組 `sm`，然後根據 `zn` 和 `nums` 的映射關係，生成一個新的數組 `ns`。

# 打印(Solution().smallerNumbersThanCurrent([8,1,2,2,3]))
```

```python
class Solution:    

    def smallerNumbersThanCurrent(self, nums: [int]) -> [int]:
        max_num = max(nums)
```

n = [0] * (max_num + 1)
for num in nums:
    n[num] += 1

sorted_ls = []
for i in range(max_num + 1):
    if n[i] > 0:
        sorted_ls.append(i)

```python
sm = [0] * (max_num + 1)
sum = 0
for i in range(len(sorted_ls)):
    v = sorted_ls[i]
    sm[v] = sum
    sum += n[v]
  
ns = [] 
for i in range(len(nums)):
    ns.append(sm[nums[i]])
return ns
# print(Solution().smallerNumbersThanCurrent([72,48,32,16,10,59,83,38,1,4,68,7,67,16,5,35,99,15,55,11,24,3,63,81,16,95,35,87,24,84,57,49,42,80,34,33,82,81,31,31,7,75,100,75,22,44,54,77,89,71,81,66,7]))
```

## 练习

* 学生像上面这样类似刷上一些题目。