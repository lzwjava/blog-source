---
audio: false
generated: true
image: false
lang: hant
layout: post
model: x-ai/grok-4-fast
title: AVL 樹概覽
translated: true
type: note
---

### 什麼是 AVL 樹？

AVL 樹是一種**自平衡二元搜尋樹（BST）**，由 Georgy Adelson-Velsky 和 Evgenii Landis 於 1962 年發明（因此得名）。與任何 BST 一樣，它以排序方式儲存資料：左子樹中的所有節點都小於父節點，而右子樹中的所有節點都大於父節點。其關鍵特性在於，它會在插入或刪除操作後自動調整結構以保持平衡。

### 它是如何運作的？

- **平衡因子**：對於每個節點，樹會計算「平衡因子」，即左子樹的高度減去右子樹的高度。此值必須始終為 -1、0 或 +1（即子樹的高度差最多為一層）。
- **用於平衡的旋轉**：如果插入或刪除操作違反了平衡因子：
  - **單旋轉**（左旋或右旋）用於修復違規發生在較近子節點的情況。
  - **雙旋轉**（左右旋或右左旋）用於處理違規發生在較遠子節點的情況。
- 這些旋轉在恢復平衡的同時，保留了 BST 的性質，且每次操作的時間複雜度為 O(1)。

範例：將節點按排序順序插入普通 BST 會使其變成鏈結串列（不平衡）。在 AVL 樹中，旋轉會使其保持大致的高度平衡，如下簡化的前後對比：

```
不平衡（插入節點 1,2,3 後）：
    2
   /
  1
 /
3  （實際上向右傾斜：1->2->3）

旋轉後：
  2
 / \
1   3
```

### 它有什麼特別之處？

- **保證效率**：與普通 BST 在最壞情況下（例如傾斜如串列）可能變成 O(n) 不同，AVL 樹確保了搜尋、插入和刪除操作的平均和最壞情況時間均為 **O(log n)**。這使得它們非常適合需要一致效能的應用，如資料庫或符號表。
- **權衡**：它們比其他平衡樹（如紅黑樹）更嚴格（紅黑樹允許稍微更多的不平衡以換取更快的插入/刪除）。AVL 樹優先考慮搜尋速度而非修改速度。
- **空間**：每個節點需要一個額外欄位來記錄高度/平衡資訊，但這影響輕微。

總之，AVL 樹的「特殊」之處在於其嚴格的自我平衡能力，能將潛在混亂的 BST 轉變為可靠且對數級效能的資料結構。

詳細資訊請參閱：[維基百科上的 AVL 樹](https://en.wikipedia.org/wiki/AVL_tree)