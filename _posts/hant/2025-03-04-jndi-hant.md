---
audio: false
generated: true
lang: hant
layout: post
title: Java 命名與目錄介面
translated: true
type: note
---

### 關鍵要點
- 看起來 `javax.naming` 很可能用於 Java 命名和目錄接口 (JNDI)，用於在數據庫等服務中查找和管理命名物件。
- 研究表明您需要一個初始上下文來開始，通常由 Java EE 應用程序伺服器為生產環境設置，或手動設置用於測試。
- 證據傾向於使用 `InitialContext` 進行查找，例如使用像 "java:comp/env/jdbc/datasource" 這樣的名稱查找 DataSource。

### 開始使用 `javax.naming`
`javax.naming` 是 JNDI 的一部分，可幫助 Java 應用程序與命名和目錄服務互動，例如查找數據庫連接。在 Java EE 環境中，應用程序伺服器通常會設置此功能，從而可以輕鬆地按名稱查找資源。

### 使用示例
以下是在 Java EE 應用程序中查找 DataSource 的簡單方法：
```java
InitialContext ctx = new InitialContext();
DataSource ds = (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
```
這假設 DataSource 已在您的伺服器中配置。對於沒有伺服器的測試，您可能需要額外的庫，例如 Simple-JNDI。

### 意外細節
您可能沒想到，對於獨立應用程序，設置 JNDI 可能需要配置自定義上下文，如果沒有像 Simple-JNDI 這樣的工具，這可能會很複雜。

---

### 調查筆記：使用 `javax.naming` 的完整指南

本筆記詳細探討了如何使用 `javax.naming`，這是 Java 命名和目錄接口 (JNDI) 的一部分，有助於 Java 應用程序與命名和目錄服務的互動。JNDI 旨在獨立於特定的服務實現，允許以統一的方式訪問各種服務，如數據庫、LDAP 和文件系統。本節擴展了直接答案，為開發人員提供了全面的理解，包括設置、示例和不同環境的考慮事項。

#### 理解 `javax.naming` 和 JNDI
`javax.naming` 是 JNDI 的核心套件，作為 Java 標準庫的一部分引入，以提供命名和目錄功能。它定義了 `Context` 接口，這是 JNDI 操作的核心，包括查找、綁定、解除綁定和重命名物件的方法，以及創建和銷毀子上下文。`lookup()` 方法通常用於按名稱檢索物件，使其在企業應用程序的資源訪問中至關重要。

JNDI 在 Java EE 環境中特別有用，它允許應用程序與特定服務細節解耦，從而提高可移植性和靈活性。例如，它通常用於訪問由應用程序伺服器管理的資源，如數據庫連接 (DataSources)、JMS 提供程序和 JavaMail 服務。

#### 設置和使用 JNDI
要使用 `javax.naming`，您首先需要創建一個初始上下文，作為命名操作的入口點。這通常使用 `InitialContext` 類來完成。設置因環境而異：

- **在 Java EE 應用程序中：** 應用程序伺服器（例如 Tomcat、JBoss、WebSphere）配置初始上下文。您可以使用標準的 JNDI 名稱查找資源，通常以 "java:comp/env/" 為前綴。例如，可以通過 "java:comp/env/jdbc/datasource" 訪問 DataSource。
- **在獨立應用程序中：** 沒有應用程序伺服器時，您需要手動配置初始上下文，指定命名服務提供者和 URL 等屬性。這可能很複雜，需要額外的庫進行測試，例如 Simple-JNDI，它提供了內存實現。

以下是總結 `javax.naming` 中關鍵類及其角色的表格：

| 類/接口                 | 角色                                                                 |
|-------------------------|----------------------------------------------------------------------|
| `Context`              | 命名操作的核心接口，如查找、綁定和解除綁定。                           |
| `InitialContext`       | 創建初始上下文以開始 JNDI 操作。                                       |
| `Name`                 | 表示通用名稱，即組件的有序序列。                                       |
| `NamingException`      | 在命名操作期間拋出的異常的基類。                                       |

#### 實際示例
讓我們探討 Java EE 和獨立場景的示例：

##### 示例 1：在 Java EE 中查找 DataSource
在 Java EE 應用程序中，您可能會查找已配置的 DataSource，如下所示：

```java
import javax.naming.InitialContext;
import javax.sql.DataSource;
import java.sql.*;

public class JNDIExample {
    public static void main(String[] args) throws Exception {
        InitialContext ctx = new InitialContext();
        DataSource ds = (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
        Connection conn = ds.getConnection();
        // 使用連接...
        conn.close();
        ctx.close();
    }
}
```

此示例假設 DataSource 已在應用程序伺服器中配置，通常在 Tomcat 的 `context.xml` 等文件中。JNDI 名稱 "java:comp/env/jdbc/datasource" 是標準約定，但可能因伺服器配置而異。

##### 示例 2：綁定和查找自定義物件
對於測試或獨立使用，您可能希望創建一個簡單的內存上下文。雖然標準 API 不包括內存上下文工廠，但像 Simple-JNDI 這樣的庫可以幫助。以下是假設此類設置的概念示例：

```java
import javax.naming.*;

public class JNDIExample {
    public static void main(String[] args) throws NamingException {
        Context ctx = new InitialContext();
        ctx.rebind("myObject", "Hello, World!");
        String value = (String) ctx.lookup("myObject");
        System.out.println(value);
        ctx.close();
    }
}
```

注意：此獨立示例需要配置具有適當屬性的初始上下文，這可能涉及將 `java.naming.factory.initial` 設置為自定義上下文工廠，例如由 Simple-JNDI 提供的工廠。

#### 不同環境的考慮事項
- **生產環境 (Java EE)：** 在生產環境中，應用程序伺服器處理 JNDI 設置，使查找資源變得簡單。通常使用 JNDI 進行數據庫連接池管理，伺服器管理連接，從而提高可擴展性和安全性。例如，更改數據庫憑據僅需要更新伺服器配置，而不需要更改應用程序代碼。
- **測試環境 (獨立)：** 對於單元和集成測試，通常需要在沒有應用程序伺服器的情況下運行。像 Simple-JNDI ([Simple-JNDI GitHub](https://github.com/h-thurow/Simple-JNDI)) 這樣的庫允許您模擬 JNDI 環境，以編程方式綁定資源。這對於測試依賴 JNDI 查找的代碼至關重要，確保其在無需部署到伺服器的情況下正常工作。
- **安全性和最佳實踐：** 注意 JNDI 注入，尤其是在舊版 Java 中，因為它們可能導致遠程代碼執行等安全漏洞。Oracle 已經解決了許多此類問題，例如 Java 8u191 關閉了 LDAP 向量漏洞。始終驗證輸入並使用最新的 Java 版本以確保安全。

#### 意外細節：獨立設置的複雜性
人們可能沒想到在沒有應用程序伺服器的情況下設置 JNDI 所涉及的複雜性。雖然 Java EE 通過伺服器管理的上下文簡化了這一點，但獨立設置需要配置上下文工廠和屬性，通常需要第三方庫。對於剛接觸 JNDI 的開發人員來說，這可能是一個障礙，但像 Simple-JNDI 這樣的工具通過提供基於內存的實現來緩解這一問題。

#### 進一步閱讀和資源
為了更深入的理解，請參考以下資源：
- [Oracle Java 教程：JNDI 概述](https://docs.oracle.com/en/ java/ tutorial/jndi/ overview/index.html) 獲取官方文檔。
- [Baeldung：Java 命名和目錄接口概述](https://www.baeldung.com/jndi) 獲取實際示例和現代用法。
- [Simple-JNDI GitHub](https://github.com/h-thurow/Simple-JNDI) 用於在沒有伺服器的情況下測試 JNDI。

這些資源提供了代碼示例、教程和最佳實踐，確保您可以在各種場景中有效實施 JNDI。

#### 關鍵引用
- [Oracle Java 教程 JNDI 概述](https://docs.oracle.com/en/ java/ tutorial/jndi/ overview/index.html)
- [Baeldung Java 命名和目錄接口概述](https://www.baeldung.com/jndi)
- [Simple-JNDI 通過 JNDI 查找訪問屬性文件](https://github.com/h-thurow/Simple-JNDI)