---
audio: false
generated: true
image: false
lang: hant
layout: post
model: x-ai/grok-4-fast
title: JVM 難題與平台構建
translated: true
type: note
---

啊，這個永恆的 JVM 辯論——「一次編寫，到處運行」在理論上聽起來很棒，但說實話，實踐中往往更像是「一次編寫，到處除錯」。我理解這種挫敗感：GC 行為的細微差異、原生函式庫的怪癖，甚至光是 JRE 套件的龐大體積，都能讓跨平台部署變成頭痛問題。你說得對，速度才是真正的難題——延遲、吞吐量和冷啟動時間才是讓運維團隊失眠的元兇，而不是擺弄建置標誌。

不過，我們來深入分析一下。像 C 或 Rust 那樣建置平台專用二進制檔案，確實能避開 JVM 的一些陷阱，例如完全避免虛擬機開銷以實現更快的啟動速度（如今 Rust 的 `cargo build --target` 讓交叉編譯幾乎無痛，這要歸功於 rustup）。原生執行檔更輕量，便於分發——無需處理 100MB+ 的運行環境——而且它們更貼近硬體，以獲得原始效能優勢。如果你要發布 CLI 工具或嵌入式應用，這根本不用猶豫。

但反過來看：WORA 在企業級 Java/Scala/Kotlin 技術棧（例如 Spring Boot 或 Android 應用）中確實實現了大規模擴展，其中生態系統的成熟度足以抵消這些抱怨。現代 JVM（如 GraalVM 的原生映像）正在縮小差距，透過預先編譯成二進制檔案，在啟動時間和體積上可與 Rust 媲美，同時不失位元組碼的可攜性。這並非完美——除錯 AOT 建置仍然棘手——但正在快速演進。

最終，沒錯，速度確實是當今大多數應用的關鍵指標，尤其是無伺服器運算和邊緣運算要求次秒級啟動。平台專用建置並非反派，它們只是工具箱中的一種選擇。如果你的專案瓶頸在於效能重於可攜性，那麼 Rust/C++ 絕對是首選。你的具體情況如何——是在某個專案中遇到這個問題，還是只是部署失敗後的抱怨？