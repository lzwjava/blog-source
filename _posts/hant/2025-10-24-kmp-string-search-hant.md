---
audio: false
generated: true
image: false
lang: hant
layout: post
model: x-ai/grok-4-fast
title: KMP 演算法高效字串搜尋
translated: true
type: note
---

### 理解 Knuth-Morris-Pratt (KMP) 演算法

你的直覺完全正確：KMP 的核心在於**不浪費部分匹配**的字串搜尋過程。當你在較長文字（例如 "ababcabc"）中尋找模式（例如 "abc"）時，樸素方法每次遇到不匹配時都會從頭開始重新比對，效率很低。KMP 聰明地「記住」你已經匹配了多少模式內容，然後跳躍前進，避免重複比較。這使得它非常快速——線性時間複雜度 O(n + m)，其中 n 是文字長度，m 是模式長度。

我將透過一個簡單範例逐步拆解。我們將在文字 `T = "ababababc"` 中搜尋模式 `P = "abab"`。（它出現在位置 0 和 2。）

#### 第一步：問題與樸素方法
- **目標**：找出所有 `P` 在 `T` 中完全匹配的起始位置。
- **樸素方式**：將 `P` 滑過 `T`，逐字元比較。如果在 `P` 的位置 i 不匹配，則將 `P` 移動 1 位，並從 `P` 的開頭重新開始。
  - 以我們的範例為例：
    - 從 T[0] 開始："a"=="a"（匹配），"b"=="b"（匹配），"a"=="a"（匹配），"b"=="b"（匹配）→ 在 0 處找到。
    - 移動到 T[1]："b"=="a"？否 → 從 `P` 開頭重新開始。浪費！
    - T[2]："a"=="a"，"b"=="b"，"a"=="a"，"b"=="b" → 在 2 處找到。
    - T[3]："a"=="a"，"b"=="b"，"a"=="a"，"b"=="a"？否 → 重新開始。
    - 依此類推。大量回溯到 `P` 的字元 0。

在最壞情況下（例如在 "aaaaa...a" 中搜尋 "aaa...ab"），這可能達到 O(n*m) 的時間複雜度。

#### 第二步：KMP 的關鍵概念——前綴表（或「失敗函數」）
KMP 預先計算模式 `P` 的一個表格 `π`（pi）。這個表格告訴你，對於 `P` 中的每個位置 i，**`P[0..i]` 的最長真前綴同時也是後綴**。換句話說：「如果我們在這裡不匹配，我們可以透過跳轉到這個重疊的前綴來重複使用多少部分匹配？」

- **真前綴/後綴**：不是整個字串的前綴/後綴（例如，對於 "aba"，前綴 "a" 匹配後綴 "a"）。
- 為什麼？它讓你在不匹配時能夠以超過 1 的距離「滑動」模式，重複使用重疊部分而不是重新開始。

對於 `P = "abab"`：
- 逐步建立 `π`（我們稍後會編寫程式碼）。

| 位置 i | P[0..i] | 最長真前綴 = 後綴 | π[i] |
|--------|---------|-------------------|------|
| 0      | "a"     | 無（單一字元）    | 0    |
| 1      | "ab"    | 無                | 0    |
| 2      | "aba"   | "a"（前綴 "a" == 後綴 "a"） | 1 |
| 3      | "abab"  | "ab"（前綴 "ab" == 後綴 "ab"） | 2 |

- π[2] = 1 表示：如果你匹配了 "aba" 但下一個字元不匹配，假設你目前匹配了前綴 "a"（長度 1）。
- π[3] = 2 表示：對於完整的 "abab"，重疊部分為 "ab"。

#### 第三步：建立前綴表（π）
這在 O(m) 時間內完成。它類似於使用相似邏輯將 `P` 與自身進行搜尋。

虛擬碼：
```
def compute_prefix_function(P):
    m = len(P)
    pi = [0] * m
    k = 0  # 目前前綴-後綴匹配的長度
    for i in range(1, m):
        while k > 0 and P[k] != P[i]:
            k = pi[k-1]  # 跳轉到先前的重疊部分（重複使用！）
        if P[k] == P[i]:
            k += 1
        pi[i] = k
    return pi
```

- 從 π[0] = 0 開始。
- 對於每個 i=1 到 m-1：
  - 嘗試擴展目前的匹配長度 k。
  - 如果不匹配，則回退到 π[k-1]（不要浪費——重複使用先前的重疊部分）。
  - 如果匹配，則 k++。

對於 "abab"：
- i=1：P[0]='a' != P[1]='b' → k=0，π[1]=0。
- i=2：P[0]='a' == P[2]='a' → k=1，π[2]=1。
- i=3：P[1]='b' == P[3]='b' → k=2，π[3]=2。

#### 第四步：使用前綴表進行搜尋
現在使用 `P` 和 `π` 搜尋 `T`：
- 保持一個變數 `q` = 目前狀態（目前匹配的前綴長度）。
- 對於 `T` 中的每個字元：
  - 當不匹配且 q>0 時，設定 q = π[q-1]（聰明地跳回）。
  - 如果匹配，則 q++。
  - 如果 q == m，找到匹配！然後 q = π[q-1] 以繼續搜尋重疊部分。

虛擬碼：
```
def kmp_search(T, P):
    n, m = len(T), len(P)
    if m == 0: return []
    pi = compute_prefix_function(P)
    q = 0
    matches = []
    for i in range(n):
        while q > 0 and P[q] != T[i]:
            q = pi[q-1]
        if P[q] == T[i]:
            q += 1
        if q == m:
            matches.append(i - m + 1)  # 起始位置
            q = pi[q-1]  # 用於下一次搜尋的重疊部分
    return matches
```

對於 `T = "ababababc"`，`P = "abab"`：
- i=0：'a'=='a' → q=1
- i=1：'b'=='b' → q=2
- i=2：'a'=='a' → q=3
- i=3：'b'=='b' → q=4 == m → 在 0 處匹配，q=π[3]=2
- i=4：現在 q=2，T[4]='a' == P[2]='a' → q=3
- i=5：'b'=='b' → q=4 == m → 在 2 處匹配，q=2
- i=6：q=2，'a'=='a' → q=3
- i=7：q=3，'b' != P[3]='b'？等等，'b'=='b' → q=4 == m？但 T[7]='b'，等等不對：T="ababababc"，i=6='a'（q=3），i=7='b'==P[3]='b' → q=4，但下一個 i=8='c'。
- 實際上：在 i=5（位置 2）第二次匹配後，q=2，i=6='a'==P[2]='a' q=3，i=7='b'==P[3]='b' q=4 → 在 4 處匹配？等等，讓我們完整追蹤。

等等，追蹤修正（完整執行會得到在 0 和 2 處的匹配；在 i=7：在 i=7 時 q=4？不對：
- 直到 i=3：匹配，q=2
- i=4：T[4]='a'（在 "ababa" 之後），P[2]='a' 是 q=3
- i=5：T[5]='b' P[3]='b' q=4 → 在 2 處匹配（5-4+1=2），q=π[3]=2
- i=6：T[6]='a' P[2]='a' q=3
- i=7：T[7]='b' P[3]='b' q=4 → 應該在 4 處匹配，但 T[4:8]="abab" 是的！等等，T="a b a b a b a b c" 位置 0-8。
- T[4:8] = "abab" 是的，但在我的 T="ababababc" 中，是的，位置 4-7：a(4)b(5)a(6)b(7) = "abab" → 在 4 處第三次匹配。
- 然後 i=8：'c' != P[4]？但 m=4，匹配後 q=2，但由於結束，沒有更多。

等等，實際上對於這個 T，匹配在 0,2,4。是的！

看到了嗎？在不匹配時（例如如果有不匹配），它會跳轉 q=π[q-1] 而不是 q=0。

#### 為什麼它感覺很神奇
- 在 `T` 中沒有回溯——你只向前移動。
- 用於不匹配的「while」迴圈總共攤還執行 O(1) 次，因為每次跳轉都會減少 q，而 q 最多增加 n 次。

#### 自己試試：簡單的 Python 程式碼
```python
def compute_prefix_function(P):
    m = len(P)
    pi = [0] * m
    k = 0
    for i in range(1, m):
        while k > 0 and P[k] != P[i]:
            k = pi[k - 1]
        if P[k] == P[i]:
            k += 1
        pi[i] = k
    return pi

def kmp_search(T, P):
    n, m = len(T), len(P)
    if m == 0: return []
    pi = compute_prefix_function(P)
    q = 0
    matches = []
    for i in range(n):
        while q > 0 and P[q] != T[i]:
            q = pi[q - 1]
        if P[q] == T[i]:
            q += 1
        if q == m:
            matches.append(i - m + 1)
            q = pi[q - 1]
    return matches

# 測試
T = "ababababc"
P = "abab"
print(kmp_search(T, P))  # 輸出：[0, 2, 4]
```

執行這個——調整 P/T 以觀察跳轉行為（為 q 添加列印）。

#### 常見陷阱與提示
- π[0] 總是 0。
- 對於沒有自我重疊的模式（例如 "abc"），π 全部為 0——回退到樸素方法。
- 非常適合 DNA 序列或程式碼自動完成。
- 如果仍然模糊，將 π 視覺化為一個「狀態機」：每個狀態是匹配的長度，根據匹配/不匹配進行轉換。

現在應該明白了——它只是透過預先計算的重疊部分進行聰明的跳過。如果你有具體的範例讓你困惑，分享出來！

[GeeksforGeeks: KMP Algorithm](https://www.geeksforgeeks.org/dsa/kmp-algorithm-for-pattern-searching/)  
[Wikipedia: Knuth–Morris–Pratt Algorithm](https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm)