---
lang: hant
layout: post
title: 深入解析Android中的自定义绘图
---

*本博客文章在ChatGPT-4o的協助下編寫。*

---

### 介绍

在这篇博客中，我们将深入探讨`DrawActivity`类，这是一个在Android应用中实现自定义绘图视图的完整示例。我们将逐一剖析每个组件及其采用的算法，详细阐述它们是如何协同运作，以实现预期的功能。

---

### 目錄
[DrawActivity概述](#DrawActivity概述)  
[初始化Activity](#初始化Activity)  
[處理圖像操作](#處理圖像操作)  
[Fragment管理](#Fragment管理)  
[事件處理](#事件處理)  
[撤銷和重做功能](#撤銷和重做功能)  
[自定義DrawView](#自定義DrawView)  
[歷史管理](#歷史管理)  
[結論](#結論)

---

### DrawActivity概述

DrawActivity是一个用于绘制图形或进行手写输入的应用程序组件。它通常包含一个画布（Canvas）和一系列工具，允许用户通过触摸屏幕来绘制线条、形状或进行其他形式的创作。DrawActivity可以用于各种场景，如笔记应用、绘图软件、教育工具等。

#### 主要功能
1. **画布绘制**：提供一块空白区域，用户可以在上面自由绘制。
2. **工具选择**：提供多种绘图工具，如画笔、橡皮擦、形状工具等。
3. **颜色选择**：允许用户选择不同的颜色进行绘制。
4. **撤销/重做**：支持撤销和重做操作，方便用户修改作品。
5. **保存/分享**：允许用户将绘制的作品保存到本地或分享给他人。

#### 技术实现
DrawActivity通常基于Android的View和Canvas类实现。通过重写`onDraw()`方法，可以在画布上绘制各种图形。触摸事件的处理则通过重写`onTouchEvent()`方法来实现，以捕捉用户的手指移动并实时更新画布内容。

#### 示例代码
以下是一个简单的DrawActivity实现示例：

```java
public class DrawActivity extends AppCompatActivity {
    private DrawView drawView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        drawView = new DrawView(this);
        setContentView(drawView);
    }

    private class DrawView extends View {
        private Paint paint;
        private Path path;

        public DrawView(Context context) {
            super(context);
            paint = new Paint();
            paint.setColor(Color.BLACK);
            paint.setStyle(Paint.Style.STROKE);
            paint.setStrokeWidth(5);
            path = new Path();
        }

        @Override
        protected void onDraw(Canvas canvas) {
            canvas.drawPath(path, paint);
        }

        @Override
        public boolean onTouchEvent(MotionEvent event) {
            float x = event.getX();
            float y = event.getY();

            switch (event.getAction()) {
                case MotionEvent.ACTION_DOWN:
                    path.moveTo(x, y);
                    break;
                case MotionEvent.ACTION_MOVE:
                    path.lineTo(x, y);
                    break;
                case MotionEvent.ACTION_UP:
                    // 绘制结束
                    break;
            }
            invalidate();
            return true;
        }
    }
}
```

#### 总结
DrawActivity是一个功能强大且灵活的组件，适用于各种需要用户绘制的应用场景。通过合理的设计和实现，可以为用户提供流畅的绘图体验。

`DrawActivity` 是负责处理绘图操作、图像裁剪以及与其他组件（如fragment和图像上传）交互的主要活动。它提供了一个用户界面，用户可以在其中进行绘图、撤销、重做以及操作图像。

```java
public class DrawActivity extends Activity implements View.OnClickListener {
  // 請求代碼和fragment ID的常量
  public static final int CAMERA_RESULT = 1;
  public static final int CROP_RESULT = 2;
  public static final int DRAW_FRAGMENT = 0;
  public static final int RECOG_FRAGMENT = 1;
  public static final int RESULT_FRAGMENT = 2;
  public static final int WAIT_FRAGMENT = 3;
  public static final int MATERIAL_RESULT = 4;
  public static final String RESULT_JSON = "resultJson";
  public static final int INIT_FLOWER_ID = R.drawable.flower_b;
  public static final int LOGOUT = 0;
  public static final int IMAGE_RESULT = 0;
  
  // 處理圖像和繪圖操作的變量
  String baseUrl;
  DrawView drawView;
  Bitmap originImg;
  public static DrawActivity instance;
  View dir, clear, cameraView, materialView, scale;
  ImageView undoView, redoView;
  View upload;
  String cropPath;
  Tooltip toolTip;
  int curFragmentId = -1;
  int serverId = -1;
  private Bitmap resultBitmap;
  private RadioGroup radioGroup;
  Fragment curFragment;
  int curDrawMode;
  RadioButton drawBackBtn;
  private Activity cxt;
  Uri curPicUri;
}
```

---

### 初始化Activity

在Activity创建时，执行各种初始化操作，例如设置视图、加载初始图像以及配置事件监听器。

```java
@Override
protected void onCreate(Bundle savedInstanceState) {
  super.onCreate(savedInstanceState);
  instance = this;
  cxt = this;
  cropPath = PathUtils.getCropPath();
  setContentView(R.layout.draw_layout);
  findView();
  setSize();
  initOriginImage();
  toolTip = new Tooltip(this);
  initUndoRedoEnable();
  setIp();
  initDrawmode();
}
```

這段代碼是Android應用程式中的一個`onCreate`方法，屬於Activity的生命週期方法之一。當Activity被創建時，這個方法會被調用。以下是代碼的詳細解釋：

1. **`super.onCreate(savedInstanceState);`**: 調用父類的`onCreate`方法，確保Activity的正常初始化。

2. **`instance = this;`**: 將當前Activity的實例賦值給`instance`變量，通常用於單例模式或全局訪問。

3. **`cxt = this;`**: 將當前Activity的上下文賦值給`cxt`變量，通常用於需要上下文的地方。

4. **`cropPath = PathUtils.getCropPath();`**: 調用`PathUtils`類的`getCropPath`方法，獲取裁剪路徑並賦值給`cropPath`變量。

5. **`setContentView(R.layout.draw_layout);`**: 設置Activity的佈局文件為`draw_layout.xml`。

6. **`findView();`**: 調用`findView`方法，通常用於查找佈局文件中的視圖元素並賦值給相應的變量。

7. **`setSize();`**: 調用`setSize`方法，通常用於設置視圖的大小或相關尺寸。

8. **`initOriginImage();`**: 調用`initOriginImage`方法，通常用於初始化原始圖片或相關資源。

9. **`toolTip = new Tooltip(this);`**: 創建一個`Tooltip`對象，並將當前Activity的上下文傳遞給它。

10. **`initUndoRedoEnable();`**: 調用`initUndoRedoEnable`方法，通常用於初始化撤銷和重做功能的可用性。

11. **`setIp();`**: 調用`setIp`方法，通常用於設置IP地址或相關網絡配置。

12. **`initDrawmode();`**: 調用`initDrawmode`方法，通常用於初始化繪圖模式或相關設置。

這段代碼的主要功能是初始化Activity的各個組件和資源，確保應用程式在啟動時能夠正常運行。

**findView()**  
此方法用於初始化Activity中所使用的視圖。

```java
private void findView() {
  drawView = findViewById(R.id.drawView); // 查找绘图视图
  undoView = findViewById(R.id.undo); // 查找撤销按钮
  redoView = findViewById(R.id.redo); // 查找重做按钮
  scale = findViewById(R.id.scale); // 查找缩放控件
  upload = findViewById(R.id.upload); // 查找上传按钮
  clear = findViewById(R.id.clear); // 查找清除按钮
  dir = findViewById(R.id.dir); // 查找方向控件
  materialView = findViewById(R.id.material); // 查找材质视图
  cameraView = findViewById(R.id.camera); // 查找相机视图
}
```

```java
dir.setOnClickListener(this);
materialView.setOnClickListener(this);
undoView.setOnClickListener(this);
scale.setOnClickListener(this);
redoView.setOnClickListener(this);
clear.setOnClickListener(this);
cameraView.setOnClickListener(this);
upload.setOnClickListener(this);
initRadio();
```
```traditional_chinese
dir.setOnClickListener(this);
materialView.setOnClickListener(this);
undoView.setOnClickListener(this);
scale.setOnClickListener(this);
redoView.setOnClickListener(this);
clear.setOnClickListener(this);
cameraView.setOnClickListener(this);
upload.setOnClickListener(this);
initRadio();
```

**setSize()**  
設置繪圖視圖的大小。

```java
private void setSize() {
  setSizeByResourceSize(); // 根据资源大小设置尺寸
  setViewSize(drawView);   // 设置视图大小
}
```

private void setSizeByResourceSize() {
  int width = getResources().getDimensionPixelSize(R.dimen.draw_width);
  int height = getResources().getDimensionPixelSize(R.dimen.draw_height);
  App.drawWidth = width;
  App.drawHeight = height;
}

```java
private void setViewSize(View v) {
  ViewGroup.LayoutParams lp = v.getLayoutParams();
  lp.width = App.drawWidth;
  lp.height = App.drawHeight;
  v.setLayoutParams(lp);
}
```

**initOriginImage()**  
加载用於繪圖的初始圖像。

```java
private void initOriginImage() {
  // 从资源中解码出初始花朵图片的位图
  Bitmap bitmap = BitmapFactory.decodeResource(getResources(), INIT_FLOWER_ID);
  // 获取相机路径
  String imgPath = PathUtils.getCameraPath();
  // 将位图保存到指定路径
  BitmapUtils.saveBitmapToPath(bitmap, imgPath);
  // 根据文件路径创建Uri
  Uri uri1 = Uri.fromFile(new File(imgPath));
  // 通过Uri设置图片
  setImageByUri(uri1);
}
```

---

### 處理影像操作

Activity负责处理各种图像操作，例如通过URI设置图像、裁剪以及保存绘制的位图。

**setImageByUri(Uri uri)**  
從給定的URI加載圖像並準備繪圖。

```java
private void setImageByUri(final Uri uri) {
  new Handler().postDelayed(new Runnable() {
    @Override
    public void run() {
      curPicUri = uri;
      Bitmap bitmap = null;
      try {
        if (uri != null) {
          bitmap = BitmapUtils.getBitmapByUri(DrawActivity.this, uri);
        }
      } catch (Exception e) {
        e.printStackTrace();
      }
```

```java
int originW = bitmap.getWidth();
int originH = bitmap.getHeight();
if (originW != App.drawWidth || originH != App.drawHeight) {
    float originRadio = originW * 1.0f / originH;
    float radio = App.drawWidth * 1.0f / App.drawHeight;
    if (Math.abs(originRadio - radio) < 0.01) {
        Bitmap originBm = bitmap;
        bitmap = Bitmap.createScaledBitmap(originBm, App.drawWidth, App.drawHeight, false);
        originBm.recycle();
    } else {
        cropIt(uri);
        return;
    }
}
ImageLoader imageLoader = ImageLoader.getInstance();
imageLoader.addOrReplaceToMemoryCache("origin", bitmap);
originImg = bitmap;
serverId = -1;
```

翻譯如下：

```java
int originW = bitmap.getWidth();
int originH = bitmap.getHeight();
if (originW != App.drawWidth || originH != App.drawHeight) {
    float originRadio = originW * 1.0f / originH;
    float radio = App.drawWidth * 1.0f / App.drawHeight;
    if (Math.abs(originRadio - radio) < 0.01) {
        Bitmap originBm = bitmap;
        bitmap = Bitmap.createScaledBitmap(originBm, App.drawWidth, App.drawHeight, false);
        originBm.recycle();
    } else {
        cropIt(uri);
        return;
    }
}
ImageLoader imageLoader = ImageLoader.getInstance();
imageLoader.addOrReplaceToMemoryCache("origin", bitmap);
originImg = bitmap;
serverId = -1;
```

這段程式碼的主要功能是檢查圖片的寬高是否符合應用程式的繪製寬高要求。如果不符合，則根據寬高比進行縮放或裁剪處理，並將處理後的圖片存入記憶體快取中。

```java
drawView.setSrcBitmap(originImg);
showDrawFragment(App.ALL_INFO);
curDrawMode = App.DRAW_FORE;
```
```java
}, 500);
}
```

翻譯成繁體中文：

```java
drawView.setSrcBitmap(originImg);
showDrawFragment(App.ALL_INFO);
curDrawMode = App.DRAW_FORE;
```
```java
}, 500);
}
```

這段程式碼的功能是設置繪圖視圖的原始圖片，顯示繪圖片段，並將當前的繪圖模式設置為前景繪製模式。整個操作在500毫秒後執行。

**cropIt(Uri uri)**  
啟動圖像裁剪活動。

```java
public void cropIt(Uri uri) {
  Crop.startPhotoCrop(this, uri, cropPath, CROP_RESULT);
}
```

**saveBitmap()**  
將繪製的位圖保存到文件並上傳到伺服器。

```java
public void saveBitmap() {
  Bitmap handBitmap = drawView.getHandBitmap();
  Bitmap originBitmap = drawView.getSrcBitmap();
  saveBitmapToFileAndUpload(handBitmap, originBitmap);
}
```

翻譯成繁體中文：

```java
public void saveBitmap() {
  Bitmap handBitmap = drawView.getHandBitmap();
  Bitmap originBitmap = drawView.getSrcBitmap();
  saveBitmapToFileAndUpload(handBitmap, originBitmap);
}
```

這段程式碼的功能是將繪製的圖像保存並上傳。具體來說，它從 `drawView` 中獲取手繪的圖像 (`handBitmap`) 和原始圖像 (`originBitmap`)，然後將這些圖像保存到文件並上傳。

**saveBitmapToFileAndUpload(Bitmap handBitmap, Bitmap originBitmap)**  
将位图保存到文件并异步上传。

```java
private void saveBitmapToFileAndUpload(Bitmap handBitmap, Bitmap originBitmap) {
  final String originPath = PathUtils.getOriginPath();
  BitmapUtils.saveBitmapToPath(originBitmap, originPath);
  final String handPath = PathUtils.getHandPath();
  BitmapUtils.saveBitmapToPath(handBitmap, handPath);
  new AsyncTask<Void, Void, Void>() {
    boolean res;
    Bitmap foreBitmap;
    Bitmap backBitmap;
```

    @Override
    protected void onPreExecute() {
      super.onPreExecute();
      显示等待片段();
    }

    @Override
    protected Void doInBackground(Void... params) {
      try {
        if (baseUrl == null) {
          throw new Exception("baseUrl 為空");
        }
        String jsonRes = UploadImage.upload(baseUrl, serverId, Web.STATUS_CONTINUE, originPath, handPath, null, false);
        getJsonData(jsonRes);
        res = true;
      } catch (Exception e) {
        res = false;
        e.printStackTrace();
      }
      return null;
    }

```java
private void getJsonData(String jsonRes) throws Exception {
    JSONObject json = new JSONObject(jsonRes);
    if (serverId == -1) {
        serverId = json.getInt(Web.ID);
    }
    String foreUrl = json.getString(Web.FORE);
    String backUrl = json.getString(Web.BACK);
    String resultUrl = json.getString(Web.RESULT);
    foreBitmap = Web.getBitmapFromUrlByStream1(foreUrl, 0);
    backBitmap = Web.getBitmapFromUrlByStream1(backUrl, 0);
    resultBitmap = Web.getBitmapFromUrlByStream1(resultUrl, 0);
}
```

這段程式碼的功能是從一個JSON字符串中提取數據，並根據提取的URL獲取對應的位圖（Bitmap）。以下是程式碼的詳細解釋：

1. **解析JSON字符串**：首先，將傳入的JSON字符串`jsonRes`解析成一個`JSONObject`對象`json`。

2. **獲取服務器ID**：如果`serverId`的值為-1，則從JSON對象中獲取名為`Web.ID`的整數值，並將其賦值給`serverId`。

3. **獲取URL**：從JSON對象中分別獲取名為`Web.FORE`、`Web.BACK`和`Web.RESULT`的字符串值，並將其分別賦值給`foreUrl`、`backUrl`和`resultUrl`。

4. **獲取位圖**：使用`Web.getBitmapFromUrlByStream1`方法，根據獲取的URL分別獲取對應的位圖，並將其賦值給`foreBitmap`、`backBitmap`和`resultBitmap`。

這段程式碼的主要作用是從JSON數據中提取必要的URL，並根據這些URL獲取對應的位圖資源。

    @Override
    protected void onPostExecute(Void aVoid) {
      super.onPostExecute(aVoid);
      if (res) {
        showRecogFragment(foreBitmap, backBitmap);
      } else {
        Utils.toast(DrawActivity.this, R.string.server_error);
        recogNo();
      }
    }

```javascript
}.execute();
}
```

---

### 片段管理

Activity负责管理不同的fragment，以应对应用的各种状态，例如绘图、识别和等待。

**showDrawFragment(int infoId)**  
顯示繪圖fragment。

```java
private void showDrawFragment(int infoId) {
  curFragmentId = DRAW_FRAGMENT;
  curFragment = new DrawFragment(infoId);
  showFragment(curFragment);
}
``` 

這段程式碼的功能是顯示一個繪圖片段（DrawFragment）。以下是其步驟：

1. **設定當前片段ID**：將 `curFragmentId` 設為 `DRAW_FRAGMENT`，這是一個代表繪圖片段的常數。
2. **創建新的繪圖片段**：使用傳入的 `infoId` 創建一個新的 `DrawFragment` 實例，並將其賦值給 `curFragment`。
3. **顯示片段**：調用 `showFragment` 方法來顯示剛剛創建的 `curFragment`。

這段程式碼的主要目的是在應用程式中顯示一個特定的繪圖片段，並確保當前片段ID和片段實例被正確更新。

**showWaitFragment()**  
顯示等待的fragment。

```java
private void showWaitFragment() {
  curFragmentId = WAIT_FRAGMENT;
  showFragment(new WaitFragment());
}
```

翻譯成繁體中文：

```java
private void showWaitFragment() {
  curFragmentId = WAIT_FRAGMENT;
  showFragment(new WaitFragment());
}
```

在這個例子中，程式碼本身是通用的，不需要翻譯。如果你需要的是對程式碼功能的解釋，可以這樣描述：

這個方法 `showWaitFragment()` 用於顯示一個等待的片段（Fragment）。首先，它將當前的片段 ID 設置為 `WAIT_FRAGMENT`，然後調用 `showFragment()` 方法來顯示一個新的 `WaitFragment` 實例。

**showFragment(Fragment fragment)**  
以指定的fragment替換當前的fragment。

```java
private void showFragment(Fragment fragment) {
  FragmentTransaction trans = getFragmentManager().beginTransaction();
  trans.replace(R.id.rightLayout, fragment);
  trans.commit();
}
```

這段程式碼是用來顯示一個Fragment的。以下是它的中文解釋：

```java
private void showFragment(Fragment fragment) {
  // 開始一個Fragment事務
  FragmentTransaction trans = getFragmentManager().beginTransaction();
  
  // 將指定的Fragment替換到ID為rightLayout的容器中
  trans.replace(R.id.rightLayout, fragment);
  
  // 提交事務，使替換操作生效
  trans.commit();
}
```

這段程式碼的主要功能是將一個指定的Fragment替換到當前Activity中的某個容器（通常是FrameLayout）中，並提交這個變更。

---

### 事件处理

Activity负责处理各种用户交互，例如按钮点击和菜单选择。

**onClick(View v)**  
處理不同視圖的點擊事件。

```java
@Override
public void onClick(View v) {
  int id = v.getId();
  if (id == R.id.drawOk) {
    if (drawView.isDrawFinish()) {
      saveBitmap();
    } else {
      Utils.alertDialog(this, R.string.please_draw_finish);
    }
  } else if (id == R.id.recogOk) {
    recogOk();
  } else if (id == R.id.recogNo) {
    recogNo();
  } else if (id == R.id.dir) {
    Utils.getGalleryPhoto(this, IMAGE_RESULT);
  } else if (id == R.id.clear) {
    clearEverything();
  } else if (id == R.id.undo) {
    drawView.undo();
  } else if (id == R.id.redo) {
    drawView.redo();
  } else if (id == R.id.camera) {
    Utils.takePhoto(cxt, CAMERA_RESULT);
  } else if (id == R.id.material) {
    goMaterial();
  } else if (id == R.id.upload) {
    com.lzw.commons.Utils.goActivity(cxt, PhotoActivity.class);
  } else if (id == R.id.scale) {
    cropIt(curPicUri);
  }
}
```

**onActivityResult(int requestCode, int resultCode, Intent data)**  
處理其他活動的結果，例如圖像選擇或裁剪。

```java
@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
  if (resultCode != RESULT_CANCELED) {
    Uri uri;
    switch (requestCode) {
      case IMAGE_RESULT:
        if (data != null) {
          setImageByUri(data.getData());
        }
        break;
      case CAMERA_RESULT:
        setImageByUri(Utils.getCameraUri());
        break;
      case CROP_RESULT:
        uri = Uri.fromFile(new File(cropPath));
        setImageByUri(uri);
        break;
      case MATERIAL_RESULT:
        setImageByUri(data.getData());
    }
  }
}
```

---

### 撤销与重做功能

Activity提供绘图操作的撤销和重做功能。

**initUndoRedoEnable()**  
通過設置回調函數來初始化撤銷和重做功能。

```java
void initUndoRedoEnable() {
  drawView.history.setCallBack(new History.CallBack() {
    @Override
    public void onHistoryChanged() {
      setUndoRedoEnable();
      if (curFragmentId != DRAW_FRAGMENT) {
        showDrawFragment(curDrawMode);
      }
    }
  });
}
```

翻譯成繁體中文：

```java
void initUndoRedoEnable() {
  drawView.history.setCallBack(new History.CallBack() {
    @Override
    public void onHistoryChanged() {
      setUndoRedoEnable();
      if (curFragmentId != DRAW_FRAGMENT) {
        showDrawFragment(curDrawMode);
      }
    }
  });
}
```

在這個方法中，我們初始化了撤銷和重做的功能。`drawView.history.setCallBack` 設置了一個回調，當歷史記錄發生變化時，會調用 `onHistoryChanged` 方法。在這個方法中，我們首先調用 `setUndoRedoEnable` 來更新撤銷和重做按鈕的狀態，然後檢查當前的片段 ID 是否不等於 `DRAW_FRAGMENT`，如果是，則顯示繪圖片段並傳入當前的繪圖模式 `curDrawMode`。

```c
void setUndoRedoEnable() {
  redoView.setEnabled(drawView.history.canRedo());
  undoView.setEnabled(drawView.history.canUndo());
}
```

---

### 自定义DrawView

`DrawView` 是一个自定义视图，用于处理绘图操作、触摸事件和缩放功能。

**onTouchEvent(MotionEvent event)**  
處理繪圖和縮放的觸控事件。

```java
@Override
public boolean onTouchEvent(MotionEvent event) {
  if (!scaleMode) {
    handleDrawTouchEvent(event);
  } else {
    handleScaleTouchEvent(event);
  }
  return true;
}
```

翻譯如下：

```java
@Override
public boolean onTouchEvent(MotionEvent event) {
  if (!scaleMode) {
    handleDrawTouchEvent(event); // 處理繪圖觸摸事件
  } else {
    handleScaleTouchEvent(event); // 處理縮放觸摸事件
  }
  return true;
}
```

private void handleDrawTouchEvent(MotionEvent event) {
  int action = event.getAction();
  float x = event.getX();
  float y = event.getY();
  if (action == MotionEvent.ACTION_DOWN) {
    path.moveTo(x, y);
  } else if (action == MotionEvent.ACTION_MOVE) {
    path.quadTo(preX, preY, x, y);
  } else if (action == MotionEvent.ACTION_UP) {
    Matrix matrix1 = new Matrix();
    matrix.invert(matrix1);
    path.transform(matrix1);
    paint.setStrokeWidth(strokeWidth * 1.0f / totalRatio);
    history.saveToStack(path, paint);
    cacheCanvas.drawPath(path, paint);
    paint.setStrokeWidth(strokeWidth);
    path.reset();
  }
  setPrev(event);
  invalidate();
}

```java
private void handleScaleTouchEvent(MotionEvent event) {
  switch (event.getActionMasked()) {
    case MotionEvent.ACTION_POINTER_DOWN:
      lastFingerDist = calFingerDistance(event);
      break;
    case MotionEvent.ACTION_MOVE:
      if (event.getPointerCount() == 1) {
        handleMove(event);
      } else if (event.getPointerCount() == 2) {
        handleZoom(event);
      }
      break;
    case MotionEvent.ACTION_UP:
    case MotionEvent.ACTION_POINTER_UP:
      lastMoveX = -1;
      lastMoveY = -1;
      break;
    default:
      break;
  }
}
```

```java
private void handleScaleTouchEvent(MotionEvent event) {
  switch (event.getActionMasked()) {
    case MotionEvent.ACTION_POINTER_DOWN:
      lastFingerDist = calFingerDistance(event);
      break;
    case MotionEvent.ACTION_MOVE:
      if (event.getPointerCount() == 1) {
        handleMove(event);
      } else if (event.getPointerCount() == 2) {
        handleZoom(event);
      }
      break;
    case MotionEvent.ACTION_UP:
    case MotionEvent.ACTION_POINTER_UP:
      lastMoveX = -1;
      lastMoveY = -1;
      break;
    default:
      break;
  }
}
```

private void handleMove(MotionEvent event) {
  float moveX = event.getX();
  float moveY = event.getY();
  if (lastMoveX == -1 && lastMoveY == -1) {
    lastMoveX = moveX;
    lastMoveY = moveY;
  }
  moveDistX = (int) (moveX - lastMoveX);
  moveDistY = (int) (moveY - lastMoveY);
  if (moveDistX + totalTranslateX > 0 || moveDistX + totalTranslateX + curBitmapWidth < width) {
    moveDistX = 0;
  }
  if (moveDistY + totalTranslateY > 0 || moveDistY + totalTranslateY + curBitmapHeight < height) {
    moveDistY = 0;
  }
  status = STATUS_MOVE;
  invalidate();
  lastMoveX = moveX;
  lastMoveY = moveY;
}

```java
private void handleZoom(MotionEvent event) {
  float fingerDist = calFingerDistance(event);
  calFingerCenter(event);
  if (fingerDist > lastFingerDist) {
    status = STATUS_ZOOM_OUT;
  } else {
    status = STATUS_ZOOM_IN;
  }
  scaledRatio = fingerDist * 1.0f / lastFingerDist;
  totalRatio = totalRatio * scaledRatio;
  if (totalRatio < initRatio) {
    totalRatio = initRatio;
  } else if (totalRatio > initRatio * 4) {
    totalRatio = initRatio * 4;
  }
  lastFingerDist = fingerDist;
  invalidate();
}
```

翻譯如下：

```java
private void handleZoom(MotionEvent event) {
  // 計算手指間的距離
  float fingerDist = calFingerDistance(event);
  // 計算手指的中心點
  calFingerCenter(event);
  // 判斷是放大還是縮小
  if (fingerDist > lastFingerDist) {
    status = STATUS_ZOOM_OUT;
  } else {
    status = STATUS_ZOOM_IN;
  }
  // 計算縮放比例
  scaledRatio = fingerDist * 1.0f / lastFingerDist;
  // 更新總縮放比例
  totalRatio = totalRatio * scaledRatio;
  // 限制縮放比例在最小和最大範圍內
  if (totalRatio < initRatio) {
    totalRatio = initRatio;
  } else if (totalRatio > initRatio * 4) {
    totalRatio = initRatio * 4;
  }
  // 更新上一次的手指距離
  lastFingerDist = fingerDist;
  // 重繪視圖
  invalidate();
}
```

**onDraw(Canvas canvas)**  
繪製視圖的當前狀態。

```java
@Override
protected void onDraw(Canvas canvas) {
  super.onDraw(canvas);
  if (scaleMode) {
    switch (status) {
      case STATUS_MOVE:
        move(canvas);
        break;
      case STATUS_ZOOM_IN:
      case STATUS_ZOOM_OUT:
        zoom(canvas);
        break;
      default:
        if (cacheBm != null) {
          canvas.drawBitmap(cacheBm, matrix, null);
          canvas.drawPath(path, paint);
        }
    }
  } else {
    if (cacheBm != null) {
      canvas.drawBitmap(cacheBm, matrix, null);
      canvas.drawPath(path, paint);
    }
  }
}
```

**move(Canvas canvas)**  
處理縮放期間的移動操作。

```java
private void move(Canvas canvas) {
  matrix.reset(); // 重置矩陣
  matrix.postScale(totalRatio, totalRatio); // 進行縮放
  totalTranslateX = moveDistX + totalTranslateX; // 計算總平移X
  totalTranslateY = moveDistY + totalTranslateY; // 計算總平移Y
  matrix.postTranslate(totalTranslateX, totalTranslateY); // 進行平移
  canvas.drawBitmap(cacheBm, matrix, null); // 繪製位圖
}
```

**zoom(Canvas canvas)**  
處理縮放操作。

```java
private void zoom(Canvas canvas) {
  matrix.reset();
  matrix.postScale(totalRatio, totalRatio);
  int scaledWidth = (int) (cacheBm.getWidth() * totalRatio);
  int scaledHeight = (int) (cacheBm.getHeight() * totalRatio);
  int translateX;
  int translateY;
  if (curBitmapWidth < width) {
    translateX = (width - scaledWidth) / 2;
  } else {
    translateX = (int) (centerPointX + (totalTranslateX - centerPointX) * scaledRatio);
    if (translateX > 0) {
      translateX = 0;
    } else if (scaledWidth + translateX < width) {
      translateX = width - scaledWidth;
    }
  }
  if (curBitmapHeight < height) {
    translateY = (height - scaledHeight) / 2;
  } else {
    translateY = (int) (centerPointY + (totalTranslateY - centerPointY) * scaledRatio);
    if (translateY > 0) {
      translateY = 0;
    } else if (scaledHeight + translateY < height) {
      translateY = height - scaledHeight;
    }
  }
  matrix.postTranslate(translateX, translateY);
  canvas.drawBitmap(cacheBm, matrix, null);
}
```

### 翻译
```java
private void zoom(Canvas canvas) {
  matrix.reset();
  matrix.postScale(totalRatio, totalRatio);
  int scaledWidth = (int) (cacheBm.getWidth() * totalRatio);
  int scaledHeight = (int) (cacheBm.getHeight() * totalRatio);
  int translateX;
  int translateY;
  if (curBitmapWidth < width) {
    translateX = (width - scaledWidth) / 2;
  } else {
    translateX = (int) (centerPointX + (totalTranslateX - centerPointX) * scaledRatio);
    if (translateX > 0) {
      translateX = 0;
    } else if (scaledWidth + translateX < width) {
      translateX = width - scaledWidth;
    }
  }
  if (curBitmapHeight < height) {
    translateY = (height - scaledHeight) / 2;
  } else {
    translateY = (int) (centerPointY + (totalTranslateY - centerPointY) * scaledRatio);
    if (translateY > 0) {
      translateY = 0;
    } else if (scaledHeight + translateY < height) {
      translateY = height - scaledHeight;
    }
  }
  matrix.postTranslate(translateX, translateY);
  canvas.drawBitmap(cacheBm, matrix, null);
}
```

### 解释
- `matrix.reset();`：重置矩阵。
- `matrix.postScale(totalRatio, totalRatio);`：根据总比例缩放矩阵。
- `int scaledWidth = (int) (cacheBm.getWidth() * totalRatio);`：计算缩放后的宽度。
- `int scaledHeight = (int) (cacheBm.getHeight() * totalRatio);`：计算缩放后的高度。
- `translateX` 和 `translateY`：根据当前位图的宽度和高度与画布宽度的关系，计算平移量。
- `matrix.postTranslate(translateX, translateY);`：应用平移变换。
- `canvas.drawBitmap(cacheBm, matrix, null);`：在画布上绘制缩放和平移后的位图。

```java
Y = 高度 - 缩放后的高度;
    }
  }
  总平移X = 平移X;
  总平移Y = 平移Y;
  当前位图宽度 = 缩放后的宽度;
  当前位图高度 = 缩放后的高度;
  矩阵.postTranslate(平移X, 平移Y);
  画布.drawBitmap(缓存位图, 矩阵, null);
}
```

---

### 历史管理

`History` 类负责管理绘图的历史记录，以实现撤销和重做的功能。

**saveToStack(Path path, Paint paint)**  
將當前路徑和畫筆保存到堆疊中。

```java
public void saveToStack(Path path, Paint paint) {
  Draw draw = new Draw();
  draw.path = new Path(path);
  draw.paint = new Paint(paint);
  saveToStack(draw);
}
```

這段程式碼的功能是將一個路徑（`Path`）和畫筆（`Paint`）保存到堆疊中。具體步驟如下：

1. 創建一個新的 `Draw` 物件。
2. 將傳入的 `path` 複製到 `draw` 物件的 `path` 屬性中。
3. 將傳入的 `paint` 複製到 `draw` 物件的 `paint` 屬性中。
4. 調用 `saveToStack` 方法，將 `draw` 物件保存到堆疊中。

這段程式碼的主要目的是保存繪圖的狀態，以便後續可以恢復或進行其他操作。

```java
public void saveToStack(Draw draw) {
  curPos++;
  while (histroy.size() > curPos) {
    histroy.pop();
  }
  histroy.push(draw);
  if (callBack != null) {
    callBack.onHistoryChanged();
  }
}
```

翻譯成繁體中文：

```java
public void saveToStack(Draw draw) {
  curPos++;
  while (histroy.size() > curPos) {
    histroy.pop();
  }
  histroy.push(draw);
  if (callBack != null) {
    callBack.onHistoryChanged();
  }
}
```

這段程式碼的功能是將一個 `Draw` 物件保存到堆疊中，並在保存後觸發歷史記錄變更的回調。以下是程式碼的解釋：

1. `curPos++;`：將當前位置 `curPos` 增加 1。
2. `while (histroy.size() > curPos) { histroy.pop(); }`：如果歷史記錄的大小大於當前位置，則從堆疊中移除最頂部的元素，直到歷史記錄的大小等於當前位置。
3. `histroy.push(draw);`：將傳入的 `Draw` 物件推入堆疊中。
4. `if (callBack != null) { callBack.onHistoryChanged(); }`：如果回調物件 `callBack` 不為空，則調用 `onHistoryChanged()` 方法，通知歷史記錄已變更。

這段程式碼的主要目的是維護一個歷史記錄堆疊，並在每次保存新的 `Draw` 物件時，確保堆疊的大小與當前位置一致，並觸發相應的回調。

**getBitmapAtDraw(int n)**  
返回表示歷史記錄中指定點狀態的位圖。

```java
public Bitmap getBitmapAtDraw(int n) {
  Canvas canvas = new Canvas();
  Bitmap bm = Utils.getCopyBitmap(srcBitmap);
  canvas.setBitmap(bm);
  for (int i = 0; i <= n; i++) {
    Draw draw = histroy.get(i);
    canvas.drawPath(draw.path, draw.paint);
  }
  return bm;
}
```

這段程式碼的功能是根據指定的索引 `n`，從歷史記錄 `histroy` 中獲取繪製路徑並將其繪製到位圖 `bm` 上，最後返回該位圖。以下是程式碼的詳細解釋：

1. **創建畫布**：`Canvas canvas = new Canvas();` 創建一個新的畫布對象。
2. **複製位圖**：`Bitmap bm = Utils.getCopyBitmap(srcBitmap);` 從源位圖 `srcBitmap` 複製一個新的位圖 `bm`。
3. **設置畫布位圖**：`canvas.setBitmap(bm);` 將畫布的位圖設置為 `bm`，這樣所有的繪製操作都會在這個位圖上進行。
4. **遍歷歷史記錄**：`for (int i = 0; i <= n; i++)` 從索引 0 開始遍歷到索引 `n`。
5. **獲取繪製對象**：`Draw draw = histroy.get(i);` 從歷史記錄 `histroy` 中獲取第 `i` 個繪製對象 `draw`。
6. **繪製路徑**：`canvas.drawPath(draw.path, draw.paint);` 在畫布上繪製 `draw` 對象中的路徑 `path`，使用 `draw` 對象中的畫筆 `paint`。
7. **返回位圖**：`return bm;` 返回繪製完成後的位圖 `bm`。

這段程式碼的主要用途是在繪圖應用中，根據用戶的操作歷史重新生成某個特定步驟的位圖狀態。

**undo()**  
執行撤銷操作。

```java
public Bitmap undo() throws UnsupportedOperationException {
  if (canUndo()) {
    curPos--;
    if (callBack != null) {
      callBack.onHistoryChanged();
    }
    return getBitmapAtDraw(curPos);
  } else {
    throw new UnsupportedOperationException("沒有可撤銷的記錄");
  }
}
```

**redo()**  
執行重做操作。

```java
public Bitmap redo() throws UnsupportedOperationException {
  if (canRedo()) {
    curPos++;
    if (callBack != null) {
      callBack.onHistoryChanged();
    }
    return getBitmapAtDraw(curPos);
  } else {
    throw new UnsupportedOperationException("沒有可重做的記錄");
  }
}
```

**canUndo()**  
檢查是否可以撤銷。

```java
public boolean canUndo() {
  return curPos > 0;
}
```

這段程式碼定義了一個名為 `canUndo` 的方法，該方法返回一個布林值。方法的目的是檢查是否可以執行「撤銷」操作。具體來說，它檢查 `curPos`（當前位置）是否大於 0。如果 `curPos` 大於 0，則返回 `true`，表示可以撤銷；否則返回 `false`，表示無法撤銷。

**canRedo()**  
檢查是否可以重做。

```java
public boolean canRedo() {
  return curPos + 1 < history.size();
}
```

這段程式碼的繁體中文解釋如下：

```java
public boolean canRedo() {
  // 檢查當前位置加一是否小於歷史記錄的大小
  return curPos + 1 < history.size();
}
```

這段程式碼定義了一個名為 `canRedo` 的方法，該方法返回一個布林值（`boolean`），表示是否可以執行「重做」操作。具體來說，它檢查當前位置（`curPos`）加一是否小於歷史記錄（`history`）的大小。如果條件成立，則返回 `true`，表示可以執行重做操作；否則返回 `false`。

---

### 结论

`DrawActivity`及其相关类提供了一个在Android中实现自定义绘图视图的完整示例。它展示了多种技术，包括处理触摸事件、管理绘图历史记录，以及与其他组件（如fragment和异步任务）的集成。通过深入理解每个组件和算法，您可以在自己的应用中运用这些技术，创建出功能强大且互动性强的绘图功能。