---
audio: false
generated: true
image: false
lang: hant
layout: post
model: x-ai/grok-4-fast
title: 快速排序與合併排序
translated: true
type: note
---

### 為何快速排序感覺棘手（而合併排序不會）

你說得沒錯——不參考資料直接手寫快速排序，確實像在抓抹了油的豬一樣費勁，而合併排序則更像摺衣服：有條不紊且可預測。合併排序的「分治合併」流程是線性且遞迴的，乾淨俐落，合併階段毫無意外。相反地，快速排序是*原地*排序，依賴一個圍繞「樞紐點」（選定的分割點）交換元素的巧妙分割技巧。起初會覺得混亂，因為樞紐點並非固定不動——它更像是在比賽中被推來擠去的裁判。但一旦你領悟了其中的直覺，就會發現它優雅而高效（平均時間複雜度 O(n log n)，最壞情況 O(n²)，如果樞紐點選擇不當）。

讓我用一個自然、故事化的視角介紹快速排序：想像要按高度整理書架上雜亂的一堆書。與其將書堆對半切開、逐一測量再合併（那是合併排序的做法），你不如挑一本書作為「基準」（即樞紐點），然後重新排列其他書，讓所有較矮的書放在它左邊，較高的放在右邊。樞紐點最終會落在它的*最終*位置，而你只需遞迴處理左右兩堆書。不需要額外空間——只需在書架上交換位置。這就像荷蘭的「快速排序」升旗儀式（因此得名），將書籍分為三組：較矮組、基準組、較高組。

### 為何有效：分割的魔力

快速排序之所以有效，在於**分治法的保證**：每個分割步驟至少會將*一個元素*（樞紐點）放置到其正確的最終位置，每次遞迴問題規模至少縮小這麼多。最佳情況下，樞紐點將陣列均勻分割（如同合併排序的對半切分），形成平衡的遞迴。最壞情況下（例如已排序陣列且樞紐點選擇不當），它會退化為 O(n²)，類似氣泡排序——但良好的樞紐點選擇策略讓它在實際應用中速度飛快。

關鍵洞見在於：**分割強制維持不變量**。一次分割後：
- 樞紐點左側的所有元素 ≤ 樞紐點。
- 樞紐點右側的所有元素 ≥ 樞紐點。
- 樞紐點從此定位完成——無需再次移動。

這保證了進展：遞迴樹的平均深度最多為 log n，每層總共進行 O(n) 的工作量（掃描和交換）。

### 如何選擇樞紐點（以及為何它在比較過程中會「移動」）

樞紐點並非神聖不可侵犯——它只是你選擇用來作為基準的任何元素。糟糕的選擇（例如總是選第一個元素）可能導致不平衡，以下是從簡單到穩健的策略演進：

1. **天真做法：選擇第一個（或最後一個）元素。**
   - 編碼簡單，但有風險。在已排序陣列 `[1,2,3,4,5]` 中，樞紐點=1 意味左側為空，右側有 4 個元素——遞迴深度失衡。
   - 「移動」原理：在分割過程中，你將其他所有元素與此樞紐值比較，但交換元素是*圍繞*其位置進行的。隨著邊界跨越它，樞紐點本身會被交換到正確位置。

2. **更好做法：選擇中間元素。**
   - 暫時將其交換到末尾，作為樞紐點使用。直覺上更平衡（更接近中位數），但仍可能受已排序/反向排序輸入的影響。

3. **實務最佳：隨機選擇一個元素。**
   - 將其交換到末尾，然後進行分割。隨機性平均掉了糟糕情況，使得最壞情況不太可能發生（以高概率仍保持 O(n log n)）。這是多數函式庫採用的方法。

4. **進階做法（面試用）：三數取中法。**
   - 選擇首、中、尾元素的中位數作為樞紐點。計算快速，能避開常見陷阱。

在程式碼中，你通常先透過交換將樞紐點固定到末尾，圍繞其*值*（而非位置）進行分割，然後再將其交換回所屬位置。這就是為什麼樞紐點感覺在「移動」——它並非靜止不動；分割過程透過兩個指針（左和右）動態地找到其位置，這兩個指針會跳躍式地相互靠近，交換違反規則的元素。

### 動手範例：使用最後一個元素作為樞紐點排序 [3, 7, 1, 9, 4]

讓我們逐步走一遍分割步驟。陣列：`[3, 7, 1, 9, 4]`。樞紐點 = 最後一個 = 4。（我們會視需要交換其位置。）

- 從左指針在索引 0（值 3）、右指針在索引 3（值 9，因為樞紐點在索引 4）開始。
- 從左掃描：3 < 4？是，保留。下一個，7 > 4？是，但等等——我們會將其與從右側找到的第一個 >4 的元素交換。
- 實際上，標準的 Lomuto 分割法（單指針風格）：
  1. i = -1（作為 < 樞紐點的邊界）。
  2. 對於 j 從 0 到 n-2（跳過樞紐點）：
     - 如果 arr[j] ≤ 樞紐點 (4)，則交換 arr[++i] 與 arr[j]。（擴大左側區域。）
  3. 最後，交換樞紐點與 arr[++i] 以放置它。

逐步過程：
- j=0：3 ≤4？是。i=0，交換 arr[0] 與 arr[0]（無操作）。陣列：[3,7,1,9,4]
- j=1：7 ≤4？否。跳過。
- j=2：1 ≤4？是。i=1，交換 arr[1] (7) 與 arr[2] (1)。陣列：[3,1,7,9,4]
- j=3：9 ≤4？否。跳過。
- 結束：交換樞紐點 (4，位於索引 4) 與 arr[++i=2] (7)。陣列：[3,1,4,9,7]

現在：4（索引 2）的左側是 [3,1]（兩者皆 ≤4，未排序），右側是 [9,7]（兩者皆 ≥4，未排序）。樞紐點=4 已*完成*。遞迴處理左側 [3,1] 和右側 [9,7]。

- 左側：樞紐點=1，分割為 [1,3]。
- 右側：樞紐點=7，分割為 [7,9]。

完全排序後：[1,3,4,7,9]。看到了嗎？每一步都鎖定了進展，交換「移動」了樞紐點歸位。

### 虛擬碼概覽（助於實作）

```
quicksort(arr, low, high):
    if low < high:
        pivot_idx = partition(arr, low, high)
        quicksort(arr, low, pivot_idx-1)
        quicksort(arr, pivot_idx+1, high)

partition(arr, low, high):  # Lomuto 風格，樞紐點在 high
    pivot = arr[high]
    i = low - 1
    for j in low to high-1:
        if arr[j] <= pivot:
            i += 1
            swap arr[i], arr[j]
    swap arr[i+1], arr[high]
    return i+1
```

「移動」發生在這些交換中：元素相互穿梭，直到樞紐點落定。用 5-6 個元素在紙上練習——一旦分割步驟豁然開朗，遞迴就會感覺自然。如果遇到困難，試著在腦海中將其動畫化，想像成整理書架上的書籍。

深入閱讀：  
[快速排序視覺化](https://visualgo.net/en/sorting?slide=9)  
[CLRS 快速排序章節](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-20.html#%_sec_3.3)