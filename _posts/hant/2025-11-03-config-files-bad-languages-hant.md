---
audio: false
generated: true
image: false
lang: hant
layout: post
model: x-ai/grok-4-fast
title: 設定檔案演變成糟糕的語言
translated: true
type: note
---

### 解釋「邏輯不可毀滅定律」及為何設定檔會變成糟糕的程式語言

您所引用的文章來自計算機科學研究員兼部落客王垠（亦稱 Yin Wang）。這是一篇深思熟慮的文章，基於程式設計傳奇人物 Guy Steele 的一個觀察：**隨著設定檔變得越來越複雜，它們無可避免地會演變成一種糟糕的程式語言**。王垠使用了他創造的一個概念——「邏輯不可毀滅定律」——來解釋*為何*這種情況幾乎每次都會發生。這是一個巧妙的類比，類似於物理學的能量守恆定律：邏輯不會消失；它只是轉移了位置。

#### 什麼是「邏輯不可毀滅定律」？
王垠將其簡單定義為：**人們需要表達的邏輯，總會以基本相同的形式出現在某個地方。**

- 本質上，如果你有一些決策或基於規則的思維（例如，「如果此條件為真，則執行那個」），它*必須*在你的系統中顯現出來。它不會因為你試圖隱藏或轉移它而蒸發。
- 這種邏輯最終可能會出現在你的主程式碼、設定檔、電子表格，甚至是白板草圖中——但它會持續存在，其核心結構保持不變。
- 它是「不可毀滅的」，因為人類的需求（例如自訂行為）要求它存在。忽略這一點會導致尷尬的解決方法。

可以把它想像成水往低處流：無論你如何試圖控制，邏輯都會流向需要它的地方。

#### 這如何解釋設定檔變成「糟糕的語言」？
設定檔一開始是無害的——作為一種在不觸及核心程式碼的情況下調整設定的方式。但隨著需求增長，它們膨脹成更險惡的東西。以下是逐步的細分，並與該定律聯繫起來：

1.  **簡單的開始：僅有變數**
    起初，設定檔是基本的鍵值對：
    - `enable_optimization = true`
    - `max_requests = 1000`
    這些就像程式設計中的「變數」（例如 `let x = 5;`）。程式讀取它們並將值插入其邏輯中。
    *為何？* 還沒有深層邏輯——只是佔位符。但變數是*任何*程式語言的基本建構塊。根據該定律，這種邏輯（賦值和使用值）已經悄悄潛入了設定檔。

2.  **逐漸蔓延：加入分支**
    當用戶要求更多靈活性（例如，「僅對高級用戶啟用功能 X」），開發者開始在設定檔中嵌入*條件邏輯*：
    - 類似這樣：`if user_type == "premium" then enable_feature_X else disable`。
    這完全是「if-then-else」分支——另一個核心的程式設計原語。
    *為何？* 開發者下意識地將邏輯從主程式碼轉移到設定檔，以便更容易調整。但定律生效了：邏輯並未從程式中消失；它只是遷移了。現在設定檔不僅僅是數據——它正在做出決策。

3.  **臨界點：全面的邏輯超載**
    隨著時間推移，設定檔積累了迴圈、函數、錯誤處理和自訂規則。最初作為一個扁平檔案（YAML、JSON 等）的設定，最終擁有了圖靈完備（能夠表達任何計算）的語法。
    - 結果：一個功能強大但很糟糕的「語言」——缺乏良好的工具、錯誤訊息、除錯功能或函式庫。就像用一種半生不熟的程式碼方言進行程式設計。
    *為何不可避免？* 邏輯不可毀滅性。如果邏輯存在（而且它必須存在，以解決實際問題），它就會在*某處*顯現出來。將其推出主程式碼，只會將其推入設定檔，讓它在那裡惡化。

Steele 的俏皮話一針見血：設定檔並非*想要*成為語言，但複雜性迫使它們成為語言。而且它們總是「糟糕的」，因為它們是為簡單性而設計，而非表達能力。

#### 與領域特定語言（DSL）的關聯
王垠引用了他早期的文章["DSL 的陷阱"](https://yinwang1.substack.com/p/dsl-misconceptions)（特別是「動態邏輯載入」部分）來延伸這一點。許多 DSL（為特定任務設計的自訂迷你語言）源於相同的動機：在運行時載入規則或行為，而無需重新編譯。

- **錯誤之處：** 團隊認為他們需要一種定製語言來實現「動態邏輯」，因此他們發明了一種——在一個笨拙的包裝中重新發明了 if-then-else。
- **解決方法：** 這大部分歸結為簡單的條件語句。只需將現有語言（例如 JavaScript 的 `if` 語句）的程式碼片段嵌入到你的設定檔中。無需創建整個新的 DSL——這是過度設計，並會導致同樣的「糟糕語言」陷阱。
- *定律在作用：* 邏輯（例如，「檢查是否為 X，然後執行 Y」）必須去某個地方。一個 JS 片段將其保留在一種*好的*語言中，避免了設定檔膨脹。

#### 這為何重要？
這不僅僅是理論——它對軟體設計是一個警示。它解釋了為什麼像 Kubernetes YAML 或 webpack 設定檔這樣的工具感覺像編碼噩夢。教訓是？擁抱邏輯在其蓬勃發展的地方（在適當的語言中），而不是將其流放到設定檔中。設計使邏輯*可見且可管理*的系統，否則它將以幽靈的形式困擾你。

如果你想深入了解，原文篇幅不長且更具細微差別。

[原文：設定檔與邏輯不可毀滅定律](https://yinwang1.substack.com/p/224)
[相關文章：DSL 的陷阱](https://yinwang1.substack.com/p/dsl-misconceptions)