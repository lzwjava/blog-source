---
audio: false
generated: true
lang: hant
layout: post
title: Rust 快速排序：資深開發者指南
translated: true
type: note
---

好的，考慮到你在演算法、全端開發甚至行動端工程方面的深厚背景，你會發現 Rust 在記憶體安全性和明確控制方面的處理方式在概念上相當熟悉，即使其語法和嚴格性是新的。讓我們來剖析這個用 Rust 實現的快速排序。

-----

### Rust 中的快速排序：給經驗豐富開發者的深入探討

這段 Rust 程式碼實現了經典的 **Quicksort 演算法**。快速排序的核心思想是選擇一個元素作為樞軸，並圍繞它對陣列進行分割，使得小於樞軸的元素位於一側，大於樞軸的元素位於另一側。然後將此過程遞迴應用於子陣列。

讓我們來看看這些函式：

-----

### `fn quick_sort(arr: &mut [i32])`

```rust
fn quick_sort(arr: &mut [i32]) {
    if arr.len() <= 1 {
        return;
    }
    let pivot_index = partition(arr);
    let (left, right) = arr.split_at_mut(pivot_index);
    quick_sort(left);
    quick_sort(&mut right[1..]);
}
```

  * **`arr: &mut [i32]`**：這裡 Rust 的型別系統立刻展現了它的特色。
      * `&mut` 表示一個 **可變引用**。這意味著 `quick_sort` 函式取得了一個對陣列 `arr` 的借用引用，並且被允許*就地*修改該陣列的內容。
      * `[i32]` 是一個 `i32` 整數的 **切片**。在 Rust 中，`[T]` 是切片的型別，它代表對連續元素序列的一個視圖。它不擁有數據；它只是指向陣列或 `Vec` 的一部分。這對於效率至關重要，因為它避免了複製數據。你從 C/C++/Java 背景中熟悉了指標和陣列區段；可以將其視為 Rust 安全且明確地管理這些概念的方式。
  * **基本情況 `if arr.len() <= 1`**：快速排序標準的遞迴基本情況。如果切片有 0 或 1 個元素，它已經排序好了，直接返回。
  * **`let pivot_index = partition(arr);`**：呼叫 `partition` 函式（我們接下來會看）來重新排列切片。它返回樞軸元素的最終位置。
  * **`let (left, right) = arr.split_at_mut(pivot_index);`**：這是 Rust 用於安全可變別名的關鍵特性。
      * `split_at_mut` 是可變切片的一個方法。它接受一個索引，並將可變切片分割成兩個*互不相交*的可變切片。
      * `left` 將是 `arr[0..pivot_index]`，而 `right` 將是 `arr[pivot_index..len]`。
      * 這是 Rust **借用檢查器** 的基礎。你不能同時擁有多個對*相同數據*的可變引用。`split_at_mut` 確保 `left` 和 `right` 引用原始陣列中完全獨立的部分，從而滿足借用檢查器，並防止在多執行緒環境中出現數據競爭（即使這裡是單執行緒的，其原則仍然適用）。
  * **`quick_sort(left);`**：遞迴地排序 `left` 子切片。
  * **`quick_sort(&mut right[1..]);`**：遞迴地排序 `right` 子切片。
      * `right[1..]` 很重要：`right` 切片從 `pivot_index` 開始。由於 `arr[pivot_index]` 現在是已正確定位的樞軸元素，我們將其從右側的遞迴呼叫中排除。
      * `&mut` 明確地從 `right` 重新借用一個可變切片。

-----

### `fn partition(arr: &mut [i32]) -> usize`

```rust
fn partition(arr: &mut [i32]) -> usize {
    let len = arr.len();
    let pivot = arr[len - 1];
    let mut i = 0;
    for j in 0..len - 1 {
        if arr[j] <= pivot {
            arr.swap(i, j);
            i += 1;
        }
    }
    arr.swap(i, len - 1);
    i
}
```

這個函式實現了 Lomuto 分割方案，這是快速排序中一種常見的陣列分割方式。

  * **`let len = arr.len();`**：取得當前切片的長度。
  * **`let pivot = arr[len - 1];`**：選擇切片的**最後一個元素**作為樞軸。
  * **`let mut i = 0;`**：`i` 充當一個指標，指向小於或等於樞軸的元素與大於樞軸的元素之間的"邊界"。`i` 左側的元素將小於或等於樞軸。
  * **`for j in 0..len - 1`**：這個迴圈遍歷*除了*樞軸（位於 `len - 1`）之外的所有元素。
  * **`if arr[j] <= pivot { ... }`**：如果當前元素 `arr[j]` 小於或等於樞軸：
      * **`arr.swap(i, j);`**：將 `arr[j]` 與 `arr[i]` 交換。這將較小的元素移動到"小於或等於"的區域。
      * **`i += 1;`**：增加 `i` 以擴展"小於或等於"的區域。
  * **`arr.swap(i, len - 1);`**：迴圈結束後，`i` 是樞軸的正確位置。我們將樞軸（仍然在 `len - 1`）交換到其最終排序位置。現在，`i` 左側的所有元素都小於或等於 `arr[i]`（即樞軸），而右側的所有元素都大於它。
  * **`i`**：函式返回 `i`，即樞軸元素的最終索引。

-----

### `fn main()`

```rust
fn main() {
    let mut arr = [3, 6, 8, 10, 1, 2, 1];
    println!("Before: {:?}", arr);
    quick_sort(&mut arr);
    println!("After: {:?}", arr);
}
```

  * **`let mut arr = [3, 6, 8, 10, 1, 2, 1];`**：
      * `let mut` 宣告一個**可變變數**。這允許你重新指派變數或修改其內容（如果它是可變型別）。
      * `[3, ...]` 在堆疊上建立一個**固定大小的陣列**。其大小在編譯時是已知的。
  * **`println!("Before: {:?}", arr);`**：使用 `println!` 巨集進行輸出。
      * `{:?}` 是**除錯列印**格式指定符。它使用 `Debug` trait 來列印陣列的人類可讀表示形式。
  * **`quick_sort(&mut arr);`**：呼叫 `quick_sort` 函式，傳遞一個對 `arr` 陣列的可變引用。
  * **`println!("After: {:?}", arr);`**：在排序後再次列印陣列。

-----

### 為你總結的 Rust 特定要點

  * **所有權與借用**：這段程式碼是 Rust 核心概念的典型範例。你傳遞的是**引用（`&` 和 `&mut`）**，而不是複製數據。`&mut` 引用對於就地修改陣列至關重要，而**借用檢查器**（例如，由 `split_at_mut` 強制執行）確保你永遠不會同時擁有多個對相同數據的可變引用，從而在編譯時消除了一整類的並行錯誤。這可能是從 Java 或 Python 等語言轉換過來時最大的典範轉移，但它提供了無需垃圾收集器的記憶體安全性。
  * **切片 `[T]`**：對於處理連續數據來說，它們非常強大。它們提供了一個安全、高效的視圖，可以查看陣列或向量的部分內容，而無需分配新的記憶體。
  * **巨集（`println!`）**：你會在很多標準庫函式（如 `println!`, `vec!`, `format!`）後面看到 `!`。這表示它們是**巨集**，而不是常規函式。巨集在編譯時擴展程式碼，與常規函式相比，提供了更大的靈活性和功能（例如可變參數或編譯時代碼生成）。

考慮到你的背景，你可能會欣賞 Rust 所提供的效能特性和安全保證，即使"借用檢查器之舞"需要一點時間來適應。這是一種關於記憶體管理的不同思考方式，但能帶來高度穩健且高效的程式碼。