---
audio: false
generated: true
lang: hant
layout: post
title: 人工智能與代碼：局限與靈活
translated: true
type: note
---

你完全正確地指出，即使是像 Grok（由 xAI 開發）、OpenAI 的模型或其他具備複雜工具使用和函數呼叫功能的先進 AI 系統，與編寫和執行自定義程式碼相比，仍然存在固有的局限性——特別是在靈活性、處理高度複雜或新穎任務，以及直接進行 API 互動方面。讓我逐步分析解釋為何通常如此，同時也指出 AI 的優勢所在以及持續存在的差距。

### 1. **程式碼與 AI 工具使用的靈活性對比**
   - **程式碼的優勢**：編寫程式碼（例如使用 Python）能提供終極的靈活性，因為你可以：
     - 直接呼叫任何 API，並完全控制參數、身份驗證、錯誤處理、重試機制和自定義邏輯。例如，如果你需要與某個小眾 API 互動，該 API 要求特定的標頭、多部分上傳或即時串流，程式碼讓你可以從頭開始構建，無需中介。
     - 以精確且無限制的方式處理狀態管理、循環、條件判斷和資料轉換。程式碼可以無限運行、處理龐大資料集或無縫整合多個函式庫。
     - 以確定性的方式進行除錯和迭代——錯誤是可追蹤的，並且你可以對所有內容進行版本控制。
     - 範例：如果你正在構建一個能適應網站結構變化的網路爬蟲，程式碼可以動態整合選擇器、代理伺服器和機器學習功能。AI 工具或許能近似實現，但往往會因預定義範圍而遇到瓶頸。

   - **AI 在此處的局限性**：像 Grok 或 GPT 模型這樣的 AI 系統依賴於預定義的工具、函數呼叫或外掛程式（例如 Grok 用於網路搜尋、程式碼執行或 X/Twitter 分析的工具）。這些功能強大但受限：
     - 工具本質上是為常見使用場景設計的「黑盒子」。如果任務無法整齊地套用到現有工具中，AI 就必須創造性地鏈接它們，這可能導致效率低下或失敗。
     - 通過 AI 進行的 API 呼叫是間接的：模型解讀你的意圖，生成函數呼叫，執行它，然後解析回應。這增加了誤解、速率限制或上下文丟失（例如，提示中的 token 限制可能會截斷複雜指令）的潛在風險。
     - 安全性和沙箱限制：AI 環境（如 Grok 的程式碼解譯器）會阻止危險操作、限制套件安裝或限制網路存取，這使得它們更安全，但比在你機器上執行的原始程式碼靈活性更低。

### 2. **處理困難或複雜任務**
   - **為何需要多重提示或工具鏈**：對於棘手的問題，AI 通常需要進行分解——通過多重提示、工具呼叫或迭代將其拆分為子任務。這模仿了程式設計師模組化程式碼的方式，但效率較低：
     - 簡單任務（例如「搜尋網路關於 X 的資料」）可以通過單一工具一次性完成。
     - 複雜任務（例如「分析即時股票資料，與新聞交叉參考，建立預測模型並進行視覺化」）可能需要 2 個以上的提示：一個用於資料收集（網路搜尋 + 程式碼執行），另一個用於分析（更多程式碼），依此類推。每一步都可能導致錯誤疊加，例如產生虛構輸出或上下文傳遞不完整。
     - 如果任務涉及專有資料、即時協作或硬體存取（例如通過 API 控制機械手臂），AI 可能會失敗，因為如果沒有人為干預，它無法在其訓練或工具集之外進行「思考」。

   - **AI 無法做到（或難以完成）的任務**：
     - 任何需要超越訓練資料模式的真正創造力或發明的任務（例如，從零開始發明一種新演算法而無需參考——AI 可以生成程式碼，但它是衍生性的）。
     - 長時間運行、資源密集的計算：AI 工作階段有超時、記憶體限制或配額，而程式碼可以在伺服器上運行數天。
     - 敏感或受限制的操作：道德防護欄會阻止有害的 API 呼叫（例如濫發服務），並且 AI 無法直接存取你的本地檔案或裝置。
     - 具有模糊性的邊緣案例：如果任務目標不明確，AI 可能會低效地循環，而程式碼讓你可以硬編碼假設並進行測試。
     - 真實範例：構建一個具有用戶身份驗證、資料庫整合和部署功能的全端應用程式——AI 可以通過工具幫助原型設計部分內容，但組裝和維護它需要人為編碼的靈活性。

### 3. **AI 的優勢所在（以及如何彌補差距）**
   - 儘管存在弱點，具備工具使用能力的 AI 是一個巨大的加速器：它讓非專家能夠快速達成複雜結果，從而 democratizes 編程。例如，Grok 可以鏈接程式碼執行、網路瀏覽和語義搜尋等工具，來解決原本需要數小時手動編碼才能解決的問題。
   - 隨著時間推移，模型不斷改進（例如更好的推理能力、更長的上下文、更多工具），差距正在縮小。但從根本上說，AI 是一個建立在程式碼之上的「推理引擎」——它並非編程原始力量的替代品。
   - 混合方法通常勝出：使用 AI 生成程式碼框架或進行除錯，然後自己運行程式碼以獲得靈活性。

總而言之，是的——對於直接的 API 呼叫和極度複雜的任務，程式碼本質上更具靈活性和威力，因為它不受 AI 的解釋層、提示工程需求以及內建限制的約束。AI 工具在許多場景中讓事情變得更簡單、更快速，但對於最困難的任務，你通常需要多步驟互動，或者回歸到純粹的程式碼。如果某個任務在 AI 中感覺「不可能」，通常是因為它需要那種低層級的控制。

如果你腦海中有具體的任務或範例，我可以嘗試在這裡用工具示範，以展示其優缺點！