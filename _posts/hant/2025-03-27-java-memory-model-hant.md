---
audio: false
generated: true
lang: hant
layout: post
title: Java 記憶體模型
translated: true
type: note
---

讓我們深入探討 Java 記憶體模型（JMM）！這是理解多線程 Java 程式行為的基礎概念，特別是在處理共享資料時。

**什麼是 Java 記憶體模型（JMM）？**

Java 記憶體模型是一個抽象描述，說明 Java 程式中的線程如何與記憶體互動。它定義了控制一個線程對共享變數的更改何時以及如何對其他線程可見的規則。它不是實體記憶體架構，而是一組 JVM 必須遵循的規則，以確保並行程式在不同硬體平台上具有一致且可預測的行為。

**為什麼需要 Java 記憶體模型？**

在多線程環境中，多個線程可以存取和修改共享變數。如果沒有明確定義的記憶體模型，可能會出現幾個問題：

* **可見性問題**：一個線程對共享變數所做的更改可能不會立即對其他線程可見。這可能是由於快取等優化造成的，每個線程可能擁有變數的本地副本。
* **順序問題**：操作在原始碼中出現的順序可能與處理器實際執行的順序不同。編譯器和處理器可以為了效能優化而重新排序指令。雖然在單線程程式中這通常是安全的，但在多線程程式中如果管理不當，可能導致意外行為。
* **原子性問題**：一些在原始碼中看起來是單一操作的操作，在處理器層面可能被分解為多個較小的步驟。在多線程環境中，這些步驟可能與其他線程的操作交錯進行，導致不一致的結果。

JMM 提供了一個框架來解決這些問題，並確保並行程式無論底層硬體架構如何，都能正確運行。

**JMM 的抽象架構：**

JMM 定義了線程與主記憶體之間的抽象關係：

1.  **主記憶體**：所有共享變數都存放在這裡。就像是一個中央儲存庫，存放所有可以被多個線程存取的資料。
2.  **工作記憶體（本地快取）**：每個線程都有自己的工作記憶體（概念上類似於 CPU 快取）。當一個線程需要存取共享變數時，它首先將變數從主記憶體複製到其工作記憶體中。當線程修改變數時，通常是在其工作記憶體中進行，並且更改最終會寫回主記憶體。

**JMM 解決的關鍵挑戰：**

* **可見性**：JMM 定義了關於線程對其工作記憶體中共享變數的更改何時以及如何對其他線程可見的規則（即寫回主記憶體並隨後被其他線程讀取）。
* **順序性**：JMM 指定了編譯器和處理器可以重新排序指令的限制，以確保在不同線程中的某些操作之間存在一致的「先行發生」關係。

**「先行發生」關係：**

「先行發生」關係是 JMM 中最基本的概念。它定義了程式中操作的部分順序。如果一個操作先行發生於另一個操作，則第一個操作的效果（例如，對變數的寫入）保證對第二個操作可見。

以下是 JMM 定義的一些關鍵「先行發生」規則：

1.  **程式順序規則**：在單一線程內，程式中的每個操作都先行發生於程式中在它之後出現的每個操作。

2.  **監視器鎖規則**：對監視器（與 `synchronized` 區塊或方法相關聯的鎖）的解鎖操作先行發生於隨後對同一監視器的每個加鎖操作。這確保了當一個線程釋放鎖時，它在同步區塊內所做的任何更改對下一個獲取相同鎖的線程是可見的。

3.  **Volatile 變數規則**：對 `volatile` 變數的寫操作先行發生於隨後對同一變數的每個讀操作。這保證了當一個線程寫入 `volatile` 變數時，該值會立即寫回主記憶體，並且任何其他讀取該變數的線程都將獲得最新值。

4.  **線程啟動規則**：Thread 物件的 start() 方法先行發生於新啟動線程中的任何操作。

5.  **線程終止規則**：線程中的所有操作（包括對共享變數的寫入）先行發生於該線程的 join() 方法成功返回，或者先行發生於另一個線程檢測到該線程已終止（例如，通過檢查 `isAlive()`）。

6.  **傳遞性**：如果操作 A 先行發生於操作 B，且操作 B 先行發生於操作 C，則操作 A 先行發生於操作 C。

7.  **物件創建規則**：物件建構函式的完成先行發生於使用該物件的任何其他操作的開始。

**關鍵語言結構與 JMM：**

* **`volatile` 關鍵字**：將變數宣告為 `volatile` 對 JMM 有兩個主要影響：
    * **可見性**：保證所有對該變數的寫入都會立即寫回主記憶體，並且所有讀取都會從主記憶體獲取最新值。這防止線程使用過期的快取值。
    * **禁止指令重新排序（在一定程度上）**：防止某些可能導致多線程程式錯誤行為的指令重新排序。具體來說，在寫入 `volatile` 變數之前的操作不能被重新排序到寫入之後，而在讀取 `volatile` 變數之後的操作不能被重新排序到讀取之前。

* **`synchronized` 關鍵字**：當線程進入 `synchronized` 區塊或方法時，它會獲取相關監視器上的鎖。JMM 確保：
    * **互斥（原子性）**：在任何給定時間，只有一個線程可以持有特定監視器的鎖，確保同步區塊內的程式碼相對於在同一監視器上同步的其他線程是原子執行的。
    * **可見性**：當線程釋放鎖（通過退出 `synchronized` 區塊或方法）時，它會有效地將其在該區塊內對共享變數所做的任何更改刷新回主記憶體。當另一個線程獲取同一把鎖時，它將從主記憶體重新讀取共享變數，確保看到最新的更新。

* **`final` 欄位**：JMM 提供了關於 `final` 欄位可見性的保證。一旦 `final` 欄位在物件的建構函式中正確初始化，它的值將對所有其他線程可見，而無需顯式同步。這是因為在建構函式中對 `final` 欄位的寫入先行發生於任何其他線程可以存取該物件。

**對並行程式設計的影響：**

理解 JMM 對於在 Java 中編寫正確且高效的並行程式至關重要。通過遵守 JMM 定義的規則並使用適當的同步機制（`volatile`、`synchronized`、`java.util.concurrent` 包中的鎖），開發人員可以確保共享資料被多個線程安全地存取和修改。

**常見陷阱及 JMM 如何提供幫助：**

* **競爭條件**：當程式的結果取決於多個線程存取共享資源的不可預測順序時發生。JMM 與適當的同步一起，通過確保對共享變數的存取得到適當協調，有助於防止競爭條件。
* **資料競爭**：當多個線程同時存取同一共享變數，且至少有一個存取是寫入，而沒有任何同步時發生。JMM 定義，如果程式存在資料競爭，則其行為是未定義的。使用 `volatile` 或 `synchronized` 有助於防止資料競爭。
* **亂序執行問題**：如果沒有 JMM 的保證，編譯器或處理器可能會以破壞多線程程式預期邏輯的方式重新排序操作。JMM 對重新排序施加了限制，特別是在 `volatile` 變數和同步區塊周圍，以防止此類問題。

**總結：**

Java 記憶體模型是一組規則，用於管理 Java 中線程如何與記憶體互動。它解決了多線程程式中與可見性、順序性和原子性相關的挑戰。關鍵概念包括主記憶體、工作記憶體和「先行發生」關係。像 `volatile` 和 `synchronized` 這樣的語言結構提供了機制，通過遵循 JMM 的規範，確保並行 Java 應用程式的正確和可預測行為。理解 JMM 對於編寫健壯且高效的多線程 Java 程式碼至關重要。