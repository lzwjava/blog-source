---
audio: false
generated: true
image: false
lang: hant
layout: post
model: x-ai/grok-4-fast
title: 數據庫版本控制與 Git 協作
translated: true
type: note
---

### 選擇 JSON（或 CSV）與 SQLite 以實現 Git 友好的版本控制

對於擁有 1-2 個資料表和 10k-100k 筆記錄的小型資料庫，JSON 和 SQLite 都是可行的選擇，因為總檔案大小應保持在可控範圍內（即使是較密集的資料，可能也低於 10-50 MB）。您面臨的主要挑戰——每次更新時 git diff 將整個檔案視為二進位 blob——在資料庫中很常見。Git 擅長處理基於文字的差異比較，因此像 JSON 這樣的格式在這方面表現出色，而 SQLite（單一二進位檔案）則需要變通方法才能顯示可讀的變更。

我將按優缺點進行分析，然後根據您的優先級給出建議。

#### 快速比較

| 方面              | JSON（或 CSV）                                                                 | SQLite                                                                 |
|---------------------|-------------------------------------------------------------------------------|------------------------------------------------------------------------|
| **檔案格式**    | 文字型（人類可讀）。在 git 中易於逐行比對差異。                  | 二進位檔案。Git 預設顯示全檔案變更；差異預設不可讀。 |
| **10k-100k 筆記錄的檔案大小** | 如果記錄簡單則檔案小（例如，每筆記錄 1-5 KB → 總計 10-500 MB）。在 git 中壓縮效果好。 | 大小相似，但無法從文字差異中獲得壓縮效益。                |
| **Git 體驗** | 優秀：可查看確切的新增/編輯行。使用如 `git diff --word-diff` 等工具來查看結構化變更。對資料進行一致排序以獲得清晰的差異比較。 | 開箱即用體驗差。需透過自訂 git 配置（例如，在 diff 時將資料庫轉儲為 SQL）來修復。或使用如 Dolt 等擴充功能來實現類似 git 的資料庫版本控制。 |
| **更新**        | 儲存時完全重寫，但如果您選擇性地載入/編輯/儲存（例如透過腳本），差異比較會突顯變更。 | 原子交易，但每次提交在 git 中看起來像是完全替換。 |
| **查詢/功能** | 基礎功能（使用如 jq/Python 等程式碼進行篩選）。無索引/交易功能。適合扁平化資料。 | 完整的 SQL：查詢、連接（適用於 2 個資料表）、索引、約束。對於任何需要「資料庫」感覺的場景更佳。 |
| **使用場景契合度**   | 如果您的應用/腳本在記憶體中處理 CRUD 且您優先考慮協作/差異比較，則為理想選擇。 | 如果您需要真正的資料庫操作，而差異比較是次要考慮，則更佳。                   |
| **所需工具**   | 原生 git + jq（用於 JSON）或 csvkit（用於 CSV）。                               | sqlite3 CLI + 用於自訂差異比較的 git 屬性。                         |

#### 建議
- **如果易於比對差異是您的首要考量，請選擇 JSON（或 CSV）**：這使得所有內容都基於文字且原生支援 git。對於 1-2 個資料表：
  - 使用 **一個 JSON 檔案** 作為物件陣列（例如 `[{"id":1, "name":"foo", ...}, ...]`）。對於簡單的關聯（將一個資料表嵌入另一個中）來說很靈活。
  - 或者使用 **CSV 檔案**（每個資料表一個）來處理更嚴格的表格資料——超級輕量且易於比對差異。像 Pandas 這樣的工具可以載入/編輯/匯出它們。
  - **工作流程提示**：在儲存前始終按 ID/鍵對記錄進行排序（例如在 Python 中：`df.sort_values('id').to_csv(...)`）。這使得差異比較僅顯示真實的變更，而非重新排序的雜訊。對於更新，讀取 → 修改特定行 → 排序 → 寫入。檔案大小保持較小，且 git 歷史記錄清晰。
  - 缺點：對於 10 萬筆記錄，每次將整個檔案載入記憶體可能會較慢，若未進行優化（例如使用如 ijson 的串流庫）。

- **如果您需要資料庫功能，請使用 SQLite**：它在查詢/連接方面更為穩健，且單一檔案設定對於 git 提交來說很簡單。為了解決差異比較問題：
  - 新增一個 `.gitattributes` 檔案：`*.db diff=sqlite` 和一個 `.gitconfig` 片段，用於在 diff 時將資料庫轉儲為 SQL（例如透過 `sqlite3 db dump.sql`）。這將二進位變更轉換為可讀的 SQL 插入/更新。
  - 範例設定腳本（使用 bash/Python）：在提交時，將結構描述/資料匯出為 SQL 檔案以供審查。
  - 對於進階需求，可以考慮 Dolt——它就像是「資料庫的 git」，具有可分支的資料表和適當的差異比較，但對於小型設定來說較為沉重。

為求簡單，從 JSON/CSV 開始——對於小規模應用來說「足夠好」，並且符合您對 git 的顧慮。如果您超出其能力範圍（例如需要複雜查詢），之後再遷移到 SQLite。對兩者進行原型設計：將範例資料轉儲到檔案中，並測試一些 git 提交。

如果您的記錄具有特定結構，請分享更多細節以獲取量身訂製的程式碼片段。

[在 Git 中對 SQLite 進行版本控制](https://dunkels.com/adam/git-diff-sqlite3/)  
[小型資料的 JSON 與資料庫比較](https://www.reddit.com/r/flask/comments/lvccgo/using_a_database_such_as_sqlite3_versus_json_to/)  
[資料版本控制選項](https://dolthub.com/blog/2022-04-27-data-version-control/)