---
audio: false
generated: true
image: false
lang: hant
layout: post
model: x-ai/grok-code-fast-1
title: Git Hooks 指南：Pre-Commit 與 Pre-Push
translated: true
type: note
---

### Git Hooks 概述
Git hooks 是可自訂的腳本，能在 Git 工作流程的特定節點自動執行任務。它們可分為客戶端（在本地機器運行）和伺服器端（在遠端儲存庫運行）。Hooks 儲存在儲存庫的 `.git/hooks/` 目錄中。以下我將詳細說明 pre-commit、pre-push 以及與推送相關的伺服器端 hooks，解釋它們的執行方式。

### 客戶端 Hooks：Pre-Commit 與 Pre-Push
這些 hooks 在操作完成前於本地機器運行，讓你能夠強制執行規則或進行檢查。

- **Pre-Commit Hook**：
  - **執行時機**：在提交變更前自動觸發（例如透過 `git commit`）。
  - **用途**：適用於程式碼品質檢查，例如運行 linters、測試或格式化工具。如果 hook 執行失敗（返回非零狀態），提交將會中止。
  - **範例**：一個典型的 pre-commit hook 可能會對 JavaScript 檔案運行 `eslint`。如果出現錯誤，提交就會停止。
  - **運作方式**：腳本位於 `.git/hooks/pre-commit`。需使用 `chmod +x .git/hooks/pre-commit` 賦予可執行權限。如果使用像 Husky 這樣的工具（一個受歡迎的 Git hooks 管理庫），可以簡化設定流程。

- **Pre-Push Hook**：
  - **執行時機**：在推送至遠端前自動觸發（例如透過 `git push`）。
  - **用途**：在將變更傳送至遠端前，檢查如運行測試、驗證程式碼覆蓋率或確保相容性等事項。如果執行失敗，推送將會被阻擋。
  - **關於 "some prepush" 的說明**：Git 中並無標準的 "prepush" hook——我假設你指的是帶有連字號的 "pre-push" hook。你可以透過像 Husky 這樣的工具建立自訂的 pre-push 腳本，以強制執行如「僅在所有測試通過時才推送」的規則。
  - **範例**：一個 pre-push hook 可以運行 `npm test` 並在測試失敗時中止推送。如果跳過檢查（例如使用 `git push --no-verify`），hook 將不會運行。
  - **運作方式**：位於 `.git/hooks/pre-push`。需要可執行權限。它會接收如遠端名稱和正在推送的引用等參數。

客戶端 hooks 能確保問題及早被發現，防止不良的提交或推送離開你的機器。

### 推送過程中的伺服器端 Hooks
當你運行 `git push` 時，推送會被傳送至遠端儲存庫（例如 GitHub、GitLab 或自訂伺服器）。遠端可以擁有自己的 hooks，在推送過程中或之後執行。這些 hooks 儲存在遠端 Git 儲存庫的 `.git/hooks/` 目錄中，並由伺服器管理員管理。

- **推送過程**：
  1. **本地檢查**：pre-push hook 首先運行（如果存在）。
  2. **資料傳輸**：變更被傳送至遠端。
  3. **遠端執行**：伺服器端 hooks 在遠端伺服器上運行，而非你的本地機器。

- **Pre-Receive Hook**：
  - **執行時機**：在遠端伺服器上，一接收到推送但尚未更新任何引用（分支或標籤）時立即運行。
  - **用途**：驗證傳入的變更。如果檢查失敗，例如強制執行提交訊息規範、程式碼審查或安全掃描，它可以拒絕整個推送。
  - **運作方式**：如果 hook 返回非零狀態，推送將被拒絕，你將會看到錯誤訊息。範例：拒絕引入超過特定大小檔案的推送。

- **Update Hook**（類似 Pre-Receive，但針對每個引用）：
  - **執行時機**：針對每個正在更新的分支/標籤，在 pre-receive 之後運行。
  - **用途**：允許細粒度控制，例如檢查推送是否來自授權用戶，或分支是否符合命名慣例。
  - **運作方式**：接收關於正在更新的引用的詳細資訊。

- **Post-Receive Hook**：
  - **執行時機**：在遠端伺服器上，於推送被完全接受且引用更新後運行。
  - **用途**：觸發下游操作，例如部署程式碼、發送通知（如 Slack 警示）或運行部署後腳本如「重新建置應用程式」。
  - **運作方式**：在成功推送後可靠地運行。範例：自動觸發 CI/CD 流程或更新網頁伺服器。

伺服器端 hooks 提供集中式的強制執行，因此即使你的本地 hooks 被繞過，遠端仍然可以驗證或對推送作出反應。像 GitHub 這樣的平台使用 webhooks（基於 API 的等效方式）來達到類似目的，但對於裸 Git 伺服器或自託管儲存庫，上述 hooks 是關鍵。

### 主要差異與最佳實踐
- **客戶端 vs 伺服器端**：客戶端 hooks（如 pre-commit/pre-push）讓你在本地獲得快速回饋。伺服器端 hooks 強制執行儲存庫範圍的規則。
- **自訂化**：Hooks 是 shell 腳本（例如 Bash），但可以調用 Python、Node.js 等。使用像 pre-commit（一個框架）這樣的工具來管理它們。
- **繞過方式**：使用 `--no-verify` 提交、使用 `--no-verify` 推送，但伺服器端 hooks 無法被繞過，除非你擁有管理員權限。
- **設定提示**：Hooks 不會在儲存庫之間複製，因此將它們加入儲存庫模板或使用工具來安裝它們。

如果你正在進行設定，請查閱 Git 的文件或像 Husky 這樣的工具（適用於 node 專案）。如果你有特定情境（例如程式碼範例），提供更多細節以獲得量身訂製的建議！