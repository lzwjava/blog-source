---
audio: false
generated: true
lang: hant
layout: post
title: Discord 的 Rust 效能提升
translated: true
type: note
---

Discord 採用 Rust 的決策源自其基於 Go 語言開發的「讀取狀態」服務出現效能瓶頸，該服務負責追蹤用戶跨頻道的訊息讀取狀態。轉用 Rust 後不僅顯著改善延遲問題、消除垃圾回收機制造成的效能峰值，更展現出 Rust 在記憶體管理與並行處理方面的優勢。以下為詳細分析：

---

### **Discord 轉用 Rust 的原因**
1. **Go 語言垃圾回收機制問題**  
   - 由於 Go 採用保守且非分代的垃圾回收機制，即使僅產生極少垃圾，*仍須掃描整個 LRU 快取*（包含數百萬個物件），導致 Discord 的 Go 服務每約 2 分鐘就會出現延遲峰值  
   - 調整 Go 垃圾回收設定（如快取大小）不僅無法解決峰值問題，反而使第 99 百分位延遲更加惡化  

2. **Rust 的記憶體管理優勢**  
   - Rust 的所有權模型能在資料從 LRU 快取淘汰時*立即釋放記憶體*，避免垃圾回收導致的停頓，這種確定性方法徹底消除延遲峰值  
   - 無需運行時垃圾回收開銷，即使面對每秒數十萬次請求的高負載仍能保持穩定效能  

3. **效能優化成果**  
   - 即使初步的 Rust 實作已能達到 Go 版本效能，經過進一步優化（如改用 `BTreeMap` 替代 `HashMap`、減少記憶體複製）後，*CPU 使用率降低 70%*，平均回應時間縮短至微秒級  

4. **生態系統與非同步支援**  
   - Discord 早期即採用 Rust 的 nightly 版本非同步功能（後續已穩定化），得以建構高效能網路服務且無需犧牲垃圾回收效能  

---

### **轉換成果**  
- **延遲表現**：消除每 2 分鐘的垃圾回收峰值，實現亞毫秒級回應時間  
- **資源效率**：降低 CPU 與記憶體使用量，快取容量可擴展至 800 萬條讀取狀態且無效能衰減  
- **可靠性**：憑藉 Rust 的編譯期安全檢查，運行時錯誤大幅減少  

---

### **Rust 為 Discord 帶來的優勢**  
1. **效能表現**  
   - 可預測的低延遲特性，特別適合即時服務場景  
   - 細粒度記憶體控制能力勝過依賴垃圾回收的程式語言  

2. **安全性保障**  
   - 所有權模型可預防記憶體洩漏、空指標與資料競爭問題  
   - 無需手動同步即可實現並行安全  

3. **現代化工具鏈**  
   - Cargo 套件管理與豐富的泛型功能，相較 Go 能減少樣板程式碼  

4. **生態系統發展**  
   - 版本升級（如 Tokio 非同步運行時）無需修改程式碼即可獲得效能提升  

---

### **劣勢與挑戰**  
1. **學習門檻**  
   - Rust 的所有權與生命週期概念需要前期投入學習成本  

2. **早期非同步功能限制**  
   - 初期依賴不穩定的 nightly 版本功能存在維護風險  

3. **生態規模較小**  
   - 相較 Go 或 C++ 可用函式庫較少，但正快速成長中  

---

### **關鍵啟示**  
Discord 的成功案例證明 Rust 特別適合*對延遲敏感、高規模的服務場景*，這類場景通常無法接受垃圾回收停頓。雖然轉換過程需克服 Rust 的陡峭學習曲線，但最終換來**更快的效能、更低的資源消耗與更少的運行時錯誤**。對於優先考慮長期維護性與效能的團隊而言，Rust 相較依賴垃圾回收的 Go 等語言具有顯著優勢。

欲深入了解技術細節，請參閱 Discord 的[原始技術部落格](https://discord.com/blog/why-discord-is-switching-from-go-to-rust)。