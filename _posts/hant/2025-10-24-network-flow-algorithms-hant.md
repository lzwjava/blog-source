---
audio: false
generated: true
image: false
lang: hant
layout: post
model: x-ai/grok-4-fast
title: 網絡流算法詳解
translated: true
type: note
---

### 理解網絡流演算法

網絡流演算法是圖論和電腦科學中的基礎主題，用於建模和解決涉及資源在網絡中流動的問題（例如管道、道路或數據流）。它們對於優化任務至關重要，例如最大流（例如，系統管道能輸送多少水）、最小割（例如，尋找瓶頸），以及應用於運輸、排程和匹配等領域。

我將逐步分解：關鍵概念、簡單範例、主要演算法以及深入學習的技巧。我們將重點放在最大流問題上，因為這是核心內容。

#### 1. 關鍵概念
- **圖表示法**：網絡是一個有向圖 \\( G = (V, E) \\)，包含頂點 \\( V \\)（節點）和邊 \\( E \\)（連接）。每條邊都有一個**容量** \\( c(u, v) \\)，即從節點 \\( u \\) 到 \\( v \\) 所能承載的最大流量。
- **源點與匯點**：一個節點是**源點** \\( s \\)（流量起始處），另一個是**匯點** \\( t \\)（流量終止處）。
- **流量**：一個函數 \\( f(u, v) \\)，分配每條邊上的流量，並滿足：
  - **容量限制**：\\( 0 \leq f(u, v) \leq c(u, v) \\)。
  - **守恆定律**：對於任何非 \\( s \\) 或 \\( t \\) 的節點，流入量等於流出量（無累積）。
- **淨流量**：流量是反對稱的：\\( f(u, v) = -f(v, u) \\)。
- **殘留圖**：追蹤發送流量後的剩餘容量。如果在容量為 \\( c \\) 的邊上發送流量 \\( f \\)，則殘留正向容量為 \\( c - f \\)，反向容量為 \\( f \\)（用於「撤銷」流量）。
- **目標**：
  - **最大流**：最大化從 \\( s \\) 到 \\( t \\) 的總流量。
  - **最小割**：將節點劃分為 \\( S \\)（包含 \\( s \\)）和 \\( T \\)（包含 \\( t \\)）；最小化從 \\( S \\) 到 \\( T \\) 的容量總和。根據最大流最小割定理，最大流等於最小割容量。

#### 2. 簡單範例
設想一個小型貨運網絡：

- 節點：\\( s \\)（源點）、A、B、\\( t \\)（匯點）。
- 邊：
  - \\( s \to A \\)：容量 10
  - \\( s \to B \\)：容量 10
  - \\( A \to B \\)：容量 2
  - \\( A \to t \\)：容量 8
  - \\( B \to t \\)：容量 9

ASCII 視覺化：
```
  s
 / \
10  10
A   B
| \ / |
8  2  9
 \ /  
  t
```

最大流量是多少？直觀上，向 A 發送 10，向 B 發送 10，但 A 只能向 t 推送 8（2 流向 B，這有助於 B 推送 9+2=11，但 B 的限制是 9？等等，讓我們正確計算。

使用演算法（如下），最大流量為 17：
- 路徑 1：s→A→t（流量 8），殘留更新。
- 路徑 2：s→B→t（流量 9），殘留更新。
- 路徑 3：s→A→B→t（流量 0？等等，第一次後，A 有 2 剩餘流向 B，但 B 到 t 的剩餘容量為 0——實際上，需調整。

更好：從 s 的總流量為 20，但瓶頸限制為 17（8 直接從 A + 9 從 B，其中 2 重新路由？不——運行演算法以獲得精確值。

#### 3. 主要演算法
從基礎開始；逐步構建至高效演算法。所有演算法均沿殘留圖中的路徑增加流量，直到無更多增廣路徑為止。

- **Ford-Fulkerson 方法**（1956，基礎）：
  - 重複在殘留圖中尋找從 s 到 t 的任何路徑（例如，透過 DFS/BFS）。
  - 以該路徑上的最小殘留容量增加流量。
  - 重複直到無路徑為止。
  - **時間**：取決於實作；若容量為無理數可能很慢（但整數：O(|E| * max_flow)）。
  - **優點**：簡單。**缺點**：對於大型圖效率低。
  - 虛擬碼：
    ```
    while 殘留圖中存在從 s 到 t 的路徑 P：
        瓶頸 = P 上的最小殘留容量
        沿 P 增加流量 瓶頸
        更新殘留容量
    return 總流量
    ```

- **Edmonds-Karp**（1972，Ford-Fulkerson 的 BFS 變體）：
  - 使用 BFS 尋找最短增廣路徑（避免長路徑）。
  - **時間**：O(|V| * |E|^2) — 多項式時間，適用於小型圖。
  - 適合學習；可用約 50 行程式碼實作。

- **Dinic 演算法**（1970，更快）：
  - 透過 BFS 建立**層級圖**（按與 s 的距離分層）。
  - 使用 DFS 尋找阻塞流（每層多條路徑）。
  - **時間**：最壞情況 O(|V|^2 * |E|)，但對於單位容量為 O(|V| * |E|)；實際中非常快速。
  - **使用時機**：中型至大型圖。

- **Push-Relabel（或 Preflow-Push）**（1980 年代，Goldberg-Tarjan）：
  - 使用啟發式方法將多餘流量從節點「推送」至匯點。
  - **時間**：O(|V|^3) 或使用 FIFO/間隙啟發式更佳。
  - **優點**：處理巨型圖（例如互聯網路由）。

對於最小割：在最大流之後，割是最終殘留圖中從 s 可到達的節點與其他節點之間的劃分。

#### 4. 實作技巧
- 使用鄰接表表示圖。
- 在程式碼中（類似 Python）：將殘留容量表示為字典的字典。
- 函式庫：NetworkX（Python）有內建功能如 `maximum_flow`。
- 在小型範例上測試；使用 Graphviz 等工具視覺化。

#### 5. 常見陷阱與擴展
- **循環**：殘留圖處理「回流」以進行調整。
- **多源點/匯點**：添加超級源點/匯點。
- **成本**：對於最小成本流，添加邊成本並使用連續最短路徑。
- **應用**：航空公司排程、圖像分割（視覺）、二分圖匹配（設定流量=1）。

#### 學習路徑
- 閱讀 CLRS（Cormen 等人）第 26 章。
- 在 LeetCode/HackerRank 上練習（例如「Minimum Cost to Make at Least One Valid Path」）。
- 視覺化：在每次增廣後繪製殘留圖。

[網絡流簡介](https://www.geeksforgeeks.org/maximum-bipartite-matching/)  
[最大流最小割定理](https://en.wikipedia.org/wiki/Max-flow_min-cut_theorem)  
[NetworkX 教程](https://networkx.org/documentation/stable/tutorial.html)