---
audio: false
generated: true
lang: hant
layout: post
title: 精通 IntelliJ 結構化替換
translated: true
type: note
---

好的，讓我們來解析 IntelliJ IDEA 的結構化替換功能。

IntelliJ IDEA 的結構化替換是一項功能極其強大，但卻經常未被充分利用的特性。它允許您根據程式碼的**結構**來尋找和替換模式，而不僅僅是文字內容。這遠遠超越了簡單的文字搜尋與替換，能夠在大型程式碼庫中實現複雜的重構、程式碼風格強制執行和錯誤修復。

以下是詳細指南：

-----

## IntelliJ IDEA 結構化替換：完整指南

### 1. 什麼是結構化搜尋與替換？

SSR 的核心在於操作抽象語法樹。您不是搜尋字面字串，而是定義一個*模式*來描述您要尋找的程式碼結構，以及另一個模式來描述您希望如何轉換它。

這讓您可以：

  * **重構程式碼：** 變更方法呼叫方式、重新排列參數、封裝欄位等。
  * **強制執行編碼標準：** 確保特定語言結構或 API 呼叫的一致性。
  * **修復常見錯誤：** 識別並修正重複出現的邏輯錯誤。
  * **遷移 API：** 在函式庫或框架變更時更新程式碼。
  * **清理已棄用的程式碼：** 尋找並替換舊的 API 用法。

### 2. 存取結構化搜尋與替換

您可以透過兩種方式存取 SSR 對話框：

  * **前往 Edit -> Find -> Search Structurally...** (用於搜尋)
  * **前往 Edit -> Find -> Replace Structurally...** (用於直接替換)

兩者的對話框非常相似，"Replace Structurally" 只是多了一個 "Replace Template" 欄位。

### 3. 理解結構化搜尋對話框

結構化搜尋對話框是您定義搜尋模式的地方。

#### 3.1. 搜尋範本

這是最關鍵的部分。您需要撰寫一個代表您要尋找的*結構*的程式碼片段。

**關鍵概念：**

  * **字面程式碼：** 您直接寫入的任何程式碼將被字面匹配。
  * **變數：** 使用變數來代表程式中可以變化的部分。變數使用特殊語法定義，並透過約束條件進行配置。
      * **常見變數語法：** `$variableName$` (用美元符號包圍)。
      * **範例：** `System.out.println($arg$);` 將尋找任何 `System.out.println` 呼叫，其中 `$arg$` 將匹配括號內的任何內容。

#### 3.2. 腳本約束 (針對變數)

在「搜尋範本」中定義變數後，您需要指定它們的約束條件。這可以透過在範本中選擇變數（或將游標置於其上），然後使用 "Edit variables" 按鈕來完成。

常見的約束條件包括：

  * **Text (regexp)：** 變數的文字內容必須匹配的正規表示式。
  * **Type (regexp)：** 變數的型別必須匹配的正規表示式 (例如 `java.lang.String`, `int[]`)。
  * **Count：** 指定變數元素可以出現的次數 (例如 `[0, N]`, `[1, N]`, `[1, 1]`)。這對於陳述式集合或方法參數特別有用。
  * **Reference：** 如果變數代表識別符號（如方法名稱或變數名稱），您可以限制它引用特定的型別或宣告。
  * **Within：** 將變數限制在特定的作用域或宣告內。
  * **Not RegExp：** 根據正規表示式排除匹配項。
  * **Condition (Groovy script)：** 這是最強大的約束條件。您可以撰寫一個評估為 `true` 或 `false` 的 Groovy 腳本。該腳本可以存取匹配的元素及其屬性，允許非常複雜的邏輯。
      * **範例腳本：** 檢查整數變數的值是否大於 10：`_target.text.toInteger() > 10` (其中 `_target` 是變數的匹配元素)。

#### 3.3. 選項

在範本下方，有各種選項可以精煉您的搜尋：

  * **Context：** 定義搜尋的範圍 (例如，整個專案、模組、目錄、選取的檔案、自訂範圍)。
  * **File type：** 將搜尋限制在特定的檔案類型 (Java, Kotlin, XML 等)。
  * **Case sensitive：** 標準的大小寫敏感開關。
  * **Match case/whole words：** 適用於範本內的文字。
  * **Match line breaks：** 對於多行模式很重要。
  * **Save Template：** 儲存您當前的搜尋範本以供將來使用。

### 4. 理解結構化替換對話框

結構化替換對話框在「搜尋範本」和為搜尋定義的「變數」基礎上，增加了一個「替換範本」欄位。

#### 4.1. 替換範本

這是您定義如何轉換找到的程式碼結構的地方。

  * **來自搜尋範本的變數：** 您可以在「替換範本」中使用在「搜尋範本」中定義的相同變數。在搜尋中由變數匹配的內容將被插入到替換範本中。
  * **新程式碼：** 您可以引入新的程式碼元素、重新排列現有的元素或移除部分內容。
  * **範例：**
      * **搜尋範本：** `System.out.println($arg$);`
      * **替換範本：** `LOGGER.info($arg$);`
      * 這將把 `System.out.println("Hello");` 更改為 `LOGGER.info("Hello");`。

#### 4.2. 縮短完整名稱

此選項（通常自動啟用）會嘗試將完整類別名稱 (例如 `java.util.ArrayList`) 替換為其短名稱 (例如 `ArrayList`) 並添加必要的 import 陳述式。這對於保持程式碼可讀性至關重要。

#### 4.3. 格式化

IntelliJ IDEA 通常會根據您專案的程式碼風格設定來重新格式化替換後的程式碼，這是非常理想的。

### 5. 實用範例

讓我們透過一些常見情境來說明。

#### 範例 1：將 `System.out.println` 替換為 Logger

**目標：** 將所有 `System.out.println("message");` 更改為 `LOGGER.info("message");` (假設 `LOGGER` 是一個 static final 欄位)。

1.  **開啟結構化替換：** `Edit -> Find -> Replace Structurally...`
2.  **搜尋範本：**
    ```java
    System.out.println($arg$);
    ```
3.  **變數：** 點擊 "Edit variables" 或前往 "Variables" 標籤頁。
      * 選擇 `$arg$`。
      * **Count：** `[1, 1]` (一個參數)。
      * **Type (regexp)：** `java.lang.String` (如果您只想替換字串字面值，否則留空以匹配任何型別)。
4.  **替換範本：**
    ```java
    LOGGER.info($arg$);
    ```
5.  **執行：** 點擊 "Find" 預覽變更，如果滿意則點擊 "Replace All"。

#### 範例 2：交換方法參數

**目標：** 將 `someMethod(paramA, paramB)` 更改為 `someMethod(paramB, paramA)`。

1.  **搜尋範本：**
    ```java
    someMethod($paramA$, $paramB$);
    ```
2.  **變數：**
      * `$paramA$`： `Count: [1,1]`, `Type (regexp): .*` (任何型別)
      * `$paramB$`： `Count: [1,1]`, `Type (regexp): .*` (任何型別)
3.  **替換範本：**
    ```java
    someMethod($paramB$, $paramA$);
    ```

#### 範例 3：封裝欄位 (簡單情況)

**目標：** 如果您有 public 欄位如 `public String name;`，並希望將直接存取 `obj.name` 替換為 `obj.getName()`。(這是一個簡化範例；通常您會使用專門的重構功能進行封裝)。

1.  **搜尋範本：**
    ```java
    $object$.$fieldName$;
    ```
2.  **變數：**
      * `$object$`： `Count: [1,1]`, `Type (regexp): .*`
      * `$fieldName$`： `Count: [1,1]`, `Text (regexp): name` (專門針對 `name` 欄位)。
3.  **替換範本：**
    ```java
    $object$.get$fieldName$();
    ```
      * **注意：** 如果 `get$fieldName$` 沒有自動將 `name` 大寫為 `Name`，您可能需要調整大小寫。為此，您可以在替換範本中對 `$fieldName$` 使用 Groovy 腳本，但這會變得更複雜。對於這種特定情況，更簡單的方法通常是使用兩個 SSR 或專用的重構功能。對於 `get$fieldName$()`，IDE 通常會為常見的 getter 模式處理大小寫。

#### 範例 4：尋找空的 `catch` 區塊

**目標：** 尋找所有空的 `catch` 區塊 (或僅包含註解/空白字元)。

1.  **搜尋範本：**
    ```java
    try {
        $statements$;
    } catch ($exceptionType$ $exceptionVariable$) {
        $emptyBody$;
    }
    ```
2.  **變數：**
      * `$statements$`： `Count: [0, N]` (try 區塊中有零個或多個陳述式)
      * `$exceptionType$`： `Count: [1,1]`
      * `$exceptionVariable$`： `Count: [1,1]`
      * `$emptyBody$`： `Count: [0, 0]` (這是空主體的關鍵)

#### 範例 5：使用 Groovy 腳本進行進階條件檢查

**目標：** 尋找條件為常數 `true` 的 `if` 陳述式。

1.  **搜尋範本：**
    ```java
    if ($condition$) {
        $thenBranch$;
    }
    ```
2.  **變數：**
      * `$condition$`： `Count: [1,1]`
          * **Condition (Groovy script)：** `_target.text == "true"` (這檢查條件的字面文字)。
      * `$thenBranch$`： `Count: [0, N]`

### 6. 技巧與最佳實踐

  * **從簡單開始：** 從基本模式開始，逐漸增加複雜度。
  * **先使用 `Find`：** 在「替換」之前，始終先使用「Find」(結構化搜尋) 來預覽匹配項，確保您的模式是正確的。
  * **在小範圍測試：** 在執行大規模替換之前，在一個小的、隔離的檔案集上測試您的模式。
  * **儲存範本：** 儲存常用或複雜的範本以便重複使用。
  * **利用現有範本：** IntelliJ IDEA 附帶了許多預定義的結構化搜尋與替換範本。您可以在 SSR 對話框中點擊 "放大鏡帶加號" 圖示並瀏覽現有範本來找到它們。這些是極佳的學習資源。
  * **Groovy 腳本的威力：** 對於高度特定或上下文敏感的匹配，Groovy 腳本非常寶貴。學習在腳本內存取元素 (`_target`, `_target.parent`, `_target.text`, `_target.type` 等) 的基礎知識。
  * **理解匹配類型：** 注意您的變數正在匹配什麼 (例如，一個陳述式、一個表達式、一個型別、一個變數名稱)。這會影響您可以應用的約束條件。
  * **正規表示式：** 對正規表示式的良好理解將顯著增強您定義 `Text` 和 `Type` 約束條件的能力。
  * **除錯：** 如果您的模式沒有按預期匹配，請簡化它。逐一移除約束條件，直到它開始匹配，然後重新引入它們以找出問題。
  * **備份您的程式碼：** 在對大型程式碼庫進行任何重大的結構化替換操作之前，請確保您有備份，或者正在使用版本控制系統，以便可以輕鬆還原變更。

### 7. 限制

  * **複雜性：** 非常複雜或高度上下文相關的替換可能難以或無法純粹透過 SSR 來表達。有時，自訂的 IntelliJ IDEA 外掛或專用腳本可能更合適。
  * **效能：** 在非常大的程式碼庫上執行極其廣泛或複雜的模式可能會很慢。
  * **模糊性：** 小心過於通用的模式，因為它們可能會無意中匹配並修改您不打算修改的程式碼。

-----

透過掌握 IntelliJ IDEA 的結構化搜尋與替換，您將獲得一個強大的工具，用於維護程式碼品質、執行大規模重構以及自動化繁瑣的程式碼修改。這是一個真正能讓開發人員在其專案中更有效率、更一致地工作的功能。