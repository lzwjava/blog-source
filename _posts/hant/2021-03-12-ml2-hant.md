---
audio: false
generated: false
image: true
lang: hant
layout: post
title: 機器學習入門 —— PyTorch
translated: true
---

```markdown
---
此帖文原本以中文撰寫。為方便翻譯成其他語言，已先轉譯為英文。

---

## PyTorch

現在來安裝它。此版本支援 Python `3.9`。

```shell
$ pip install torch torchvision
Collecting torch
  Downloading torch-1.8.0-cp39-none-macosx_10_9_x86_64.whl (120.6 MB)
     |████████████████████████████████| 120.6 MB 224 kB/s
Collecting torchvision
  Downloading torchvision-0.9.0-cp39-cp39-macosx_10_9_x86_64.whl (13.1 MB)
     |████████████████████████████████| 13.1 MB 549 kB/s
Requirement already satisfied: numpy in /usr/local/lib/python3.9/site-packages (from torch) (1.20.1)
Collecting typing-extensions
  Downloading typing_extensions-3.7.4.3-py3-none-any.whl (22 kB)
Requirement already satisfied: pillow>=4.1.1 in /usr/local/lib/python3.9/site-packages (from torchvision) (8.0.1)
Installing collected packages: typing-extensions, torch, torchvision
Successfully installed torch-1.8.0 torchvision-0.9.0 typing-extensions-3.7.4.3
```

驗證一下。

```python
import torch
x = torch.rand(5, 3)
print(x)
```

出現錯誤。

```shell
Traceback (most recent call last):
  File "torch.py", line 1, in <module>
    import torch
  File "torch.py", line 2, in <module>
    x = torch.rand(5, 3)
AttributeError: partially initialized module 'torch' has no attribute 'rand' (most likely due to a circular import)
```

搜尋錯誤訊息後，發現原來檔案名稱也叫做 `torch`，導致命名衝突。重新命名後即可正常運行。

```shell
tensor([[0.5520, 0.9446, 0.5543],
        [0.6192, 0.0908, 0.8726],
        [0.0223, 0.7685, 0.9814],
        [0.4019, 0.5406, 0.3861],
        [0.5485, 0.6040, 0.2387]])
```

來看一個範例。

```python
# -*- coding: utf-8 -*-

import torch
import math
dtype = torch.float
device = torch.device("cpu")
# device = torch.device("cuda:0") # 取消註解以使用 GPU 運行

# 建立隨機輸入與輸出數據
x = torch.linspace(-math.pi, math.pi, 2000, device=device, dtype=dtype)
y = torch.sin(x)

# 隨機初始化權重
a = torch.randn((), device=device, dtype=dtype)
b = torch.randn((), device=device, dtype=dtype)
c = torch.randn((), device=device, dtype=dtype)
d = torch.randn((), device=device, dtype=dtype)

learning_rate = 1e-6
for t in range(2000):
    # 前向傳播：計算預測 y
    y_pred = a + b * x + c * x ** 2 + d * x ** 3

    # 計算並列印損失
    loss = (y_pred - y).pow(2).sum().item()
    if t % 100 == 99:
        print(t, loss)

    # 反向傳播：計算 a, b, c, d 對損失的梯度
    grad_y_pred = 2.0 * (y_pred - y)
    grad_a = grad_y_pred.sum()
    grad_b = (grad_y_pred * x).sum()
    grad_c = (grad_y_pred * x ** 2).sum()
    grad_d = (grad_y_pred * x ** 3).sum()

    # 使用梯度下降更新權重
    a -= learning_rate * grad_a
    b -= learning_rate * grad_b
    c -= learning_rate * grad_c
    d -= learning_rate * grad_d
print(f'結果：y = {a.item()} + {b.item()} x + {c.item()} x^2 + {d.item()} x^3')
```

運行結果：

```shell
99 1273.537353515625
199 849.24853515625
299 567.4786987304688
399 380.30291748046875
499 255.92752075195312
599 173.2559814453125
699 118.2861328125
799 81.72274780273438
899 57.39331817626953
999 41.198158264160156
1099 30.41307830810547
1199 23.227672576904297
1299 18.438262939453125
1399 15.244369506835938
1499 13.113286972045898
1599 11.690631866455078
1699 10.740333557128906
1799 10.105220794677734
1899 9.6804780960083
1999 9.39621353149414
結果：y = -0.011828352697193623 + 0.8360244631767273 x + 0.002040589228272438 x^2 + -0.09038365632295609 x^3
```

再看看僅使用 `numpy` 函式庫的程式碼。

```python
# -*- coding: utf-8 -*-
import numpy as np
import math

# 建立隨機輸入與輸出數據
x = np.linspace(-math.pi, math.pi, 2000)
y = np.sin(x)

# 隨機初始化權重
a = np.random.randn()
b = np.random.randn()
c = np.random.randn()
d = np.random.randn()

learning_rate = 1e-6
for t in range(2000):
    # 前向傳播：計算預測 y
    y_pred = a + b * x + c * x ** 2 + d * x ** 3

    # 計算並列印損失
    loss = np.square(y_pred - y).sum()
    if t % 100 == 99:
        print(t, loss)

    # 反向傳播：計算 a, b, c, d 對損失的梯度
    grad_y_pred = 2.0 * (y_pred - y)
    grad_a = grad_y_pred.sum()
    grad_b = (grad_y_pred * x).sum()
    grad_c = (grad_y_pred * x ** 2).sum()
    grad_d = (grad_y_pred * x ** 3).sum()

    # 更新權重
    a -= learning_rate * grad_a
    b -= learning_rate * grad_b
    c -= learning_rate * grad_c
    d -= learning_rate * grad_d

print(f'結果：y = {a} + {b} x + {c} x^2 + {d} x^3')
```

注意這兩種方法均可實現相同的計算。

在這些範例中，首先產生一組 x 與 y 值，然後假設它們符合三次方程式。接著使用某些方法反覆計算係數。這些算法是什麼？注意程式迴圈執行 `2000` 次，每次迭代結果都會更精確。這裡不會深入探討細節。

## 最後

目前我們並不清楚機器學習背後的運算原理，但這並不重要。憑藉上述知識，我們已經能做很多事情。機器學習還可用於處理文字、音訊等。在探索數十個範例後，再學習理論也不遲。

## 練習

* 學生應按上述方式進行探索。
```