---
audio: false
generated: true
image: false
lang: hant
layout: post
model: x-ai/grok-4-fast:free
title: GitHub Copilot 模式比較
translated: true
type: note
---

### 概述
GitHub Copilot 在 VS Code 和 Visual Studio 等 IDE 中提供多種程式碼輔助模式，包括編輯模式（符合您描述的「修復模式」，用於選擇和修復特定程式碼行或函式）和代理模式（處理整個檔案或專案的廣泛自主編輯）。編輯模式精確且由使用者控制，適合針對性修復；而代理模式則像一位 AI 配對程式設計師，能推理複雜任務並進行多檔案變更，無需持續輸入。[1][1] 兩種模式都能提升生產力，但在範圍、自主性和工作流程上有所不同。

### 主要差異
編輯模式專注於使用者選取的程式碼片段，在套用變更前提供建議供審核和批准。相比之下，代理模式運作層級更高，會分析完整程式庫上下文來自主規劃、執行和迭代編輯，通常會修改整個檔案或相關元件以保持一致性。[2][1] 以下是並排比較：

| 功能                      | 編輯模式（修復模式）                                                                 | 代理模式                                                                 |
|---------------------------|--------------------------------------------------------------------------------------|----------------------------------------------------------------------------|
| **範圍**                  | 僅限選取的行、函式或單一檔案。您可標示程式碼來修復錯誤、重構或改進特定部分。[1] | 整個工作區或專案。它會自動識別並編輯相關檔案，超出您的選取範圍。[2][3] |
| **使用者控制度**          | 高：提供變更建議供您審核和明確批准。您可精確定義要編輯的內容。[4] | 中等：自動套用編輯，但會標記高風險指令（例如終端機執行）供審核。您透過自然語言提示設定目標。[1][1] |
| **自主性**                | 低：提供針對性建議；不會跨檔案推理或執行獨立動作。[1] | 高：逐步推理、執行測試/指令、偵測錯誤並自我修正。在會話間保持上下文。[2][3] |
| **回應時間**              | 快速：僅對選取內容進行快速分析。[2] | 較慢：分析完整專案上下文，對於大型程式庫可能耗時較長。[2] |
| **最適合場景**            | 快速修復，例如除錯函式、優化迴圈或重寫方法，且不產生廣泛影響。[1] | 複雜任務，例如跨檔案重構、為模組生成測試、遷移程式碼或從頭開始建置功能。[3][5] |
| **範例**                  | - 選取有錯誤的函式：「修復此空值檢查。」<br>- 標示程式碼行：「將此改為非同步。」[2] | - 提示：「重構整個服務層以使用 async/await 並更新所有相依性。」<br>- 或：「將此 Java 專案現代化至 JDK 21，涵蓋所有檔案。」[5][6] |
| **風險/限制**             | 風險極低，因為變更是隔離的；但每個修復都需要手動選取。[1] | 較高的自主性可能導致非預期變更；務必審核差異。不適合高度受控的環境。[7][4] |

### 使用案例與工作流程
- **編輯模式用於針對性修復**：當您確切知道問題所在時使用此模式，例如選取函式中有錯誤的程式碼來解決錯誤或提升效能。它就像「局部編輯」工具——在 IDE 中選取程式碼，透過聊天提示 Copilot（例如「@workspace /fix」），然後套用差異預覽。此模式在迭代開發中表現出色，讓您保持完全控制並避免影響未變更區域。例如，在 .NET 專案中，您可能選取一個方法並要求「識別空參考例外並建議修復」，且僅針對該程式碼片段。[2][8] 此模式在 VS Code 和 Visual Studio 中透過 GitHub Copilot 擴充功能提供。

- **代理模式用於專案範圍編輯**：當需要編輯整個檔案或協調程式庫更新時，啟用此模式進行整體性變更。在 Copilot Chat 中啟動會話（例如「#agentmode」或透過下拉選單），提供高層級提示如「找出所有已棄用 API 的使用並遷移至新版本」，觀察其規劃步驟：分析檔案、提議編輯、執行測試和迭代。它能建立新檔案、更新命名空間，甚至搭建應用程式部分結構。例如，在 Java 現代化中，它會掃描舊版專案、更新 Gradle 相依性並驗證跨多檔案的變更。[5][3] 此模式特別適合重構、大規模錯誤搜尋或自動化重複性任務（如新增文件或測試）。[6][9]

代理模式建立在編輯模式的基礎上並加以擴展——可將編輯模式視為精準切割的手術刀，而代理模式則是處理整個手術的外科醫生。[1] 自訂指令（例如透過 VS Code 設定）可引導代理模式以保持一致性，例如在編輯中強制執行命名慣例。[1]

### 何時選擇每種模式
- 若任務是局部性的（例如修復單一函式），請選擇**編輯/修復模式**以保持簡單快速。
- 若範圍較大（如整個檔案編輯或多步驟重構），請切換至**代理模式**以提高效率，但建議從小處開始以建立對其輸出的信任。[2][1] 兩種模式均需 GitHub Copilot 訂閱（Pro 或更高版本），並整合於 VS Code/Visual Studio 中。為達最佳效果，可結合使用：先使用編輯模式進行初步修復，再使用代理模式將變更擴展至整個專案。[8] 若處理敏感程式碼，請仔細審核所有代理提案以避免意外。[7]

引用來源：
[1] https://github.blog/ai-and-ml/github-copilot/copilot-ask-edit-and-agent-modes-what-they-do-and-when-to-use-them/
[2] https://devblogs.microsoft.com/dotnet/ask-mode-vs-agent-mode/
[3] https://github.blog/ai-and-ml/github-copilot/agent-mode-101-all-about-github-copilots-powerful-mode/
[4] https://github.blog/developer-skills/github/less-todo-more-done-the-difference-between-coding-agent-and-agent-mode-in-github-copilot/
[5] https://github.blog/ai-and-ml/github-copilot/a-step-by-step-guide-to-modernizing-java-projects-with-github-copilot-agent-mode/
[6] https://code.visualstudio.com/docs/copilot/chat/chat-agent-mode
[7] https://www.reddit.com/r/GithubCopilot/comments/1je448f/after_playing-with_agent-mode_i_think_my_favorite/
[8] https