---
audio: false
generated: true
image: false
lang: hant
layout: post
model: x-ai/grok-4-fast
title: 靜態記憶體管理不可行
translated: true
type: note
---

你所引述的那段話，是程式語言史上一個著名的時刻（出自一位中國程式語言研究者在回顧與 Chez Scheme 主要作者 Kent Dybvig 的對話）。Kent 當時說的關鍵一句話大致是：

「記憶體管理本質上是一個動態過程。」

這簡短的一句話，擊碎了打造一個實用、通用程式語言的夢想——即純粹透過靜態分析（在編譯時期完成，無需執行階段的垃圾回收、參考計數、手動釋放，沒有任何動態機制）來管理所有記憶體。

### 為什麼記憶體管理本質上是動態的？

核心原因可歸結為電腦科學中的一個基本定理：**任意配置物件的生命週期在編譯時期是不可判定的**。換句話說：

> 要針對程式的每一條可能執行路徑，精確判斷一塊記憶體何時不再被需要，等價於解決停機問題——而這是不可能的。

以下逐步解釋為何如此：

1. **記憶體安全需要知道物件何時消亡**  
   為了在釋放或重用記憶體時避免懸空指標或記憶體洩漏，系統必須知道物件變得不可達（即沒有任何參考能再次使用它）的確切時刻。

2. **可達性取決於控制流程**  
   一個參考是否會被再次使用，取決於條件判斷、迴圈、遞迴、函式指標、高階函式、動態分派等。

3. **經典的停機問題歸約**  
   假設你有一個程式 P，你想知道它在輸入 x 上是否會停止。你幾乎可以在任何現實的語言中構造以下程式：

   ```pseudo
   配置一個新物件 O
   如果 P 在 x 上停止：
       丟棄所有對 O 的參考
   否則：
       永遠保留對 O 的參考並使用它
   ```

   現在詢問靜態分析器：「O 的記憶體能否在此時（或某個固定程式點）安全釋放？」  
   正確回答需要知道 `if` 分支是否會被執行——這正是停機問題。由於停機問題不可判定，沒有靜態分析器能對**所有**程式給出正確答案。

4. **真實語言使情況更糟**  
   - 一級函式 / 閉包  
   - 動態程式碼載入 / eval  
   - 指標運算、內部指標、XOR 連結串列等  
   所有這些都讓精確的靜態生命週期分析變得指數級更難（或直接不可能）。

### 靜態分析實際能做什麼？

現代系統在靜態記憶體管理方面做得非常出色，但總有妥協：

| 方法                      | 靜態？ | 保證無洩漏/懸空？        | 需要執行階段協助？        | 範例                          |
|---------------------------|--------|-----------------------|-------------------------|-------------------------------|
| 手動 malloc/free          | 否     | 否                    | 是（程式設計師）         | C                             |
| RAII / 解構式             | 大部分 | 是（若無循環）         | 是（堆疊 + 解構式）      | C++、Rust（非 Rc 類型）       |
| 線性 / 仿射類型           | 是     | 是                    | 是（所有權檢查）         | Rust、ATS、Linear Haskell     |
| 區域分析                  | 是     | 是（區域內）           | 是（區域堆疊）           | MLKit、Cyclone                |
| 完全靜態回收              | 是     | 僅限受限語言           | 通常是                  | 極小型研究語言                |
| 垃圾回收                  | 否     | 是                    | 是（GC）                | Java、Scheme、Go、JavaScript  |
| 參考計數                  | 否     | 是（除循環外）         | 是（增/減計數）          | Python、Swift、Objective-C    |

Rust 是最接近原始夢想的現實語言：它在編譯時期證明記憶體被釋放 exactly once，且釋放後絕不會再被使用——**但僅因為它禁止了某些模式**（無 Rc/Arc 的循環、自參考結構體等），並將大量負擔轉移到類型系統和借用檢查器。即使如此，Rust 仍需要執行階段支援來處理 `Rc`/`Arc` 循環（洩漏或弱參考）及一般的堆積配置。

### Kent 觀點的核心

對於一個支援以下功能的通用語言：

- 任意遞迴
- 高階函式
- 可變的堆積資料結構
- 無限制的控制流程

…你**無法**完全靜態地決定記憶體生命週期，而不會：
- 拒絕安全的程式（不健全的通過），或
- 接受不安全的程式（洩漏或懸空指標）。

這就是為什麼即使最先進的靜態系統（Rust、Vale 等）要么限制表達能力，要么在棘手情況下仍依賴某種執行階段機制。

因此，Kent 那平靜的評論並非貶低這個想法愚蠢——他是指出一個深層且已被證明的理論障礙。一旦你接受記憶體管理是一種動態屬性（通常不可判定），你就會停止對抗現實，轉而選擇最不差的執行階段妥協：GC、參考計數、借用檢查、區域管理等。

這一領悟解釋了為何當今幾乎沒有嚴肅的語言設計師會聲稱「我們將純粹靜態地解決記憶體安全問題，且無執行階段成本」。當你真正內化停機問題的歸約時，這個夢想便隨之破滅。