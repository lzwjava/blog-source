---
audio: false
generated: true
image: false
lang: hant
layout: post
model: x-ai/grok-4-fast
title: 伴隨矩陣定義與餘因子關係
translated: true
type: note
---

### 釐清伴隨矩陣的定義（及其與餘因子的關係）

你對於伴隨矩陣如何透過餘因子構建的理解大致正確，但有一個細微卻重要的修正需要說明。伴隨矩陣（通常記為 `adj(A)`）並非透過將原始元素 `a(i,j)` 乘以「其餘部分」（即移除第 i 行第 j 列後的子矩陣）的帶符號行列式來構建。實際情況是：

- 元素 `a(i,j)` 的**餘因子** `C_ij` 定義為 `C_ij = (-1)^{i+j} * det(M_ij)`，其中 `M_ij` 是從 A 中刪除第 i 行第 j 列後得到的子矩陣。這純粹是**帶符號的子式**——並不乘以 `a(i,j)` 本身。
- **餘因子矩陣** C 以這些 `C_ij` 作為其元素。
- **伴隨矩陣**是餘因子矩陣的**轉置**：`adj(A) = C^T`。因此，`adj(A)` 在位置 (i,j) 上的元素實際上是 `C_ji`（來自交換索引後的餘因子）。

這種帶符號子式的設定源自計算行列式的拉普拉斯展開（詳見下文）。你的描述聽起來有點像行列式公式本身：`det(A) = 對 j 求和 a(i,j) * C_ij`（沿任意第 i 行），該公式*確實*涉及乘以 `a(i,j)`。但伴隨矩陣跳過了這一步乘法——它僅僅是這些帶符號子式的集合，經過轉置，以實現簡潔的代數恆等式。

舉一個快速的 2x2 例子來說明（假設 A = [[a, b], [c, d]]）：
- 餘因子：C_11 = (-1)^{1+1} det([d]) = d；C_12 = (-1)^{1+2} det([c]) = -c；C_21 = (-1)^{2+1} det([b]) = -b；C_22 = (-1)^{2+2} det([a]) = a。
- 餘因子矩陣 C = [[d, -c], [-b, a]]。
- 伴隨矩陣 adj(A) = C^T = [[d, -b], [-c, a]]。
- 注意餘因子中沒有原始的 a、b、c、d 乘數——它完全關乎「其餘」子矩陣。

是的，這正是你計算伴隨矩陣的方式：為每個位置移除行/列，取其餘部分的行列式，應用符號 `(-1)^{i+j}`，組合成 C，然後轉置得到 adj(A)。它是遞歸的（子式得到更小的矩陣），因此對於大的 n x n 矩陣，計算量很大——這就是為什麼在實踐中我們通常使用高斯消去法來求逆矩陣。

### 為什麼我們需要伴隨矩陣？（它不僅僅是一個中間步驟）

你準確地指出它感覺像是矩陣求逆的「中間展示」——在許多計算意義上，確實如此！關鍵公式是 `A^{-1} = (1 / det(A)) * adj(A)`，假設 det(A) ≠ 0。這直接使用子矩陣的行列式給出逆矩陣，無需進行行運算。但它*不僅僅*是一塊墊腳石；以下是它有用且必要的原因：

1. **矩陣求逆公式**：對於小矩陣或符號計算（例如在證明或精確算術中），這是一種清晰、明確的表達逆矩陣的方式。它突顯了逆矩陣如何「分解」為縮放的餘因子。

2. **理論洞察**：恆等式 `A * adj(A) = adj(A) * A = det(A) * I`（其中 I 是單位矩陣）揭示了深層結構。它顯示每個矩陣與其伴隨矩陣在標量倍數下可交換，並且是理解奇異矩陣的基礎（det(A)=0 意味著 A adj(A)=0，因此零空間對齊）。

3. **用於線性系統的克萊姆法則**：要求解 Ax = b，第 i 個解元素是 `x_i = det(A_i) / det(A)`，其中 A_i 將 A 的第 i 列替換為 b。但 det(A_i) 透過涉及 b 元素的餘因子展開——本質上在幕後利用伴隨矩陣進行高效計算，而無需完全求逆。

4. **行列式展開**：餘因子使得拉普拉斯展開（你的「det(rest)」想法）成為可能，這對於透過將問題分解為更小的問題來計算 det(A) 至關重要。歷史上，這在電腦出現之前使行列式易於處理。

5. **更廣泛的應用**：在射影幾何、電腦圖學（變換）甚至物理學（例如阻抗矩陣）中，伴隨矩陣出現在處理奇點或推導實數域之外（如多項式）的環中的逆矩陣時。

總之，雖然行消去法在數值計算上更快，但伴隨矩陣提供了一條「解析」路徑，對於理論、教育以及需要顯式公式的情況來說非常優雅。它就像是逆矩陣背後的「原因」，而不僅僅是達到目的的手段。

### 伴隨矩陣是如何被發明的？（一點歷史）

伴隨矩陣並非來自某個「尤里卡」時刻——它是 18-19 世紀行列式和線性方程組工作的自然產物，當時矩陣尚未正式化（「矩陣」一詞出現於 1850 年）。沒有單一的發明者被歸功，但以下是其發展軌跡：

- **根源於行列式（17 世紀末–18 世紀）**：行列式源自求解線性系統（例如萊布尼茲在 1693 年針對 2x2 情況）。到了 18 世紀，像克萊姆（1750 年）這樣的數學家使用子式展開來求解，隱含地觸及了餘因子。

- **早期「伴隨」概念（1760 年代–1800 年代）**：約瑟夫·路易斯·拉格朗日於 1766 年左右在微分方程中創造了「伴隨方程」一詞，其中「伴隨」運算元鏡像了原始運算元（類似於矩陣的轉置）。阿瑟·凱萊（1840 年代–50 年代）在他的矩陣工作中將其擴展到「伴隨線性形式」。馬克西姆·博赫爾在 20 世紀初正式化了「伴隨矩陣」，但其核心思想早於他。

- **高斯的關鍵見解（1801 年）**：卡爾·弗里德里希·高斯在他的《算術研究》中為二次型（例如 ax² + 2bxy + cy²）定義了一個「伴隨」。他構建了一個伴隨形式，其係數本質上是代表原始形式的對稱矩陣的帶符號 2x2 子式——精確地預示了現代的定義（直至符號約定）。這本是用於數論（二元二次型），但它直接預見了現代的定義。高斯的工作使這種構建系統化。

- **正式化（19 世紀中期及以後）**：隨著矩陣理論的鞏固（凱萊、西爾維斯特、克羅內克），餘因子展開（來自拉普拉斯，1772 年）與這些思想融合。到了 1850 年代–60 年代，完整的逆矩陣公式 `A^{-1} = adj(A)/det(A)` 出現在教科書中，「伴隨矩陣」（源自拉丁語「adjugare」，意為結合在一起）強調了它在求逆中的結合作用。

「發明」很可能源於模式識別：在展開行列式時，數學家們注意到餘因子的集合在縮放後可以「逆轉」矩陣。它較少是靈光一現，更多是從手工求解方程組的有機演化。現代教科書（例如斯特朗的《線性代數導論》）仍然以這種方式教授它以培養直覺。

如果你需要程式碼範例（例如透過 NumPy/SymPy 在 Python 中計算伴隨矩陣）或對高斯構建的深入探討，儘管說！

[伴隨矩陣 - 維基百科](https://en.wikipedia.org/wiki/Adjugate_matrix)  
[「伴隨」一詞的首次使用 - 科學與數學史 Stack Exchange](https://hsm.stackexchange.com/questions/5908/what-is-the-first-usage-of-the-term-adjoint-and-why-was-this-word-chosen)