---
audio: false
generated: true
lang: hant
layout: post
title: 簡單物件存取協定 - SOAP
translated: true
type: note
---

讓我們深入探討關於 SOAP envelope 的疑問，包括當你訪問 URL 並收到包含 envelope、body、fault 和 detail 等元素的 SOAP 回應時會發生什麼，以及這如何與後端和前端之間的通信聯繫起來，特別是在涉及 listener 的情況下。

### 什麼是 SOAP Envelope？它是如何運作的？

SOAP 代表 **Simple Object Access Protocol**，這是一種在系統之間交換結構化資訊的方法，通常透過 HTTP 使用 XML 作為格式。**SOAP envelope** 是 SOAP 訊息的核心結構——它就像是將所有內容包裹在一起的外層封套。

SOAP envelope 有兩個主要部分：
- **Header**（可選）：包含元數據，例如身份驗證詳細資訊或路由資訊。
- **Body**（必需）：包含實際發送的數據，無論是請求、回應還是錯誤訊息。

以下是 SOAP envelope 的基本範例：

```xml
<soap:Envelope xmlns:soap="http://www.w3.org/2003/05/soap-envelope/">
  <soap:Header>
    <!-- 可選的 header 元素 -->
  </soap:Header>
  <soap:Body>
    <!-- 請求、回應或 fault 放在這裡 -->
  </soap:Body>
</soap:Envelope>
```

當客戶端（例如前端應用程式）向伺服器發送 SOAP 請求時，它會將請求數據包裝在 envelope 中。伺服器處理該請求並發送回同樣包裝在 envelope 中的回應。這種結構確保兩個系統都能理解訊息格式，使得 SOAP 非常適合分散式系統（如 Web 服務）中的通信。

### 訪問 URL 並獲得帶有 Envelope、Body、Fault 和 Detail 的 SOAP 回應

你的查詢中提到訪問 URL 並獲得帶有 "envelope body fault, detail" 的 "soup"（很可能是 SOAP 的筆誤）回應。讓我們將其理解為當你與 URL 互動時，收到了一個在其 body 中包含 fault 的 SOAP envelope。

通常，在瀏覽器中訪問 URL 會返回 HTML，但如果該 URL 是一個 **SOAP Web 服務端點**，它則設計用於處理 SOAP 請求並返回 SOAP 回應。通常，你會透過帶有 SOAP envelope 的 HTTP POST 請求發送 SOAP 請求。然而，如果你僅僅「訪問」該 URL（例如使用 GET 請求），伺服器可能仍然會回應 SOAP 訊息——也許是一個 fault——這取決於其配置方式。

**SOAP fault** 發生在處理請求時出現錯誤的情況下。伺服器不會返回正常回應，而是在 `Body` 內放置一個 `Fault` 元素。以下是 SOAP 1.1（一個常見版本）中的樣子：

```xml
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body>
    <soap:Fault>
      <faultcode>soap:Client</faultcode>
      <faultstring>Invalid request</faultstring>
      <detail>
        <errorCode>123</errorCode>
        <errorMessage>Missing required parameter</errorMessage>
      </detail>
    </soap:Fault>
  </soap:Body>
</soap:Envelope>
```

分解來看：
- **faultcode**：指示錯誤類型（例如，`soap:Client` 表示客戶端問題，`soap:Server` 表示伺服器端問題）。
- **faultstring**：人類可讀的錯誤訊息。
- **detail**（可選）：提供應用程式特定的錯誤資訊，例如錯誤代碼或詳細描述。

因此，如果你訪問 URL 並收到帶有 fault 的 SOAP envelope，這意味著：
- 伺服器收到了你的互動（很可能預期是 SOAP 請求）。
- 某些地方出錯了（例如，無效的請求格式、伺服器錯誤）。
- 伺服器返回了一條 fault 訊息來說明問題，其中 `detail` 元素提供了額外的上下文。

這種情況可能發生在：
- 你發送了不正確的 SOAP 請求（例如，透過工具或程式碼）。
- 伺服器配置為對不支援的操作（例如對僅限 POST 的端點發送 GET 請求）返回 fault。

### 在這種情況下，什麼是 Listener？

「listener」很可能指的是等待傳入 SOAP 請求的**伺服器端元件**。在 Web 服務中，這可能是：
- 基於 Java 的伺服器中的 servlet。
- .NET WCF (Windows Communication Foundation) 應用程式中的服務主機。
- 任何在特定 URL 上監聽包含 SOAP 訊息的 HTTP 請求的程式。

Listener 的作用是：
1. 接收 SOAP 請求（例如，帶有 SOAP envelope 的 HTTP POST 請求）。
2. 處理它（例如，解析 XML，執行請求的操作）。
3. 發送回 SOAP 回應，這可能是成功的結果，也可能是錯誤時發出的 fault。

### 後端和前端之間的通信如何運作

SOAP 透過 HTTP 促進**前端**（客戶端）和**後端**（伺服器）之間的通信。流程如下：

1. **前端（客戶端）**：
   - 在 `Body` 中構建帶有必要數據的 SOAP 請求 envelope。
   - 使用 HTTP POST 請求將其發送到伺服器的 URL（SOAP 端點）。
   - 範例工具：自訂應用程式、SOAP 客戶端函式庫（例如 Java 中的 JAX-WS）或測試工具如 Postman。

2. **後端（帶有 Listener 的伺服器）**：
   - Listener 接收 HTTP 請求並提取 SOAP envelope。
   - 處理請求（例如，呼叫函數、查詢資料庫）。
   - 如果成功，則構建一個在 `Body` 中包含結果的回應 envelope。
   - 如果發生錯誤，則構建一個 fault 回應（如上例所示），包含 `faultcode`、`faultstring` 以及可選的 `detail`。
   - 透過 HTTP 發送回回應。

3. **前端（處理回應）**：
   - 接收 SOAP 回應 envelope。
   - 解析 XML 以檢查 `Body`。
   - 如果是正常回應，則處理數據。
   - 如果包含 `Fault`，則提取錯誤詳細資訊（例如從 `faultstring` 和 `detail` 中）並進行處理——也許是向用戶顯示錯誤訊息。

例如：
- **請求**：客戶端透過 SOAP 請求要求用戶數據。
- **成功回應**：伺服器在 `Body` 中返回數據。
- **Fault 回應**：如果用戶 ID 無效，伺服器返回一個 fault，其訊息類似「User not found」，並且 `detail` 元素指定了無效的 ID。

### 總結

當你「訪問 URL 並獲得帶有 body fault 和 detail 的 SOAP envelope」時，這很可能意味著你與一個 SOAP Web 服務端點進行了互動，而伺服器回應了一個錯誤。**Envelope** 包裹了訊息，**body** 包含了一個指示錯誤的 **fault**，而 **detail** 則提供了關於問題具體內容的詳細資訊。

**Listener** 是伺服器用於接收和處理這些請求的機制。**後端**（伺服器）和**前端**（客戶端）之間的通信透過 HTTP 進行，SOAP envelope 以 XML 形式交換。客戶端發送請求，伺服器的 listener 處理它們，然後回應——無論是成功還是 fault——都會返回給客戶端處理。

這種結構使得 SOAP 在結構化、具錯誤感知的通信中非常可靠，特別是在需要精確錯誤報告（透過 fault）的企業系統中。如果你正在測試這個，嘗試使用工具或程式碼向 URL 發送正確的 SOAP 請求，以查看成功和 fault 回應的實際情況！