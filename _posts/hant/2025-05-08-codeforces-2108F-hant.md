---
audio: false
generated: true
lang: hant
layout: post
title: Codeforces 2108F
translated: true
type: note
---

讓我們深入探討為何提供的 Java 程式碼能夠解決「倒塌高塔」問題。該問題涉及一個包含 \\( n \\) 座高塔的陣列，每座高塔的高度為 \\( a_i \geq 0 \\)。你可以擊倒位置 \\( i \\) 的高塔，此操作會將後續 \\( a_i \\) 座高塔的高度增加 1（如果剩餘的高塔不足，則增加較少的高塔），然後將 \\( a_i \\) 設為 0。目標是以任意順序恰好擊倒所有 \\( n \\) 座高塔一次，並確保最終陣列是非遞減的（即對於任何 \\( i < j \\)，位置 \\( i \\) 的高度不大於位置 \\( j \\) 的高度）。輸出是最終陣列的最大 MEX，其中 MEX 是陣列中未出現的最小非負整數。

---

### 問題分析

1. **操作定義**：
   - 擊倒高度為 \\( a_i \\) 的位置 \\( i \\) 高塔：
     - 將位置 \\( i+1, i+2, \dots, i+a_i \\) 的高塔高度增加 1（如果它們存在）。
     - 將 \\( a_i \\) 設為 0。
   - 每座高塔必須恰好被擊倒一次，順序任意。
   - 如果 \\( a_i = 0 \\)，擊倒高塔 \\( i \\) 對其他高塔沒有影響。

2. **非遞減最終陣列**：
   - 所有操作完成後，最終陣列 \\( b_1, b_2, \dots, b_n \\) 必須滿足 \\( b_i \leq b_{i+1} \\) 對於所有 \\( i < n \\)。

3. **MEX**：
   - 最終陣列的 MEX 是未出現在 \\( \{b_1, b_2, \dots, b_n\} \\) 中的最小非負整數 \\( m \\)。
   - 由於陣列是非遞減的，如果陣列包含值 \\( 0, 1, 2, \dots, k-1 \\)（可能重複）但不包含 \\( k \\)，則 MEX 為 \\( k \\)。
   - 目標是最大化此 MEX。

4. **MEX 的解釋**：
   - 要實現 MEX 為 \\( m \\)，最終陣列必須至少包含一次從 0 到 \\( m-1 \\) 的所有整數，且不能出現 \\( m \\)。
   - 由於陣列是非遞減的，實現 MEX 為 \\( m \\) 意味著最終陣列的值類似 \\( 0, 0, \dots, 1, 1, \dots, m-1, m-1 \\)，其中從 0 到 \\( m-1 \\) 的每個整數至少出現一次，且沒有值 \\( m \\) 或更高。

5. **關鍵洞察**：
   - MEX \\( m \\) 對應於至少有一個位置擁有從 0 到 \\( m-1 \\) 的每個值。
   - 等效地說，對於 MEX \\( m \\)，我們需要最終陣列中至少有 \\( m \\) 個位置，使得位置 \\( i \\) 的值至少為 \\( i - (n - m) \\)，因為：
     - 最後 \\( m \\) 個位置（從索引 \\( n-m+1 \\) 到 \\( n \\)）必須涵蓋值 0 到 \\( m-1 \\)。
     - 位置 \\( n-m+1 \\) 的值應至少為 0，位置 \\( n-m+2 \\) 至少為 1，...，位置 \\( n \\) 至少為 \\( m-1 \\)。
   - 這轉化為要求位置 \\( i \\) 的最終高度至少為 \\( \max(0, m - (n - i + 1)) = \max(0, m - n + i) \\)。

---

### 解決方法

程式碼使用二元搜尋來尋找最大可能的 MEX \\( m \\)。對於每個候選 \\( m \\)，它檢查是否可能實現一個非遞減的最終陣列，其中每個位置 \\( i \\) 的高度至少為 \\( \max(0, m - n + i) \\)。這確保了最後 \\( m \\) 個位置可以涵蓋值 0 到 \\( m-1 \\)，使得 MEX 至少為 \\( m \\)。

#### 二元搜尋
- **範圍**：MEX \\( m \\) 至少為 0（空陣列情況），最多為 \\( n \\)（因為我們需要至少 \\( m \\) 個位置來擁有值 0 到 \\( m-1 \\)）。因此，在 \\( [0, n] \\) 範圍內搜尋 \\( m \\)。
- **檢查函數**：對於給定的 \\( m \\)，判斷是否存在一種擊倒高塔的順序，使得最終陣列滿足：
  - \\( b_i \geq \max(0, m - n + i) \\) 對於所有 \\( i \\)。
  - 陣列是非遞減的。

#### 檢查函數
檢查函數使用差分陣列方法模擬是否可以使用任何順序擊倒高塔來達到所需高度。

1. **所需高度**：
   - 對於 MEX \\( m \\)，位置 \\( i \\) 需要最終高度 \\( b_i \geq \text{need}_i \\)，其中：
     \\[
     \text{need}_i = \max(0, m - n + i)
     \\]
   - 這確保了位置 \\( n-m+1 \\) 到 \\( n \\) 的高度分別至少為 0, 1, ..., \\( m-1 \\)。

2. **差分陣列**：
   - 程式碼使用差分陣列 \\( d \\) 來追蹤操作的累積效果。
   - 初始化所有 \\( i \\) 的 \\( d[i] = 0 \\)。
   - 對於每個位置 \\( i \\)：
     - 計算累加和：\\( d[i] += d[i-1] \\)（如果 \\( i > 0 \\)），表示位置 \\( i \\) 當前的額外方塊數量。
     - 檢查 \\( d[i] \geq \text{need}_i \\) 是否成立。如果不成立，則無法達到所需高度，返回 \\( false \\)。
     - 計算擊倒高塔 \\( i \\) 所影響的範圍長度：
       \\[
       \text{len} = d[i] - \text{need}_i + a_i
       \\]
       - \\( d[i] - \text{need}_i \\)：在滿足最低要求後可用的額外方塊。
       - \\( a_i \\)：由高塔 \\( i \\) 的高度貢獻的方塊數量。
       - 此 \\( \text{len} \\) 表示當高塔 \\( i \\) 被擊倒時，可以向右增加多少個位置的高度。
     - 更新差分陣列：
       - 增加 \\( d[i+1] \\)（如果 \\( i+1 < n \\)）以開始擊倒高塔 \\( i \\) 的效果。
       - 減少 \\( d[i + \text{len} + 1] \\)（如果 \\( i + \text{len} + 1 < n \\)）以在 \\( \text{len} \\) 個位置後結束效果。

3. **可行性**：
   - 差分陣列模擬了基於當前狀態擊倒高塔 \\( i \\) 的效果。
   - 如果循環完成且未返回 \\( false \\)，則可以實現 MEX \\( m \\) 所需的高度。

4. **為何有效**：
   - 檢查函數不模擬實際操作順序，而是驗證是否存在滿足高度要求的順序。
   - 差分陣列方法確保添加到每個位置的方塊數量與某些有效操作序列一致。
   - 非遞減條件隱含滿足，因為所需高度 \\( \text{need}_i = \max(0, m - n + i) \\) 是非遞減的（隨著 \\( i \\) 增加，\\( m - n + i \\) 增加或保持為 0）。

#### 主循環
- 讀取測試案例數量 \\( t \\)。
- 對於每個測試案例：
  - 讀取 \\( n \\) 和陣列 \\( a \\)。
  - 在 \\( m \\) 從 0 到 \\( n \\) 的範圍內執行二元搜尋。
  - 使用檢查函數判斷 MEX \\( m \\) 是否可實現。
  - 更新 \\( lo \\)（如果可實現）或 \\( hi \\)（如果不可實現）。
- 輸出每個測試案例的最大 \\( m \\)（即 \\( lo \\)）。

---

### 為何程式碼能解決問題

1. **二元搜尋的正確性**：
   - 二元搜尋找到檢查函數返回 \\( true \\) 的最大 \\( m \\)。
   - 由於 MEX \\( m \\) 的可行性意味著所有較小 MEX 值（較低的 \\( m \\) 需要較少位置且高度較低）的可行性，二元搜尋正確識別了最大可能的 MEX。

2. **檢查函數的準確性**：
   - 檢查函數確保每個位置 \\( i \\) 在所有操作後能夠擁有至少 \\( \max(0, m - n + i) \\) 個方塊。
   - 差分陣列模擬擊倒高塔的累積效果，考慮到每座高塔貢獻 \\( a_i \\) 個方塊給後續 \\( a_i \\) 個位置。
   - 通過從左到右處理位置並調整差分陣列，它驗證初始高度 \\( a_i \\) 是否可以重新分配以滿足所需高度。

3. **處理非遞減約束**：
   - 所需高度 \\( \max(0, m - n + i) \\) 是非遞減的，這與問題對非遞減最終陣列的要求一致。
   - 如果檢查函數成功，則可以通過確保每個位置達到或超過所需高度來使最終陣列非遞減。

4. **效率**：
   - **二元搜尋**：\\( O(\log n) \\) 次迭代（因為 \\( m \leq n \\)）。
   - **檢查函數**：每次呼叫 \\( O(n) \\)，因為它處理每個位置一次並在每個位置以常數時間更新差分陣列。
   - **每個測試案例總計**：\\( O(n \log n) \\)。
   - **所有測試案例總計**：由於 \\( \sum n \leq 10^5 \\)，總體複雜度為 \\( O(t \cdot n \log n) \\)，這在 3 秒時間限制內是可行的。

5. **邊界情況**：
   - **\\( n = 1 \\)**：如果 \\( a_1 = 0 \\)，MEX = 1（陣列變為 [0]）。如果 \\( a_1 > 0 \\)，MEX = 0（陣列變為 [0]）。程式碼正確處理此情況。
   - **大的 \\( a_i \\)**：雖然 \\( a_i \leq 10^9 \\)，但僅影響前 \\( n-i \\) 個位置，程式碼使用陣列限制正確地約束了效果。
   - **所有 \\( a_i = 0 \\)**：最終陣列全為零，MEX = 1。檢查函數確認這一點。
   - **混合值**：二元搜尋和檢查函數處理任意的 \\( a_i \geq 0 \\)。

---

### Java 程式碼細節

Java 程式碼使用 `BufferedReader` 和 `PrintWriter` 進行高效 I/O，以適應要求。關鍵方面：

1. **輸入處理**：
   - 使用 `BufferedReader` 讀取行，並使用 `StringTokenizer` 解析整數。
   - 讀取 \\( t \\)，然後對於每個測試案例，讀取 \\( n \\) 和陣列 \\( a \\)。

2. **檢查器類別**：
   - 封裝檢查邏輯以模擬 C++ lambda 函數。
   - 使用陣列 \\( d \\) 來模擬差分陣列方法。

3. **輸出**：
   - 使用 `PrintWriter` 輸出每個測試案例的結果，並使用 `out.flush()` 確保所有輸出都被寫入。

4. **效能**：
   - Java 程式碼保持每個測試案例相同的 \\( O(n \log n) \\) 複雜度。
   - `BufferedReader` 和 `PrintWriter` 確保 I/O 對於 \\( \sum n \leq 10^5 \\) 足夠快。

---

### 結論

程式碼通過以下方式解決「倒塌高塔」問題：
- 使用二元搜尋尋找最大 MEX \\( m \\)。
- 採用基於差分陣列的檢查函數來驗證初始高塔高度是否可以重新分配以實現具有所需高度的非遞減陣列。
- 通過所需高度的非遞增性質和操作序列的可行性確保正確性。
- 處理所有邊界情況並符合時間和記憶體限制。

Java 實現忠實地翻譯了 C++ 邏輯，使用高效的 I/O 以滿足問題的要求。