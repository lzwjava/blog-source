---
audio: false
generated: true
image: false
lang: hant
layout: post
title: 模型關係而非數據
translated: true
type: note
---

你說得完全正確——「一對一、一對多、多對多」無處不在：家庭、團隊、支付；課程、代碼庫、拉取請求。這是一份精煉的實戰手冊，用於**釐清關係**，讓設計保持簡潔並符合實際使用場景。

# 實用建模手冊

## 1) 從行為出發，而非數據

* 寫下**前5項用戶任務**（例如「下訂單」、「審批費用」、「分配審核者」）。
* 在每項任務下列出**名詞**（實體）和**動詞**（關係/動作）。
* 只保留那些會**改變任務結果**的關係；其餘皆視為元數據。

## 2) 先決定所有權與邊界

* 提問：*誰擁有誰的生命週期？*
  * 若A脫離B便無法存在 → A**屬於**B的一部分（組合關係）。
  * 若A與B可獨立存在 → **引用**關係。
* 運用**限界上下文**：同一個「客戶」在計費系統與行銷系統中可能不同。勿強行建立單一巨型模型。

## 3) 選擇**最簡基數**即可

* 僅在兩筆記錄操作上不可分離但需不同安全性或變動性時（例如用戶 ↔ 憑證），才採用**一對一**。
* 當存在明確所有權且需頻繁存取父項→子項時（例如訂單 → 訂單明細），優先採用**一對多**。
* 僅當雙方為對等關係且連結本身具業務意義時（例如學生 ↔ 課程，透過包含成績、狀態、日期的「註冊」連結），才使用**多對多**。

## 4) 以不變條件明確表達關係

為每個關係用淺白語言寫下不變條件：

* **基數**：「一個用戶最多有一個主要電郵。」
* **可選性**：「一張發票必須包含≥1個項目。」
* **時效性**：「會員資格在[開始時間,結束時間)內有效。」
* **唯一性**：「產品代碼在每個租戶內唯一。」
  這些條件可直接轉化為約束、索引和檢查。

## 5) 按基數進行建模模式（無需表格😉）

### 一對一

* 在拆分易變/安全字段，或實體需模組化擴展時使用。
* 透過外鍵上的唯一鍵強制執行。
* 若總是同時讀取，可考慮**嵌入**（文件型數據庫）。

### 一對多

* 若子項絕不更換父項 → 在子項保留**父項鍵值**；依策略級聯刪除。
* 若存在重新分配父項的情況 → 允許外鍵可為空值 + 業務規則處理過渡。
* 若讀取操作以父項為中心 → 在父項反正規化摘要字段（如計數、最後更新時間）。

### 多對多

* 將連結提升為**首要實體**（例如註冊、會員資格、分配）。
* 將**業務數據**置於連結上（例如角色、優先級、權重、時間戳）。
* 若連結無屬性且數據量龐大，根據查詢量較大一方的需求選擇儲存方式與索引。

## 6) 根據存取模式選擇儲存方案

* **關聯式數據庫**：最強一致性、複雜聯結、報表功能。
* **文件型數據庫**：聚合優先、讀取密集型且以父項為中心的流程、局部更新。
* **圖數據庫**：路徑查詢、推薦系統、權限繼承、可變深度遍歷。
  為每個**限界上下文**選擇一種；透過事件同步，而非共享表格。

## 7) API 設計需有意圖地反映關係

* **聚合**成為主要 API 資源。
* **子集合**作為嵌套路由（例如 `/orders/{id}/items`）。
* **聯結實體**若具重要性則擁有自身資源（例如 `/enrollments`）。
* 為提升客戶端靈活性，僅在領域本身具圖形特性或客戶端差異極大時才暴露 **GraphQL**；否則保持 REST 簡潔。

## 8) 保持可演進性（時態性 + 軟性變更）

* 在重要連結上追蹤**有效時間**（`valid_from`, `valid_to`），而不僅是 `updated_at`。
* 對關係數據行優先採用**軟刪除**，以便重建歷史記錄。
* 所有實體及連結數據行均使用**代理鍵**；切勿在 ID 中嵌入業務含義。

## 9) 積極簡化

* 若用戶從未感知差異，則合併實體。
* 當安全性/效能原因不再存在時，合併一對一拆分。
* 若業務規則確呈樹狀結構，則以**層級結構**取代複雜的多對多網絡。
* 引入**角色**以替代多種連結類型（例如，使用單一「會員資格」實體並以 role=owner/viewer 區分，而非建立獨立連結）。

## 10) 對現有混亂進行反向研究（逆向工程）

* 映射**實際查詢**（慢查詢日誌、儀表板）。僅保留被≥1個關鍵查詢使用的關係。
* 繪製**上下文映射圖**：哪些團隊/系統擁有哪些實體，以及誰消費哪些事件。
* 識別**熱點聯結** → 透過反正規化、緩存或轉為聚合來處理。
* 將繁雜的多對多連結提升為具明確不變條件的**首要概念**。
* 添加**合約**：對結構描述與 API 實施約束、測試及檢查工具，防止偏離。

# 應避免的常見陷阱

* 將多對多視為「僅僅是一個聯結表」，而其實它是業務核心（例如權限、分配）。
* 對需要低延遲的讀取路徑過度正規化；可透過**讀取模型**（CQRS）或物化視圖修正。
* 未明確規範可選性——`NULL` 會導致複雜度激增。在有意義時，優先採用明確的「未知/不適用」狀態。
* 忽略**多租戶**：及早按租戶限定唯一性與查詢範圍。
* 忘記**方向性**：「關注」與「好友」並不相同。

# 可重用的輕量級檢查清單

* 首要任務及其成功指標為何？
* 聚合是哪些（所有權/生命週期）？
* 不變條件是哪些（基數、可選性、時效性、唯一性）？
* 哪些關係承載業務屬性（需提升為實體）？
* 哪些存取模式佔主導（據此選擇儲存/索引）？
* 當前可安全實施哪些簡化（合併/拆分/反正規化）？
* 哪些合約可強化此設計（約束、API 測試、事件結構描述）？

如果你願意，提供你領域的一小部分（三個實體 + 主要用戶任務），我將為你勾勒出關係、不變條件以及可直接實施的儲存/API 結構。