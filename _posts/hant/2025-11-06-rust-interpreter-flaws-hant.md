---
audio: false
generated: true
image: false
lang: hant
layout: post
model: x-ai/grok-4-fast
title: Rust 解譯器的痛點與設計缺陷
translated: true
type: note
---

### 英文翻譯與解說

這段文字節錄自王垠（一位以直譯器與程式語言研究聞名的計算機科學研究員及教育者）的部落格文章。原文以中文撰寫，記錄了他教授 Rust 並在構建基礎函數式程式語言直譯器過程中的親身經歷。以下提供清晰且地道的英文翻譯：

> 當我最初開始接觸 Rust 語言時，內心確實有些疑慮。Rust 的型別系統相當嚴格，入門門檻頗高——我們真的能用它來構建直譯器嗎？答案是肯定的。雖然用 Rust 編寫直譯器的過程確實充滿挑戰，還是有幾位學生成功完成了任務。透過這個過程，他們對 Rust 記憶體管理的核心概念：所有權、生命週期、`Rc`、`RefCell` 等有了深刻理解。這不僅是表面功夫，更是從本質上揭示了這些概念的真正內涵。
> 
> 對我而言，用 Rust 編寫直譯器是首次嘗試。在過去二十多年間，我曾用其他語言構建過無數直譯器、型別系統、編譯器、混淆器等類似專案。但這次即便是基礎函數式語言直譯器，也讓我遭遇了重大困難。雖然編寫典型的 Rust 程式並非特別困難，但我明顯感受到與其他語言相比，認知負荷要沉重得多。大量額外精力都消耗在與記憶體管理細節的搏鬥上，導致能專注於直譯器語義邏輯的思維空間所剩無幾。網路上找不到可參考的程式碼——只能依靠自己不斷試錯與探索理解。最終我不僅完成了直譯器，更透過這段掙扎徹底掌握了 Rust 的記憶體管理原則。這段經歷讓我發現了 Rust 中存在的嚴重設計缺陷，這些缺陷造成了不必要的困難。因此，儘管我現在已深度掌握 Rust，對其長期發展前景仍持悲觀態度。

本質上，王垠描述了一場教學實驗：他與學生們透過實作直譯器直面 Rust 陡峭的學習曲線。他特別強調了 Rust 的所有權與借用規則（在編譯時強制保證記憶體安全）與直譯器中常見的動態遞迴資料結構（例如需要可變引用的抽象語法樹或環境）之間的衝突所帶來的挫折感。儘管過程痛苦，他仍視其為內化 Rust 安全保證的寶貴（雖艱辛）途徑。然而他最終結論是，這些機制存在「設計錯誤」，會分散對高階程式設計關注點的注意力，使得 Rust 在語言實作等複雜系統中的吸引力大打折扣。

### 評斷：此評估是否公允準確？

王垠的論述是基於真實專業知識的個人見解——他曾在 Scheme、Python、OCaml 等多種語言中實作過數十種語言工具，因此他的挫折感並非空穴來風。對於某些特定任務（特別是涉及複雜資料流的情境，如直譯器中常需透過 `Rc<RefCell<T>>` 來處理共享可變狀態以規避借用檢查器的警告），Rust 確實會帶來較高的前期認知成本。這確實可能使關注點從「語義邏輯」（例如求值規則或型別推論）轉移至繁瑣的生命週期標註或克隆策略。他關於參考資料稀缺的觀點（考慮到這篇文章可能發表於 2023-2024 年間）也有其道理；雖然 Rust 生態系統不斷成長，但高品質、符合語言習慣的直譯器範例相比 Python 或 Haskell 仍相對匱乏。

然而，他的 broader claims——特別是將 Rust 核心設計稱為「嚴重缺陷」並斷言其未來黯淡——則顯得言過其實且主觀。以下是平衡分析：

#### 其觀點的優勢
- **直譯器的學習曲線**：對新手而言一針見血。Rust 在安全、並行的系統程式設計（例如網頁伺服器、CLI 工具）領域表現卓越，但直譯器常需要具備循環引用或內部可變性的圖狀結構，這與所有權的設計理念天然衝突。這迫使開發者採取「取巧」的解決方案（例如使用分配器 arena 或引用計數 `Rc`），增加了樣板程式碼。多項研究與調查（包括 Rust 官方團隊的）都承認這是常見痛點，約 20-30% 的早期使用者將借用檢查列為主要障礙。
- **對語義邏輯的干擾**：中肯合理。在動態語言中可快速原型化語義邏輯；而在 Rust 中，安全證明發生在編譯時，這轉移了精力投入。王垠提出的「腦力負擔」與其他程式語言研究者的抱怨不謀而合（例如在關於 Rust 中嵌入 DSL 的學術論文中）。
- **探索的回報**：他正確指出了回報——掌握所有權/生命週期後會豁然開朗，使 Rust 成為實現無錯誤程式碼的利器。

#### 弱點與反駁觀點
- **並非對所有人都是「不必要的困難」**：Rust 的嚴格性正能預防記憶體洩漏、釋放後使用錯誤或垃圾回收停頓等困擾 C、Python 甚至 Lisp 直譯器實作的問題。一旦度過適應期，其程式碼往往更易於推理（無執行時意外）。對於函數式風格的直譯器，像 `im`（不可變集合）或 `generational-arena` 這類套件能讓實作更流暢，減少對 RefCell 的依賴。
- **參考程式碼確實存在（與其主張相反）**：截至 2024 年末/2025 年初，GitHub 上已有大量優質範例：
  - [RustPython](https://github.com/RustPython/RustPython)：以 Rust 實作的完整 Python 直譯器，優雅處理求值、AST 與可變性。
  - [rune](https://github.com/rune-rs/rune)：基於 Rust 的可嵌入腳本語言直譯器。
  - 更簡易的實作如 [brainfuck-rs](https://github.com/P0lip/brainfuck-rs) 或 Lisp 直譯器（例如 [mylisp](https://github.com/kanaka/mylisp)）展示了所有權模型能夠在不過度痛苦的情況下模擬直譯器狀態。
  王垠可能因語言隔閡或時效性忽略了這些資源，但它們確實存在——且社群（例如透過 `rust-embedded` 或程式語言論壇）持續分享環境/作用域的實作模式。
- **未來展望過度悲觀**：Rust 的採用率正蓬勃發展（Stack Overflow 最受喜愛語言九連冠，應用於 Firefox、AWS、Discord）。設計「錯誤」？所有權機制並非缺陷——而是其核心賣點，以人體工學換取零成本安全。即將推出的新功能（例如非同步改進、1.80+ 版本中更完善的模式匹配）正持續改善人體工學。像王垠這樣直言不諱的批評者（他在 Twitter/X 平台相當活躍）屬於發聲的少數群體；多數程式語言研究者認為 Rust 正在向兼具表達力與安全性的方向演進。
- **情境重要性**：這本質是針對初學者的教學練習，自然會放大痛點。對於專業開發者，Rust 在生產環境直譯器（例如 WebAssembly 的 Wasmtime）中表現卓越。

總體而言，王垠的經驗作為個案記錄是「真實」的——這是條艱辛卻具啟發性的道路，揭示了 Rust 的權衡取捨。但他關於「嚴重設計錯誤」與黯淡未來的結論，讀來更像是挫折感驅動的誇大其詞，而非客觀的缺陷指證。若您正準備構建直譯器，建議從 Rust 的 [The Little Book of Rust Macros](https://veykril.github.io/tlborm/) 或 nom 解析器函式庫入手以積累動能。Rust 不會取代具垃圾回收機制的語言在快速原型開發中的地位，但對於需要可靠性與高效能的實作？它的發展正欣欣向榮。

參考資料：  
[王垠的 Substack 文章](https://yinwang1.substack.com/p/5)  
[RustPython GitHub](https://github.com/RustPython/RustPython)  
[Rune Language GitHub](https://github.com/rune-rs/rune)  
[Stack Overflow 2024 年開發者調查](https://survey.stackoverflow.co/2024/)