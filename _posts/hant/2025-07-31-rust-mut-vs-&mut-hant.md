---
audio: false
generated: true
image: false
lang: hant
layout: post
title: Rust 的 mut 與 &mut 詳解
translated: true
type: note
---

在 Rust 中，關鍵字 `mut` 和 `&mut` 有著相關但不同的用途，它們並不完全等同於 Java 的深層/淺層複製概念或 C 的指標——儘管我們可以透過類比來幫助理解。我將逐步分解說明、解釋差異，並回答你關於值傳遞與參考傳遞、可變性以及變更如何影響原始資料的問題。我會使用你提供的程式碼範例來說明。

### 1. **理解變數宣告中的 `mut`**
   - 當你用 `let mut` 宣告變數時，你讓*繫結*（變數名稱）成為可變的。這表示你可以重新指派該變數或直接修改其內容，但僅限於宣告它的作用域內。
   - 來自你的程式碼範例：
     ```rust
     let mut arr = [3, 6, 8, 10, 1, 2, 1];
     ```
     這裡，`arr` 是可變的，所以你可以執行 `arr[0] = 99;` 或甚至之後重新指派 `arr = [1, 2, 3];`。如果沒有 `mut`，Rust 會對嘗試修改不可變變數的行為報錯（Rust 預設為不可變以確保安全）。
   - 這個 `mut` 是關於變數本身，而不是關於它如何傳遞給函式。它並不意味著複製或參考——它只是允許在該位置修改變數的權限。

### 2. **理解函式參數和參考中的 `&mut`**
   - `&mut` 建立一個*可變參考*（也稱為可變借用）。這類似於 C 中允許讀取*和*寫入指向資料的指標，但 Rust 的嚴格借用檢查器確保了安全性（無資料競爭，無懸空指標）。
   - 在你的程式碼中：
     ```rust
     fn quick_sort(arr: &mut [i32]) { ... }
     ```
     - 參數 `arr` 是一個對 `i32` 切片（`&mut [i32]`）的可變參考。Rust 中的切片是對陣列或向量的視圖（類似指標 + 長度），它們幾乎總是以參考形式傳遞，因為切片是「非固定大小」類型（其大小在編譯時未知）。
     - 當你呼叫 `quick_sort(&mut arr);` 時，你傳遞的是對原始 `arr` 的可變參考。這允許函式透過參考修改原始陣列的元素（例如，透過 `partition` 中的交換操作）。
     - 在函式內部，像 `arr.swap(i, j);` 這樣的操作會直接影響原始資料，因為 `arr` 是指向它的參考。
   - 如果沒有 `&`，你無法以這種方式直接將像 `[i32]` 這樣的切片作為參數傳遞——Rust 對非固定大小類型要求使用參考。但更一般地說，`&mut` 實現了具有變更權限的參考傳遞。

### 3. **Rust 中的值傳遞與參考傳遞**
   - Rust 使用*所有權*作為其核心模型，這與 Java（主要是基於參考並帶有垃圾回收）或 C（手動指標）不同。
     - **值傳遞（所有權轉移）**：當你沒有使用 `&` 傳遞值時（例如 `fn foo(x: i32)` 或 `fn bar(mut v: Vec<i32>)`），資料的所有權會轉移到函式。函式可以在本地修改它，但變更不會影響呼叫者的原始資料（因為呼叫者不再擁有它）。如果該類型實現了 `Copy`（例如像 `i32` 這樣的原始類型），它會自動被複製而不是移動——除非你明確克隆，否則不會進行深層複製。
       - 範例：
         ```rust
         fn foo(mut x: i32) {
             x += 1;  // 修改本地 x，但呼叫者的原始資料未變（或被移動/複製）。
             println!("Inside: {}", x);
         }

         let y = 5;
         foo(y);  // 透過值傳遞（複製，因為 i32 是 Copy）。
         println!("After: {}", y);  // 仍然是 5。
         ```
       - 這類似於其他語言中的「值傳遞」：原始類型被複製，較大的類型（如陣列/向量）被移動（高效，除非克隆否則不複製）。
     - **參考傳遞（借用）**：使用 `&`（不可變參考）或 `&mut`（可變參考）來「借用」資料而不轉移所有權。函式獲得一個臨時視圖（類似指標），原始所有者保留控制權。
       - `&`：唯讀借用。無法修改原始資料。
       - `&mut`：讀寫借用。*可以*修改原始資料，類似於 C++ 中的參考傳遞或 C 中的可變指標。
       - 範例：
         ```rust
         fn bar(x: &mut i32) {
             *x += 1;  // 解參考並修改原始資料。
         }

         let mut y = 5;
         bar(&mut y);  // 傳遞可變參考。
         println!("After: {}", y);  // 現在是 6，原始資料被改變。
         ```
       - 在你的快速排序程式碼中，使用的是帶有 `&mut` 的參考傳遞，因此交換操作會改變原始陣列。如果只是 `& [i32]`，你將無法修改它（不可變借用）。

   - 針對你的觀點：是的，`&mut` 允許改變原始值（帶有變更的參考傳遞），而不使用 `&` 的傳遞（值傳遞）則會複製/移動資料，因此修改是局部的，不會影響原始資料。但是：
     - 並非所有類型都會自動複製——只有實現了 `Copy` 的類型才會（例如 `i32`，而不是陣列或向量）。對於像你的陣列這樣的非 `Copy` 類型，透過值傳遞會*移動*所有權，你需要將其返回以「歸還」給呼叫者。
     - Rust 為了效率避免不必要的複製。你的陣列在作為 `&mut [i32]` 傳遞時不會被複製——它只是一個參考（淺層，類似指標）。

### 4. **與 Java 和 C 的比較**
   - **Java**：所有非原始類型都是透過參考傳遞（淺層——物件是共享的，但重新指派參數不會影響呼叫者）。原始類型是透過值傳遞（複製）。沒有直接對應於 `mut` 或 `&mut` 的概念；可變性由類別設計控制（例如 final 欄位）。Java 沒有 Rust 的所有權概念，因此更容易出現共享可變狀態的問題。深層複製需要手動克隆。
   - **C**：`&mut` 類似於傳遞指標（`int*`），你可以解參考並修改（`*ptr = 10;`）。單純的 `mut`（在宣告中）類似於非 const 變數。但 C 沒有借用檢查器，因此你需要手動管理生命週期（容易出錯）。在 C 中透過值傳遞會複製資料（對於結構體是淺層複製，除非你進行深層複製）。
   - 關鍵差異：Rust 強制執行「一次只能有一個可變參考」（或多個不可變參考），從而防止錯誤。沒有空值，沒有野指標。

### 5. **為什麼你的程式碼中有時用 `mut`，有時用 `&mut`？**
   - 單獨使用 `mut`：用於需要可變的局部變數，例如 `let mut arr`（以便之後可以傳遞 `&mut arr` 或直接修改它）。
   - `&mut`：用於參數中，當函式需要借用並修改呼叫者的資料而不取得所有權時。在 `quick_sort` 和 `partition` 中，`&mut [i32]` 讓它們能夠原地排序陣列而不移動/複製它。
   - 如果你嘗試 `fn quick_sort(mut arr: [i32])`，它將無法編譯——切片不能以這種方式透過值傳遞。你需要一個固定大小的陣列（例如 `[i32; 7]`），並且它會移動所有權。
   - 在 `partition` 中，迴圈內部使用 `mut i`——那是一個局部可變變數，與傳遞無關。

### 6. **它會改變原始值嗎？**
   - 對於 `&mut`：會，變更會傳播到原始資料（參考傳遞）。
   - 對於值傳遞（沒有 `&`）：不會，僅局部變更（除非你返回修改後的值）。
   - 在你的 `quick_sort_interact()` 中，`println!("After: {:?}", arr);` 將顯示排序後的陣列，因為使用了 `&mut`。

如果你執行程式碼，它應該輸出：
```
Before: [3, 6, 8, 10, 1, 2, 1]
After: [1, 1, 2, 3, 6, 8, 10]
```
（`mod simple;` 和 `simple::run_simple();` 似乎無關——可能是佔位符？如果那裡有錯誤，可能是因為 `simple` 未定義。）

如果這還不夠清楚，或者你有特定的程式碼部分需要調整/測試，請告訴我！