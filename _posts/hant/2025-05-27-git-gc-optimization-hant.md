---
audio: false
generated: true
image: false
lang: hant
layout: post
model: x-ai/grok-code-fast-1
title: Git 垃圾收集優化詳解
translated: true
type: note
---

### Git GC 的作用
Git GC（垃圾收集）是一項維護指令，能透過清理不必要的檔案並壓縮資料來優化 Git 儲存庫，從而節省空間並提升效能。它主要針對儲存所有歷史記錄、物件和中繼資料的 `.git` 目錄進行操作。

其主要執行以下關鍵操作：
- **清除不可達物件**：移除不再被引用的提交、樹狀結構和 blob 物件（例如在 rebase 或刪除分支後）。這些物件會成為 `.git/objects` 中的「鬆散物件」，而 GC 會將其清理。
- **重新打包物件**：將鬆散物件（單獨儲存）壓縮成更高效的 pack 檔案（`.git/objects/pack`）。此過程使用差異壓縮技術來儲存相似檔案之間的變更，從而減少磁碟使用量。
- **更新參考**：重新整理儲存庫的內部狀態，例如重寫 pack 索引以加快查詢速度。
- **執行相關工具**：它通常會在過程中調用如 `git prune`、`git repack` 和 `git rerere`（用於重複使用解決方案）等指令。

實證依據：根據 Git 官方文件（例如 `git gc --help`），GC 的設計目的就是對儲存庫進行「日常維護」。例如，一個擁有 10,000 個鬆散物件的儲存庫，在打包後可能從數百 MB 大幅縮減至原體積的一小部分，這是因為差異壓縮技術能有效利用程式碼歷史中檔案版本之間的相似性。

### 內部運作原理
1. **觸發條件**：GC 可透過手動執行 `git gc` 啟動，或在 Git 偵測到特定條件時自動執行（詳見下文）。為了避免拖慢效能，它不會在每次指令執行時都啟動。
2. **執行流程**：
   - 計算鬆散物件和 pack 檔案的數量。
   - 若超過預設閾值（例如預設 >6,700 個鬆散物件，可透過 `gc.auto` 設定調整），則會進行積極的重新打包。
   - 為了避免資料遺失，它會建立暫存檔案（例如 `.git/objects/tmp_*`），然後以原子操作方式進行替換。
   - 較輕量的模式如 `git gc --auto` 僅執行清除操作，而不進行完整的重新打包。
3. **壓縮細節**：使用 zlib 進行壓縮。重新打包會建立 pack 檔案，其中物件以與基礎物件之間的差異形式儲存，這對於程式碼持續演進的儲存庫特別高效——例如，在大型程式碼庫中為檔案新增一行時，只會產生一個小型差異檔，而非複製整個檔案。

此機制有 Git 原始碼（可在 GitHub 上取得）作為支持，其中將 GC 實現為一系列呼叫清除與打包工具的 shell 指令，以確保可靠性。

### 為何會突然執行
GC 經常「突然」觸發，是因為其自動執行機制並非即時運作，而是為了平衡效能。常見原因包括：
- **達到閾值**：在累積大量鬆散物件後（例如頻繁提交或抓取後未進行打包）。Git 會在如 `git commit`、`git merge` 或 `push` 等操作後檢查此情況。若鬆散物件數量超過 `gc.auto` 限制（預設約 6,700），便會觸發執行。這解釋了為何在密集操作後，GC 可能會「突然」啟動。
- **清除排程**：若設定了 `gc.prune`，它會定期清除過時的參考，但主要的自動 GC 仍是基於物件數量觸發。
- **大型操作**：大量的 rebase 或 clone 操作可能快速產生大量鬆散物件，從而觸發 GC。
- **指令後掛鉤**：某些工作流程或工具（例如 Git hooks 或 IDE）可能會在重大變更後調用 `git gc`。

若要控制此行為：可調整設定，例如使用 `git config --global gc.auto 0` 停用自動 GC（改為手動執行），或提高閾值以減少干擾。定期執行 GC 可防止儲存庫體積過度膨脹——例如 Linux kernel 儲存庫便是透過 GC 來管理其龐大規模的歷史記錄。若問題持續，可透過 `git count-objects -v` 檢查鬆散物件的統計資訊。