---
audio: false
generated: true
lang: hant
layout: post
title: Rust 與 C 語言的關係
translated: true
type: note
---

不，Rust 並非「建基於 C」——它不會編譯成 C 語言，也不需要 C 語言作為其運作的基礎層。Rust 是一門獨立且現代的系統程式語言。

以下是 Rust 與 C 語言的關係說明，以及 Rust 如何與 C 函式庫互動：

**Rust 是否建基於 C？**

* **編譯器：** Rust 編譯器（`rustc`）主要使用 Rust 自身編寫。早期版本雖透過 OCaml 實現引導，但現已實現自舉編譯。
* **底層互動：** Rust 作為底層語言，能像 C 或 C++ 般直接與作業系統及硬體互動，無需依賴 C 語言作為中介。
* **LLVM：** Rust 編譯器使用 LLVM（低階虛擬機器）作為程式碼生成與最佳化的後端。LLVM 本身主要以 C++ 編寫。這意味著 Rust 程式碼最終會轉譯為 LLVM 中介表示層（IR），再經最佳化編譯為機器碼。就此而言，Rust 確實依賴基於 C++ 的工具鏈（LLVM），但 Rust 本身並非「建基於 C」。

**Rust 能否使用所有 C 函式庫？**

能。Rust 透過**外部函式介面（FFI）** 實現與 C 函式庫的卓越互通性，這意味著您可以直接在 Rust 程式碼中呼叫現有 C 函式庫的函式與資料結構。

具體運作方式如下：

1.  **`extern "C"` 區塊：** 在 Rust 程式碼中透過 `extern "C"` 區塊宣告要呼叫的 C 函式簽名，告知 Rust 編譯器這些函式遵循 C 應用二進位介面（ABI）規範（即函式呼叫與記憶體資料佈局的約定）。
2.  **`#[link]` 屬性：** 使用 `#[link(name = "foo")]` 屬性指示 Rust 連結器連結指定的 C 函式庫（例如 `libfoo.so` 或 `foo.lib`）。
3.  **`unsafe` 區塊：** 呼叫 C 函式時通常需包裹在 `unsafe` 區塊中。因為當與未遵循 Rust 記憶體安全規則的「外部」程式碼互動時，Rust 無法強制保證其記憶體安全性，程式設計師需自行確保這些呼叫的安全性。
4.  **`bindgen` 工具：** 對於大型 C 函式庫，手動編寫所有 `extern "C"` 宣告極為繁瑣。使用 `bindgen` 等工具可自動從 C 標頭檔案生成 Rust FFI 綁定程式碼，大幅簡化流程。
5.  **`cty` 套件：** 該套件提供 C 相容的基礎型別（如 `c_int`、`c_char` 等），確保 Rust 與 C 之間的資料型別正確對應。

**為何要在 Rust 中使用 C 函式庫？**

* **利用現有程式碼：** 存在大量經過充分測試且高度最佳化的 C 函式庫（例如系統呼叫、加密運算、數值計算、圖形處理等），Rust 讓您無需重複造輪子即可運用這些現成資源。
* **作業系統介面：** 作業系統多透過 C 相容介面暴露其功能，Rust 需能呼叫這些函式以與作業系統互動。
* **高效能關鍵區段：** 雖然 Rust 本身效能優異，但某些高度特化的效能關鍵程式碼可能已存在於 C 語言實現中，可直接整合使用。

總而言之，Rust 並非「建基於 C」，但透過完善的互通機制（FFI）實現與 C 函式庫的無縫協作，使 Rust 開發者能充分利用龐大的 C 生態系。