---
audio: false
generated: true
lang: hant
layout: post
title: Java 垃圾收集
translated: true
type: note
---

好的，讓我們來學習 Java 中的垃圾回收（GC）！這是 Java 記憶體管理的一個關鍵面向，能幫助開發者避免手動分配和釋放記憶體。

**什麼是 Java 中的垃圾回收？**

垃圾回收是一個自動回收不再被 Java 應用程式使用的物件所佔用記憶體的過程。本質上，這是 Java 清理「垃圾」（未使用的物件）以釋放空間給新物件的方式。

**為什麼需要垃圾回收？**

在許多其他程式語言（如 C 或 C++）中，開發者需負責使用像 `malloc` 和 `free` 這樣的函數來明確分配和釋放記憶體。這種手動記憶體管理可能導致幾個問題：

*   **記憶體洩漏：** 如果記憶體被分配但從未釋放，應用程式最終可能耗盡記憶體並崩潰。
*   **懸空指標：** 如果記憶體已被釋放，但指標仍指向該記憶體位置，使用該指標可能導致不可預測的行為或崩潰。
*   **增加開發複雜性：** 手動管理記憶體為軟體開發增加了顯著的複雜度。

Java 的垃圾回收自動化了這個過程，使開發者免於手動記憶體管理的負擔，並使編寫更安全、更可靠的程式碼變得更容易。

**垃圾回收如何運作？**

垃圾回收背後的核心思想是識別記憶體中哪些物件仍被應用程式使用，哪些沒有。垃圾回收器隨後回收未使用物件所佔用的記憶體。

以下是該過程的簡化概述：

1.  **識別存活物件（標記）：** 垃圾回收器從識別一組從「根」物件仍然可達的物件開始。根物件通常是應用程式可以直接存取的物件，例如：
    *   目前執行方法中的區域變數。
    *   靜態變數。
    *   被原生程式碼引用的物件。
    *   Java 虛擬機（JVM）的活動執行緒。

    垃圾回收器從這些根開始遍歷物件圖，標記所有可達的物件。

2.  **回收記憶體（清除與壓縮）：** 一旦存活物件被標記，垃圾回收器需要回收未標記（不可達）物件所佔用的記憶體。不同的垃圾回收演算法對此採用不同的策略：

    *   **標記清除：** 此演算法識別並標記存活物件，然後清除記憶體，釋放未標記物件所佔用的空間。這可能導致記憶體碎片化（零散的小塊空閒記憶體，不足以分配新物件）。
    *   **標記壓縮：** 此演算法也標記存活物件。標記後，它將存活物件移動（壓縮）到一起，消除碎片化，使為新物件分配連續記憶體區塊變得更容易。
    *   **複製：** 此演算法將記憶體分成兩個或多個區域。存活物件從一個區域複製到另一個區域，從而有效回收原始區域的空間。

**Java 垃圾回收的關鍵概念：**

*   **堆積：** Java 中分配物件的記憶體區域。垃圾回收器主要在堆積上運作。
*   **年輕代：** 這是堆積的一部分，新建立的物件最初分配於此。它進一步劃分為：
    *   **伊甸園空間：** 大多數新物件建立的地方。
    *   **倖存區空間（S0 和 S1）：** 用於存放經歷過幾次次要垃圾回收週期後仍存活的物件。
*   **老年代：** 在年輕代中經歷多次垃圾回收週期後仍存活的物件最終會被移到老年代。老年代中的物件通常是長壽命的。
*   **永久代 / 元空間：** 在舊版 Java（Java 8 之前）中，永久代儲存有關類別和方法的元資料。在 Java 8 及以後版本中，這已被元空間取代，元空間是原生記憶體的一部分（不屬於 Java 堆積）。
*   **垃圾回收演算法：** 不同的演算法用於垃圾回收，每種在效能和效率方面都有其自身的權衡。

**分代垃圾回收：**

Java HotSpot JVM（最常見的 JVM）使用分代方法進行垃圾回收。這基於觀察到應用程式中的大多數物件壽命都很短。

1.  **次要 GC（年輕代 GC）：** 當伊甸園空間變滿時，會觸發一次次要 GC。來自伊甸園和其中一個倖存區（例如 S0）的存活物件被複製到另一個倖存區（S1）。經歷過一定次數的次要 GC 週期後仍存活的物件會被移到老年代。不可達的物件將被丟棄。

2.  **主要 GC（老年代 GC）/ 完全 GC：** 當老年代變滿時，會執行一次主要 GC（或有時是完全 GC，可能涉及年輕代和老年代）。這個過程通常比次要 GC 更耗時，並且可能導致應用程式執行出現較長的暫停。

**Java HotSpot JVM 中常見的垃圾回收器：**

Java HotSpot JVM 提供了多種垃圾回收演算法，可以根據應用程式的需求（例如，低延遲、高吞吐量）進行選擇。一些常見的包括：

*   **串行回收器：** 使用單一執行緒進行垃圾回收。適用於資源有限的小型應用程式。
*   **並行回收器：** 使用多個執行緒進行垃圾回收，提高吞吐量。適用於在多核心處理器上執行的具有中到大型資料集的應用程式。
*   **CMS 回收器：** 嘗試通過將大部分垃圾回收工作與應用程式執行緒並行執行來最小化暫停時間。然而，它可能導致碎片化，並最終可能需要一次完全 GC。
*   **G1 回收器：** 旨在提供吞吐量和低延遲之間的良好平衡。它將堆積劃分為多個區域，並優先從垃圾最多的區域進行回收。它是 Java 9 及以後版本的預設回收器。
*   **ZGC：** 一種為大堆積設計的低延遲垃圾回收器。其目標是暫停時間少於 10 毫秒。
*   **Shenandoah：** 另一種低延遲垃圾回收器，目標與 ZGC 相似。

您可以通過 JVM 命令列選項指定要使用的垃圾回收器。

**垃圾回收何時執行？**

垃圾回收主要是一個由 JVM 驅動的自動過程。它通常在以下時機執行：

*   年輕代（伊甸園空間）變滿時。
*   老年代變滿時。
*   系統記憶體不足時。

雖然您無法直接控制垃圾回收*何時*執行，但您可以使用 `System.gc()` 向 JVM 建議現在可能是執行垃圾回收的好時機。然而，無法保證 JVM 在您呼叫此方法時會立即或完全執行垃圾回收器。通常最好依賴 JVM 的自動垃圾回收機制。

**`System.gc()` 與終結化：**

*   **`System.gc()`：** 如前所述，這是向 JVM 發出執行垃圾回收器的請求。通常建議避免依賴此方法進行關鍵的記憶體管理，因為 JVM 通常更擅長決定何時執行 GC。
*   **`finalize()` 方法：** 在物件被垃圾回收之前，JVM 會通過呼叫其 `finalize()` 方法（如果已實作）給它一個執行任何清理操作的機會。然而，`finalize()` 有幾個缺點，在現代 Java 開發中通常不鼓勵使用。它可能引入效能問題並使垃圾回收變得不那麼可預測。請考慮使用其他機制，如 try-with-resources 來管理資源。

**垃圾回收對應用程式效能的影響：**

雖然垃圾回收對於記憶體管理至關重要，但它也可能由於「停止世界」的暫停而影響應用程式的效能。在這些暫停期間，所有應用程式執行緒都會停止，而垃圾回收器則執行其工作。這些暫停的持續時間和頻率取決於所使用的垃圾回收演算法以及堆積的大小和特性。

像 G1、ZGC 和 Shenandoah 這樣的低延遲垃圾回收器旨在最小化這些暫停時間，使應用程式響應更迅速。

**調校垃圾回收：**

對於有特定效能要求的應用程式，可以通過調整 JVM 參數來調校垃圾回收，例如：

*   堆積大小（`-Xms`, `-Xmx`）
*   年輕代大小（`-Xmn`）
*   倖存區比例（`-XX:SurvivorRatio`）
*   選擇特定的垃圾回收器（`-XX:+UseG1GC`, `-XX:+UseZGC` 等）
*   設定垃圾回收標誌以進行更細粒度的控制。

GC 調校是一個高級主題，通常需要仔細分析應用程式的行為和效能。

**編寫對垃圾回收器友善的程式碼的最佳實踐：**

雖然 Java 自動處理記憶體管理，但編寫程式碼時考慮到垃圾回收器可以帶來更好的效能：

*   **最小化物件建立：** 建立大量短壽命的物件會給垃圾回收器帶來壓力。在適當的時候嘗試重複使用物件。
*   **釋放物件參考：** 如果您有一個不再需要的物件參考，請將該參考設為 `null`。這使得該物件可以更快地被垃圾回收。
*   **明智地使用資料結構：** 選擇適合您需求的資料結構。例如，使用一個大的 `ArrayList` 然後丟棄其大部分元素可能是低效的。
*   **避免終結器：** 如前所述，避免依賴 `finalize()` 方法進行資源清理。對於檔案和網路連線等資源，請使用 try-with-resources。
*   **注意靜態變數：** 被靜態變數引用的物件將在應用程式的整個生命週期內存活，因此請謹慎在靜態欄位中儲存大型或不必要的物件。

**總結：**

Java 中的垃圾回收是一個自動記憶體管理過程，它回收未使用物件所佔用的記憶體。它通過使開發者免於手動記憶體管理來簡化開發。了解它的工作原理、堆積的不同代別以及可用的垃圾回收演算法，可以幫助您編寫更高效、效能更好的 Java 應用程式。