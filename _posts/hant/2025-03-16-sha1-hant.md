---
audio: false
generated: true
lang: hant
layout: post
title: SHA-1 雜湊函數
translated: true
type: note
---

讓我們深入解析給定程式碼片段的工作原理，特別是以下幾行：

```python
hash_obj = hashlib.sha1(piece)
hashes.append(hash_obj.hexdigest())
return hashes
```

使用者要求我們在不使用程式庫的情況下解釋這段程式碼，因此我將先說明使用 `hashlib` 程式庫時程式碼的功能，再探討如何在不使用程式庫的情況下實現相同的功能。

---

### 使用 `hashlib` 理解程式碼

此程式碼片段計算資料片段的雜湊值並將其儲存在列表中。以下是逐步解析：

1. **`hash_obj = hashlib.sha1(piece)`**
   - **功能**：此行程式碼使用 Python 的 `hashlib` 模組建立一個 SHA-1 雜湊物件。SHA-1（安全雜湊演算法 1）是一種密碼雜湊函數，接收輸入（此處為 `piece`）並產生一個 160 位元（20 位元組）的雜湊值。
   - **輸入**：`piece` 是一個資料區塊，可能是從檔案或其他來源讀取的位元組資料。
   - **處理過程**：`hashlib.sha1()` 函數初始化一個雜湊物件，並立即使用 `piece` 中的資料更新它。可以將其想像為將資料送入一個開始處理數字的雜湊機器。

2. **`hashes.append(hash_obj.hexdigest())`**
   - **功能**：`hexdigest()` 方法獲取雜湊物件計算出的雜湊值，並將其轉換為十六進位字串（一種使用數字 0-9 和字母 a-f 的可讀格式）。
   - **輸出**：對於 SHA-1，此字串長度為 40 個字元，因為每個 20 位元組中的每個位元組都用兩個十六進位數字表示（例如，位元組值 255 變為 "ff"）。
   - **儲存**：產生的字串被附加到名為 `hashes` 的列表中，該列表可能用於收集多個資料片段的雜湊值。

3. **`return hashes`**
   - **功能**：在處理完所有片段後（假設此程式碼位於迴圈或函數中），返回包含所有十六進位雜湊字串的 `hashes` 列表。

**總結**：對於每個資料 `piece`，程式碼使用 `hashlib.sha1()` 計算其 SHA-1 雜湊值，使用 `hexdigest()` 將雜湊值轉換為十六進位字串，並將其儲存在 `hashes` 列表中，最後返回該列表。

---

### 不使用程式庫：從頭開始計算 SHA-1

使用者的指示「不要使用程式庫」表明他們希望了解在不依賴 `hashlib` 的情況下如何實現此功能。從頭實現 SHA-1 非常複雜，但我將清晰地解釋過程，並提供一個可在此基礎上擴展的簡化版本。

#### 什麼是 SHA-1？
SHA-1 是一種雜湊函數，具有以下特性：
- 接收任何輸入資料（例如 `piece`）。
- 產生固定的 160 位元（20 位元組）輸出。
- 使用一系列位元運算、旋轉和加法來轉換輸入。

在不使用 `hashlib` 的情況下，我們需要自己複製此演算法。以下是針對給定程式碼的實現方式：

#### 逐步 SHA-1 處理過程

1. **準備輸入（填充）**
   - SHA-1 以 512 位元（64 位元組）區塊處理資料。如果 `piece` 不是恰好 64 位元組，我們需要對其進行填充：
     - 附加一個 `1` 位元（例如，位元組中的 `0x80`）。
     - 添加足夠的 `0` 位元，使長度變為 512 的倍數減 64 位元（即 448 位元模 512）。
     - 附加 `piece` 的原始長度（以位元為單位）作為 64 位元整數。
   - 為簡化起見，如果 `piece` 小於 64 位元組，我們可以將其填充到一個區塊。

2. **初始化雜湊值**
   - SHA-1 使用五個 32 位元變數（總共 160 位元），初始化為特定常數：
     - `h0 = 0x67452301`
     - `h1 = 0xEFCDAB89`
     - `h2 = 0x98BADCFE`
     - `h3 = 0x10325476`
     - `h4 = 0xC3D2E1F0`

3. **處理資料區塊**
   - 將 64 位元組區塊分割為 16 個 32 位元字（每個 4 位元組）。
   - 使用以下公式將這些字擴展為 80 個字：
     ```python
     w[i] = left_rotate(w[i-3] ^ w[i-8] ^ w[i-14] ^ w[i-16], 1)  # 對於 i = 16 到 79
     ```
     其中 `left_rotate` 將位元向左旋轉並環繞。
   - 在 80 輪中，更新臨時變數 `a`、`b`、`c`、`d`、`e`（初始為 `h0` 到 `h4` 的副本）：
     - 根據輪數（0-19、20-39 等）使用不同的函數和常數。
     - 例如，對於 0-19 輪：
       ```python
       f = (b & c) | (~b & d)
       k = 0x5A827999
       temp = (left_rotate(a, 5) + f + e + k + w[i]) & 0xFFFFFFFF
       ```
     - 輪換變數：`e = d`、`d = c`、`c = left_rotate(b, 30)`、`b = a`、`a = temp`。

4. **更新雜湊值**
   - 80 輪後，將結果加到初始雜湊值中：
     ```python
     h0 = (h0 + a) & 0xFFFFFFFF
     h1 = (h1 + b) & 0xFFFFFFFF
     # ...依此類推處理 h2、h3、h4
     ```

5. **產生十六進位輸出**
   - 將 `h0` 到 `h4` 連接為 160 位元值，並轉換為 40 字元的十六進位字串。

#### 簡化的 Python 實現

以下是您如何在不使用 `hashlib` 的情況下改寫程式碼的基本版本：

```python
def left_rotate(value, shift):
    """將 32 位元整數向左旋轉 'shift' 位元。"""
    return ((value << shift) | (value >> (32 - shift))) & 0xFFFFFFFF

def custom_sha1(piece):
    """計算 'piece' 的 SHA-1 雜湊值並以十六進位字串形式返回。"""
    # 為簡化起見，假設 piece 小於 56 位元組並填充到一個區塊
    message = piece + b'\x80' + (b'\x00' * (55 - len(piece))) + (len(piece) * 8).to_bytes(8, 'big')
    
    # 初始化雜湊值
    h0, h1, h2, h3, h4 = (
        0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0
    )
    
    # 分割為 16 個 32 位元字
    w = [int.from_bytes(message[i:i+4], 'big') for i in range(0, 64, 4)]
    
    # 擴展到 80 個字
    for i in range(16, 80):
        w.append(left_rotate(w[i-3] ^ w[i-8] ^ w[i-14] ^ w[i-16], 1))
    
    # 初始化工作變數
    a, b, c, d, e = h0, h1, h2, h3, h4
    
    # 80 輪處理
    for i in range(80):
        if 0 <= i < 20:
            f = (b & c) | (~b & d)
            k = 0x5A827999
        elif 20 <= i < 40:
            f = b ^ c ^ d
            k = 0x6ED9EBA1
        elif 40 <= i < 60:
            f = (b & c) | (b & d) | (c & d)
            k = 0x8F1BBCDC
        else:
            f = b ^ c ^ d
            k = 0xCA62C1D6
        
        temp = (left_rotate(a, 5) + f + e + k + w[i]) & 0xFFFFFFFF
        e = d
        d = c
        c = left_rotate(b, 30)
        b = a
        a = temp
    
    # 更新雜湊值
    h0 = (h0 + a) & 0xFFFFFFFF
    h1 = (h1 + b) & 0xFFFFFFFF
    h2 = (h2 + c) & 0xFFFFFFFF
    h3 = (h3 + d) & 0xFFFFFFFF
    h4 = (h4 + e) & 0xFFFFFFFF
    
    # 以 40 字元十六進位字串形式返回
    return f"{h0:08x}{h1:08x}{h2:08x}{h3:08x}{h4:08x}"

# 改寫後的不使用 hashlib 的程式碼
def compute_hashes(pieces):
    hashes = []
    for piece in pieces:  # 假設 pieces 是位元組區塊的列表
        hash_value = custom_sha1(piece)
        hashes.append(hash_value)
    return hashes

# 使用範例
pieces = [b"hello", b"world"]
hashes = compute_hashes(pieces)
print(hashes)
```

#### 如何與原始程式碼對應
- **`hash_obj = hashlib.sha1(piece)`**：替換為 `custom_sha1(piece)`，後者手動計算 SHA-1 雜湊值。
- **`hashes.append(hash_obj.hexdigest())`**：`custom_sha1` 函數直接返回十六進位字串，因此我們將其附加到 `hashes`。
- **`return hashes`**：保持不變，返回雜湊字串列表。

---

### 主要差異與注意事項
- **簡化**：此實現假設每個 `piece` 適合一個 512 位元區塊（由於填充，需小於 56 位元組）。完整的 SHA-1 實現會處理多個區塊。
- **效能**：手動實現比 `hashlib` 慢且未經優化。
- **可靠性**：像 `hashlib` 這樣的程式庫經過測試且安全；自訂版本除非經過徹底驗證，否則可能存在錯誤。

總而言之，原始程式碼使用 `hashlib` 作為高效計算 SHA-1 雜湊值的捷徑，而不使用程式庫則需要手動編寫整個 SHA-1 演算法、處理填充並將結果轉換為十六進位格式。邏輯保持不變：處理每個片段、計算其雜湊值、儲存並返回集合。