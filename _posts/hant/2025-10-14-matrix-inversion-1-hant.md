---
audio: false
generated: true
image: false
lang: hant
layout: post
model: openai/gpt-5
title: 反轉3x3矩陣
translated: true
type: note
---

好的 — 讓我們清晰直觀地拆解這個問題，不使用表格格式，以便逐行閱讀。

---

### 1. 目標是什麼
我們想求一個 3×3 矩陣的逆矩陣，通常寫作 A⁻¹。
逆矩陣就是能夠「還原」A 的矩陣，意思是
A × A⁻¹ = I，
其中 I 是單位矩陣。

---

### 2. 核心公式
任何可逆方陣的通用公式是

A⁻¹ = (1 / det(A)) × adj(A)。

所以我們需要兩個要素：
- 行列式 det(A)，以及
- 伴隨矩陣 adj(A)，也就是餘因子矩陣的轉置。

---

### 3. 3×3 矩陣的行列式
如果
A =
[a  b  c]
[d  e  f]
[g  h  i]，

那麼

det(A) = a(ei − fh) − b(di − fg) + c(dh − eg)。

這個值告訴你矩陣是否可逆：
- 如果 det(A) = 0 → 沒有逆矩陣（矩陣是奇異的），
- 如果 det(A) ≠ 0 → 逆矩陣存在。

---

### 4. 餘因子
為了建立 adj(A)，我們首先求每個元素的餘因子。
元素 aᵢⱼ 的餘因子是
Cᵢⱼ = (−1)^(i+j) × Mᵢⱼ，
其中 Mᵢⱼ 是刪除第 i 行和第 j 列後得到的 2×2 子矩陣的行列式。

對所有九個位置進行此操作，得到「餘因子矩陣」。
對於上述一般情況：

C₁₁ = ei − fh
C₁₂ = −(di − fg)
C₁₃ = dh − eg

C₂₁ = −(bi − ch)
C₂₂ = ai − cg
C₂₃ = −(ah − bg)

C₃₁ = bf − ce
C₃₂ = −(af − cd)
C₃₃ = ae − bd

---

### 5. 轉置餘因子矩陣
現在將餘因子矩陣轉置 — 也就是交換行和列。
這個新矩陣稱為 A 的**伴隨矩陣**，記為 adj(A)。
如果從視覺上思考，這種「轉置」就像旋轉矩陣：原本在第一行的元素變成第一列，依此類推。

---

### 6. 乘以 1/det(A)
最後，將伴隨矩陣的每一項除以 det(A) 進行縮放。
這樣就得到了 A⁻¹。

符號表示：
A⁻¹ = (1/det(A)) × adj(A)。

---

### 7. 為什麼這個方法有效
這個公式來自行列式和餘因子的基本性質：

A × adj(A) = det(A) × I。

如果將兩邊都除以 det(A)，就會得到
A × [(1/det(A)) × adj(A)] = I。

因此右邊的因子必然就是逆矩陣。

這個等式成立的原因在於，當你將 A 乘以其餘因子矩陣時，每個對角線項會變成行列式本身（因為這是沿該行的展開），而每個非對角線項由於餘因子的正負號交替而變成零 — 這就是代數消去在起作用。

---

### 8. 範例
設
A =
[1  2  3]
[0  1  4]
[5  6  0]。

計算 det(A)：
= 1(1×0 − 4×6) − 2(0×0 − 4×5) + 3(0×6 − 1×5)
= (−24) − (−40) + (−15)
= −24 + 40 − 15 = 1。

所以 det(A) = 1。

然後求出所有餘因子（有點繁瑣但直接），將它們轉置得到 adj(A)，由於 det(A) = 1，伴隨矩陣本身就是逆矩陣。

---

### 9. 直觀總結
- 行列式 → 衡量矩陣如何「縮放空間」。
- 餘因子 → 捕捉每個元素對該縮放的貢獻。
- 轉置 → 對齊這些貢獻，使乘法能夠重建單位矩陣。
- 除以行列式 → 將縮放效果歸一化。

---

需要我為那個範例（[1 2 3; 0 1 4; 5 6 0]）展示詳細的餘因子計算過程，讓你看到每個子式和符號嗎？